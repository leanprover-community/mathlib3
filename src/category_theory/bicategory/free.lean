/-
Copyright (c) 2022 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import category_theory.bicategory.functor

/-!
# Free bicategories

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define the free bicategory over a quiver. In this bicategory, the 1-morphisms are freely
generated by the arrows in the quiver, and the 2-morphisms are freely generated by the formal
identities, the formal unitors, and the formal associators modulo the relation derived from the
axioms of a bicategory.

## Main definitions

* `free_bicategory B`: the free bicategory over a quiver `B`.
* `free_bicategory.lift F`: the pseudofunctor from `free_bicategory B` to `C` associated with a
  prefunctor `F` from `B` to `C`.
-/

universes w wâ‚ wâ‚‚ v vâ‚ vâ‚‚ u uâ‚ uâ‚‚

namespace category_theory
open category bicategory
open_locale bicategory

/-- Free bicategory over a quiver. Its objects are the same as those in the underlying quiver. -/
def free_bicategory (B : Type u) := B

instance (B : Type u) : Î  [inhabited B], inhabited (free_bicategory B) := id

namespace free_bicategory

section
variables {B : Type u} [quiver.{v+1} B]

/-- 1-morphisms in the free bicategory. -/
inductive hom : B â†’ B â†’ Type (max u v)
| of {a b : B} (f : a âŸ¶ b) : hom a b
| id (a : B) : hom a a
| comp {a b c : B} (f : hom a b) (g : hom b c) : hom a c

instance (a b : B) [inhabited (a âŸ¶ b)] : inhabited (hom a b) := âŸ¨hom.of defaultâŸ©

/-- Representatives of 2-morphisms in the free bicategory. -/
@[nolint has_nonempty_instance]
inductive homâ‚‚ : Î  {a b : B}, hom a b â†’ hom a b â†’ Type (max u v)
| id {a b} (f : hom a b) : homâ‚‚ f f
| vcomp {a b} {f g h : hom a b} (Î· : homâ‚‚ f g) (Î¸ : homâ‚‚ g h) : homâ‚‚ f h
| whisker_left {a b c} (f : hom a b) {g h : hom b c} (Î· : homâ‚‚ g h) : homâ‚‚ (f.comp g) (f.comp h)
-- `Î·` cannot be earlier than `h` since it is a recursive argument.
| whisker_right {a b c} {f g : hom a b} (h : hom b c) (Î· : homâ‚‚ f g) : homâ‚‚ (f.comp h) (g.comp h)
| associator {a b c d} (f : hom a b) (g : hom b c) (h : hom c d) :
    homâ‚‚ ((f.comp g).comp h) (f.comp (g.comp h))
| associator_inv {a b c d} (f : hom a b) (g : hom b c) (h : hom c d) :
    homâ‚‚ (f.comp (g.comp h)) ((f.comp g).comp h)
| right_unitor     {a b} (f : hom a b) : homâ‚‚ (f.comp (hom.id b)) f
| right_unitor_inv {a b} (f : hom a b) : homâ‚‚ f (f.comp (hom.id b))
| left_unitor      {a b} (f : hom a b) : homâ‚‚ ((hom.id a).comp f) f
| left_unitor_inv  {a b} (f : hom a b) : homâ‚‚ f ((hom.id a).comp f)

section
variables {B}

-- The following notations are only used in the definition of `rel` to simplify the notation.
local infixr (name := vcomp) ` â‰« ` := homâ‚‚.vcomp
local notation (name := id) `ğŸ™` := homâ‚‚.id
local notation (name := whisker_left) f ` â— ` Î· := homâ‚‚.whisker_left f Î·
local notation (name := whisker_right) Î· ` â–· ` h := homâ‚‚.whisker_right h Î·
local notation (name := associator) `Î±_` := homâ‚‚.associator
local notation (name := left_unitor) `Î»_` := homâ‚‚.left_unitor
local notation (name := right_unitor) `Ï_` := homâ‚‚.right_unitor
local notation (name := associator_inv) `Î±â»Â¹_` := homâ‚‚.associator_inv
local notation (name := left_unitor_inv) `Î»â»Â¹_` := homâ‚‚.left_unitor_inv
local notation (name := right_unitor_inv) `Ïâ»Â¹_` := homâ‚‚.right_unitor_inv

/-- Relations between 2-morphisms in the free bicategory. -/
inductive rel : Î  {a b : B} {f g : hom a b}, homâ‚‚ f g â†’ homâ‚‚ f g â†’ Prop
| vcomp_right {a b} {f g h : hom a b} (Î· : homâ‚‚ f g) (Î¸â‚ Î¸â‚‚ : homâ‚‚ g h) :
    rel Î¸â‚ Î¸â‚‚ â†’ rel (Î· â‰« Î¸â‚) (Î· â‰« Î¸â‚‚)
| vcomp_left {a b} {f g h : hom a b} (Î·â‚ Î·â‚‚ : homâ‚‚ f g) (Î¸ : homâ‚‚ g h) :
    rel Î·â‚ Î·â‚‚ â†’ rel (Î·â‚ â‰« Î¸) (Î·â‚‚ â‰« Î¸)
| id_comp {a b} {f g : hom a b} (Î· : homâ‚‚ f g) :
    rel (ğŸ™ f â‰« Î·) Î·
| comp_id {a b} {f g : hom a b} (Î· : homâ‚‚ f g) :
    rel (Î· â‰« ğŸ™ g) Î·
| assoc {a b} {f g h i : hom a b} (Î· : homâ‚‚ f g) (Î¸ : homâ‚‚ g h) (Î¹ : homâ‚‚ h i) :
    rel ((Î· â‰« Î¸) â‰« Î¹) (Î· â‰« (Î¸ â‰« Î¹))
| whisker_left {a b c} (f : hom a b) (g h : hom b c) (Î· Î·' : homâ‚‚ g h) :
    rel Î· Î·' â†’ rel (f â— Î·) (f â— Î·')
| whisker_left_id {a b c} (f : hom a b) (g : hom b c) :
    rel (f â— ğŸ™ g) (ğŸ™ (f.comp g))
| whisker_left_comp {a b c} (f : hom a b) {g h i : hom b c} (Î· : homâ‚‚ g h) (Î¸ : homâ‚‚ h i) :
    rel (f â— (Î· â‰« Î¸)) (f â— Î· â‰« f â— Î¸)
| id_whisker_left {a b} {f g : hom a b} (Î· : homâ‚‚ f g) :
    rel (hom.id a â— Î·) (Î»_ f â‰« Î· â‰« Î»â»Â¹_ g)
| comp_whisker_left
    {a b c d} (f : hom a b) (g : hom b c) {h h' : hom c d} (Î· : homâ‚‚ h h') :
    rel ((f.comp g) â— Î·) (Î±_ f g h â‰« f â— g â— Î· â‰« Î±â»Â¹_ f g h')
| whisker_right {a b c} (f g : hom a b) (h : hom b c) (Î· Î·' : homâ‚‚ f g) :
    rel Î· Î·' â†’ rel (Î· â–· h) (Î·' â–· h)
| id_whisker_right {a b c} (f : hom a b) (g : hom b c) :
    rel (ğŸ™ f â–· g) (ğŸ™ (f.comp g))
| comp_whisker_right {a b c} {f g h : hom a b} (i : hom b c) (Î· : homâ‚‚ f g) (Î¸ : homâ‚‚ g h) :
    rel ((Î· â‰« Î¸) â–· i) (Î· â–· i â‰« Î¸ â–· i)
| whisker_right_id {a b} {f g : hom a b} (Î· : homâ‚‚ f g) :
    rel (Î· â–· hom.id b) (Ï_ f â‰« Î· â‰« Ïâ»Â¹_ g)
| whisker_right_comp
    {a b c d} {f f' : hom a b} (g : hom b c) (h : hom c d) (Î· : homâ‚‚ f f') :
    rel (Î· â–· (g.comp h)) (Î±â»Â¹_ f g h â‰« Î· â–· g â–· h â‰« Î±_ f' g h)
| whisker_assoc
    {a b c d} (f : hom a b) {g g' : hom b c} (Î· : homâ‚‚ g g') (h : hom c d) :
    rel ((f â— Î·) â–· h) (Î±_ f g h â‰« f â— (Î· â–· h)â‰« Î±â»Â¹_ f g' h)
| whisker_exchange {a b c} {f g : hom a b} {h i : hom b c} (Î· : homâ‚‚ f g) (Î¸ : homâ‚‚ h i) :
    rel (f â— Î¸ â‰« Î· â–· i) (Î· â–· h â‰« g â— Î¸)
| associator_hom_inv {a b c d} (f : hom a b) (g : hom b c) (h : hom c d) :
    rel (Î±_ f g h â‰« Î±â»Â¹_ f g h) (ğŸ™ ((f.comp g).comp h))
| associator_inv_hom {a b c d} (f : hom a b) (g : hom b c) (h : hom c d) :
    rel (Î±â»Â¹_ f g h â‰« Î±_ f g h) (ğŸ™ (f.comp (g.comp h)))
| left_unitor_hom_inv {a b} (f : hom a b) :
    rel (Î»_ f â‰« Î»â»Â¹_ f) (ğŸ™ ((hom.id a).comp f))
| left_unitor_inv_hom {a b} (f : hom a b) :
    rel (Î»â»Â¹_ f â‰« Î»_ f) (ğŸ™ f)
| right_unitor_hom_inv {a b} (f : hom a b) :
    rel (Ï_ f â‰« Ïâ»Â¹_ f) (ğŸ™ (f.comp (hom.id b)))
| right_unitor_inv_hom {a b} (f : hom a b) :
    rel (Ïâ»Â¹_ f â‰« Ï_ f) (ğŸ™ f)
| pentagon {a b c d e} (f : hom a b) (g : hom b c) (h : hom c d) (i : hom d e) :
    rel (Î±_ f g h â–· i â‰« Î±_ f (g.comp h) i â‰« f â— Î±_ g h i)
        (Î±_ (f.comp g) h i â‰« Î±_ f g (h.comp i))
| triangle {a b c} (f : hom a b) (g : hom b c) :
    rel (Î±_ f (hom.id b) g â‰« f â— Î»_ g) (Ï_ f â–· g)

end

variables {B}

instance hom_category (a b : B) : category (hom a b) :=
{ hom       := Î» f g, quot (@rel _ _ _ _ f g),
  id        := Î» f, quot.mk rel (homâ‚‚.id f),
  comp      := Î» f g h, quot.mapâ‚‚ homâ‚‚.vcomp rel.vcomp_right rel.vcomp_left,
  id_comp'  := by { rintros f g âŸ¨Î·âŸ©, exact quot.sound (rel.id_comp Î·) },
  comp_id'  := by { rintros f g âŸ¨Î·âŸ©, exact quot.sound (rel.comp_id Î·) },
  assoc'    := by { rintros f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ© âŸ¨Î¹âŸ©, exact quot.sound (rel.assoc Î· Î¸ Î¹) } }

/-- Bicategory structure on the free bicategory. -/
instance bicategory : bicategory (free_bicategory B) :=
{ hom   := Î» a b : B, hom a b,
  id    := hom.id,
  comp  := Î» a b c, hom.comp,
  hom_category := free_bicategory.hom_category,
  whisker_left := Î» a b c f g h Î·,
    quot.map (homâ‚‚.whisker_left f) (rel.whisker_left f g h) Î·,
  whisker_left_id' := Î» a b c f g, quot.sound (rel.whisker_left_id f g),
  whisker_left_comp' := by
  { rintros a b c f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ©, exact quot.sound (rel.whisker_left_comp f Î· Î¸) },
  id_whisker_left' := by
  { rintros a b f g âŸ¨Î·âŸ©, exact quot.sound (rel.id_whisker_left Î·) },
  comp_whisker_left' := by
  { rintros a b c d f g h h' âŸ¨Î·âŸ©, exact quot.sound (rel.comp_whisker_left f g Î·) },
  whisker_right := Î» a b c f g Î· h,
    quot.map (homâ‚‚.whisker_right h) (rel.whisker_right f g h) Î·,
  id_whisker_right' := Î» a b c f g, quot.sound (rel.id_whisker_right f g),
  comp_whisker_right' := by
  { rintros a b c f g h âŸ¨Î·âŸ© âŸ¨Î¸âŸ© i, exact quot.sound (rel.comp_whisker_right i Î· Î¸) },
  whisker_right_id' := by
  { rintros a b f g âŸ¨Î·âŸ©, exact quot.sound (rel.whisker_right_id Î·) },
  whisker_right_comp' := by
  { rintros a b c d f f' âŸ¨Î·âŸ© g h, exact quot.sound (rel.whisker_right_comp g h Î·) },
  whisker_assoc' := by
  { rintros a b c d f g g' âŸ¨Î·âŸ© h, exact quot.sound (rel.whisker_assoc f Î· h) },
  whisker_exchange' := by
  { rintros a b c f g h i âŸ¨Î·âŸ© âŸ¨Î¸âŸ©, exact quot.sound (rel.whisker_exchange Î· Î¸) },
  associator := Î» a b c d f g h,
  { hom := quot.mk rel (homâ‚‚.associator f g h),
    inv := quot.mk rel (homâ‚‚.associator_inv f g h),
    hom_inv_id' := quot.sound (rel.associator_hom_inv f g h),
    inv_hom_id' := quot.sound (rel.associator_inv_hom f g h) },
  left_unitor := Î» a b f,
  { hom := quot.mk rel (homâ‚‚.left_unitor f),
    inv := quot.mk rel (homâ‚‚.left_unitor_inv f),
    hom_inv_id' := quot.sound (rel.left_unitor_hom_inv f),
    inv_hom_id' := quot.sound (rel.left_unitor_inv_hom f) },
  right_unitor := Î» a b f,
  { hom := quot.mk rel (homâ‚‚.right_unitor f),
    inv := quot.mk rel (homâ‚‚.right_unitor_inv f),
    hom_inv_id' := quot.sound (rel.right_unitor_hom_inv f),
    inv_hom_id' := quot.sound (rel.right_unitor_inv_hom f) },
  pentagon' := Î» a b c d e f g h i, quot.sound (rel.pentagon f g h i),
  triangle' := Î» a b c f g, quot.sound (rel.triangle f g) }

variables {a b c d : free_bicategory B}

@[simp] lemma mk_vcomp {f g h : a âŸ¶ b} (Î· : homâ‚‚ f g) (Î¸ : homâ‚‚ g h) :
  quot.mk rel (Î·.vcomp Î¸) = (quot.mk rel Î· â‰« quot.mk rel Î¸ : f âŸ¶ h) := rfl
@[simp] lemma mk_whisker_left (f : a âŸ¶ b) {g h : b âŸ¶ c} (Î· : homâ‚‚ g h) :
  quot.mk rel (homâ‚‚.whisker_left f Î·) = (f â— quot.mk rel Î· : f â‰« g âŸ¶ f â‰« h) := rfl
@[simp] lemma mk_whisker_right {f g : a âŸ¶ b} (Î· : homâ‚‚ f g) (h : b âŸ¶ c) :
  quot.mk rel (homâ‚‚.whisker_right h Î·) = (quot.mk rel Î· â–· h : f â‰« h âŸ¶ g â‰« h) := rfl

variables (f : a âŸ¶ b) (g : b âŸ¶ c) (h : c âŸ¶ d)

lemma id_def : hom.id a = ğŸ™ a := rfl
lemma comp_def : hom.comp f g = f â‰« g := rfl
@[simp] lemma mk_id : quot.mk _ (homâ‚‚.id f) = ğŸ™ f := rfl
@[simp] lemma mk_associator_hom : quot.mk _ (homâ‚‚.associator f g h) = (Î±_ f g h).hom := rfl
@[simp] lemma mk_associator_inv : quot.mk _ (homâ‚‚.associator_inv f g h) = (Î±_ f g h).inv := rfl
@[simp] lemma mk_left_unitor_hom : quot.mk _ (homâ‚‚.left_unitor f) = (Î»_ f).hom := rfl
@[simp] lemma mk_left_unitor_inv : quot.mk _ (homâ‚‚.left_unitor_inv f) = (Î»_ f).inv := rfl
@[simp] lemma mk_right_unitor_hom : quot.mk _ (homâ‚‚.right_unitor f) = (Ï_ f).hom := rfl
@[simp] lemma mk_right_unitor_inv : quot.mk _ (homâ‚‚.right_unitor_inv f) = (Ï_ f).inv := rfl

/-- Canonical prefunctor from `B` to `free_bicategory B`. -/
@[simps]
def of : prefunctor B (free_bicategory B) :=
{ obj := id,
  map := Î» a b, hom.of }

end

section
variables {B : Type uâ‚} [quiver.{vâ‚+1} B] {C : Type uâ‚‚} [category_struct.{vâ‚‚} C]
variables (F : prefunctor B C)

/-- Auxiliary definition for `lift`. -/
@[simp]
def lift_hom : âˆ€ {a b : B}, hom a b â†’ (F.obj a âŸ¶ F.obj b)
| _ _ (hom.of f)      := F.map f
| _ _ (hom.id a)      := ğŸ™ (F.obj a)
| _ _ (hom.comp f g)  := lift_hom f â‰« lift_hom g

@[simp] lemma lift_hom_id (a : free_bicategory B) : lift_hom F (ğŸ™ a) = ğŸ™ (F.obj a) := rfl
@[simp] lemma lift_hom_comp {a b c : free_bicategory B} (f : a âŸ¶ b) (g : b âŸ¶ c) :
  lift_hom F (f â‰« g) = lift_hom F f â‰« lift_hom F g := rfl

end

section
variables {B : Type uâ‚} [quiver.{vâ‚+1} B] {C : Type uâ‚‚} [bicategory.{wâ‚‚ vâ‚‚} C]
variables (F : prefunctor B C)

/-- Auxiliary definition for `lift`. -/
@[simp]
def lift_homâ‚‚ : âˆ€ {a b : B} {f g : hom a b}, homâ‚‚ f g â†’ (lift_hom F f âŸ¶ lift_hom F g)
| _ _ _ _ (homâ‚‚.id _)                   := ğŸ™ _
| _ _ _ _ (homâ‚‚.associator _ _ _)       := (Î±_ _ _ _).hom
| _ _ _ _ (homâ‚‚.associator_inv _ _ _)   := (Î±_ _ _ _).inv
| _ _ _ _ (homâ‚‚.left_unitor _)          := (Î»_ _).hom
| _ _ _ _ (homâ‚‚.left_unitor_inv _)      := (Î»_ _).inv
| _ _ _ _ (homâ‚‚.right_unitor _)         := (Ï_ _).hom
| _ _ _ _ (homâ‚‚.right_unitor_inv _)     := (Ï_ _).inv
| _ _ _ _ (homâ‚‚.vcomp Î· Î¸)              := lift_homâ‚‚ Î· â‰« lift_homâ‚‚ Î¸
| _ _ _ _ (homâ‚‚.whisker_left f Î·)       := lift_hom F f â— lift_homâ‚‚ Î·
| _ _ _ _ (homâ‚‚.whisker_right h Î·)      := lift_homâ‚‚ Î· â–· lift_hom F h

local attribute [simp] whisker_exchange

lemma lift_homâ‚‚_congr {a b : B} {f g : hom a b} {Î· Î¸ : homâ‚‚ f g} (H : rel Î· Î¸) :
  lift_homâ‚‚ F Î· = lift_homâ‚‚ F Î¸ :=
by induction H; tidy

/--
A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from
`free_bicategory B` to `C`.
-/
@[simps]
def lift : pseudofunctor (free_bicategory B) C :=
{ obj       := F.obj,
  map       := Î» a b, lift_hom F,
  mapâ‚‚      := Î» a b f g, quot.lift (lift_homâ‚‚ F) (Î» Î· Î¸ H, lift_homâ‚‚_congr F H),
  map_id    := Î» a, iso.refl _,
  map_comp  := Î» a b c f g, iso.refl _ }

end

end free_bicategory

end category_theory
