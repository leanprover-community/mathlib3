/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton
-/
import category_theory.limits.shapes.images
import category_theory.filtered
import data.quot
import tactic.equiv_rw

universes u

open category_theory
open category_theory.limits

namespace category_theory.limits

variables {J : Type u} [small_category J]

namespace types

/--
(internal implementation) the limit cone of a functor,
implemented as flat sections of a pi type
-/
def limit_cone (F : J â¥¤ Type u) : cone F :=
{ X := F.sections,
  Ï€ := { app := Î» j u, u.val j } }

local attribute [elab_simple] congr_fun
/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limit_cone_is_limit (F : J â¥¤ Type u) : is_limit (limit_cone F) :=
{ lift := Î» s v, âŸ¨Î» j, s.Ï€.app j v, Î» j j' f, congr_fun (cone.w s f) _âŸ©,
  uniq' := by { intros, ext x j, exact congr_fun (w j) x } }

/--
The category of types has all limits.

See https://stacks.math.columbia.edu/tag/002U.
-/
instance : has_limits (Type u) :=
{ has_limits_of_shape := Î» J ğ’¥, by exactI
  { has_limit := Î» F, has_limit.mk
    { cone := limit_cone F, is_limit := limit_cone_is_limit F } } }

/--
The equivalence between a limiting cone of `F` in `Type u` and the "concrete" definition as the
sections of `F`.
-/
def is_limit_equiv_sections {F : J â¥¤ Type u} {c : cone F} (t : is_limit c) :
  c.X â‰ƒ F.sections :=
(is_limit.cone_point_unique_up_to_iso t (limit_cone_is_limit F)).to_equiv

@[simp]
lemma is_limit_equiv_sections_apply
  {F : J â¥¤ Type u} {c : cone F} (t : is_limit c) (j : J) (x : c.X) :
  (((is_limit_equiv_sections t) x) : Î  j, F.obj j) j = c.Ï€.app j x :=
rfl

@[simp]
lemma is_limit_equiv_sections_symm_apply
  {F : J â¥¤ Type u} {c : cone F} (t : is_limit c) (x : F.sections) (j : J) :
  c.Ï€.app j ((is_limit_equiv_sections t).symm x) = (x : Î  j, F.obj j) j :=
begin
  equiv_rw (is_limit_equiv_sections t).symm at x,
  simp,
end

/--
The equivalence between the abstract limit of `F` in `Type u`
and the "concrete" definition as the sections of `F`.
-/
noncomputable
def limit_equiv_sections (F : J â¥¤ Type u) : (limit F : Type u) â‰ƒ F.sections :=
is_limit_equiv_sections (limit.is_limit _)

@[simp]
lemma limit_equiv_sections_apply (F : J â¥¤ Type u) (x : limit F) (j : J) :
  (((limit_equiv_sections F) x) : Î  j, F.obj j) j = limit.Ï€ F j x :=
rfl

@[simp]
lemma limit_equiv_sections_symm_apply (F : J â¥¤ Type u) (x : F.sections) (j : J) :
  limit.Ï€ F j ((limit_equiv_sections F).symm x) = (x : Î  j, F.obj j) j :=
is_limit_equiv_sections_symm_apply _ _ _

/--
Construct a term of `limit F : Type u` from a family of terms `x : Î  j, F.obj j`
which are "coherent": `âˆ€ (j j') (f : j âŸ¶ j'), F.map f (x j) = x j'`.
-/
@[ext]
noncomputable
def limit.mk (F : J â¥¤ Type u) (x : Î  j, F.obj j) (h : âˆ€ (j j') (f : j âŸ¶ j'), F.map f (x j) = x j') :
  (limit F : Type u) :=
(limit_equiv_sections F).symm âŸ¨x, hâŸ©

@[simp]
lemma limit.Ï€_mk
  (F : J â¥¤ Type u) (x : Î  j, F.obj j) (h : âˆ€ (j j') (f : j âŸ¶ j'), F.map f (x j) = x j') (j) :
  limit.Ï€ F j (limit.mk F x h) = x j :=
by { dsimp [limit.mk], simp, }

-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits
@[ext]
lemma limit_ext (F : J â¥¤ Type u) (x y : limit F) (w : âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y) :
  x = y :=
begin
  apply (limit_equiv_sections F).injective,
  ext j,
  simp [w j],
end

lemma limit_ext_iff (F : J â¥¤ Type u) (x y : limit F) :
  x = y â†” (âˆ€ j, limit.Ï€ F j x = limit.Ï€ F j y) :=
âŸ¨Î» t _, t â–¸ rfl, limit_ext _ _ _âŸ©

-- TODO: are there other limits lemmas that should have `_apply` versions?
-- Can we generate these like with `@[reassoc]`?
-- PROJECT: prove these for any concrete category where the forgetful functor preserves limits?

@[simp]
lemma limit.w_apply {F : J â¥¤ Type u} {j j' : J} {x : limit F} (f : j âŸ¶ j') :
  F.map f (limit.Ï€ F j x) = limit.Ï€ F j' x :=
congr_fun (limit.w F f) x

@[simp]
lemma limit.lift_Ï€_apply (F : J â¥¤ Type u) (s : cone F) (j : J) (x : s.X) :
  limit.Ï€ F j (limit.lift F s x) = s.Ï€.app j x :=
congr_fun (limit.lift_Ï€ s j) x

@[simp]
lemma limit.map_Ï€_apply {F G : J â¥¤ Type u} (Î± : F âŸ¶ G) (j : J) (x) :
  limit.Ï€ G j (lim_map Î± x) = Î±.app j (limit.Ï€ F j x) :=
congr_fun (lim_map_Ï€ Î± j) x

/--
The relation defining the quotient type which implements the colimit of a functor `F : J â¥¤ Type u`.
See `category_theory.limits.types.quot`.
-/
def quot.rel (F : J â¥¤ Type u) : (Î£ j, F.obj j) â†’ (Î£ j, F.obj j) â†’ Prop :=
(Î» p p', âˆƒ k (f : x.1 âŸ¶ k) (g : y.1 âŸ¶ k), F.map f x.2 = F.map g y.2)

/--
A quotient type implementing the colimit of a functor `F : J â¥¤ Type u`,
as pairs `âŸ¨j, xâŸ©` where `x : F.obj j`, modulo the equivalence relation generated by
`âŸ¨j, xâŸ© ~ âŸ¨j', x'âŸ©` whenever there is a `k : J` and morphisms `f : j âŸ¶ k` and `f' : j' âŸ¶ k`
so `F.map f x = F.map f' x'`.

(This generates the same equivalence relation as `âŸ¨j, xâŸ© ~ âŸ¨j', x'âŸ©` whenever there is
a morphism `f : j âŸ¶ j'` so `F.map f x = x'`, but this one is more convenient to work with
when we construct filtered colimits.)
-/
@[nolint has_inhabited_instance]
def quot (F : J â¥¤ Type u) : Type u :=
@quot (Î£ j, F.obj j) (quot.rel F)

/--
(internal implementation) the colimit cocone of a functor,
implemented as a quotient of a sigma type
-/
@[simps]
def colimit_cocone (F : J â¥¤ Type u) : cocone F :=
{ X := quot F,
  Î¹ :=
  { app := Î» j x, quot.mk _ âŸ¨j, xâŸ©,
    naturality' := Î» j j' f, funext $ Î» x, eq.symm (quot.sound âŸ¨j', f, ğŸ™ _, by simpâŸ©) } }

local attribute [elab_with_expected_type] quot.lift

/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
@[simps]
def colimit_cocone_is_colimit (F : J â¥¤ Type u) : is_colimit (colimit_cocone F) :=
{ desc := Î» s, quot.lift (Î» (p : Î£ j, F.obj j), s.Î¹.app p.1 p.2)
    (assume âŸ¨j, xâŸ© âŸ¨j', x'âŸ© âŸ¨j'', f, f', hfâŸ©, by { rw [â†s.w f, â†s.w f'], dsimp, rw hf, }) }

/--
The category of types has all colimits.

See https://stacks.math.columbia.edu/tag/002U.
-/
instance : has_colimits (Type u) :=
{ has_colimits_of_shape := Î» J ğ’¥, by exactI
  { has_colimit := Î» F, has_colimit.mk
    { cocone := colimit_cocone F, is_colimit := colimit_cocone_is_colimit F } } }

/--
The equivalence between the abstract colimit of `F` in `Type u`
and the "concrete" definition as a quotient.
-/
noncomputable
def colimit_equiv_quot (F : J â¥¤ Type u) : (colimit F : Type u) â‰ƒ quot F :=
(is_colimit.cocone_point_unique_up_to_iso
  (colimit.is_colimit F)
  (colimit_cocone_is_colimit F)).to_equiv

@[simp]
lemma colimit_equiv_quot_symm_apply (F : J â¥¤ Type u) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F).symm (quot.mk _ âŸ¨j, xâŸ©) = colimit.Î¹ F j x :=
rfl

@[simp]
lemma colimit_equiv_quot_apply (F : J â¥¤ Type u) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F) (colimit.Î¹ F j x) = quot.mk _ âŸ¨j, xâŸ© :=
begin
  apply (colimit_equiv_quot F).symm.injective,
  simp,
end

@[simp]
lemma colimit.w_apply {F : J â¥¤ Type u} {j j' : J} {x : F.obj j} (f : j âŸ¶ j') :
  colimit.Î¹ F j' (F.map f x) = colimit.Î¹ F j x :=
congr_fun (colimit.w F f) x

@[simp]
lemma colimit.Î¹_desc_apply (F : J â¥¤ Type u) (s : cocone F) (j : J) (x : F.obj j) :
  colimit.desc F s (colimit.Î¹ F j x) = s.Î¹.app j x :=
congr_fun (colimit.Î¹_desc s j) x

@[simp]
lemma colimit.Î¹_map_apply {F G : J â¥¤ Type u} (Î± : F âŸ¶ G) (j : J) (x) :
  colim.map Î± (colimit.Î¹ F j x) = colimit.Î¹ G j (Î±.app j x) :=
congr_fun (colimit.Î¹_map Î± j) x

lemma colimit_sound
  {F : J â¥¤ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j âŸ¶ j') (w : F.map f x = x') :
  colimit.Î¹ F j x = colimit.Î¹ F j' x' :=
begin
  rw [â†w],
  simp,
end

lemma colimit_sound'
  {F : J â¥¤ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J} (f : j âŸ¶ j'') (f' : j' âŸ¶ j'')
  (w : F.map f x = F.map f' x') :
  colimit.Î¹ F j x = colimit.Î¹ F j' x' :=
begin
  rw [â†colimit.w _ f, â†colimit.w _ f'],
  rw [types_comp_apply, types_comp_apply, w],
end

lemma colimit_eq {F : J â¥¤ Type u } {j j' : J} {x : F.obj j} {x' : F.obj j'}
  (w : colimit.Î¹ F j x = colimit.Î¹ F j' x') : eqv_gen (quot.rel F) âŸ¨j, xâŸ© âŸ¨j', x'âŸ© :=
begin
  apply quot.eq.1,
  simpa using congr_arg (colimit_equiv_quot F) w,
end

lemma jointly_surjective (F : J â¥¤ Type u) {t : cocone F} (h : is_colimit t)
  (x : t.X) : âˆƒ j y, t.Î¹.app j y = x :=
begin
  suffices : (Î» (x : t.X), ulift.up (âˆƒ j y, t.Î¹.app j y = x)) = (Î» _, ulift.up true),
  { have := congr_fun this x,
    have H := congr_arg ulift.down this,
    dsimp at H,
    rwa eq_true at H },
  refine h.hom_ext _,
  intro j, ext y,
  erw iff_true,
  exact âŸ¨j, y, rflâŸ©
end

/-- A variant of `jointly_surjective` for `x : colimit F`. -/
lemma jointly_surjective' (F : J â¥¤ Type u)
  (x : colimit F) : âˆƒ j y, colimit.Î¹ F j y = x :=
jointly_surjective F (colimit.is_colimit _) x


namespace filtered_colimit
/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/

variables (F : J â¥¤ Type u)

variables [is_filtered_or_empty J]

protected lemma r_equiv : equivalence (types.r F) :=
âŸ¨Î» x, âŸ¨x.1, ğŸ™ x.1, ğŸ™ x.1, rflâŸ©,
 Î» x y âŸ¨k, f, g, hâŸ©, âŸ¨k, g, f, h.symmâŸ©,
 Î» x y z âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ©,
   let âŸ¨l, fl, gl, _âŸ© := is_filtered_or_empty.cocone_objs k k',
       âŸ¨m, n, hnâŸ© := is_filtered_or_empty.cocone_maps (g â‰« fl) (f' â‰« gl) in
   âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n, calc
      F.map (f â‰« fl â‰« n) x.2
          = F.map (fl â‰« n) (F.map f x.2)  : by simp
      ... = F.map (fl â‰« n) (F.map g y.2)  : by rw h
      ... = F.map ((g â‰« fl) â‰« n) y.2      : by simp
      ... = F.map ((f' â‰« gl) â‰« n) y.2     : by rw hn
      ... = F.map (gl â‰« n) (F.map f' y.2) : by simp
      ... = F.map (gl â‰« n) (F.map g' z.2) : by rw h'
      ... = F.map (g' â‰« gl â‰« n) z.2       : by simpâŸ©âŸ©

lemma colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
begin
  change quot.mk _ _ = quot.mk _ _ â†” _,
  rw [quot.eq, relation.eqv_gen_iff_of_equivalence (filtered_colimit.r_equiv F)],
  refl,
end

variables {t : cocone F} (ht : is_colimit t)
local attribute [elab_simple] nat_trans.app
lemma is_colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
let t' := colimit.cocone F,
    e : t' â‰… t := is_colimit.unique_up_to_iso (colimit.is_colimit F) ht,
    e' : t'.X â‰… t.X := (cocones.forget _).map_iso e in
begin
  refine iff.trans _ (colimit_eq_iff F),
  convert equiv.apply_eq_iff_eq e'.to_equiv _ _; rw â†e.hom.w; refl
end

variables (t)
/-- Recognizing filtered colimits of types. -/
noncomputable def is_colimit_of (hsurj : âˆ€ (x : t.X), âˆƒ i xi, x = t.Î¹.app i xi)
  (hinj : âˆ€ i j xi xj, t.Î¹.app i xi = t.Î¹.app j xj â†’
   âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj) : is_colimit t :=
-- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
-- is a bijection.
begin
  apply is_colimit.of_iso_colimit (colimit.is_colimit F),
  refine cocones.ext (equiv.to_iso (equiv.of_bijective _ _)) _,
  { exact colimit.desc F t },
  { split,
    { show function.injective _,
      intros a b h,
      rcases jointly_surjective F (colimit.is_colimit F) a with âŸ¨i, xi, rflâŸ©,
      rcases jointly_surjective F (colimit.is_colimit F) b with âŸ¨j, xj, rflâŸ©,
      change (colimit.Î¹ F i â‰« colimit.desc F t) xi = (colimit.Î¹ F j â‰« colimit.desc F t) xj at h,
      rw [colimit.Î¹_desc, colimit.Î¹_desc] at h,
      rcases hinj i j xi xj h with âŸ¨k, f, g, h'âŸ©,
      change colimit.Î¹ F i xi = colimit.Î¹ F j xj,
      rw [â†colimit.w F f, â†colimit.w F g],
      change colimit.Î¹ F k (F.map f xi) = colimit.Î¹ F k (F.map g xj),
      rw h' },
    { show function.surjective _,
      intro x,
      rcases hsurj x with âŸ¨i, xi, rflâŸ©,
      use colimit.Î¹ F i xi,
      simp } },
  { intro j, apply colimit.Î¹_desc }
end

variables [is_filtered_or_empty J]

protected lemma r_equiv : equivalence (filtered_colimit.r F) :=
âŸ¨Î» x, âŸ¨x.1, ğŸ™ x.1, ğŸ™ x.1, rflâŸ©,
 Î» x y âŸ¨k, f, g, hâŸ©, âŸ¨k, g, f, h.symmâŸ©,
 Î» x y z âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ©,
   let âŸ¨l, fl, gl, _âŸ© := is_filtered_or_empty.cocone_objs k k',
       âŸ¨m, n, hnâŸ© := is_filtered_or_empty.cocone_maps (g â‰« fl) (f' â‰« gl) in
   âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n, calc
      F.map (f â‰« fl â‰« n) x.2
          = F.map (fl â‰« n) (F.map f x.2)  : by simp
      ... = F.map (fl â‰« n) (F.map g y.2)  : by rw h
      ... = F.map ((g â‰« fl) â‰« n) y.2      : by simp
      ... = F.map ((f' â‰« gl) â‰« n) y.2     : by rw hn
      ... = F.map (gl â‰« n) (F.map f' y.2) : by simp
      ... = F.map (gl â‰« n) (F.map g' z.2) : by rw h'
      ... = F.map (g' â‰« gl â‰« n) z.2       : by simpâŸ©âŸ©

protected lemma r_eq :
  filtered_colimit.r F = eqv_gen (Î» x y, âˆƒ f : x.1 âŸ¶ y.1, y.2 = F.map f x.2) :=
begin
  apply le_antisymm,
  { rintros âŸ¨i, xâŸ© âŸ¨j, yâŸ© âŸ¨k, f, g, hâŸ©,
    exact eqv_gen.trans _ âŸ¨k, F.map f xâŸ© _ (eqv_gen.rel _ _ âŸ¨f, rflâŸ©)
      (eqv_gen.symm _ _ (eqv_gen.rel _ _ âŸ¨g, hâŸ©)) },
  { intros x y,
    convert relation.eqv_gen_mono (filtered_colimit.r_ge F),
    apply propext,
    symmetry,
    exact relation.eqv_gen_iff_of_equivalence (filtered_colimit.r_equiv F) }
end

lemma colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :
  (colimit_cocone F).Î¹.app i xi = (colimit_cocone F).Î¹.app j xj â†”
    âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
begin
  change quot.mk _ _ = quot.mk _ _ â†” _,
  rw [quot.eq, quot.rel, â†filtered_colimit.r_eq],
  refl
end

variables {t} (ht : is_colimit t)
lemma is_colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
let t' := colimit_cocone F,
    e : t' â‰… t := is_colimit.unique_up_to_iso (colimit_cocone_is_colimit F) ht,
    e' : t'.X â‰… t.X := (cocones.forget _).map_iso e in
begin
  refine iff.trans _ (colimit_eq_iff_aux F),
  convert e'.to_equiv.apply_eq_iff_eq; rw â†e.hom.w; refl
end

lemma colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
is_colimit_eq_iff _ (colimit.is_colimit F)

end filtered_colimit

variables {Î± Î² : Type u} (f : Î± âŸ¶ Î²)

section -- implementation of `has_image`
/-- the image of a morphism in Type is just `set.range f` -/
def image : Type u := set.range f

instance [inhabited Î±] : inhabited (image f) :=
{ default := âŸ¨f (default Î±), âŸ¨_, rflâŸ©âŸ© }

/-- the inclusion of `image f` into the target -/
def image.Î¹ : image f âŸ¶ Î² := subtype.val

instance : mono (image.Î¹ f) :=
(mono_iff_injective _).2 subtype.val_injective

variables {f}

/-- the universal property for the image factorisation -/
noncomputable def image.lift (F' : mono_factorisation f) : image f âŸ¶ F'.I :=
(Î» x, F'.e (classical.indefinite_description _ x.2).1 : image f â†’ F'.I)

lemma image.lift_fac (F' : mono_factorisation f) : image.lift F' â‰« F'.m = image.Î¹ f :=
begin
  ext x,
  change (F'.e â‰« F'.m) _ = _,
  rw [F'.fac, (classical.indefinite_description _ x.2).2],
  refl,
end
end

/-- the factorisation of any morphism in Type through a mono. -/
def mono_factorisation : mono_factorisation f :=
{ I := image f,
  m := image.Î¹ f,
  e := set.range_factorization f }

/-- the facorisation through a mono has the universal property of the image. -/
noncomputable def is_image : is_image (mono_factorisation f) :=
{ lift := image.lift,
  lift_fac' := image.lift_fac }

instance : has_image f :=
has_image.mk âŸ¨_, is_image fâŸ©

instance : has_images (Type u) :=
{ has_image := by apply_instance }

instance : has_image_maps (Type u) :=
{ has_image_map := Î» f g st, has_image_map.transport st (mono_factorisation f.hom) (is_image g.hom)
    (Î» x, âŸ¨st.right x.1, âŸ¨st.left (classical.some x.2),
      begin
        have p := st.w,
        replace p := congr_fun p (classical.some x.2),
        simp only [functor.id_map, types_comp_apply, subtype.val_eq_coe] at p,
        erw [p, classical.some_spec x.2],
      endâŸ©âŸ©) rfl }

end types

end category_theory.limits
