/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton
-/
import category_theory.limits.shapes.images
import category_theory.filtered
import data.quot

universes u

open category_theory
open category_theory.limits

namespace category_theory.limits.types

variables {J : Type u} [small_category J]

/-- (internal implementation) the limit cone of a functor, implemented as flat sections of a pi type -/
def limit_ (F : J â¥¤ Type u) : cone F :=
{ X := F.sections,
  Ï€ := { app := Î» j u, u.val j } }

local attribute [elab_simple] congr_fun
/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limit_is_limit_ (F : J â¥¤ Type u) : is_limit (limit_ F) :=
{ lift := Î» s v, âŸ¨Î» j, s.Ï€.app j v, Î» j j' f, congr_fun (cone.w s f) _âŸ©,
  uniq' := by { intros, ext x j, exact congr_fun (w j) x } }

instance : has_limits (Type u) :=
{ has_limits_of_shape := Î» J ğ’¥,
  { has_limit := Î» F, by exactI { cone := limit_ F, is_limit := limit_is_limit_ F } } }

@[simp] lemma types_limit (F : J â¥¤ Type u) :
  limits.limit F = {u : Î  j, F.obj j // âˆ€ {j j'} f, F.map f (u j) = u j'} := rfl
@[simp] lemma types_limit_Ï€ (F : J â¥¤ Type u) (j : J) (g : limit F) :
  limit.Ï€ F j g = g.val j := rfl
@[simp] lemma types_limit_pre
  (F : J â¥¤ Type u) {K : Type u} [ğ’¦ : small_category K] (E : K â¥¤ J) (g : limit F) :
  limit.pre F E g = (âŸ¨Î» k, g.val (E.obj k), by obviouslyâŸ© : limit (E â‹™ F)) := rfl
@[simp] lemma types_limit_map {F G : J â¥¤ Type u} (Î± : F âŸ¶ G) (g : limit F) :
  (lim.map Î± : limit F â†’ limit G) g =
  (âŸ¨Î» j, (Î±.app j) (g.val j), Î» j j' f,
    by {rw â†functor_to_types.naturality, dsimp, rw â†(g.prop f)}âŸ© : limit G) := rfl

@[simp] lemma types_limit_lift (F : J â¥¤ Type u) (c : cone F) (x : c.X) :
  limit.lift F c x = (âŸ¨Î» j, c.Ï€.app j x, Î» j j' f, congr_fun (cone.w c f) xâŸ© : limit F) :=
rfl

/-- (internal implementation) the limit cone of a functor, implemented as a quotient of a sigma type -/
def colimit_ (F : J â¥¤ Type u) : cocone F :=
{ X := @quot (Î£ j, F.obj j) (Î» p p', âˆƒ f : p.1 âŸ¶ p'.1, p'.2 = F.map f p.2),
  Î¹ :=
  { app := Î» j x, quot.mk _ âŸ¨j, xâŸ©,
    naturality' := Î» j j' f, funext $ Î» x, eq.symm (quot.sound âŸ¨f, rflâŸ©) } }

local attribute [elab_with_expected_type] quot.lift

/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
def colimit_is_colimit_ (F : J â¥¤ Type u) : is_colimit (colimit_ F) :=
{ desc := Î» s, quot.lift (Î» (p : Î£ j, F.obj j), s.Î¹.app p.1 p.2)
    (assume âŸ¨j, xâŸ© âŸ¨j', x'âŸ© âŸ¨f, hfâŸ©, by rw hf; exact (congr_fun (cocone.w s f) x).symm) }

instance : has_colimits (Type u) :=
{ has_colimits_of_shape := Î» J ğ’¥,
  { has_colimit := Î» F, by exactI { cocone := colimit_ F, is_colimit := colimit_is_colimit_ F } } }

@[simp] lemma types_colimit (F : J â¥¤ Type u) :
  limits.colimit F = @quot (Î£ j, F.obj j) (Î» p p', âˆƒ f : p.1 âŸ¶ p'.1, p'.2 = F.map f p.2) := rfl
@[simp] lemma types_colimit_Î¹ (F : J â¥¤ Type u) (j : J) :
  colimit.Î¹ F j = Î» x, quot.mk _ âŸ¨j, xâŸ© := rfl
@[simp] lemma types_colimit_pre
  (F : J â¥¤ Type u) {K : Type u} [ğ’¦ : small_category K] (E : K â¥¤ J) :
  colimit.pre F E =
  quot.lift (Î» p, quot.mk _ âŸ¨E.obj p.1, p.2âŸ©) (Î» p p' âŸ¨f, hâŸ©, quot.sound âŸ¨E.map f, hâŸ©) := rfl
@[simp] lemma types_colimit_map {F G : J â¥¤ Type u} (Î± : F âŸ¶ G) :
  (colim.map Î± : colimit F â†’ colimit G) =
  quot.lift
    (Î» p, quot.mk _ âŸ¨p.1, (Î±.app p.1) p.2âŸ©)
    (Î» p p' âŸ¨f, hâŸ©, quot.sound âŸ¨f, by rw h; exact functor_to_types.naturality _ _ Î± f _âŸ©) := rfl

@[simp] lemma types_colimit_desc (F : J â¥¤ Type u) (c : cocone F) :
  colimit.desc F c =
  quot.lift
    (Î» p, c.Î¹.app p.1 p.2)
    (Î» p p' âŸ¨f, hâŸ©, by rw h; exact (functor_to_types.naturality _ _ c.Î¹ f _).symm) := rfl

lemma jointly_surjective (F : J â¥¤ Type u) {t : limits.cocone F} (h : limits.is_colimit t)
  (x : t.X) : âˆƒ j y, t.Î¹.app j y = x :=
begin
  suffices : (Î» (x : t.X), ulift.up (âˆƒ j y, t.Î¹.app j y = x)) = (Î» _, ulift.up true),
  { have := congr_fun this x,
    have H := congr_arg ulift.down this,
    dsimp at H,
    rwa eq_true at H },
  refine h.hom_ext _,
  intro j, ext y,
  erw iff_true,
  exact âŸ¨j, y, rflâŸ©
end

namespace filtered_colimit
/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/

variables [is_filtered_or_empty.{u+1} J]
variables (F : J â¥¤ Type u)

protected def r (x y : Î£ j, F.obj j) : Prop :=
âˆƒ k (f : x.1 âŸ¶ k) (g : y.1 âŸ¶ k), F.map f x.2 = F.map g y.2

protected lemma r_equiv : equivalence (filtered_colimit.r F) :=
âŸ¨Î» x, âŸ¨x.1, ğŸ™ x.1, ğŸ™ x.1, rflâŸ©,
 Î» x y âŸ¨k, f, g, hâŸ©, âŸ¨k, g, f, h.symmâŸ©,
 Î» x y z âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ©,
   let âŸ¨l, fl, gl, _âŸ© := is_filtered_or_empty.cocone_objs.{u+1} k k',
       âŸ¨m, n, hnâŸ© := is_filtered_or_empty.cocone_maps (g â‰« fl) (f' â‰« gl) in
   âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n, calc
      F.map (f â‰« fl â‰« n) x.2
          = F.map (fl â‰« n) (F.map f x.2)  : by simp
      ... = F.map (fl â‰« n) (F.map g y.2)  : by rw h
      ... = F.map ((g â‰« fl) â‰« n) y.2      : by simp
      ... = F.map ((f' â‰« gl) â‰« n) y.2     : by rw hn
      ... = F.map (gl â‰« n) (F.map f' y.2) : by simp
      ... = F.map (gl â‰« n) (F.map g' z.2) : by rw h'
      ... = F.map (g' â‰« gl â‰« n) z.2       : by simpâŸ©âŸ©

protected lemma r_ge (x y : Î£ j, F.obj j) :
  (âˆƒ f : x.1 âŸ¶ y.1, y.2 = F.map f x.2) â†’ filtered_colimit.r F x y :=
Î» âŸ¨f, hfâŸ©, âŸ¨y.1, f, ğŸ™ y.1, by simp [hf]âŸ©

protected lemma r_eq :
  filtered_colimit.r F = eqv_gen (Î» x y, âˆƒ f : x.1 âŸ¶ y.1, y.2 = F.map f x.2) :=
begin
  apply le_antisymm,
  { rintros âŸ¨i, xâŸ© âŸ¨j, yâŸ© âŸ¨k, f, g, hâŸ©,
    exact eqv_gen.trans _ âŸ¨k, F.map f xâŸ© _ (eqv_gen.rel _ _ âŸ¨f, rflâŸ©)
      (eqv_gen.symm _ _ (eqv_gen.rel _ _ âŸ¨g, hâŸ©)) },
  { intros x y,
    convert relation.eqv_gen_mono (filtered_colimit.r_ge F),
    apply propext,
    symmetry,
    exact relation.eqv_gen_iff_of_equivalence (filtered_colimit.r_equiv F) }
end

lemma colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
begin
  change quot.mk _ _ = quot.mk _ _ â†” _,
  rw [quot.eq, â†filtered_colimit.r_eq],
  refl
end

variables {t : cocone F} (ht : is_colimit t)
local attribute [elab_simple] nat_trans.app
lemma is_colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
let t' := colimit.cocone F,
    e : t' â‰… t := is_colimit.unique (colimit.is_colimit F) ht,
    e' : t'.X â‰… t.X := cocones.forget.on_iso e in
begin
  refine iff.trans _ (colimit_eq_iff F),
  convert equiv.apply_eq_iff_eq e'.to_equiv _ _; rw â†e.hom.w; refl
end

variables (t)
/-- Recognizing filtered colimits of types. -/
noncomputable def is_colimit_of (hsurj : âˆ€ (x : t.X), âˆƒ i xi, x = t.Î¹.app i xi)
  (hinj : âˆ€ i j xi xj, t.Î¹.app i xi = t.Î¹.app j xj â†’
   âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj) : is_colimit t :=
-- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
-- is a bijection.
begin
  apply is_colimit.of_iso_colimit (colimit.is_colimit F),
  refine cocones.ext (equiv.to_iso (equiv.of_bijective _)) _,
  { exact colimit.desc F t },
  { split,
    { show function.injective _,
      intros a b h,
      rcases jointly_surjective F (colimit.is_colimit F) a with âŸ¨i, xi, rflâŸ©,
      rcases jointly_surjective F (colimit.is_colimit F) b with âŸ¨j, xj, rflâŸ©,
      change (colimit.Î¹ F i â‰« colimit.desc F t) xi = (colimit.Î¹ F j â‰« colimit.desc F t) xj at h,
      rw [colimit.Î¹_desc, colimit.Î¹_desc] at h,
      rcases hinj i j xi xj h with âŸ¨k, f, g, h'âŸ©,
      change colimit.Î¹ F i xi = colimit.Î¹ F j xj,
      rw [â†colimit.w F f, â†colimit.w F g],
      change colimit.Î¹ F k (F.map f xi) = colimit.Î¹ F k (F.map g xj),
      rw h' },
    { show function.surjective _,
      intro x,
      rcases hsurj x with âŸ¨i, xi, rflâŸ©,
      use colimit.Î¹ F i xi,
      simp } },
  { intro j, apply colimit.Î¹_desc }
end

end filtered_colimit

variables {Î± Î² : Type u} (f : Î± âŸ¶ Î²)

section -- implementation of `has_image`
/-- the image of a morphism in Type is just `set.range f` -/
def image : Type u := set.range f

instance [inhabited Î±] : inhabited (image f) :=
{ default := âŸ¨f (default Î±), âŸ¨_, rflâŸ©âŸ© }

/-- the inclusion of `image f` into the target -/
def image.Î¹ : image f âŸ¶ Î² := subtype.val

instance : mono (image.Î¹ f) :=
(mono_iff_injective _).2 subtype.val_injective

variables {f}

/-- the universal property for the image factorisation -/
noncomputable def image.lift (F' : mono_factorisation f) : image f âŸ¶ F'.I :=
(Î» x, F'.e (classical.indefinite_description _ x.2).1 : image f â†’ F'.I)

lemma image.lift_fac (F' : mono_factorisation f) : image.lift F' â‰« F'.m = image.Î¹ f :=
begin
  ext x,
  change (F'.e â‰« F'.m) _ = _,
  rw [F'.fac, (classical.indefinite_description _ x.2).2],
  refl,
end
end

/-- the factorisation of any morphism in AddCommGroup through a mono. -/
def mono_factorisation : mono_factorisation f :=
{ I := image f,
  m := image.Î¹ f,
  e := set.range_factorization f }

noncomputable instance : has_image f :=
{ F := mono_factorisation f,
  is_image :=
  { lift := image.lift,
    lift_fac' := image.lift_fac } }

noncomputable instance : has_images (Type u) :=
{ has_image := infer_instance }

end category_theory.limits.types
