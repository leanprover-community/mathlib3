/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton
-/
import category_theory.limits.shapes.images
import category_theory.filtered
import data.quot
import tactic.equiv_rw

universes u

open category_theory
open category_theory.limits

namespace category_theory.limits.types

variables {J : Type u} [small_category J]

/--
(internal implementation) the limit cone of a functor,
implemented as flat sections of a pi type
-/
def limit_cone (F : J ‚•§ Type u) : cone F :=
{ X := F.sections,
  œÄ := { app := Œª j u, u.val j } }

local attribute [elab_simple] congr_fun
/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limit_cone_is_limit (F : J ‚•§ Type u) : is_limit (limit_cone F) :=
{ lift := Œª s v, ‚ü®Œª j, s.œÄ.app j v, Œª j j' f, congr_fun (cone.w s f) _‚ü©,
  uniq' := by { intros, ext x j, exact congr_fun (w j) x } }

instance : has_limits (Type u) :=
{ has_limits_of_shape := Œª J ùí•, by exactI
  { has_limit := Œª F,
    { cone := limit_cone F, is_limit := limit_cone_is_limit F } } }

/--
The equivalence between the abstract limit of `F` in `Type u`
and the "concrete" definition as the sections of `F`.
-/
def limit_equiv_sections (F : J ‚•§ Type u) : (limit F : Type u) ‚âÉ F.sections :=
(is_limit.cone_point_unique_up_to_iso (limit.is_limit F) (limit_cone_is_limit F)).to_equiv

@[simp]
lemma limit_equiv_sections_apply (F : J ‚•§ Type u) (x : limit F) (j : J) :
  (((limit_equiv_sections F) x) : Œ† j, F.obj j) j = limit.œÄ F j x :=
rfl

@[simp]
lemma limit_equiv_sections_symm_apply (F : J ‚•§ Type u) (x : F.sections) (j : J) :
  limit.œÄ F j ((limit_equiv_sections F).symm x) = (x : Œ† j, F.obj j) j :=
begin
  equiv_rw (limit_equiv_sections F).symm at x,
  simp,
end

-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits
lemma limit_ext (F : J ‚•§ Type u) (x y : limit F) (w : ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y) :
  x = y :=
begin
  apply (limit_equiv_sections F).injective,
  ext j,
  simp [w j],
end

-- TODO: are there other limits lemmas that should have `_apply` versions?
-- Can we generate these like with `@[reassoc]`?
-- PROJECT: prove these for any concrete category where the forgetful functor preserves limits?
@[simp]
lemma lift_œÄ_apply (F : J ‚•§ Type u) (s : cone F) (j : J) (x : s.X) :
  limit.œÄ F j (limit.lift F s x) = s.œÄ.app j x :=
congr_fun (limit.lift_œÄ s j) x

/--
A quotient type implementing the colimit of a functor `F : J ‚•§ Type u`,
as pairs `‚ü®j, x‚ü©` where `x : F.obj j`, modulo the equivalence relation generated by
`‚ü®j, x‚ü© ~ ‚ü®j', x'‚ü©` whenever there is a morphism `f : j ‚ü∂ j'` so `F.map f x = x'`.
-/
@[nolint has_inhabited_instance]
def quot (F : J ‚•§ Type u) : Type u :=
@quot (Œ£ j, F.obj j) (Œª p p', ‚àÉ f : p.1 ‚ü∂ p'.1, p'.2 = F.map f p.2)

/--
(internal implementation) the colimit cocone of a functor,
implemented as a quotient of a sigma type
-/
def colimit_cocone (F : J ‚•§ Type u) : cocone F :=
{ X := quot F,
  Œπ :=
  { app := Œª j x, quot.mk _ ‚ü®j, x‚ü©,
    naturality' := Œª j j' f, funext $ Œª x, eq.symm (quot.sound ‚ü®f, rfl‚ü©) } }

local attribute [elab_with_expected_type] quot.lift

/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
def colimit_cocone_is_colimit (F : J ‚•§ Type u) : is_colimit (colimit_cocone F) :=
{ desc := Œª s, quot.lift (Œª (p : Œ£ j, F.obj j), s.Œπ.app p.1 p.2)
    (assume ‚ü®j, x‚ü© ‚ü®j', x'‚ü© ‚ü®f, hf‚ü©, by rw hf; exact (congr_fun (cocone.w s f) x).symm) }

instance : has_colimits (Type u) :=
{ has_colimits_of_shape := Œª J ùí•, by exactI
  { has_colimit := Œª F,
    { cocone := colimit_cocone F, is_colimit := colimit_cocone_is_colimit F } } }

/--
The equivalence between the abstract colimit of `F` in `Type u`
and the "concrete" definition as a quotient.
-/
def colimit_equiv_quot (F : J ‚•§ Type u) : (colimit F : Type u) ‚âÉ quot F :=
(is_colimit.cocone_point_unique_up_to_iso (colimit.is_colimit F) (colimit_cocone_is_colimit F)).to_equiv

@[simp]
lemma colimit_equiv_quot_symm_apply (F : J ‚•§ Type u) (j : J) (x : F.obj j) :
  (colimit_equiv_quot F).symm (quot.mk _ ‚ü®j, x‚ü©) = colimit.Œπ F j x :=
rfl

@[simp]
lemma Œπ_desc_apply (F : J ‚•§ Type u) (s : cocone F) (j : J) (x : F.obj j) :
  colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
congr_fun (colimit.Œπ_desc s j) x

lemma jointly_surjective (F : J ‚•§ Type u) {t : cocone F} (h : is_colimit t)
  (x : t.X) : ‚àÉ j y, t.Œπ.app j y = x :=
begin
  suffices : (Œª (x : t.X), ulift.up (‚àÉ j y, t.Œπ.app j y = x)) = (Œª _, ulift.up true),
  { have := congr_fun this x,
    have H := congr_arg ulift.down this,
    dsimp at H,
    rwa eq_true at H },
  refine h.hom_ext _,
  intro j, ext y,
  erw iff_true,
  exact ‚ü®j, y, rfl‚ü©
end

/-- A variant of `jointly_surjective` for `x : colimit F`. -/
lemma jointly_surjective' {F : J ‚•§ Type u}
  (x : colimit F) : ‚àÉ j y, colimit.Œπ F j y = x :=
jointly_surjective F (colimit.is_colimit _) x

namespace filtered_colimit
/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/

variables (F : J ‚•§ Type u)

/--
An alternative relation on `Œ£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def r (x y : Œ£ j, F.obj j) : Prop :=
‚àÉ k (f : x.1 ‚ü∂ k) (g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2

protected lemma r_ge (x y : Œ£ j, F.obj j) :
  (‚àÉ f : x.1 ‚ü∂ y.1, y.2 = F.map f x.2) ‚Üí filtered_colimit.r F x y :=
Œª ‚ü®f, hf‚ü©, ‚ü®y.1, f, ùüô y.1, by simp [hf]‚ü©

variables (t : cocone F)
local attribute [elab_simple] nat_trans.app

/-- Recognizing filtered colimits of types. -/
noncomputable def is_colimit_of (hsurj : ‚àÄ (x : t.X), ‚àÉ i xi, x = t.Œπ.app i xi)
  (hinj : ‚àÄ i j xi xj, t.Œπ.app i xi = t.Œπ.app j xj ‚Üí
   ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj) : is_colimit t :=
-- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
-- is a bijection.
begin
  apply is_colimit.of_iso_colimit (colimit.is_colimit F),
  refine cocones.ext (equiv.to_iso (equiv.of_bijective _ _)) _,
  { exact colimit.desc F t },
  { split,
    { show function.injective _,
      intros a b h,
      rcases jointly_surjective F (colimit.is_colimit F) a with ‚ü®i, xi, rfl‚ü©,
      rcases jointly_surjective F (colimit.is_colimit F) b with ‚ü®j, xj, rfl‚ü©,
      change (colimit.Œπ F i ‚â´ colimit.desc F t) xi = (colimit.Œπ F j ‚â´ colimit.desc F t) xj at h,
      rw [colimit.Œπ_desc, colimit.Œπ_desc] at h,
      rcases hinj i j xi xj h with ‚ü®k, f, g, h'‚ü©,
      change colimit.Œπ F i xi = colimit.Œπ F j xj,
      rw [‚Üêcolimit.w F f, ‚Üêcolimit.w F g],
      change colimit.Œπ F k (F.map f xi) = colimit.Œπ F k (F.map g xj),
      rw h' },
    { show function.surjective _,
      intro x,
      rcases hsurj x with ‚ü®i, xi, rfl‚ü©,
      use colimit.Œπ F i xi,
      simp } },
  { intro j, apply colimit.Œπ_desc }
end

variables [is_filtered_or_empty J]

protected lemma r_equiv : equivalence (filtered_colimit.r F) :=
‚ü®Œª x, ‚ü®x.1, ùüô x.1, ùüô x.1, rfl‚ü©,
 Œª x y ‚ü®k, f, g, h‚ü©, ‚ü®k, g, f, h.symm‚ü©,
 Œª x y z ‚ü®k, f, g, h‚ü© ‚ü®k', f', g', h'‚ü©,
   let ‚ü®l, fl, gl, _‚ü© := is_filtered_or_empty.cocone_objs k k',
       ‚ü®m, n, hn‚ü© := is_filtered_or_empty.cocone_maps (g ‚â´ fl) (f' ‚â´ gl) in
   ‚ü®m, f ‚â´ fl ‚â´ n, g' ‚â´ gl ‚â´ n, calc
      F.map (f ‚â´ fl ‚â´ n) x.2
          = F.map (fl ‚â´ n) (F.map f x.2)  : by simp
      ... = F.map (fl ‚â´ n) (F.map g y.2)  : by rw h
      ... = F.map ((g ‚â´ fl) ‚â´ n) y.2      : by simp
      ... = F.map ((f' ‚â´ gl) ‚â´ n) y.2     : by rw hn
      ... = F.map (gl ‚â´ n) (F.map f' y.2) : by simp
      ... = F.map (gl ‚â´ n) (F.map g' z.2) : by rw h'
      ... = F.map (g' ‚â´ gl ‚â´ n) z.2       : by simp‚ü©‚ü©

protected lemma r_eq :
  filtered_colimit.r F = eqv_gen (Œª x y, ‚àÉ f : x.1 ‚ü∂ y.1, y.2 = F.map f x.2) :=
begin
  apply le_antisymm,
  { rintros ‚ü®i, x‚ü© ‚ü®j, y‚ü© ‚ü®k, f, g, h‚ü©,
    exact eqv_gen.trans _ ‚ü®k, F.map f x‚ü© _ (eqv_gen.rel _ _ ‚ü®f, rfl‚ü©)
      (eqv_gen.symm _ _ (eqv_gen.rel _ _ ‚ü®g, h‚ü©)) },
  { intros x y,
    convert relation.eqv_gen_mono (filtered_colimit.r_ge F),
    apply propext,
    symmetry,
    exact relation.eqv_gen_iff_of_equivalence (filtered_colimit.r_equiv F) }
end

lemma colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj :=
begin
  change quot.mk _ _ = quot.mk _ _ ‚Üî _,
  rw [quot.eq, ‚Üêfiltered_colimit.r_eq],
  refl
end

variables {t} (ht : is_colimit t)
lemma is_colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Œπ.app i xi = t.Œπ.app j xj ‚Üî ‚àÉ k (f : i ‚ü∂ k) (g : j ‚ü∂ k), F.map f xi = F.map g xj :=
let t' := colimit.cocone F,
    e : t' ‚âÖ t := is_colimit.unique_up_to_iso (colimit.is_colimit F) ht,
    e' : t'.X ‚âÖ t.X := (cocones.forget _).map_iso e in
begin
  refine iff.trans _ (colimit_eq_iff F),
  convert equiv.apply_eq_iff_eq e'.to_equiv _ _; rw ‚Üêe.hom.w; refl
end

end filtered_colimit

variables {Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤)

section -- implementation of `has_image`
/-- the image of a morphism in Type is just `set.range f` -/
def image : Type u := set.range f

instance [inhabited Œ±] : inhabited (image f) :=
{ default := ‚ü®f (default Œ±), ‚ü®_, rfl‚ü©‚ü© }

/-- the inclusion of `image f` into the target -/
def image.Œπ : image f ‚ü∂ Œ≤ := subtype.val

instance : mono (image.Œπ f) :=
(mono_iff_injective _).2 subtype.val_injective

variables {f}

/-- the universal property for the image factorisation -/
noncomputable def image.lift (F' : mono_factorisation f) : image f ‚ü∂ F'.I :=
(Œª x, F'.e (classical.indefinite_description _ x.2).1 : image f ‚Üí F'.I)

lemma image.lift_fac (F' : mono_factorisation f) : image.lift F' ‚â´ F'.m = image.Œπ f :=
begin
  ext x,
  change (F'.e ‚â´ F'.m) _ = _,
  rw [F'.fac, (classical.indefinite_description _ x.2).2],
  refl,
end
end

/-- the factorisation of any morphism in AddCommGroup through a mono. -/
def mono_factorisation : mono_factorisation f :=
{ I := image f,
  m := image.Œπ f,
  e := set.range_factorization f }

noncomputable instance : has_image f :=
{ F := mono_factorisation f,
  is_image :=
  { lift := image.lift,
    lift_fac' := image.lift_fac } }

noncomputable instance : has_images (Type u) :=
{ has_image := infer_instance }

noncomputable instance : has_image_maps (Type u) :=
{ has_image_map := Œª f g st,
  { map := Œª x, ‚ü®st.right x.1, ‚ü®st.left (classical.some x.2),
      begin
        have p := st.w,
        replace p := congr_fun p (classical.some x.2),
        simp only [functor.id_map, types_comp_apply, subtype.val_eq_coe] at p,
        erw [p, classical.some_spec x.2],
      end‚ü©‚ü© } }

@[simp] lemma image_map {f g : arrow (Type u)} (st : f ‚ü∂ g) (x : image f.hom) :
  (image.map st x).val = st.right x.1 :=
rfl

end category_theory.limits.types
