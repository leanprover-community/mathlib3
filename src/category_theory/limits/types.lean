-- Copyright (c) 2018 Scott Morrison. All rights reserved.
-- Released under Apache 2.0 license as described in the file LICENSE.
-- Authors: Scott Morrison, Reid Barton

import category_theory.limits.limits
import category_theory.filtered
import data.quot

universes u

open category_theory
open category_theory.limits

namespace category_theory.limits.types

variables {J : Type u} [small_category J]

def limit (F : J â¥¤ Type u) : cone F :=
{ X := {u : Î  j, F.obj j // âˆ€ {j j'} (f : j âŸ¶ j'), F.map f (u j) = u j'},
  Ï€ := { app := Î» j u, u.val j } }

local attribute [elab_simple] congr_fun
def limit_is_limit (F : J â¥¤ Type u) : is_limit (limit F) :=
{ lift := Î» s v, âŸ¨Î» j, s.Ï€.app j v, Î» j j' f, congr_fun (cone.w s f) _âŸ©,
  uniq' :=
  begin
    intros, ext x, apply subtype.eq, ext j,
    exact congr_fun (w j) x
  end }

instance : has_limits.{u} (Type u) :=
Î» J ğ’¥ F, by exactI { cone := limit F, is_limit := limit_is_limit F }

@[simp] lemma types_limit (F : J â¥¤ Type u) :
  limits.limit F = {u : Î  j, F.obj j // âˆ€ {j j'} f, F.map f (u j) = u j'} := rfl
@[simp] lemma types_limit_Ï€ (F : J â¥¤ Type u) (j : J) (g : (limit F).X) :
  limit.Ï€ F j g = g.val j := rfl
@[simp] lemma types_limit_pre
  (F : J â¥¤ Type u) {K : Type u} [ğ’¦ : small_category K] (E : K â¥¤ J) (g : (limit F).X) :
  limit.pre F E g = (âŸ¨Î» k, g.val (E.obj k), by obviouslyâŸ© : (limit (E â‹™ F)).X) := rfl
@[simp] lemma types_limit_map {F G : J â¥¤ Type u} (Î± : F âŸ¹ G) (g : (limit F).X) :
  (lim.map Î± : (limit F).X â†’ (limit G).X) g =
  (âŸ¨Î» j, (Î±.app j) (g.val j), Î» j j' f,
    by rw [â†functor_to_types.naturality, â†(g.property f)]âŸ© : (limit G).X) := rfl

@[simp] lemma types_limit_lift (F : J â¥¤ Type u) (c : cone F) (x : c.X):
  limit.lift F c x = (âŸ¨Î» j, c.Ï€.app j x, Î» j j' f, congr_fun (cone.w c f) xâŸ© : (limit F).X) :=
rfl


def colimit (F : J â¥¤ Type u) : cocone F :=
{ X := @quot (Î£ j, F.obj j) (Î» p p', âˆƒ f : p.1 âŸ¶ p'.1, p'.2 = F.map f p.2),
  Î¹ :=
  { app := Î» j x, quot.mk _ âŸ¨j, xâŸ©,
    naturality' := Î» j j' f, funext $ Î» x, eq.symm (quot.sound âŸ¨f, rflâŸ©) } }

local attribute [elab_with_expected_type] quot.lift

def colimit_is_colimit (F : J â¥¤ Type u) : is_colimit (colimit F) :=
{ desc := Î» s, quot.lift (Î» (p : Î£ j, F.obj j), s.Î¹.app p.1 p.2)
    (assume âŸ¨j, xâŸ© âŸ¨j', x'âŸ© âŸ¨f, hfâŸ©, by rw hf; exact (congr_fun (cocone.w s f) x).symm) }

instance : has_colimits.{u} (Type u) :=
Î» J ğ’¥ F, by exactI { cocone := colimit F, is_colimit := colimit_is_colimit F }

@[simp] lemma types_colimit (F : J â¥¤ Type u) :
  limits.colimit F = @quot (Î£ j, F.obj j) (Î» p p', âˆƒ f : p.1 âŸ¶ p'.1, p'.2 = F.map f p.2) := rfl
@[simp] lemma types_colimit_Î¹ (F : J â¥¤ Type u) (j : J) :
  colimit.Î¹ F j = Î» x, quot.mk _ âŸ¨j, xâŸ© := rfl
@[simp] lemma types_colimit_pre
  (F : J â¥¤ Type u) {K : Type u} [ğ’¦ : small_category K] (E : K â¥¤ J) (g : (colimit (E â‹™ F)).X) :
  colimit.pre F E =
  quot.lift (Î» p, quot.mk _ âŸ¨E.obj p.1, p.2âŸ©) (Î» p p' âŸ¨f, hâŸ©, quot.sound âŸ¨E.map f, hâŸ©) := rfl
@[simp] lemma types_colimit_map {F G : J â¥¤ Type u} (Î± : F âŸ¹ G) :
  (colim.map Î± : (colimit F).X â†’ (colimit G).X) =
  quot.lift
    (Î» p, quot.mk _ âŸ¨p.1, (Î±.app p.1) p.2âŸ©)
    (Î» p p' âŸ¨f, hâŸ©, quot.sound âŸ¨f, by rw h; exact functor_to_types.naturality _ _ Î± f _âŸ©) := rfl

@[simp] lemma types_colimit_desc (F : J â¥¤ Type u) (c : cocone F) :
  colimit.desc F c =
  quot.lift
    (Î» p, c.Î¹.app p.1 p.2)
    (Î» p p' âŸ¨f, hâŸ©, by rw h; exact (functor_to_types.naturality _ _ c.Î¹ f _).symm) := rfl

namespace filtered_colimit
/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/

variables [is_filtered_or_empty.{u+1} J]
variables (F : J â¥¤ Type u)

protected def r (x y : Î£ j, F.obj j) : Prop :=
âˆƒ k (f : x.1 âŸ¶ k) (g : y.1 âŸ¶ k), F.map f x.2 = F.map g y.2

protected lemma r_equiv : equivalence (filtered_colimit.r F) :=
âŸ¨Î» x, âŸ¨x.1, ğŸ™ x.1, ğŸ™ x.1, rflâŸ©,
 Î» x y âŸ¨k, f, g, hâŸ©, âŸ¨k, g, f, h.symmâŸ©,
 Î» x y z âŸ¨k, f, g, hâŸ© âŸ¨k', f', g', h'âŸ©,
   let âŸ¨l, fl, gl, _âŸ© := is_filtered_or_empty.cocone_objs.{u+1} k k',
       âŸ¨m, n, hnâŸ© := is_filtered_or_empty.cocone_maps (g â‰« fl) (f' â‰« gl) in
   âŸ¨m, f â‰« fl â‰« n, g' â‰« gl â‰« n, calc
      F.map (f â‰« fl â‰« n) x.2
          = F.map (fl â‰« n) (F.map f x.2)  : by simp
      ... = F.map (fl â‰« n) (F.map g y.2)  : by rw h
      ... = F.map ((g â‰« fl) â‰« n) y.2      : by simp
      ... = F.map ((f' â‰« gl) â‰« n) y.2     : by rw hn
      ... = F.map (gl â‰« n) (F.map f' y.2) : by simp
      ... = F.map (gl â‰« n) (F.map g' z.2) : by rw h'
      ... = F.map (g' â‰« gl â‰« n) z.2       : by simpâŸ©âŸ©

protected lemma r_ge (x y : Î£ j, F.obj j) :
  (âˆƒ f : x.1 âŸ¶ y.1, y.2 = F.map f x.2) â†’ filtered_colimit.r F x y :=
Î» âŸ¨f, hfâŸ©, âŸ¨y.1, f, ğŸ™ y.1, by simp [hf]âŸ©

protected lemma r_eq :
  filtered_colimit.r F = eqv_gen (Î» x y, âˆƒ f : x.1 âŸ¶ y.1, y.2 = F.map f x.2) :=
begin
  apply le_antisymm,
  { rintros âŸ¨i, xâŸ© âŸ¨j, yâŸ© âŸ¨k, f, g, hâŸ©,
    exact eqv_gen.trans _ âŸ¨k, F.map f xâŸ© _ (eqv_gen.rel _ _ âŸ¨f, rflâŸ©)
      (eqv_gen.symm _ _ (eqv_gen.rel _ _ âŸ¨g, hâŸ©)) },
  { intros x y,
    convert relation.eqv_gen_mono (filtered_colimit.r_ge F),
    apply propext,
    symmetry,
    exact relation.eqv_gen_iff_of_equivalence (filtered_colimit.r_equiv F) }
end

lemma colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  colimit.Î¹ F i xi = colimit.Î¹ F j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
begin
  change quot.mk _ _ = quot.mk _ _ â†” _,
  rw [quot.eq, â†filtered_colimit.r_eq],
  refl
end

variables {t : cocone F} (ht : is_colimit t)
local attribute [elab_simple] nat_trans.app
lemma is_colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
  t.Î¹.app i xi = t.Î¹.app j xj â†” âˆƒ k (f : i âŸ¶ k) (g : j âŸ¶ k), F.map f xi = F.map g xj :=
let t' := colimit.cocone F,
    e : t' â‰… t := is_colimit.unique (colimit.is_colimit F) ht,
    e' : t'.X â‰… t.X := cocones.forget.on_iso e in
begin
  refine iff.trans _ (colimit_eq_iff F),
  convert equiv.apply_eq_iff_eq e'.to_equiv _ _; rw â†e.hom.w; refl
end

end filtered_colimit

end category_theory.limits.types
