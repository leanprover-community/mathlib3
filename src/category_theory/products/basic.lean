/-
Copyright (c) 2017 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Stephen Morgan, Scott Morrison
-/
import category_theory.eq_to_hom
import category_theory.functor.const
import data.prod.basic

/-!
# Cartesian products of categories

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We define the category instance on `C √ó D` when `C` and `D` are categories.

We define:
* `sectl C Z` : the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ ‚ü®X, Z‚ü©`
* `sectr Z D` : the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ ‚ü®Z, Y‚ü©`
* `fst`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ X`
* `snd`       : the functor `‚ü®X, Y‚ü© ‚Ü¶ Y`
* `swap`      : the functor `C √ó D ‚•§ D √ó C` given by `‚ü®X, Y‚ü© ‚Ü¶ ‚ü®Y, X‚ü©`
    (and the fact this is an equivalence)

We further define `evaluation : C ‚•§ (C ‚•§ D) ‚•§ D` and `evaluation_uncurried : C √ó (C ‚•§ D) ‚•§ D`,
and products of functors and natural transformations, written `F.prod G` and `Œ±.prod Œ≤`.
-/

namespace category_theory

-- declare the `v`'s first; see `category_theory.category` for an explanation
universes v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ u‚ÇÅ u‚ÇÇ u‚ÇÉ u‚ÇÑ

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/--
`prod C D` gives the cartesian product of two categories.

See <https://stacks.math.columbia.edu/tag/001K>.
-/
@[simps {not_recursive := []}] -- the generates simp lemmas like `id_fst` and `comp_snd`
instance prod : category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) :=
{ hom     := Œª X Y, ((X.1) ‚ü∂ (Y.1)) √ó ((X.2) ‚ü∂ (Y.2)),
  id      := Œª X, ‚ü® ùüô (X.1), ùüô (X.2) ‚ü©,
  comp    := Œª _ _ _ f g, (f.1 ‚â´ g.1, f.2 ‚â´ g.2) }

/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/
@[simp] lemma prod_id (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y) := rfl
@[simp] lemma prod_comp {P Q R : C} {S T U : D} (f : (P, S) ‚ü∂ (Q, T)) (g : (Q, T) ‚ü∂ (R, U)) :
  f ‚â´ g = (f.1 ‚â´ g.1, f.2 ‚â´ g.2) := rfl

lemma is_iso_prod_iff {P Q : C} {S T : D} {f : (P, S) ‚ü∂ (Q, T)} :
  is_iso f ‚Üî is_iso f.1 ‚àß is_iso f.2 :=
begin
  split,
  { rintros ‚ü®g, hfg, hgf‚ü©,
    simp at hfg hgf,
    rcases hfg with ‚ü®hfg‚ÇÅ, hfg‚ÇÇ‚ü©,
    rcases hgf with ‚ü®hgf‚ÇÅ, hgf‚ÇÇ‚ü©,
    exact ‚ü®‚ü®‚ü®g.1, hfg‚ÇÅ, hgf‚ÇÅ‚ü©‚ü©, ‚ü®‚ü®g.2, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©‚ü© },
  { rintros ‚ü®‚ü®g‚ÇÅ, hfg‚ÇÅ, hgf‚ÇÅ‚ü©, ‚ü®g‚ÇÇ, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©,
    dsimp at hfg‚ÇÅ hgf‚ÇÅ hfg‚ÇÇ hgf‚ÇÇ,
    refine ‚ü®‚ü®(g‚ÇÅ, g‚ÇÇ), _, _‚ü©‚ü©; { simp; split; assumption } }
end

section
variables {C D}

/-- The isomorphism between `(X.1, X.2)` and `X`. -/
@[simps]
def prod.eta_iso (X : C √ó D) : (X.1, X.2) ‚âÖ X := { hom := (ùüô _, ùüô _), inv := (ùüô _, ùüô _) }

/-- Construct an isomorphism in `C √ó D` out of two isomorphisms in `C` and `D`. -/
@[simps]
def iso.prod {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T) :=
{ hom := (f.hom, g.hom),
  inv := (f.inv, g.inv), }

end

end

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÅ) [category.{v‚ÇÅ} D]
/--
`prod.category.uniform C D` is an additional instance specialised so both factors have the same
universe levels. This helps typeclass resolution.
-/
instance uniform_prod : category (C √ó D) := category_theory.prod C D
end

-- Next we define the natural functors into and out of product categories. For now this doesn't
-- address the universal properties.
namespace prod

/-- `sectl C Z` is the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ (X, Z)`. -/
@[simps] def sectl
  (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D :=
{ obj := Œª X, (X, Z),
  map := Œª X Y f, (f, ùüô Z) }

/-- `sectr Z D` is the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ (Z, Y)` . -/
@[simps] def sectr
  {C : Type u‚ÇÅ} [category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D] : D ‚•§ C √ó D :=
{ obj := Œª X, (Z, X),
  map := Œª X Y f, (ùüô Z, f) }

variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/-- `fst` is the functor `(X, Y) ‚Ü¶ X`. -/
@[simps] def fst : C √ó D ‚•§ C :=
{ obj := Œª X, X.1,
  map := Œª X Y f, f.1 }

/-- `snd` is the functor `(X, Y) ‚Ü¶ Y`. -/
@[simps] def snd : C √ó D ‚•§ D :=
{ obj := Œª X, X.2,
  map := Œª X Y f, f.2 }

/-- The functor swapping the factors of a cartesian product of categories, `C √ó D ‚•§ D √ó C`. -/
@[simps] def swap : C √ó D ‚•§ D √ó C :=
{ obj := Œª X, (X.2, X.1),
  map := Œª _ _ f, (f.2, f.1) }

/--
Swapping the factors of a cartesion product of categories twice is naturally isomorphic
to the identity functor.
-/
@[simps] def symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) :=
{ hom := { app := Œª X, ùüô X },
  inv := { app := Œª X, ùüô X } }

/--
The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.
-/
@[simps]
def braiding : C √ó D ‚âå D √ó C :=
equivalence.mk (swap C D) (swap D C)
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))
  (nat_iso.of_components (Œª X, eq_to_iso (by simp)) (by tidy))

instance swap_is_equivalence : is_equivalence (swap C D) :=
(by apply_instance : is_equivalence (braiding C D).functor)

end prod

section
variables (C : Type u‚ÇÅ) [category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [category.{v‚ÇÇ} D]

/--
The "evaluation at `X`" functor, such that
`(evaluation.obj X).obj F = F.obj X`,
which is functorial in both `X` and `F`.
-/
@[simps] def evaluation : C ‚•§ (C ‚•§ D) ‚•§ D :=
{ obj := Œª X,
  { obj := Œª F, F.obj X,
    map := Œª F G Œ±, Œ±.app X, },
  map := Œª X Y f,
  { app := Œª F, F.map f,
    naturality' := Œª F G Œ±, eq.symm (Œ±.naturality f) } }

/--
The "evaluation of `F` at `X`" functor,
as a functor `C √ó (C ‚•§ D) ‚•§ D`.
-/
@[simps] def evaluation_uncurried : C √ó (C ‚•§ D) ‚•§ D :=
{ obj := Œª p, p.2.obj p.1,
  map := Œª x y f, (x.2.map f.1) ‚â´ (f.2.app y.1),
  map_comp' := Œª X Y Z f g,
  begin
    cases g, cases f, cases Z, cases Y, cases X,
    simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc],
    rw [‚Üênat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app,
        category.assoc, nat_trans.naturality],
  end }

variables {C}

/-- The constant functor followed by the evalutation functor is just the identity. -/
@[simps] def functor.const_comp_evaluation_obj (X : C) :
  functor.const C ‚ãô (evaluation C D).obj X ‚âÖ ùü≠ D :=
nat_iso.of_components (Œª Y, iso.refl _) (Œª Y Z f, by simp)

end

variables {A : Type u‚ÇÅ} [category.{v‚ÇÅ} A]
          {B : Type u‚ÇÇ} [category.{v‚ÇÇ} B]
          {C : Type u‚ÇÉ} [category.{v‚ÇÉ} C]
          {D : Type u‚ÇÑ} [category.{v‚ÇÑ} D]

namespace functor
/-- The cartesian product of two functors. -/
@[simps] def prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D :=
{ obj := Œª X, (F.obj X.1, G.obj X.2),
  map := Œª _ _ f, (F.map f.1, G.map f.2) }

/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F √ó G`.
   You can use `F.prod G` as a "poor man's infix", or just write `functor.prod F G`. -/

/-- Similar to `prod`, but both functors start from the same category `A` -/
@[simps] def prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ (B √ó C) :=
{ obj := Œª a, (F.obj a, G.obj a),
  map := Œª x y f, (F.map f, G.map f), }

/-- The product `F.prod' G` followed by projection on the first component is isomorphic to `F` -/
@[simps]
def prod'_comp_fst (F : A ‚•§ B) (G : A ‚•§ C) : (F.prod' G) ‚ãô (category_theory.prod.fst B C) ‚âÖ F :=
nat_iso.of_components (Œª X, iso.refl _) (Œª X Y f, by simp)

/-- The product `F.prod' G` followed by projection on the second component is isomorphic to `G` -/
@[simps]
def prod'_comp_snd (F : A ‚•§ B) (G : A ‚•§ C) : (F.prod' G) ‚ãô (category_theory.prod.snd B C) ‚âÖ G :=
nat_iso.of_components (Œª X, iso.refl _) (Œª X Y f, by simp)

section
variable (C)

/-- The diagonal functor. -/
def diag : C ‚•§ C √ó C := (ùü≠ C).prod' (ùü≠ C)

@[simp] lemma diag_obj (X : C) : (diag C).obj X = (X, X) := rfl

@[simp] lemma diag_map {X Y : C} (f : X ‚ü∂ Y) : (diag C).map f = (f, f) := rfl

end

end functor

namespace nat_trans

/-- The cartesian product of two natural transformations. -/
@[simps] def prod {F G : A ‚•§ B} {H I : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) :
  F.prod H ‚ü∂ G.prod I :=
{ app         := Œª X, (Œ±.app X.1, Œ≤.app X.2),
  naturality' := Œª X Y f,
  begin
    cases X, cases Y,
    simp only [functor.prod_map, prod.mk.inj_iff, prod_comp],
    split; rw naturality
  end }

/- Again, it is inadvisable in Lean 3 to setup a notation `Œ± √ó Œ≤`;
   use instead `Œ±.prod Œ≤` or `nat_trans.prod Œ± Œ≤`. -/

end nat_trans

/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/
@[simps]
def flip_comp_evaluation (F : A ‚•§ B ‚•§ C) (a) :
  F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=
nat_iso.of_components (Œª b, eq_to_iso rfl) $ by tidy

variables (A B C)

/-- The forward direction for `functor_prod_functor_equiv` -/
@[simps] def prod_functor_to_functor_prod : (A ‚•§ B) √ó (A ‚•§ C) ‚•§ A ‚•§ B √ó C :=
{ obj := Œª F, F.1.prod' F.2,
  map := Œª F G f, { app := Œª X, (f.1.app X, f.2.app X) } }

/-- The backward direction for `functor_prod_functor_equiv` -/
@[simps] def functor_prod_to_prod_functor : (A ‚•§ B √ó C) ‚•§ (A ‚•§ B) √ó (A ‚•§ C) :=
{ obj := Œª F, ‚ü®F ‚ãô (category_theory.prod.fst B C), F ‚ãô (category_theory.prod.snd B C)‚ü©,
  map := Œª F G Œ±,
  ‚ü®{ app := Œª X, (Œ±.app X).1,
     naturality' := Œª X Y f,
     by simp only [functor.comp_map, prod.fst_map, ‚Üêprod_comp_fst, Œ±.naturality] },
   { app := Œª X, (Œ±.app X).2,
     naturality' := Œª X Y f,
     by simp only [functor.comp_map, prod.snd_map, ‚Üêprod_comp_snd, Œ±.naturality] }‚ü© }

/-- The unit isomorphism for `functor_prod_functor_equiv` -/
@[simps] def functor_prod_functor_equiv_unit_iso :
  ùü≠ _ ‚âÖ prod_functor_to_functor_prod A B C ‚ãô functor_prod_to_prod_functor A B C :=
nat_iso.of_components
  (Œª F, (((functor.prod'_comp_fst _ _).prod (functor.prod'_comp_snd _ _)).trans
  (prod.eta_iso F)).symm) (Œª F G Œ±, by {tidy})

/-- The counit isomorphism for `functor_prod_functor_equiv` -/
@[simps] def functor_prod_functor_equiv_counit_iso :
  functor_prod_to_prod_functor A B C ‚ãô prod_functor_to_functor_prod A B C ‚âÖ ùü≠ _ :=
nat_iso.of_components
  (Œª F, nat_iso.of_components (Œª X, prod.eta_iso (F.obj X)) (by tidy)) (by tidy)

/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/
@[simps] def functor_prod_functor_equiv : ((A ‚•§ B) √ó (A ‚•§ C)) ‚âå (A ‚•§ (B √ó C)) :=
{ functor := prod_functor_to_functor_prod A B C,
  inverse := functor_prod_to_prod_functor A B C,
  unit_iso := functor_prod_functor_equiv_unit_iso A B C,
  counit_iso := functor_prod_functor_equiv_counit_iso A B C }

end category_theory
