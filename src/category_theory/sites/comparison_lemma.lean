
import category_theory.sites.dense_subsite
import category_theory.sites.cover_lifting


namespace category_theory

universes v u

section
open limits
open opposite
open presieve
variables {C D : Type u} [category.{u} C] [category.{u} D] {G : C ‚•§ D}
variables {J : grothendieck_topology C} {K : grothendieck_topology D}
variables {A : Type v} [category.{u} A]
variables (H : cover_dense J K G) (H' : cover_preserving J K G)

namespace comparison_lemma
variables {‚Ñ± ‚Ñ±' : SheafOfTypes K} (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val)

/--
(Implementation). Given an hom between the pullbacks of two sheaves, we can whisker it with
`coyoneda` to obtain an hom between the pullbacks of the sheaves of maps from `X`.
-/
@[simps] def hom_over {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val) (X : A) :
  G.op ‚ãô (sheaf_over ‚Ñ± X).val ‚ü∂ G.op ‚ãô (sheaf_over ‚Ñ±' X).val :=
whisker_right Œ± (coyoneda.obj (op X))

/--
(Implementation). Given an iso between the pullbacks of two sheaves, we can whisker it with
`coyoneda` to obtain an iso between the pullbacks of the sheaves of maps from `X`.
-/
@[simps] def iso_over {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : A) :
  G.op ‚ãô (sheaf_over ‚Ñ± X).val ‚âÖ G.op ‚ãô (sheaf_over ‚Ñ±' X).val :=
iso_whisker_right Œ± (coyoneda.obj (op X))


include H ‚Ñ± ‚Ñ±'
open structured_arrow
namespace types
/--
(Implementation). Given a section of `‚Ñ±` on `X`, we can obtain a family of elements valued in `‚Ñ±'`
that is defined on a cover generated by the images of `G`. -/
@[simp] noncomputable
def pushforward_family {X}
  (x : ‚Ñ±.val.obj (op X)) : family_of_elements ‚Ñ±'.val (H.obj' X) := Œª Y f hf,
  ‚Ñ±'.val.map (H.obj_fac' _ hf).lift.op $ Œ±.app (op (H.obj_fac' X hf).obj) $
    ‚Ñ±.val.map (H.obj_fac' _ hf).map.op x

include H'

/-- (Implementation). The `pushforward_family` defined is compatible. -/
lemma pushforward_family_compatible {X} (x : ‚Ñ±.val.obj (op X)) :
  (pushforward_family H Œ± x).compatible :=
begin
  intros Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ e,
  change (‚Ñ±'.val.map (H.obj_fac' X h‚ÇÅ).lift.op ‚â´ ‚Ñ±'.val.map g‚ÇÅ.op) _ =
  (‚Ñ±'.val.map (H.obj_fac' X h‚ÇÇ).lift.op ‚â´ ‚Ñ±'.val.map g‚ÇÇ.op) _,
  simp only [‚Üêfunctor.map_comp, ‚Üê op_comp],
  apply functor_pushforward_compatible_of_dense_subsite H H'
    ‚Ñ±' (g‚ÇÅ ‚â´ (H.obj_fac' X h‚ÇÅ).lift) (g‚ÇÇ ‚â´ (H.obj_fac' X h‚ÇÇ).lift)
    (H.obj_fac' X h‚ÇÅ).map (H.obj_fac' X h‚ÇÇ).map,
  { simp only [category.assoc],
    convert e,
    exact (H.obj_fac' _ h‚ÇÅ).fac.symm,
    exact (H.obj_fac' _ h‚ÇÇ).fac.symm },
  { intros X' f‚ÇÅ' f‚ÇÇ' eq',
    convert congr_fun _ x,
    change ‚Ñ±.val.map _ ‚â´ Œ±.app (op _) ‚â´ ‚Ñ±'.val.map _ =
      ‚Ñ±.val.map _ ‚â´ Œ±.app (op _) ‚â´ ‚Ñ±'.val.map _,
    erw [‚Üê Œ±.naturality f‚ÇÅ'.op, ‚Üê Œ±.naturality f‚ÇÇ'.op],
    simp only [quiver.hom.unop_op, functor.comp_map, G.op_map,
    ‚Üê category.assoc, ‚Üê ‚Ñ±.val.map_comp, ‚Üêop_comp, eq'] }
end

/-- (Implementation). The morphism `‚Ñ±(X) ‚ü∂ ‚Ñ±'(X)` given by glueing the `pushforward_family`. -/
noncomputable
def app_hom (X : D) : ‚Ñ±.val.obj (op X) ‚ü∂ ‚Ñ±'.val.obj (op X) := Œª x,
  (‚Ñ±'.property _ (H.obj' X).property).amalgamate
    (pushforward_family H Œ± x)
    (pushforward_family_compatible H H' Œ± x)

lemma pushforward_family_apply {X} (x : ‚Ñ±.val.obj (op X)) {Y : C} {f : G.obj Y ‚ü∂ X} :
  pushforward_family H Œ± x f (H.obj'_in f) = Œ±.app (op Y) (‚Ñ±.val.map f.op x) :=
begin
  unfold pushforward_family, conv_rhs { rw (H.obj_fac' X (H.obj'_in f)).fac },
  refine eq.trans _ (functor_to_types.map_id_apply ‚Ñ±'.val _),
  rw ‚Üê op_id,
  apply functor_pushforward_compatible_of_dense_subsite H H' ‚Ñ±' _ _
    (H.obj_fac' X (H.obj'_in f)).map f,
  { rw ‚Üê(H.obj_fac' X (H.obj'_in f)).fac, simp },
  intros X' f‚ÇÅ' f‚ÇÇ' eq',
  simp only [functor_to_types.map_comp_apply, op_comp],
  change (‚Ñ±.val.map _ ‚â´ Œ±.app (op (H.obj_fac' X (H.obj'_in f)).obj) ‚â´ ‚Ñ±'.val.map _) _
    = (‚Ñ±.val.map _ ‚â´ ‚Ñ±.val.map _ ‚â´ Œ±.app (op Y) ‚â´ ‚Ñ±'.val.map _) _,
  erw [‚Üê Œ±.naturality f‚ÇÅ'.op, ‚Üê Œ±.naturality f‚ÇÇ'.op],
  simp only [quiver.hom.unop_op, functor.comp_map, G.op_map,
    ‚Üê category.assoc, ‚Üê ‚Ñ±.val.map_comp, ‚Üêop_comp, eq'],
  conv_lhs { rw (H.obj_fac' X (H.obj'_in f)).fac },
  simp
end

@[simp] lemma app_hom_restrict {X : D} {Y : C} (f : op X ‚ü∂ op (G.obj Y)) (x) :
  ‚Ñ±'.val.map f (app_hom H H' Œ± X x) = Œ±.app (op Y) (‚Ñ±.val.map f x) :=
begin
  refine ((‚Ñ±'.property _ (H.obj' X).property).valid_glue
    (pushforward_family_compatible H H' Œ± x) f.unop (H.obj'_in f.unop)).trans _,
  apply pushforward_family_apply,
  exact H',
end

@[simp] lemma app_hom_valid_glue {X : D} {Y : C} (f : op X ‚ü∂ op (G.obj Y)) :
  (app_hom H H' Œ± X) ‚â´ ‚Ñ±'.val.map f = ‚Ñ±.val.map f ‚â´ Œ±.app (op Y) :=
by { ext, apply app_hom_restrict }

/--
(Implementation). The maps given in `app_iso` is inverse to each other and gives a `‚Ñ±(X) ‚âÖ ‚Ñ±'(X)`.
-/
@[simps] noncomputable
def app_iso (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X : D) :
  ‚Ñ±.val.obj (op X) ‚âÖ ‚Ñ±'.val.obj (op X) :=
{ hom := app_hom H H' i.hom X,
  inv := app_hom H H' i.inv X,
  hom_inv_id' :=
  begin
    ext x,
    apply (‚Ñ±.property _ (H.obj' X).property).is_separated_for.ext,
    intros Y f hf,
    rw (H.obj_fac' _ hf).fac,
    simp
  end,
  inv_hom_id' :=
  begin
    ext x,
    apply (‚Ñ±'.property _ (H.obj' X).property).is_separated_for.ext,
    intros Y f hf,
    rw (H.obj_fac' _ hf).fac,
    simp
  end }

/--
Given an natural transformation `G ‚ãô ‚Ñ± ‚ü∂ G ‚ãô ‚Ñ±'` between sheaves of types, we may obtain a
natural transformation between sheaves.
-/
@[simps] noncomputable
def sheaf_hom (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ±.val ‚ü∂ ‚Ñ±'.val :=
{ app := Œª X, app_hom H H' Œ± (unop X), naturality' := Œª X Y f,
  begin
    ext x,
    apply (‚Ñ±'.property _ (H.obj' (unop Y)).property).is_separated_for.ext,
    intros Y' f' hf',
    rw (H.obj_fac' _ hf').fac,
    simp only [app_hom_restrict, types_comp_apply, op_comp,
      functor_to_types.map_comp_apply, app_iso],
    change _ = ‚Ñ±'.val.map _ ((‚Ñ±'.val.map _ ‚â´ ‚Ñ±'.val.map _) _),
    rw [‚Üê ‚Ñ±'.val.map_comp, ‚Üê f.op_unop, ‚Üê op_comp, app_hom_restrict],
    simp
  end }

/--
Given an natural isomorphsim `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between sheaves of types, we may obtain a natural
isomorphism between sheaves.
-/
@[simps] noncomputable
def sheaf_iso (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) : ‚Ñ±.val ‚âÖ ‚Ñ±'.val :=
nat_iso.of_components (Œª X, app_iso H H' i (unop X)) (sheaf_hom H H' i.hom).naturality

end types
open types

include H'

@[simp, reassoc]
lemma app_hom_is_valid_glue (‚Ñ± ‚Ñ±' : Sheaf K A) (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X) {Y U}
{f : Y ‚ü∂ U} (hf : (H.obj' U).val f) (x) :
 app_hom H H' (iso_over i (unop X)).hom U x ‚â´ ‚Ñ±'.val.map (H.obj_fac' U hf).map.op =
  x ‚â´ ‚Ñ±.val.map (H.obj_fac' U hf).map.op ‚â´ i.hom.app (op (H.obj_fac' U hf).obj) :=
(congr_fun (app_hom_valid_glue H H' (iso_over i (unop X)).hom (H.obj_fac' U hf).map.op) x).trans
  (by { rw ‚Üêcategory.assoc, refl  })

@[simp]
lemma app_hom_apply_comp (‚Ñ± ‚Ñ±' : Sheaf K A) (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X Y) (U) (x y) :
  app_hom H H' (iso_over i (unop X)).hom U (y ‚â´ x) =
    y ‚â´ app_hom H H' (iso_over i (unop Y)).hom U x :=
begin
  apply ((sheaf_over ‚Ñ±' (unop X)).property _ (H.obj' U).property).is_separated_for,
  apply is_sheaf_for.is_amalgamation,
  intros Y f h,
  conv_lhs { rw (H.obj_fac' _ h).fac },
  delta sheaf_over,
  simp only [pushforward_family, op_comp, functor_to_types.map_comp_apply, iso_over_hom_app,
    functor.comp_map, coyoneda_obj_map, category.assoc],
  congr' 1,
  simp
end

@[simp]
lemma app_hom_apply_comp_id (‚Ñ± ‚Ñ±' : Sheaf K A) (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) (X) (U)
  (x : X ‚ü∂ ‚Ñ±.val.obj U) :
  x ‚â´ app_hom H H' (iso_over i (‚Ñ±.val.obj U)).hom (unop U) (ùüô _) =
    app_hom H H' (iso_over i X).hom (unop U) x :=
begin
  convert (app_hom_apply_comp H H' ‚Ñ± ‚Ñ±' i (op X) (op (‚Ñ±.val.obj U)) (unop U) (ùüô _) x).symm,
  exact (category.comp_id x).symm,
end

/-- (Implementation). The sheaf map given in `types.sheaf_hom` is natural in terms of `X`. -/
@[simps] noncomputable
def sheaf_coyoneda_hom (‚Ñ± ‚Ñ±' : Sheaf K A) (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val) :
  coyoneda ‚ãô (whiskering_left D·µí·µñ A (Type u)).obj ‚Ñ±.val ‚ü∂
  coyoneda ‚ãô (whiskering_left D·µí·µñ A (Type u)).obj ‚Ñ±'.val :=
{ app := Œª X, sheaf_hom H H' (hom_over Œ± (unop X)), naturality' := Œª X Y f,
  begin
  ext U x,
  change app_hom H H' (hom_over Œ± (unop Y)) (unop U) (f.unop ‚â´ x) =
    f.unop ‚â´ app_hom H H' (hom_over Œ± (unop X)) (unop U) x,
  apply ((sheaf_over ‚Ñ±' (unop Y)).property _ (H.obj' (unop U)).property).is_separated_for,
  apply is_sheaf_for.is_amalgamation,
  intros Y' f' h',
  dsimp[pushforward_family],
  conv_lhs { rw (H.obj_fac' _ h').fac },
  simp only [category.assoc, op_comp, functor.map_comp],
  congr' 1,
  simp only [‚Üêcategory.assoc],
  congr' 1,
  have := app_hom_restrict H H' (hom_over Œ± (unop X)) (H.obj_fac' (unop U) h').map.op x,
  refine this.trans _,
  dsimp, simp
  end }

/--
(Implementation). `sheaf_coyoneda_hom` but the order of the arguments of the functor are swapped.
-/
@[simps] noncomputable
def sheaf_yoneda_hom (‚Ñ± ‚Ñ±' : Sheaf K A) (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val) :
  ‚Ñ±.val ‚ãô yoneda ‚ü∂ ‚Ñ±'.val ‚ãô yoneda :=
begin
  let Œ± := sheaf_coyoneda_hom H H' ‚Ñ± ‚Ñ±' Œ±,
  refine { app := _, naturality' := _ },
  { intro U,
    refine { app := Œª X, (Œ±.app X).app U,
      naturality' := Œª X Y f, by simpa using congr_app (Œ±.naturality f) U } },
  { intros U V i,
    ext X x,
    exact congr_fun ((Œ±.app X).naturality i) x },
end

/--
Given an natural transformation `G ‚ãô ‚Ñ± ‚ü∂ G ‚ãô ‚Ñ±'` between sheaves of arbitrary category,
we may obtain a natural transformation between sheaves.
-/
@[simps] noncomputable
def sheaf_hom (‚Ñ± ‚Ñ±' : Sheaf K A) (Œ± : G.op ‚ãô ‚Ñ±.val ‚ü∂ G.op ‚ãô ‚Ñ±'.val) :
  ‚Ñ±.val ‚ü∂ ‚Ñ±'.val :=
begin
  have Œ±' := sheaf_yoneda_hom H H' ‚Ñ± ‚Ñ±' Œ±,
  exact { app := Œª X, yoneda.preimage (Œ±'.app X),
          naturality' := Œª X Y f, yoneda.map_injective (by simpa using Œ±'.naturality f) }
end

/--
Given an natural isomorphism `G ‚ãô ‚Ñ± ‚âÖ G ‚ãô ‚Ñ±'` between sheaves of arbitrary category,
we may obtain a natural isomorphism between sheaves.
-/
@[simps] noncomputable
def sheaf_iso (‚Ñ± ‚Ñ±' : Sheaf K A) (i : G.op ‚ãô ‚Ñ±.val ‚âÖ G.op ‚ãô ‚Ñ±'.val) :
  ‚Ñ±.val ‚âÖ ‚Ñ±'.val :=
begin
  haveI : ‚àÄ (X : D·µí·µñ), is_iso ((sheaf_hom H H' ‚Ñ± ‚Ñ±' i.hom).app X),
  { intro X,
    apply is_iso_of_reflects_iso _ yoneda,
    use (sheaf_yoneda_hom H H' ‚Ñ±' ‚Ñ± i.inv).app X,
    split;
      ext x : 2;
      simp only [sheaf_hom_app, nat_trans.comp_app, nat_trans.id_app, functor.image_preimage],
      exact ((sheaf_iso H H' (iso_over i (unop x))).app X).hom_inv_id,
      exact ((sheaf_iso H H' (iso_over i (unop x))).app X).inv_hom_id,
    apply_instance },
  haveI : is_iso (sheaf_hom H H' ‚Ñ± ‚Ñ±' i.hom) := by apply nat_iso.is_iso_of_is_iso_app,
apply as_iso (sheaf_hom H H' ‚Ñ± ‚Ñ±' i.hom),
end

/--
If the pullback map is given by whiskering,
then the result `sheaf_hom` is equal to the original one.
-/
lemma sheaf_hom_eq (‚Ñ± ‚Ñ±' : Sheaf K A) (Œ± : ‚Ñ±.val ‚ü∂ ‚Ñ±'.val) :
  Œ± = sheaf_hom H H' ‚Ñ± ‚Ñ±' (whisker_left G.op Œ±) :=
begin
  ext X,
  apply yoneda.map_injective,
  ext U,
  erw yoneda.image_preimage,
  apply ((sheaf_over ‚Ñ±' (unop U)).property _ (H.obj' (unop X)).property).is_separated_for,
  swap,
  apply is_sheaf_for.is_amalgamation,
  intros Y f hf,
  conv_lhs { rw (H.obj_fac' _ hf).fac },
  simpa,
  apply_instance
end

/--
Given an natural transformation `‚Ñ± ‚ü∂ ‚Ñ±'`, if its pullback wrt `G` is an iso, then it is also iso.
-/
lemma iso_of_restrict_iso {‚Ñ± ‚Ñ±' : Sheaf K A} (Œ± : ‚Ñ±.val ‚ü∂ ‚Ñ±'.val)
  (i : is_iso (whisker_left G.op Œ±)) : is_iso Œ± :=
begin
  convert is_iso.of_iso (sheaf_iso H H' ‚Ñ± ‚Ñ±' (as_iso (whisker_left G.op Œ±))),
  apply sheaf_hom_eq,
end

variables [has_limits A] (hG'' : cover_lifting J K G)

end comparison_lemma
end
end category_theory
