/-
Copyright (c) 2020 Simon Hudon. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Author: Simon Hudon
-/
import data.pfunctor.indexed.basic
universe u

/-!
# Indexed quotients of polynomial functors.

Basic definition of indexed QPF. QPFs form a compositional framework
for defining inductive and coinductive types, their quotients and nesting.

The idea is based on building ever larger functors. For instance, we can define
a list using a shape functor:

```lean
inductive list_shape (Î± Î² : Type)
| nil : list_shape
| cons : Î± â†’ Î² â†’ list_shape
```

This shape can itself be decomposed as a sum of product which are themselves
QPFs. It follows that the shape is a QPF and we can take its fixed point
and create the list itself:

```lean
def list (Î± : Type) := fix list_shape Î± -- not the actual notation
```

We can continue and define the quotient on permutation of lists and create
the multiset type:

```lean
def multiset (Î± : Type) := qpf.quot list.perm list Î± -- not the actual notation
```

And `multiset` is also a QPF. We can then create a novel data type (for Lean):

```lean
inductive tree (Î± : Type)
| node : Î± â†’ multiset tree â†’ tree
```

An unordered tree. This is currently not supported by Lean because it nests
an inductive type inside of a quotient. We can go further and define
unordered, possibly infinite trees:

```lean
coinductive tree' (Î± : Type)
| node : Î± â†’ multiset tree' â†’ tree'
```

by using the `cofix` construct. Those options can all be mixed and
matched because they preserve the properties of QPF. The latter
example, `tree'`, combines fixed point, co-fixed point and quotients.

The features described so far are also avaiable for
multivariate. Indexed QPFs also enable the use of indexed
(co)inductive families. For instance, we can try and encode
de Bruijn indices with dependent types as the following
inductive family:

```lean
inductive term : â„• â†’ Type
| var {n} : fin n â†’ term n
| app {n} : term n â†’ term n â†’ term n
| abs {n} : term (succ n) â†’ term n
```

That inductive family can be generated by the following functor:

```lean
inductive term_shape (X : â„• â†’ Type) : â„• â†’ Type
| var {n} : fin n â†’ term_shape n
| app {n} : X n â†’ X n â†’ term_shape n
| abs {n} : X (succ n) â†’ term_shape n

def term := fix term_shape
```

This part of the QPF theory is not covered by [avigad-carneiro-hudon2019].

## Related modules

 * constructions
   * fix
   * cofix
   * quot
   * comp

each proves that some operations on functors preserves the QPF structure

##reference

 * [Jeremy Avigad, Mario M. Carneiro and Simon Hudon, *Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]

-/

local infixr ` âŠ— `:20 := (â¨¯)
local infixr ` âŠ—' `:20 := category_theory.limits.prod.map

/-- Indexed Quotient of Polynomial Functor -/
class iqpf {I J : Type u} (F : fam I â¥¤ fam J) :=
(P         : ipfunctor.{u} I J)
(abs []    : Î  Î±, P.obj Î± âŸ¶ F.obj Î±)
(repr []   : Î  Î±, F.obj Î± âŸ¶ P.obj Î±)
(abs_repr  : âˆ€ Î±, repr Î± â‰« abs Î± = ğŸ™ _)
(abs_map   : âˆ€ {Î± Î²} (f : Î± âŸ¶ Î²), P.map f â‰« abs _ = abs _ â‰« F.map f)

namespace iqpf
variables {I J : Type u} {F : fam I â¥¤ fam J} [q : iqpf F]
open category_theory.functor.fam (liftp liftr)

/-
Show that every iqpf is a lawful mvfunctor.
-/
include q

attribute [simp, reassoc] abs_map abs_repr

theorem abs_repr' {Î±} {i} (x : F.obj Î± i) : abs F Î± i (repr F Î± i x) = x :=
show (repr F Î± â‰« abs F Î±) i x = x, by rw abs_repr; refl

theorem abs_map' {Î± Î² : fam I} (f : Î± âŸ¶ Î²) {i} {x : (P F).obj Î± i} : abs F Î² i ((P F).map f i x) = F.map f i (abs F Î± i x) :=
show ((P F).map f â‰« abs F _) i x = (abs F _ â‰« F.map f) i x, by rw abs_map

/- Lifting predicates and relations -/

open category_theory

theorem abs_epi {Î± : fam I} {X : fam J} (f g : F.obj Î± âŸ¶ X)
  (h : abs F Î± â‰« f = abs F Î± â‰« g) : f = g :=
suffices ğŸ™ _ â‰« f = g, by rw [â† this,category.id_comp],
by rw [â† abs_repr,category.assoc,h,â† category.assoc,abs_repr,category.id_comp]

theorem repr_mono {Î² : fam I} {X : fam J} (f g : X âŸ¶ F.obj Î²)
  (h : f â‰« repr F Î² = g â‰« repr F Î²) : f = g :=
suffices f â‰« ğŸ™ _ = g, by rw [â† this,category.comp_id],
by rw [â† abs_repr,â† category.assoc,h,category.assoc,abs_repr,category.comp_id]

theorem trade  {Î± : fam I} {X : fam J} (f : (P F).obj Î± âŸ¶ X) (g : F.obj Î± âŸ¶ X)
  (h : f = abs F Î± â‰« g) : repr F Î± â‰« f = g :=
by rw [h,â† category.assoc,abs_repr,category.id_comp]

open ipfunctor (map_eq')

open iqpf (abs_map)
open set fam ipfunctor
open category_theory.functor (fam.supp)

/-- eliminator for an arbitrary `iqpf` -/
@[elab_as_eliminator]
def abs_cases
   {Î± : fam I} {j} {C : (unit j âŸ¶ F.obj Î±) â†’ Sort*}
   (h : âˆ€ a f, C $ pf.mk (P F) j âŸ¨a,fâŸ© â‰« abs F Î±)
   (x : unit j âŸ¶ F.obj Î±) : C x :=
begin
  rcases h' : repr F Î± j (x j unit.rfl) with âŸ¨a,fâŸ©,
  have : pf.mk _ _ (repr F Î± j (x j unit.rfl)) =
             x â‰« repr F Î±,
      { ext _ âŸ¨ âŸ© : 2, refl },
  rw h' at this, specialize h a f,
  simpa [this] using h
end

section tactic

setup_tactic_parser

open tactic
omit q

/-- This tactic takes a value `x : X âŸ¶ F.obj Î±` and deconstructs it using `abs_cases`.
This replaces `induction x using abs_cases` which rejects such applications.
-/
@[interactive]
meta def tac.abs_cases (x : parse ident) (ids : parse with_ident_list) : tactic unit :=
do
   x â† get_local x,
   n â† revert x,
   refine ``(iqpf.abs_cases _),
   intro_lst $ (ids ++ [`_,`_]).take 2,
   intron $ n-1,
   skip

end tactic

theorem liftp_iff {Î± : fam I} (p : Î  i, Î± i â†’ Prop) {j} (x : unit j âŸ¶ F.obj Î±) :
  liftp p x â†” âˆƒ a f, x = pf.mk (P F) j âŸ¨a,fâŸ© â‰« abs F Î± âˆ§ f âŠ¨ p :=
begin
  split,
  { rintros âŸ¨y, hyâŸ©,
    abs_cases y with a f,
    use [a,f â‰« fam.subtype.val], split,
    { simp [â† pf.mk_map_eq,â† hy], },
    { existsi f, refl }, },
  rintros f,
  choose a f hf using f,
  rcases hf with âŸ¨h,h'âŸ©,
  choose f' h' using h',
  let g : unit j âŸ¶ (P F).obj (fam.subtype p) := value _ _ âŸ¨a, f'âŸ©,
  have h : g â‰« (P F).map fam.subtype.val â‰« abs F _ = x,
  { dsimp [g], erw [map_eq_assoc, h, â† h'], refl },
  refine âŸ¨g â‰« abs F _, _âŸ©,
  rw [category_theory.category.assoc,â† abs_map,h],
end

theorem liftr_iff {Î± Î² : fam I} {j} (r : fam.Pred (Î± âŠ— Î²))
  (x : unit j âŸ¶ F.obj Î±) (y : unit j âŸ¶ F.obj Î²) :
  liftr r x y â†” âˆƒ a fâ‚€ fâ‚,
    x = pf.mk (P F) j âŸ¨a, fâ‚€âŸ© â‰« abs F _ âˆ§
    y = pf.mk (P F) j âŸ¨a, fâ‚âŸ© â‰« abs F _ âˆ§
    limits.prod.lift fâ‚€ fâ‚ âŠ¨ r :=
begin
  split,
  { rintros âŸ¨y, hy, hy'âŸ©,
    abs_cases y with a f,
    use [a,f â‰« fam.subtype.val â‰« fam.prod.fst,f â‰« fam.subtype.val â‰« fam.prod.snd], split,
    { simp only [â†pf.mk_map_eq, abs_map, â†hy, abs_repr_assoc, category.assoc], refl },
    split,
    { simp only [â†pf.mk_map_eq, â†hy', abs_map, abs_repr_assoc, category.assoc], refl },
    existsi f, ext1; simp only [limits.prod.lift_fst, category.assoc]; refl },
  rintros f,
  choose a fâ‚€ fâ‚ hf using f,
  rcases hf with âŸ¨hfâ‚€,hfâ‚,f,hrâŸ©,
  let g : unit j âŸ¶ (P F).obj (fam.subtype r) := value j _ âŸ¨a,fâŸ©,
  have h : g â‰« (P F).map (fam.subtype.val â‰« fam.prod.fst) â‰« abs F _ = x,
  { dsimp [g], rw [map_eq_assoc, â† reassoc_of hr, fam.prod.fst, limits.prod.lift_fst, hfâ‚€], refl },
  have h' : g â‰« (P F).map (fam.subtype.val â‰« fam.prod.snd) â‰« abs F _ = y,
  { dsimp [g], rw [map_eq_assoc, â† reassoc_of hr, fam.prod.snd, limits.prod.lift_snd, hfâ‚], refl },
  -- clear_value g, -- put this back when naming issue is fixed in `clear_value`
  refine âŸ¨g â‰« abs F _, _âŸ©,
  simp only [h.symm,h'.symm,ipfunctor.map_comp,abs_map,abs_map_assoc,fam.prod.fst,fam.prod.snd,
    category.assoc,and_self,eq_self_iff_true,category_theory.functor.map_comp],
end

theorem liftp_iffâ‚€ {Î± : fam I} {X : fam J} (p : Î  i, Î± i â†’ Prop) (x : X âŸ¶ F.obj Î±) :
  liftp p x â†” âˆ€ j (y : X j), âˆƒ a f, x j y = abs F Î± j âŸ¨a,fâŸ© âˆ§ âˆ€ i a, p i (f i a) :=
begin
  split,
  { rintros âŸ¨y, hyâŸ© j z, cases h : repr F _ _ (y _ z) with a f,
    use [a,f â‰« fam.subtype.val], split,
    { rw [â† ipfunctor.map_eq', â† h, abs_map', abs_repr', â† hy], reflexivity },
    intros i j, apply (f _ j).property },
  rintros f,
  choose a f hf hf' using f,
  replace hf' : âˆ€ j y, f j y âŠ¨ p,
  { intros, apply sat_intro, apply hf' },
  choose gâ‚€ h using hf',
  let g : X âŸ¶ (P F).obj (fam.subtype p) := Î» j y, âŸ¨a j y, gâ‚€ j yâŸ©,
  have h : g â‰« (P F).map fam.subtype.val â‰« abs F _ = x,
  { ext : 2, simp, dsimp [g],
    erw [â† abs_map',map_eq', â† h, â† hf], },
  refine âŸ¨g â‰« abs F _, _âŸ©,
  rw [category_theory.category.assoc,â† abs_map,h],
end

theorem liftr_iffâ‚€ {Î± Î² : fam I} {X : fam J} (r : fam.Pred (Î± âŠ— Î²))
  (x : X âŸ¶ F.obj Î±) (y : X âŸ¶ F.obj Î²) :
  liftr r x y â†” âˆ€ j (k : X j), âˆƒ a fâ‚€ fâ‚, x j k = abs F _ _ âŸ¨a, fâ‚€âŸ© âˆ§ y _ k = abs F _ _ âŸ¨a, fâ‚âŸ© âˆ§ âˆ€ i a, r i (fam.prod.mk (fâ‚€ _ a) (fâ‚ _ a)) :=
begin
  split,
  { rintros âŸ¨y, hyâŸ© j z, cases h : repr F _ _ (y _ z) with a f,
    use [a,f â‰« fam.subtype.val â‰« fam.prod.fst,f â‰« fam.subtype.val â‰« fam.prod.snd], split,
    { rw [â† ipfunctor.map_eq', â† h, abs_map', abs_repr', â† hy.1], reflexivity },
    split,
    { rw [â† ipfunctor.map_eq', â† h, abs_map', abs_repr', â† hy.2], reflexivity },
    apply sat_elim _ r, existsi f, ext _ _ âŸ¨ âŸ©; refl, },
  rintros f,
  choose a fâ‚€ fâ‚ hfâ‚€ hfâ‚ hf using f,
  replace hf : âˆ€ j y, limits.prod.lift (fâ‚€ j y) (fâ‚ j y) âŠ¨ r,
  { intros, apply sat_intro, intros, convert hf j y_1 i x_1 using 1, ext âŸ¨ âŸ©; refl, },
  choose gâ‚€ h using hf,
  let g : X âŸ¶ (P F).obj (fam.subtype r) := Î» j y, âŸ¨a j y, gâ‚€ j yâŸ©,
  have hâ‚€ : g â‰« (P F).map (fam.subtype.val â‰« fam.prod.fst) â‰« abs F _ = x,
  { ext : 2, simp, dsimp [g],
    erw [â† abs_map',â† abs_map', map_eq', â† h, limits.prod.lift_fst, hfâ‚€] },
  have hâ‚ : g â‰« (P F).map (fam.subtype.val â‰« fam.prod.snd) â‰« abs F _ = y,
  { ext : 2, simp, dsimp [g],
    erw [â† abs_map',â† abs_map', map_eq', â† h, limits.prod.lift_snd, hfâ‚] },
  refine âŸ¨g â‰« abs F _, _âŸ©,
  simp only [â† hâ‚€, â† hâ‚,ipfunctor.map_comp,abs_map,abs_map_assoc,fam.prod.snd,fam.prod.fst,
    category.assoc,and_self,eq_self_iff_true,category_theory.functor.map_comp],
end

theorem liftr_iffâ‚€' {Î± Î² : fam I} (r : fam.Pred (Î± âŠ— Î²))
  {i : J} (x : unit i âŸ¶ F.obj Î±) (y : unit i âŸ¶ F.obj Î²) :
  liftr r x y â†” âˆƒ a fâ‚€ fâ‚, x = value i (q.P.obj _) âŸ¨a, fâ‚€âŸ© â‰« abs F _ âˆ§ y = value i (q.P.obj _) âŸ¨a, fâ‚âŸ© â‰« abs F _ âˆ§ âˆ€ i a, r i (fam.prod.mk (fâ‚€ _ a) (fâ‚ _ a)) :=
begin
  rw liftr_iffâ‚€, split,
  { intros h, rcases h _ unit.rfl with âŸ¨a,fâ‚€,fâ‚,hx,hy,hfâ‚€â‚âŸ©, clear h,
    refine âŸ¨a,fâ‚€,fâ‚,_,_,hfâ‚€â‚âŸ©; ext _ âŸ¨ âŸ©,
    rw hx, refl, rw hy, refl },
  { rintro âŸ¨a,fâ‚€,fâ‚,hx,hy,hfâ‚€â‚âŸ© _ âŸ¨ âŸ©,
    refine âŸ¨a,fâ‚€,fâ‚,_,_,hfâ‚€â‚âŸ©,
    rw hx, refl, rw hy, refl }
end

theorem mem_supp {Î± : fam I}
  {j} (x : unit j âŸ¶ F.obj Î±) (i) (u : Î± i) :
  u âˆˆ fam.supp x i â†”
  âˆ€ a (f : (P F).B j a âŸ¶ Î±),
  pf.mk (P F) j âŸ¨a, fâŸ© â‰« abs F Î± = x â†’ u âˆˆ (@f i '' univ) :=
begin
  rw [fam.supp], dsimp, split,
  { intros h a f haf,
    have : liftp (Î» i u, u âˆˆ @f i '' univ) x,
    { rw liftp_iff, refine âŸ¨a, f, haf.symm, _âŸ©,
      apply sat_intro, intros i u, exact mem_image_of_mem _ (mem_univ _) },
    exact h this },
  intros h p, rw liftp_iff,
  intro h,
  rcases h with âŸ¨a, f, xeq, h'âŸ©,
  rcases h a f xeq.symm with âŸ¨i, _, hiâŸ©,
  { rw â†hi, apply sat_elim _ _ h' },
end

theorem supp_eq {Î± : fam I} {j} (x : unit j âŸ¶ F.obj Î±) (i) :
  fam.supp x i = { u | âˆ€ a (f : (P F).B j a âŸ¶ Î±), pf.mk (P F) j âŸ¨a, fâŸ© â‰« abs F Î± = x â†’ u âˆˆ @f i '' univ } :=
by ext; apply mem_supp

theorem has_good_supp_iff {Î± : fam I} {j} (x : unit j âŸ¶ F.obj Î±) :
  (âˆ€ p, liftp p x â†” âˆ€ i (u âˆˆ fam.supp x i), p i u) â†”
    âˆƒ a (f : (P F).B j a âŸ¶ Î±), pf.mk (P F) j âŸ¨a, fâŸ© â‰« abs F Î± = x âˆ§
    âˆ€ i a' (f' : (P F).B j a' âŸ¶ Î±),
    pf.mk (P F) j âŸ¨a', f'âŸ© â‰« abs F Î± = x â†’ @f i '' univ âŠ† @f' i '' univ :=
begin
  split,
  { intros h,
    have : liftp (fam.supp x) x, by { rw h, introv, exact id, },
    rw liftp_iff at this,
    rcases this with âŸ¨a, f, xeq, h'âŸ©,
    refine âŸ¨a, f, _, _âŸ©,
    { ext _ âŸ¨ âŸ©, rw xeq, },
    intros i' a' f' h'',
    rintro u âŸ¨j, hâ‚‚, hfiâŸ©,
    have hh : u âˆˆ fam.supp x i', by rw â†hfi; apply sat_elim _ _ h',
    refine (mem_supp x _ u).mp hh _ _ h'', },
  rintros âŸ¨a, f, xeq, hâŸ© p, rw liftp_iff, split,
  { intro h,
    rcases h with âŸ¨a', f', xeq', h'âŸ©,
    intros i u usuppx,
    rcases (mem_supp x _ u).mp @usuppx a' f' _ with âŸ¨i, _, f'ieqâŸ©,
    { rw â†f'ieq, apply sat_elim _ _ h' },
    ext _ âŸ¨ âŸ©, rw xeq',  },
  intro h',
  refine âŸ¨a, f, _, _âŸ©,
  { rw â† xeq, },
  apply sat_intro, intros j y,
  apply h', rw mem_supp,
  intros a' f' xeq',
  apply h _ a' f' xeq',
  apply mem_image_of_mem _ (mem_univ _)
end

variable (q)

/-- A qpf is said to be uniform if every polynomial functor
representing a single value all have the same range. -/
def is_uniform : Prop := âˆ€ â¦ƒÎ± : fam Iâ¦„ {j} (a a' : q.P.A j)
    (f : q.P.B j a âŸ¶ Î±) (f' : q.P.B j a' âŸ¶ Î±),
  pf.mk (P F) j âŸ¨a, fâŸ© â‰« abs F Î± = pf.mk (P F) j âŸ¨a', f'âŸ© â‰« abs F Î± â†’ âˆ€ i, @f i '' univ = @f' i '' univ

/-- does `abs` preserve `liftp`? -/
def liftp_preservation : Prop :=
âˆ€ â¦ƒÎ± : fam Iâ¦„ (p : Î  â¦ƒiâ¦„, Î± i â†’ Prop) {j} (x : unit j âŸ¶ q.P.obj Î±), liftp p (x â‰« abs F Î±) â†” liftp p x

/-- does `abs` preserve `supp`? -/
def supp_preservation : Prop :=
âˆ€ â¦ƒÎ±â¦„ {j} (x : unit j âŸ¶ q.P.obj Î±), fam.supp (x â‰« abs F Î±) = fam.supp x

variable [q]

theorem supp_eq_of_is_uniform (h : q.is_uniform) {Î± : fam I} {j} (a : q.P.A j) (f : q.P.B j a âŸ¶ Î±) :
  âˆ€ i, fam.supp (pf.mk (P F) j âŸ¨a, fâŸ© â‰« abs F Î±) i = @f i '' univ :=
begin
  intro, ext u, rw [mem_supp], split,
  { intro h', apply h' _ _ rfl },
  intros h' a' f' e,
  rw [â†h _ _ _ _ e.symm], apply h'
end

theorem liftp_iff_of_is_uniform (h : q.is_uniform) {Î± : fam I}
  {j} (x : unit j âŸ¶ F.obj Î±) (p : Î  â¦ƒiâ¦„, Î± i â†’ Prop) :
  liftp p x â†” âˆ€ i (u âˆˆ fam.supp x i), p u :=
begin
  rw [liftp_iff p x],
  abs_cases x, split,
  { rintros âŸ¨a', f', abseq, hfâŸ© u,
    rw [supp_eq_of_is_uniform h, h _ _ _ _ abseq],
    rintros b âŸ¨i, _, hiâŸ©, rw â†hi, apply sat_elim _ _ hf },
  intro h',
  refine âŸ¨a, f, rfl, _âŸ©,
  apply sat_intro,
  intros, apply h',
  rw supp_eq_of_is_uniform h,
  exact âŸ¨x, mem_univ x, rflâŸ©,
end

theorem supp_map (h : q.is_uniform) {Î± Î² : fam I} (g : Î± âŸ¶ Î²) (i j) (x : unit j âŸ¶ F.obj Î±) :
  fam.supp (x â‰« F.map g) i = @g i '' fam.supp x i :=
begin
  abs_cases x, simp only [â†abs_map,category.assoc,pf.mk_map_eq_assoc],
  rw [supp_eq_of_is_uniform h, supp_eq_of_is_uniform h, â† image_comp],
  refl,
end

theorem supp_preservation_iff_uniform :
  q.supp_preservation â†” q.is_uniform :=
begin
  split,
  { intros h Î± j a a' f f' h' i,
    rw [â† ipfunctor.supp_eq,â† ipfunctor.supp_eq],
    change ((P F).apply.obj Î±) with ((P F).obj Î±),
    rw [â† pf.mk,â† pf.mk,â† h,h',h] },
  { rintros h Î± X,
    refine ipfunctor.obj_cases _, intros,
    ext,
    rw [â† pf.mk, supp_eq_of_is_uniform h,pf.mk],
    dsimp [ipfunctor.obj],
    rw [ipfunctor.supp_eq] }
end

theorem supp_preservation_iff_liftp_preservation :
  q.supp_preservation â†” q.liftp_preservation :=
begin
  split; intro h,
  { rintros Î± p j, refine ipfunctor.obj_cases _, intros a f,
    have h' := h, rw supp_preservation_iff_uniform at h',
    dsimp only [supp_preservation,fam.supp] at h,
    simp only [liftp_iff_of_is_uniform, supp_eq_of_is_uniform, ipfunctor.liftp_iff, h', image_univ, mem_range, exists_imp_distrib],
    dsimp [ipfunctor.obj], simp [h,ipfunctor.supp_eq],
    split; intros; subst_vars,
    { use [a,f,rfl], intros, apply a_1, refl, },
    { rcases a_1 with âŸ¨a',f',hâ‚€,hâ‚âŸ©,
      replace hâ‚€ := congr_fun (congr_fun hâ‚€ _) unit.rfl,
      simp only [value] at hâ‚€, cases hâ‚€, apply hâ‚, } },
  { rintros Î± j, refine ipfunctor.obj_cases _, intros a f,
    simp only [liftp_preservation] at h,
    ext, simp [fam.supp,h] }
end

theorem liftp_preservation_iff_uniform :
  q.liftp_preservation â†” q.is_uniform :=
by rw [â† supp_preservation_iff_liftp_preservation, supp_preservation_iff_uniform]

end iqpf
