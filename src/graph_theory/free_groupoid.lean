import graph_theory.path_category
import graph_theory.paths
import category_theory.quotient
import category_theory.groupoid
import group_theory.free_group

open path directed_multigraph category_theory free_group

universes v vâ‚ u uâ‚

variables {V : Type u}

namespace multigraph

def free (G : directed_multigraph.{v+1} V) : multigraph V :=
{ edge := Î» s t, G.edge s t âŠ• G.edge t s,
  inv := Î» s t, equiv.sum_comm _ _ }

variable {G : multigraph.{v} V}

def rev {s t : V} : G.edge s t â†’ G.edge t s := (G.inv s t).to_fun

lemma rev_inl (G : directed_multigraph.{v+1} V) {s t : V} (e : G.edge s t) :
  @rev V (free G) s t (sum.inl e) = sum.inr e := rfl

lemma rev_inr (G : directed_multigraph.{v+1} V) {s t : V} (e : G.edge s t) :
  @rev V (free G) t s (sum.inr e) = sum.inl e := rfl

-- If we can reverse edges, then we can reverse paths
@[simp]
def path_rev : Î  {a b : V}, G.path a b â†’ G.path b a
| _ _ p[] := p[]
| _ _ (e :: l) := concat (path_rev l) p[rev e]

variable (G)

-- rev e should be the inverse of e in the free groupoid
inductive red.step : Î  (a b : paths G.to_directed_multigraph), (a âŸ¶ b) â†’ (a âŸ¶ b) â†’ Prop
| rev {a b} (e : G.edge a b) : red.step a a p[e, rev e] p[]

@[derive category]
def free_groupoid := quotient (red.step G)

variable {G}

-- path_rev gives inverses as expected
lemma rev_concat_map_id {a b} (p : a âŸ¶ b) :
  (quotient.functor (red.step G)).map (p â‰« path_rev p) = ğŸ™ _ :=
begin
  induction p with s h s t e l ih,
  refl,
  set F := quotient.functor (red.step G),
  have : F.map ((e::l) â‰« path_rev (e::l))
    = F.map p[e] â‰« F.map (l â‰« path_rev l) â‰« F.map p[rev e],
  { have : path_rev (e :: l) = concat (path_rev l) p[rev e] := rfl,
    rw this,
    rw cons_as_concat,
    repeat { rw concat_as_comp },
    repeat { rw F.map_comp },
    simp, },
  rw this,
  rw ih,
  apply category_theory.quotient.sound,
  exact red.step.rev e
end

instance : groupoid (free_groupoid G) :=
groupoid.of_trunc_split_mono $ Î» x y f, quot.rec_on_subsingleton f $ Î» p,
trunc.mk { retraction := (quotient.functor _).map (path_rev p),
           id' := by simpa using rev_concat_map_id p }

end multigraph

namespace free_groupoid

variables (G : directed_multigraph.{v+1} V)

@[derive category, derive groupoid]
def free_groupoid := multigraph.free_groupoid (multigraph.free G)

variable {G}

def of {s t : free_groupoid G} : G.edge s.as t.as â†’ (s âŸ¶ t) :=
Î» e, (quotient.functor _).map p[sum.inl e]

lemma free_groupoid.induction {C : Î  {s t : free_groupoid G}, (s âŸ¶ t) â†’ Prop}
  (h_id : âˆ€ {s}, C (ğŸ™ s))
  (h_of : âˆ€ (s t : free_groupoid G) (e : G.edge s.as t.as), C (of e))
  (h_inv : âˆ€ {s t : free_groupoid G} {f : s âŸ¶ t}, C f â†’ C (inv f))
  (h_comp : âˆ€ {x y z : free_groupoid G} (f : x âŸ¶ y) (g : y âŸ¶ z), C f â†’ C g â†’ C (f â‰« g))
  {s t} (f : s âŸ¶ t)
  : C f :=
category_theory.quotient.induction _
begin
  intros _ _ p,
  induction p with a a b c e l ih,
  { exact h_id },
  { rw [cons_as_concat, concat_as_comp, functor.map_comp],
    apply h_comp,
    { cases e,
      { exact h_of { as := a } {as := b } e },
      { change C (inv $ @of _ _ {as := b} {as := a} e),
        exact h_inv (h_of _ _ _),
      },
    },
    { exact ih } }
end f

variables {D : Type uâ‚} [ğ’Ÿ : groupoid.{vâ‚} D]
  (F : graph_hom G (as_graph D))
include ğ’Ÿ F

def to_groupoid : free_groupoid G â¥¤ D :=
category_theory.quotient.lift _
  (functor_of_edge_map { obj := F.obj,
            edge := Î» a b f, sum.rec_on f (Î» e, F.edge e) (Î» e, inv $ F.edge e)} ) $
  begin
    rintros _ _ _ _ âŸ¨x, y, eâŸ©,
    rw [cons_as_concat, concat_as_comp, functor.map_comp],
    repeat { rw [functor_of_edge_map.map_edge] },
    rw [nil_as_id, category_theory.functor.map_id],
    cases e,
    { rw multigraph.rev_inl, simp, },
    { rw multigraph.rev_inr, simp, },
  end

lemma to_groupoid.obj {s : free_groupoid G} :
  (to_groupoid F).obj s = F.obj s.as := rfl

lemma to_groupoid.map_of {s t : free_groupoid G} (e : G.edge s.as t.as) :
  (to_groupoid F).map (of e) = F.edge e â‰« ğŸ™ _ := rfl

omit F

-- Morally, a groupoid is freely generated by a subgraph it the embedding satisfies the UMP,
-- i.e. graph homs lift uniquely to functors. But this definition would involve 2 universe
-- parameters? Instead we offer this simple charaterisation: a groupoid is freely generated by
-- a subgraph if the induced map from the free groupoid is fully faithful. From this condition
-- we should be able to derive the UMP.
class freely_generating (S : subgraph (as_graph D)) extends
  full (to_groupoid $ subgraph_embedding S),
  faithful (to_groupoid $ subgraph_embedding S)

end free_groupoid
