/-
Copyright (c) 2021 David W√§rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David W√§rn
-/
import category_theory.action
import category_theory.is_connected
import combinatorics.quiver
import group_theory.free_group
import group_theory.semidirect_product
/-!
# The Nielsen-Schreier theorem

A subgroup of a free group is itself free.

## Proof sketch

The proof is analogous to the classical proof in terms of fundamental groups of graphs,
but we work directly with groupoids instead of spaces. The main steps are as follows

- Given a subgroup `H` of a free group `G`, observe that `H` is the stabilizer of `1H` in
  the action of `G` on `G / H`. Moreover, whenever `G` acts on a set `A`, there is a
  corresponding action groupoid (with object set `A`), and stabilizers are precisely
  vertex groups in this groupoid. (This corresponds to the observation that `H` is a
  fundamental group in a certain covering space.)

- Say a groupoid `G` is _freely generated_ by a family `D` of morphisms if defining a functor
  from `G` to a group `X` is equivalent to assigning a value in `X` to every morphism in `D`.
  (Free groupoids play the same role as topological graphs.)

- Show that if a free group `G` acts on a set `A`, then the corresponding action groupoid is
  freely generated by morphisms lying above generators of `G`. To prove this, we show that
  functors from the action groupoid to a group `X` correspond to group homomorphism
  from `G` to the semidirect product `G ‚ãâ (A ‚Üí X)`. (This corresponds to the fact that
  a covering space of a graph is a graph.)

- Show that if a groupoid `G` is freely generated by `D` and `D` has a spanning tree `T`,
  then a vertex group in `G` is freely generated by certain elements coming from
  the complement of `T`. (This corresponds to retracting `T` to a point.)

This finishes the proof, modulo finding an appropriate rooted subtree.

## References

https://ncatlab.org/nlab/show/Nielsen-Schreier+theorem

## Tags

free group, Nielsen-Schreier

-/

noncomputable theory
open_locale classical
universes v u

open category_theory opposite category_theory.action_category semidirect_product

/-- `is_free_group G` means that `G` has the universal property of a free group.
    That is, it has a family `generators G` of elements, such that a group homomorphism
    `G ‚Üí* X` is uniquely determined by a function `generators G ‚Üí X`. -/
class is_free_group (G) [group.{u} G] :=
(generators : Type u)
(of : generators ‚Üí G)
(unique_lift : ‚àÄ {X} [group.{u} X] (f : generators ‚Üí X),
                ‚àÉ! F : G ‚Üí* X, ‚àÄ a, F (of a) = f a)

instance {A} : is_free_group (free_group A) :=
{ generators := A,
  of := free_group.of,
  unique_lift := by { introsI X _ f, exact ‚ü®free_group.lift f, Œª _, free_group.lift.of,
      Œª g hg, monoid_hom.ext (Œª _, free_group.lift.unique g hg)‚ü© } }

namespace is_free_group

lemma end_is_id {G} [group G] [is_free_group G] (f : G ‚Üí* G)
  (h : ‚àÄ a, f (of a) = of a) : ‚àÄ g, f g = g :=
let ‚ü®_, _, u‚ü© := unique_lift (f ‚àò of) in
have claim : f = monoid_hom.id G := trans (u _ (Œª _, rfl)) (u _ (by simp [h])).symm,
monoid_hom.ext_iff.mp claim

/-- An abstract free group is isomorphic to a concrete free group. -/
def iso_free_group_of_is_free_group (G) [group G] [is_free_group G] :
  G ‚âÉ* free_group (generators G) :=
let ‚ü®F, hF, uF‚ü© := classical.indefinite_description _ (unique_lift free_group.of) in
{ to_fun := F,
  inv_fun := free_group.lift of,
  left_inv := end_is_id ((free_group.lift of).comp F) (by simp [hF]),
  right_inv := by { suffices : F.comp (free_group.lift of) = monoid_hom.id _,
    { rwa monoid_hom.ext_iff at this }, apply free_group.ext_hom, simp [hF] },
  map_mul' := F.map_mul }

/-- Being a free group transports across group isomorphisms. -/
def of_mul_equiv {G H : Type u} [group G] [group H] (h : G ‚âÉ* H) [is_free_group G] :
  is_free_group H :=
{ generators := generators G,
  of := h ‚àò of,
  unique_lift := begin
    introsI X _ f,
    rcases unique_lift f with ‚ü®F, hF, uF‚ü©,
    refine ‚ü®F.comp h.symm.to_monoid_hom, by simp [hF], _‚ü©,
    intros F' hF',
    suffices : F'.comp h.to_monoid_hom = F,
    { rw ‚Üêthis, ext, simp },
    apply uF,
    simp [hF'],
  end }

end is_free_group

/-- A groupoid `G` is free when we have the following data:
 - a quiver `generators G` whose vertices are objects of `G`
 - a function `of` sending an arrow in `generators G` to a morphism in `G`
 - such that a functor from `G` to any group `X` is uniquely determined
   by assigning labels in `X` to the vertices of `X`. -/
class is_free_groupoid (G) [groupoid.{v} G] :=
(generators : quiver.{v+1} G)
(of : Œ† ‚¶Éa b‚¶Ñ, generators.arrow a b ‚Üí (a ‚ü∂ b))
(unique_lift : ‚àÄ {X} [group.{v} X] (f : generators.labelling X),
                ‚àÉ! F : G ‚•§ single_obj X, ‚àÄ a b (g : generators.arrow a b),
                  F.map (of g) = f g)

namespace is_free_groupoid

@[ext]
lemma ext_functor {G X} [groupoid.{v} G] [is_free_groupoid G] [group.{v} X]
  (f g : G ‚•§ single_obj X)
  (h : ‚àÄ a b (e : generators.arrow a b), f.map (of e) = g.map (of e)) :
  f = g :=
match unique_lift (show generators.labelling X, from Œª a b e, g.map (of e)) with
| ‚ü®m, _, um‚ü© := trans (um _ h) (um _ (Œª _ _ _, rfl)).symm
end

namespace covering

instance {G A X : Type*} [monoid G] [mul_action G A] : mul_action G·µí·µñ (A ‚Üí X) :=
{ smul := Œª g' F a, F (g'.unop ‚Ä¢ a),
  one_smul := by simp,
  mul_smul := by simp [mul_smul] }

@[simp] lemma arrow_action_apply {G A X : Type*} [monoid G] [mul_action G A]
  (g : G·µí·µñ) (F : A ‚Üí X) (a : A) : (g ‚Ä¢ F) a = F (g.unop ‚Ä¢ a) := rfl

/-- Given groups `G X` with `G` acting on `A`,
    `G·µí·µñ` acts by multiplicative automorphisms on `A ‚Üí X`. -/
def mul_aut_of_action (G A X) [group G] [mul_action G A] [has_mul X] :
  G·µí·µñ ‚Üí* mul_aut (A ‚Üí X) :=
{ to_fun := Œª g, {
    to_fun := Œª F, g ‚Ä¢ F,
    inv_fun := Œª F, g‚Åª¬π ‚Ä¢ F,
    left_inv := Œª F, inv_smul_smul g F,
    right_inv := Œª F, smul_inv_smul g F,
    map_mul' := by { intros, funext, simp only [arrow_action_apply, pi.mul_apply]} },
  map_one' := by { ext, simp only [mul_aut.one_apply, mul_equiv.coe_mk, one_smul]},
  map_mul' := by {intros, ext, simp only [mul_smul, mul_equiv.coe_mk, mul_aut.mul_apply] } }

@[simp] lemma mul_aut_of_action_apply {G A X : Type*} [group G] [mul_action G A] [has_mul X]
  (g : G·µí·µñ) (F : A ‚Üí X) (a : A) : mul_aut_of_action G A X g F a = F (g.unop ‚Ä¢ a) := rfl

/-- A group homomorphisms `G ‚Üí* H·µí·µñ` is the sa-/
def hom_op_equiv_op_hom {G H} [monoid G] [monoid H] :
  (G ‚Üí* H·µí·µñ) ‚âÉ (G·µí·µñ ‚Üí* H) :=
{ to_fun := Œª f, { to_fun := Œª g', (f g'.unop).unop,
    map_one' := by simp, map_mul' := by simp },
  inv_fun := Œª f, { to_fun := Œª g, op (f (op g)),
    map_one' := by simp, map_mul' := by simp },
  left_inv := by { intro, ext, simp },
  right_inv := by { intro, ext, simp } }

/-- Given `G` acting on `A`, a functor from the corresponding action groupoid to a group `X`
    can be curried to a group homomorphism `G ‚Üí* G ‚ãâ (A ‚Üí X)`.
    (We simulate `‚ãâ` using `‚ãä` and lots of `·µí·µñ`s.) -/
def curry {G A X} [group G] [mul_action G A] [group X]
  (F : action_category G A ‚•§ single_obj X) :
  G ‚Üí* ((A ‚Üí X·µí·µñ) ‚ãä[mul_aut_of_action G A X·µí·µñ] G·µí·µñ)·µí·µñ :=
have F_map_eq : ‚àÄ {a b} {f : a ‚ü∂ b}, F.map f = (F.map (hom_of_pair a.back f.val) : X) :=
  action_category.cases (Œª _ _, rfl),
{ to_fun := Œª g, op ‚ü®Œª a, op (F.map (hom_of_pair a g)), op g‚ü©,
  map_one' := begin
    rw [op_eq_iff_eq_unop, unop_one],
    congr, funext,
    rw [pi.one_apply, op_eq_iff_eq_unop, unop_one],
    exact F_map_eq.symm.trans (F.map_id a),
  end,
  map_mul' := begin
    intros g h,
    rw [op_eq_iff_eq_unop, ‚Üêop_mul, unop_op],
    congr, funext,
    rw [op_eq_iff_eq_unop, pi.mul_apply, unop_mul, unop_op],
    exact F_map_eq.symm.trans (F.map_comp (hom_of_pair a h) (hom_of_pair (h ‚Ä¢ a) g)),
  end }

/-- Given `G` acting on `A`, a group homomorphism `œÜ : G ‚Üí* G ‚ãâ (A ‚Üí X)` can be uncurried to
    a functor from the action groupoid to `X`, provided that `œÜ g = (g, _)` for all `g`.
    (We simulate `‚ãâ` using `‚ãä` and lots of `·µí·µñ`s.) -/
def uncurry {G A X} [group G] [mul_action G A] [group X]
  (F : G ‚Üí* ((A ‚Üí X·µí·µñ) ‚ãä[mul_aut_of_action G A X·µí·µñ] G·µí·µñ)·µí·µñ)
  (sane : ‚àÄ g, (F g).unop.right.unop = g) :
  action_category G A ‚•§ single_obj X :=
{ obj := Œª _, (),
  map := Œª a b f, ((F f.val).unop.left a.back).unop,
  map_id' := by { intro x, rw [action_category.id_val, F.map_one], refl },
  map_comp' := by {
    intros x y z f, revert x y f,
    refine action_category.cases _, intros x g f,
    rw [action_category.comp_val, F.map_mul, unop_mul,
        mul_left, pi.mul_apply, mul_aut_of_action_apply, sane],
    refl } }

open is_free_group as fgp

instance {G A : Type u} [group G] [is_free_group G] [mul_action G A] :
  is_free_groupoid (action_category G A) :=
{ generators := ‚ü®Œª a b, { e : fgp.generators G // fgp.of e ‚Ä¢ a.back = b.back }‚ü©,
  of := Œª a b e, ‚ü®fgp.of e, e.property‚ü©,
  unique_lift := begin
    introsI X _ f,
    let X' := ((A ‚Üí X·µí·µñ) ‚ãä[mul_aut_of_action G A X·µí·µñ] G·µí·µñ)·µí·µñ,
    let f' : fgp.generators G ‚Üí X' := Œª e, op ‚ü®Œª a, op (@f a (_ : A) ‚ü®e, rfl‚ü©), op (fgp.of e)‚ü©,
    rcases fgp.unique_lift f' with ‚ü®F', hF', uF'‚ü©,
    let F : action_category G A ‚•§ single_obj X := uncurry F' _,
    refine ‚ü®F, _, _‚ü©,
    { rintros ‚ü®‚ü®‚ü©, a : A‚ü© ‚ü®‚ü®‚ü©, b‚ü© ‚ü®e, h : fgp.of e ‚Ä¢ a = b‚ü©,
      change ((F' (fgp.of _)).unop.left _).unop = _,
      rw hF', cases h, refl },
    { intros E hE,
      let E' := curry E,
      have : E' = F',
      { apply uF',
        intro e,
        refine unop_injective (semidirect_product.ext _ _ _ rfl),
        funext,
        change op (E.map _) = op (f _),
        rw [op_eq_iff_eq_unop, unop_op],
        exact hE _ _ ‚ü®e, _‚ü© },
      apply functor.hext,
      { intro, apply unit.ext },
      { refine action_category.cases _, intros,
        change _ == ((F' _).unop.left _).unop,
        rw ‚Üêthis, refl } },
    { apply fgp.end_is_id ((hom_op_equiv_op_hom (right_hom : _ ‚Üí* G·µí·µñ)).comp F'),
      intro, rw [monoid_hom.comp_apply, hF'], refl }
  end }

end covering

section retract
open quiver

variables {G : Type u} [groupoid.{u} G] [is_free_groupoid G]
  (T : wide_subquiver (generators.symmetrify : quiver G))

-- an abbreviation for taking the quiver corresponding to a subquiver
local notation T `‚ôØ` :10000 := T.quiver

variable [arborescence T‚ôØ]

/-- A path in the tree gives a hom, by composition. -/
noncomputable def hom_of_path : Œ† {a : G}, T‚ôØ.path T‚ôØ.root a ‚Üí (T‚ôØ.root ‚ü∂ a)
| _ path.nil := ùüô _
| a (path.cons p ‚ü®sum.inl e, h‚ü©) := hom_of_path p ‚â´ of e
| a (path.cons p ‚ü®sum.inr e, h‚ü©) := hom_of_path p ‚â´ inv (of e)

/-- For every vertex `a`, there is a canonical hom from the root, given by the
    path in the tree. -/
def tree_hom (a : G) : T‚ôØ.root ‚ü∂ a := hom_of_path T (default _)

lemma tree_hom_eq {a : G} (p q : T‚ôØ.path T‚ôØ.root a) : hom_of_path T p = hom_of_path T q :=
by congr

@[simp] lemma tree_hom_root : tree_hom T T‚ôØ.root = ùüô _ :=
trans (tree_hom_eq T _ path.nil) rfl -- ???

/-- Any hom in `G` can be made into a loop, by conjugating with `tree_hom`s. -/
@[simp] def loop_of_hom {a b : G} (p : a ‚ü∂ b) : End T‚ôØ.root :=
tree_hom T a ‚â´ p ‚â´ inv (tree_hom T b)

lemma loop_of_hom_eq_id {a b : G} {e : generators.arrow a b} :
  (sum.inl e) ‚àà T a b ‚à® (sum.inr e) ‚àà T b a
    ‚Üí loop_of_hom T (of e) = ùüô _ :=
begin
  rw [loop_of_hom, ‚Üêcategory.assoc, is_iso.comp_inv_eq, category.id_comp, tree_hom, tree_hom],
  rintro (h | h),
  { refine eq.trans _ (tree_hom_eq T (path.cons (default _) ‚ü®sum.inl e, h‚ü©) _),
    rw hom_of_path },
  { rw tree_hom_eq T (default _) (path.cons (default _) ‚ü®sum.inr e, h‚ü©),
    simp only [hom_of_path, is_iso.inv_hom_id, category.comp_id, category.assoc] }
end

/-- Since a hom gives a loop, a homomorphism from the vertex group at the root
    extends to a functor on the whole groupoid. -/
def functor_of_monoid_hom {X} [monoid X] (f : End T‚ôØ.root ‚Üí* X) :
  G ‚•§ single_obj X :=
{ obj := Œª _, (),
  map := Œª a b p, f (loop_of_hom T p),
  map_id' := begin intro a, convert f.map_one, simp end,
  map_comp' := by { intros, rw [single_obj.comp_as_mul, ‚Üêf.map_mul],
    simp only [is_iso.inv_hom_id_assoc, loop_of_hom, End.mul_def, category.assoc] } }

@[simp] lemma functor_of_monoid_hom.apply {X} [monoid X] (f : End T‚ôØ.root ‚Üí* X)
  {a b : G} (p : a ‚ü∂ b) : (functor_of_monoid_hom T f).map p = f (loop_of_hom T p) := rfl

/-- Given a free groupoid and an arborescence of its generating quiver, the vertex
    group at the root is freely generated by loops coming from generating arrows
    in the complement of the tree. -/
def End_is_free_group_of_arborescence : is_free_group (End T‚ôØ.root) :=
{ generators := set.compl (wide_subquiver_equiv_set_total $ wide_subquiver_symmetrify T),
  of := Œª e, loop_of_hom T (of e.val.arrow),
  unique_lift := begin
    introsI X _ f,
    let f' : Œ† ‚¶Éa b : G‚¶Ñ, generators.arrow a b ‚Üí X := Œª a b e,
      if h : sum.inl e ‚àà T a b ‚à® sum.inr e ‚àà T b a then 1
      else f ‚ü®‚ü®a, b, e‚ü©, h‚ü©,
    rcases unique_lift f' with ‚ü®F', hF', uF'‚ü©,
    let F : End T‚ôØ.root ‚Üí* X := F'.map_End _,
    have sane : ‚àÄ {a b} (p : a ‚ü∂ b), (functor_of_monoid_hom T F).map p = F'.map p,
    { intros a b p,
      change F'.map _ = _,
      suffices : ‚àÄ {a} (p : T‚ôØ.path T‚ôØ.root a), F'.map (hom_of_path T p) = 1,
      { simp [this, tree_hom, single_obj.comp_as_mul, single_obj.inv_as_inv] },
      intros a p, induction p with b c p e ih,
      { apply F'.map_id },
      rcases e with ‚ü®e | e, eT‚ü©,
      { have : f' e = 1 := dif_pos (or.inl eT),
        simp only [hom_of_path, ih, hF', this, single_obj.comp_as_mul, mul_one, F'.map_comp] },
      { have : f' e = 1 := dif_pos (or.inr eT),
        simp [hom_of_path, ih, hF', this, single_obj.comp_as_mul, single_obj.inv_as_inv] } },
    refine ‚ü®F, _, _‚ü©,
    { intro e,
      convert sane _,
      rw hF',
      change _ = dite _ _ _,
      convert (dif_neg e.property).symm,
      apply congr_arg, ext; refl },
    { intros E hE,
      have : functor_of_monoid_hom T E = F',
      { apply uF',
        intros a b e,
        change E (loop_of_hom T _) = dite _ _ _,
        split_ifs,
        { rw loop_of_hom_eq_id T h, apply E.map_one },
        exact hE ‚ü®‚ü®a, b, e‚ü©, h‚ü© },
      ext,
      have : (functor_of_monoid_hom T E).map x = (functor_of_monoid_hom T F).map x,
      { rw [this, sane] },
      simpa using this }
  end }

end retract

open is_free_groupoid quotient_group

/-- `G` acts pretransitively on `X` if for any `x y` there is `g` such that `g ‚Ä¢ x = y`. -/
class is_pretransitive (G X) [monoid G] [mul_action G X] : Prop :=
(exists_smul_eq : ‚àÄ x y : X, ‚àÉ g : G, g ‚Ä¢ x = y)

lemma exists_smul_eq (M) {X} [monoid M] [mul_action M X] [is_pretransitive M X] (x y : X) :
  ‚àÉ m : M, m ‚Ä¢ x = y := is_pretransitive.exists_smul_eq x y

instance is_transitive_quotient (G) [group G] (H : subgroup G) : is_pretransitive G (quotient H) :=
{ exists_smul_eq := by { rintros ‚ü®x‚ü© ‚ü®y‚ü©, refine ‚ü®y * x‚Åª¬π, quotient_group.eq.mpr _‚ü©,
    simp only [mul_left_inv, inv_mul_cancel_right, H.one_mem] } }

instance (G X) [monoid G] [mul_action G X] [is_pretransitive G X] [nonempty X] :
  is_connected (action_category G X) :=
zigzag_is_connected $ Œª x y, relation.refl_trans_gen.single $ or.inl $
  nonempty_subtype.mpr (show _, from exists_smul_eq G x.back y.back)

instance (G) [groupoid G] [is_connected G] (x y : G) : nonempty (x ‚ü∂ y) :=
begin
  have h := is_connected_zigzag x y,
  induction h with z w _ h ih,
  { exact ‚ü®ùüô x‚ü© },
  { refine nonempty.map (Œª f, f ‚â´ classical.choice _) ih,
    cases h,
    { assumption },
    { apply nonempty.map (Œª f, inv f) h } }
end

/-- Given a function `f : C ‚Üí G` from a category to a group, we get a functor
    `C ‚•§ G` sending any morphism `x ‚ü∂ y` to `f y * (f x)‚Åª¬π`. -/
def difference_functor {C G} [category C] [group G] (f : C ‚Üí G) : C ‚•§ single_obj G :=
{ obj := Œª _, (),
  map := Œª x y _, f y * (f x)‚Åª¬π,
  map_id' := by { intro, rw [single_obj.id_as_one, mul_right_inv] },
  map_comp' := by { intros, rw single_obj.comp_as_mul, group } }

@[simp]
lemma difference_functor_map {C G} [category C] [group G] (f : C ‚Üí G) (x y : C) (p : x ‚ü∂ y) :
  (difference_functor f).map p = f y * (f x)‚Åª¬π := rfl

instance generators_connected (G) [groupoid.{u u} G] [is_connected G] [is_free_groupoid G] (r : G) :
  (generators : quiver G).symmetrify.rooted_connected r :=
begin
  let X := free_group (generators : quiver G).weakly_connected_component,
  set f : G ‚Üí X := Œª g, free_group.of ‚Üëg with hf,
  set F : G ‚•§ single_obj X := difference_functor f with hF,
  have claim : F = (category_theory.functor.const G).obj (),
  { ext,
    rw [functor.const.obj_map, single_obj.id_as_one, hF,
      difference_functor_map, mul_inv_eq_one, hf],
    apply congr_arg free_group.of,
    rw quiver.weakly_connected_component.eq,
    exact ‚ü®quiver.arrow.to_path (sum.inr e)‚ü© },
  refine ‚ü®Œª b, _‚ü©,
  rw ‚Üêquiver.weakly_connected_component.eq,
  apply free_group.of_injective,
  rw ‚Üêmul_inv_eq_one,
  rcases (infer_instance : nonempty (b ‚ü∂ r)) with ‚ü®p‚ü©,
  change F.map p = _,
  rw [claim, functor.const.obj_map, single_obj.id_as_one],
end

lemma stabilizer_quotient {G} [group G] (H : subgroup G) :
  mul_action.stabilizer G ((1 : G) : quotient H) = H :=
by { ext, change _ = _ ‚Üî _, rw eq_comm, convert quotient_group.eq, simp }

/-- Any subgroup of `G` is a vertex group in its action groupoid. -/
def End_mul_equiv_subgroup {G} [group G] (H : subgroup G) :
  End (obj_equiv G (quotient H) (1 : G)) ‚âÉ* H :=
mul_equiv.trans
  (stabilizer_iso_End G ((1 : G) : quotient H)).symm
  (mul_equiv.subgroup_congr $ stabilizer_quotient H)

instance {G} [groupoid G] [is_free_groupoid G] [is_connected G] (r : G) : is_free_group (End r) :=
End_is_free_group_of_arborescence (quiver.geodesic_subtree _ r)

instance {G} [group.{u} G] [is_free_group G] (H : subgroup G) : is_free_group H :=
is_free_group.of_mul_equiv (End_mul_equiv_subgroup H)

end is_free_groupoid
