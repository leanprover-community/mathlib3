/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Yury Kudryashov
-/
import measure_theory.measure_space
import analysis.normed_space.finite_dimension
/-!
# Borel (measurable) space

## Main definitions

* `borel Î±` : the least `Ïƒ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `â€¹measurable_space Î±â€º = borel Î±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Î± â‰¤ â€¹measurable_space Î±â€º`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `â„`, `â„â‰¥0`, `ennreal`.
* A measure is `regular` if it is finite on compact sets, inner regular and outer regular.

## Main statements

* `is_open.is_measurable`, `is_closed.is_measurable`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Î± â†’ Î²` and `g : Î± â†’ Î³` are measurable and `op : Î² Ã— Î³ â†’ Î´`
  is continuous, then `Î» x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `measurable.ennreal*` : special cases for arithmetic operations on `ennreal`s.
-/

noncomputable theory

open classical set
open_locale classical big_operators topological_space

universes u v w x y
variables {Î± Î² Î³ Î´ : Type*} {Î¹ : Sort y} {s t u : set Î±}

open measurable_space topological_space

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Î± : Type u) [topological_space Î±] : measurable_space Î± :=
generate_from {s : set Î± | is_open s}

lemma borel_eq_top_of_discrete [topological_space Î±] [discrete_topology Î±] :
  borel Î± = âŠ¤ :=
top_le_iff.1 $ Î» s hs, generate_measurable.basic s (is_open_discrete s)

lemma borel_eq_top_of_encodable [topological_space Î±] [t1_space Î±] [encodable Î±] :
  borel Î± = âŠ¤ :=
begin
  refine (top_le_iff.1 $ Î» s hs, bUnion_of_singleton s â–¸ _),
  apply is_measurable.bUnion s.countable_encodable,
  intros x hx,
  apply is_measurable.of_compl,
  apply generate_measurable.basic,
  exact is_closed_singleton
end

lemma borel_eq_generate_from_of_subbasis {s : set (set Î±)}
  [t : topological_space Î±] [second_countable_topology Î±] (hs : t = generate_from s) :
  borel Î± = generate_from s :=
le_antisymm
  (generate_from_le $ assume u (hu : t.is_open u),
    begin
      rw [hs] at hu,
      induction hu,
      case generate_open.basic : u hu
      { exact generate_measurable.basic u hu },
      case generate_open.univ
      { exact @is_measurable.univ Î± (generate_from s) },
      case generate_open.inter : sâ‚ sâ‚‚ _ _ hsâ‚ hsâ‚‚
      { exact @is_measurable.inter Î± (generate_from s) _ _ hsâ‚ hsâ‚‚ },
      case generate_open.sUnion : f hf ih {
        rcases is_open_sUnion_countable f (by rwa hs) with âŸ¨v, hv, vf, vuâŸ©,
        rw â† vu,
        exact @is_measurable.sUnion Î± (generate_from s) _ hv
          (Î» x xv, ih _ (vf xv)) }
    end)
  (generate_from_le $ assume u hu, generate_measurable.basic _ $
    show t.is_open u, by rw [hs]; exact generate_open.basic _ hu)

lemma is_pi_system_is_open [topological_space Î±] : is_pi_system (is_open : set Î± â†’ Prop) :=
Î» s t hs ht hst, is_open_inter hs ht

section order_topology

variable (Î±)
variables [topological_space Î±] [second_countable_topology Î±] [linear_order Î±] [order_topology Î±]

lemma borel_eq_generate_Iio : borel Î± = generate_from (range Iio) :=
begin
  refine le_antisymm _ (generate_from_le _),
  { rw borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals Î± _ _ _),
    letI : measurable_space Î± := measurable_space.generate_from (range Iio),
    have H : âˆ€ a:Î±, is_measurable (Iio a) := Î» a, generate_measurable.basic _ âŸ¨_, rflâŸ©,
    refine generate_from_le _, rintro _ âŸ¨a, rfl | rflâŸ©; [skip, apply H],
    by_cases h : âˆƒ a', âˆ€ b, a < b â†” a' â‰¤ b,
    { rcases h with âŸ¨a', ha'âŸ©,
      rw (_ : Ioi a = (Iio a')á¶œ), { exact (H _).compl },
      simp [set.ext_iff, ha'] },
    { rcases is_open_Union_countable
        (Î» a' : {a' : Î± // a < a'}, {b | a'.1 < b})
        (Î» a', is_open_lt' _) with âŸ¨v, âŸ¨hvâŸ©, vuâŸ©,
      simp [set.ext_iff] at vu,
      have : Ioi a = â‹ƒ x : v, (Iio x.1.1)á¶œ,
      { simp [set.ext_iff],
        refine Î» x, âŸ¨Î» ax, _, Î» âŸ¨a', âŸ¨h, avâŸ©, axâŸ©, lt_of_lt_of_le h axâŸ©,
        rcases (vu x).2 _ with âŸ¨a', hâ‚, hâ‚‚âŸ©,
        { exact âŸ¨a', hâ‚, le_of_lt hâ‚‚âŸ© },
        refine not_imp_comm.1 (Î» h, _) h,
        exact âŸ¨x, Î» b, âŸ¨Î» ab, le_of_not_lt (Î» h', h âŸ¨b, ab, h'âŸ©),
          lt_of_lt_of_le axâŸ©âŸ© },
      rw this, resetI,
      apply is_measurable.Union,
      exact Î» _, (H _).compl } },
  { rw forall_range_iff,
    intro a,
    exact generate_measurable.basic _ is_open_Iio }
end

lemma borel_eq_generate_Ioi : borel Î± = generate_from (range Ioi) :=
@borel_eq_generate_Iio (order_dual Î±) _ (by apply_instance : second_countable_topology Î±) _ _

end order_topology

lemma borel_comap {f : Î± â†’ Î²} {t : topological_space Î²} :
  @borel Î± (t.induced f) = (@borel Î² t).comap f :=
comap_generate_from.symm

lemma continuous.borel_measurable [topological_space Î±] [topological_space Î²]
  {f : Î± â†’ Î²} (hf : continuous f) :
  @measurable Î± Î² (borel Î±) (borel Î²) f :=
measurable.of_le_map $ generate_from_le $
  Î» s hs, generate_measurable.basic (f â»Â¹' s) (hf s hs)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class opens_measurable_space (Î± : Type*) [topological_space Î±] [h : measurable_space Î±] : Prop :=
(borel_le : borel Î± â‰¤ h)

/-- A space with `measurable_space` and `topological_space` structures such that
the `Ïƒ`-algebra of measurable sets is exactly the `Ïƒ`-algebra generated by open sets. -/
class borel_space (Î± : Type*) [topological_space Î±] [measurable_space Î±] : Prop :=
(measurable_eq : â€¹measurable_space Î±â€º = borel Î±)

/-- In a `borel_space` all open sets are measurable. -/
@[priority 100]
instance borel_space.opens_measurable {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [borel_space Î±] : opens_measurable_space Î± :=
âŸ¨ge_of_eq $ borel_space.measurable_eqâŸ©

instance subtype.borel_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [hÎ± : borel_space Î±] (s : set Î±) :
  borel_space s :=
âŸ¨by { rw [hÎ±.1, subtype.measurable_space, â† borel_comap], refl }âŸ©

instance subtype.opens_measurable_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [h : opens_measurable_space Î±] (s : set Î±) :
  opens_measurable_space s :=
âŸ¨by { rw [borel_comap], exact comap_mono h.1 }âŸ©

section
variables [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
   [topological_space Î²] [measurable_space Î²] [opens_measurable_space Î²]
   [topological_space Î³] [measurable_space Î³] [borel_space Î³]
   [measurable_space Î´]

lemma is_open.is_measurable (h : is_open s) : is_measurable s :=
opens_measurable_space.borel_le _ $ generate_measurable.basic _ h

lemma is_measurable_interior : is_measurable (interior s) := is_open_interior.is_measurable

lemma is_closed.is_measurable (h : is_closed s) : is_measurable s :=
is_measurable.compl_iff.1 $ h.is_measurable

lemma is_compact.is_measurable [t2_space Î±] (h : is_compact s) : is_measurable s :=
h.is_closed.is_measurable

lemma is_measurable_closure : is_measurable (closure s) :=
is_closed_closure.is_measurable

lemma measurable_of_is_open {f : Î´ â†’ Î³} (hf : âˆ€ s, is_open s â†’ is_measurable (f â»Â¹' s)) :
  measurable f :=
by { rw [â€¹borel_space Î³â€º.measurable_eq], exact measurable_generate_from hf }

lemma measurable_of_is_closed {f : Î´ â†’ Î³} (hf : âˆ€ s, is_closed s â†’ is_measurable (f â»Â¹' s)) :
  measurable f :=
begin
  apply measurable_of_is_open, intros s hs,
  rw [â† is_measurable.compl_iff, â† preimage_compl], apply hf, rw [is_closed_compl_iff], exact hs
end

lemma measurable_of_is_closed' {f : Î´ â†’ Î³}
  (hf : âˆ€ s, is_closed s â†’ s.nonempty â†’ s â‰  univ â†’ is_measurable (f â»Â¹' s)) : measurable f :=
begin
  apply measurable_of_is_closed, intros s hs,
  cases eq_empty_or_nonempty s with h1 h1, { simp [h1] },
  by_cases h2 : s = univ, { simp [h2] },
  exact hf s hs h1 h2
end

instance nhds_is_measurably_generated (a : Î±) : (ğ“ a).is_measurably_generated :=
begin
  rw [nhds, infi_subtype'],
  refine @filter.infi_is_measurably_generated _ _ _ _ (Î» i, _),
  exact i.2.2.is_measurable.principal_is_measurably_generated
end

/-- If `s` is a measurable set, then `ğ“[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : is_measurable s`.
-/
lemma is_measurable.nhds_within_is_measurably_generated {s : set Î±} (hs : is_measurable s) (a : Î±) :
  (ğ“[s] a).is_measurably_generated :=
by haveI := hs.principal_is_measurably_generated; exact filter.inf_is_measurably_generated _ _

@[priority 100] -- see Note [lower instance priority]
instance opens_measurable_space.to_measurable_singleton_class [t1_space Î±] :
  measurable_singleton_class Î± :=
âŸ¨Î» x, is_closed_singleton.is_measurableâŸ©

instance prod.opens_measurable_space [second_countable_topology Î±] [second_countable_topology Î²] :
  opens_measurable_space (Î± Ã— Î²) :=
begin
  refine âŸ¨_âŸ©,
  rcases is_open_generated_countable_inter Î± with âŸ¨a, haâ‚, haâ‚‚, haâ‚ƒ, haâ‚„, haâ‚…âŸ©,
  rcases is_open_generated_countable_inter Î² with âŸ¨b, hbâ‚, hbâ‚‚, hbâ‚ƒ, hbâ‚„, hbâ‚…âŸ©,
  have : prod.topological_space = generate_from {g | âˆƒuâˆˆa, âˆƒvâˆˆb, g = set.prod u v},
  { rw [haâ‚…, hbâ‚…], exact prod_generate_from_generate_from_eq haâ‚„ hbâ‚„ },
  rw [borel_eq_generate_from_of_subbasis this],
  apply generate_from_le,
  rintros _ âŸ¨u, hu, v, hv, rflâŸ©,
  have hu : is_open u, by { rw [haâ‚…], exact generate_open.basic _ hu },
  have hv : is_open v, by { rw [hbâ‚…], exact generate_open.basic _ hv },
  exact hu.is_measurable.prod hv.is_measurable
end

section preorder
variables [preorder Î±] [order_closed_topology Î±] {a b : Î±}

lemma is_measurable_Ici : is_measurable (Ici a) := is_closed_Ici.is_measurable
lemma is_measurable_Iic : is_measurable (Iic a) := is_closed_Iic.is_measurable
lemma is_measurable_Icc : is_measurable (Icc a b) := is_closed_Icc.is_measurable

instance nhds_within_Ici_is_measurably_generated :
  (ğ“[Ici b] a).is_measurably_generated :=
is_measurable_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated :
  (ğ“[Iic b] a).is_measurably_generated :=
is_measurable_Iic.nhds_within_is_measurably_generated _

instance at_top_is_measurably_generated : (filter.at_top : filter Î±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Î» a, (is_measurable_Ici : is_measurable (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (filter.at_bot : filter Î±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Î» a, (is_measurable_Iic : is_measurable (Iic a)).principal_is_measurably_generated

end preorder

section partial_order
variables [partial_order Î±] [order_closed_topology Î±] [second_countable_topology Î±]
  {a b : Î±}

lemma is_measurable_le' : is_measurable {p : Î± Ã— Î± | p.1 â‰¤ p.2} :=
order_closed_topology.is_closed_le'.is_measurable

lemma is_measurable_le {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  is_measurable {a | f a â‰¤ g a} :=
hf.prod_mk hg is_measurable_le'

end partial_order

section linear_order
variables [linear_order Î±] [order_closed_topology Î±] {a b : Î±}

lemma is_measurable_Iio : is_measurable (Iio a) := is_open_Iio.is_measurable
lemma is_measurable_Ioi : is_measurable (Ioi a) := is_open_Ioi.is_measurable
lemma is_measurable_Ioo : is_measurable (Ioo a b) := is_open_Ioo.is_measurable
lemma is_measurable_Ioc : is_measurable (Ioc a b) := is_measurable_Ioi.inter is_measurable_Iic
lemma is_measurable_Ico : is_measurable (Ico a b) := is_measurable_Ici.inter is_measurable_Iio

instance nhds_within_Ioi_is_measurably_generated :
  (ğ“[Ioi b] a).is_measurably_generated :=
is_measurable_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated :
  (ğ“[Iio b] a).is_measurably_generated :=
is_measurable_Iio.nhds_within_is_measurably_generated _

variables [second_countable_topology Î±]

lemma is_measurable_lt' : is_measurable {p : Î± Ã— Î± | p.1 < p.2} :=
(is_open_lt continuous_fst continuous_snd).is_measurable

lemma is_measurable_lt {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  is_measurable {a | f a < g a} :=
hf.prod_mk hg is_measurable_lt'

end linear_order

section decidable_linear_order

variables [decidable_linear_order Î±] [order_closed_topology Î±]

lemma is_measurable_interval {a b : Î±} : is_measurable (interval a b) :=
is_measurable_Icc

variables [second_countable_topology Î±]

lemma measurable.max {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î»a, max (f a) (g a)) :=
hf.piecewise (is_measurable_le hg hf) hg

lemma measurable.min {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î»a, min (f a) (g a)) :=
hf.piecewise (is_measurable_le hf hg) hg

end decidable_linear_order

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
lemma continuous.measurable {f : Î± â†’ Î³} (hf : continuous f) :
  measurable f :=
hf.borel_measurable.mono opens_measurable_space.borel_le
  (le_of_eq $ borel_space.measurable_eq)

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def homeomorph.to_measurable_equiv {Î± : Type*} {Î² : Type*} [topological_space Î±]
  [measurable_space Î±] [borel_space Î±] [topological_space Î²] [measurable_space Î²]
  [borel_space Î²] (h : Î± â‰ƒâ‚œ Î²) :
  measurable_equiv Î± Î² :=
{ measurable_to_fun := h.continuous_to_fun.measurable,
  measurable_inv_fun := h.continuous_inv_fun.measurable,
  .. h }

lemma measurable_of_continuous_on_compl_singleton [t1_space Î±] {f : Î± â†’ Î³} (a : Î±)
  (hf : continuous_on f {x | x â‰  a}) :
  measurable f :=
measurable_of_measurable_on_compl_singleton a
  (continuous_on_iff_continuous_restrict.1 hf).measurable

lemma continuous.measurable2 [second_countable_topology Î±] [second_countable_topology Î²]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³}
  (h : continuous (Î»p:Î±Ã—Î², c p.1 p.2)) (hf : measurable f) (hg : measurable g) :
  measurable (Î»a, c (f a) (g a)) :=
h.measurable.comp (hf.prod_mk hg)

lemma measurable.smul [semiring Î±] [second_countable_topology Î±]
  [add_comm_monoid Î³] [second_countable_topology Î³]
  [semimodule Î± Î³] [topological_semimodule Î± Î³]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î³} (hf : measurable f) (hg : measurable g) :
  measurable (Î» c, f c â€¢ g c) :=
continuous_smul.measurable2 hf hg

lemma measurable.const_smul {R M : Type*} [topological_space R] [semiring R]
  [add_comm_monoid M] [semimodule R M] [topological_space M] [topological_semimodule R M]
  [measurable_space M] [borel_space M]
  {f : Î´ â†’ M} (hf : measurable f) (c : R) :
  measurable (Î» x, c â€¢ f x) :=
(continuous_const.smul continuous_id).measurable.comp hf

lemma measurable_const_smul_iff {Î± : Type*} [topological_space Î±]
  [division_ring Î±] [add_comm_monoid Î³]
  [semimodule Î± Î³] [topological_semimodule Î± Î³]
  {f : Î´ â†’ Î³} {c : Î±} (hc : c â‰  0) :
  measurable (Î» x, c â€¢ f x) â†” measurable f :=
âŸ¨Î» h, by simpa only [smul_smul, inv_mul_cancel hc, one_smul] using h.const_smul câ»Â¹,
  Î» h, h.const_smul câŸ©

lemma measurable.const_mul {R : Type*} [topological_space R] [measurable_space R]
  [borel_space R] [semiring R] [topological_semiring R]
  {f : Î´ â†’ R} (hf : measurable f) (c : R) :
  measurable (Î» x, c * f x) :=
hf.const_smul c

lemma measurable.mul_const {R : Type*} [topological_space R] [measurable_space R]
  [borel_space R] [semiring R] [topological_semiring R]
  {f : Î´ â†’ R} (hf : measurable f) (c : R) :
  measurable (Î» x, f x * c) :=
(continuous_id.mul continuous_const).measurable.comp hf

end

section borel_space
variables [topological_space Î±] [measurable_space Î±] [borel_space Î±]
  [topological_space Î²] [measurable_space Î²] [borel_space Î²]
  [topological_space Î³] [measurable_space Î³] [borel_space Î³]
  [measurable_space Î´]

lemma prod_le_borel_prod : prod.measurable_space â‰¤ borel (Î± Ã— Î²) :=
begin
  rw [â€¹borel_space Î±â€º.measurable_eq, â€¹borel_space Î²â€º.measurable_eq],
  refine sup_le _ _,
  { exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable },
  { exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable }
end

instance prod.borel_space [second_countable_topology Î±] [second_countable_topology Î²] :
  borel_space (Î± Ã— Î²) :=
âŸ¨le_antisymm prod_le_borel_prod opens_measurable_space.borel_leâŸ©

@[to_additive]
lemma measurable_mul [has_mul Î±] [has_continuous_mul Î±] [second_countable_topology Î±] :
  measurable (Î» p : Î± Ã— Î±, p.1 * p.2) :=
continuous_mul.measurable

@[to_additive]
lemma measurable.mul [has_mul Î±] [has_continuous_mul Î±] [second_countable_topology Î±]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} : measurable f â†’ measurable g â†’ measurable (Î»a, f a * g a) :=
continuous_mul.measurable2

/-- A variant of `measurable.mul` that uses `*` on functions -/
@[to_additive]
lemma measurable.mul' [has_mul Î±] [has_continuous_mul Î±] [second_countable_topology Î±]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î±} : measurable f â†’ measurable g â†’ measurable (f * g) :=
measurable.mul

@[to_additive]
lemma measurable_mul_left [has_mul Î±] [has_continuous_mul Î±] (x : Î±) :
  measurable (Î» y : Î±, x * y) :=
continuous.measurable $ continuous_const.mul continuous_id

@[to_additive]
lemma measurable_mul_right [has_mul Î±] [has_continuous_mul Î±] (x : Î±) :
  measurable (Î» y : Î±, y * x) :=
continuous.measurable $ continuous_id.mul continuous_const

@[to_additive]
lemma finset.measurable_prod {Î¹ : Type*} [comm_monoid Î±] [has_continuous_mul Î±]
  [second_countable_topology Î±] {f : Î¹ â†’ Î´ â†’ Î±} (s : finset Î¹) (hf : âˆ€i, measurable (f i)) :
  measurable (Î»a, âˆ i in s, f i a) :=
finset.induction_on s
  (by simp only [finset.prod_empty, measurable_const])
  (assume i s his ih, by simpa [his] using (hf i).mul ih)

@[to_additive]
lemma measurable_inv [group Î±] [topological_group Î±] : measurable (has_inv.inv : Î± â†’ Î±) :=
continuous_inv.measurable

@[to_additive]
lemma measurable.inv [group Î±] [topological_group Î±] {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î»a, (f a)â»Â¹) :=
measurable_inv.comp hf

lemma measurable_inv' {Î± : Type*} [normed_field Î±] [measurable_space Î±] [borel_space Î±] :
  measurable (has_inv.inv : Î± â†’ Î±) :=
measurable_of_continuous_on_compl_singleton 0 normed_field.continuous_on_inv

lemma measurable.inv' {Î± : Type*} [normed_field Î±] [measurable_space Î±] [borel_space Î±]
  {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î»a, (f a)â»Â¹) :=
measurable_inv'.comp hf

@[to_additive]
lemma measurable.of_inv [group Î±] [topological_group Î±] {f : Î´ â†’ Î±}
  (hf : measurable (Î» a, (f a)â»Â¹)) : measurable f :=
by simpa only [inv_inv] using hf.inv

@[simp, to_additive]
lemma measurable_inv_iff [group Î±] [topological_group Î±] {f : Î´ â†’ Î±} :
  measurable (Î» a, (f a)â»Â¹) â†” measurable f :=
âŸ¨measurable.of_inv, measurable.invâŸ©

lemma measurable.sub [add_group Î±] [topological_add_group Î±] [second_countable_topology Î±]
  {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» x, f x - g x) :=
hf.add hg.neg

lemma measurable_comp_iff_of_closed_embedding {f : Î´ â†’ Î²} (g : Î² â†’ Î³) (hg : closed_embedding g) :
  measurable (g âˆ˜ f) â†” measurable f :=
begin
  refine âŸ¨Î» hf, _, Î» hf, hg.continuous.measurable.comp hfâŸ©,
  apply measurable_of_is_closed, intros s hs,
  convert hf (hg.is_closed_map s hs).is_measurable,
  rw [@preimage_comp _ _ _ f g, preimage_image_eq _ hg.to_embedding.inj]
end

section linear_order

variables [linear_order Î±] [order_topology Î±] [second_countable_topology Î±]

lemma measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, is_measurable (f â»Â¹' Iio x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_Iio _),
  rintro _ âŸ¨x, rflâŸ©, exact hf x
end

lemma measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, is_measurable (f â»Â¹' Ioi x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_Ioi _),
  rintro _ âŸ¨x, rflâŸ©, exact hf x
end

lemma measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, is_measurable (f â»Â¹' Iic x)) : measurable f :=
begin
  apply measurable_of_Ioi,
  simp_rw [â† compl_Iic, preimage_compl, is_measurable.compl_iff],
  assumption
end

lemma measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, is_measurable (f â»Â¹' Ici x)) : measurable f :=
begin
  apply measurable_of_Iio,
  simp_rw [â† compl_Ici, preimage_compl, is_measurable.compl_iff],
  assumption
end

lemma measurable.is_lub {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i))
  (hg : âˆ€ b, is_lub {a | âˆƒ i, f i b = a} (g b)) :
  measurable g :=
begin
  change âˆ€ b, is_lub (range $ Î» i, f i b) (g b) at hg,
  rw [â€¹borel_space Î±â€º.measurable_eq, borel_eq_generate_Ioi Î±],
  apply measurable_generate_from,
  rintro _ âŸ¨a, rflâŸ©,
  simp only [set.preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists],
  exact is_measurable.Union (Î» i, hf i (is_open_lt' _).is_measurable)
end

lemma measurable.is_glb {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i))
  (hg : âˆ€ b, is_glb {a | âˆƒ i, f i b = a} (g b)) :
  measurable g :=
begin
  change âˆ€ b, is_glb (range $ Î» i, f i b) (g b) at hg,
  rw [â€¹borel_space Î±â€º.measurable_eq, borel_eq_generate_Iio Î±],
  apply measurable_generate_from,
  rintro _ âŸ¨a, rflâŸ©,
  simp only [set.preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists],
  exact is_measurable.Union (Î» i, hf i (is_open_gt' _).is_measurable)
end

end linear_order

lemma measurable.supr_Prop {Î±} [measurable_space Î±] [complete_lattice Î±]
  (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î» b, â¨† h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact supr_pos h end)
  (assume h : Â¬p, begin convert measurable_const, funext, exact supr_neg h end)

lemma measurable.infi_Prop {Î±} [measurable_space Î±] [complete_lattice Î±]
  (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î» b, â¨… h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact infi_pos h end )
  (assume h : Â¬p, begin convert measurable_const, funext, exact infi_neg h end)

section complete_linear_order

variables [complete_linear_order Î±] [order_topology Î±] [second_countable_topology Î±]

lemma measurable_supr {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» b, â¨† i, f i b) :=
measurable.is_lub hf $ Î» b, is_lub_supr

lemma measurable_infi {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» b, â¨… i, f i b) :=
measurable.is_glb hf $ Î» b, is_glb_infi

lemma measurable_bsupr {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, measurable (f i)) : measurable (Î» b, â¨† i âˆˆ s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [supr_subtype'],
     exact measurable_supr (Î» i, hf i) }

lemma measurable_binfi {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, measurable (f i)) : measurable (Î» b, â¨… i âˆˆ s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [infi_subtype'],
     exact measurable_infi (Î» i, hf i) }

end complete_linear_order

section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Î±] [second_countable_topology Î±] [order_topology Î±]

lemma measurable_cSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : set Î¹} (hs : s.countable)
  (hf : âˆ€ i, measurable (f i)) (bdd : âˆ€ x, bdd_above ((Î» i, f i x) '' s)) :
  measurable (Î» x, Sup ((Î» i, f i x) '' s)) :=
begin
  cases eq_empty_or_nonempty s with h2s h2s,
  { simp [h2s, measurable_const] },
  { apply measurable_of_Iic, intro y,
    simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall],
    exact is_measurable.bInter hs (Î» i hi, is_measurable_le (hf i) measurable_const) }
end

end conditionally_complete_linear_order

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def homemorph.to_measurable_equiv (h : Î± â‰ƒâ‚œ Î²) :
  measurable_equiv Î± Î² :=
{ to_equiv := h.to_equiv,
  measurable_to_fun := h.continuous_to_fun.measurable,
  measurable_inv_fun := h.continuous_inv_fun.measurable }

end borel_space

instance empty.borel_space : borel_space empty := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance unit.borel_space : borel_space unit := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance bool.borel_space : borel_space bool := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance nat.borel_space : borel_space â„• := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance int.borel_space : borel_space â„¤ := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance rat.borel_space : borel_space â„š := âŸ¨borel_eq_top_of_encodable.symmâŸ©

instance real.measurable_space : measurable_space â„ := borel â„
instance real.borel_space : borel_space â„ := âŸ¨rflâŸ©

instance nnreal.measurable_space : measurable_space nnreal := borel nnreal
instance nnreal.borel_space : borel_space nnreal := âŸ¨rflâŸ©

instance ennreal.measurable_space : measurable_space ennreal := borel ennreal
instance ennreal.borel_space : borel_space ennreal := âŸ¨rflâŸ©

instance complex.measurable_space : measurable_space â„‚ := borel â„‚
instance complex.borel_space : borel_space â„‚ := âŸ¨rflâŸ©

section metric_space

variables [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
variables [measurable_space Î²] {x : Î±} {Îµ : â„}

open metric

lemma is_measurable_ball : is_measurable (metric.ball x Îµ) :=
metric.is_open_ball.is_measurable

lemma is_measurable_closed_ball : is_measurable (metric.closed_ball x Îµ) :=
metric.is_closed_ball.is_measurable

lemma measurable_inf_dist {s : set Î±} : measurable (Î» x, inf_dist x s) :=
(continuous_inf_dist_pt s).measurable

lemma measurable.inf_dist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
  measurable (Î» x, inf_dist (f x) s) :=
measurable_inf_dist.comp hf

variables [second_countable_topology Î±]
lemma measurable_dist : measurable (Î»p:Î±Ã—Î±, dist p.1 p.2) :=
continuous_dist.measurable

lemma measurable.dist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, dist (f b) (g b)) :=
continuous_dist.measurable2 hf hg

lemma measurable_nndist : measurable (Î»p:Î±Ã—Î±, nndist p.1 p.2) :=
continuous_nndist.measurable

lemma measurable.nndist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, nndist (f b) (g b)) :=
continuous_nndist.measurable2 hf hg

end metric_space

section emetric_space

variables [emetric_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
variables [measurable_space Î²] {x : Î±} {Îµ : ennreal}

open emetric

lemma is_measurable_eball : is_measurable (emetric.ball x Îµ) :=
emetric.is_open_ball.is_measurable

lemma measurable_edist_right : measurable (edist x) :=
(continuous_const.edist continuous_id).measurable

lemma measurable_edist_left : measurable (Î» y, edist y x) :=
(continuous_id.edist continuous_const).measurable

lemma measurable_inf_edist {s : set Î±} : measurable (Î» x, inf_edist x s) :=
continuous_inf_edist.measurable

lemma measurable.inf_edist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
  measurable (Î» x, inf_edist (f x) s) :=
measurable_inf_edist.comp hf

variables [second_countable_topology Î±]

lemma measurable_edist : measurable (Î»p:Î±Ã—Î±, edist p.1 p.2) :=
continuous_edist.measurable

lemma measurable.edist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, edist (f b) (g b)) :=
continuous_edist.measurable2 hf hg

end emetric_space

namespace real
open measurable_space measure_theory

lemma borel_eq_generate_from_Ioo_rat :
  borel â„ = generate_from (â‹ƒ(a b : â„š) (h : a < b), {Ioo a b}) :=
borel_eq_generate_from_of_subbasis is_topological_basis_Ioo_rat.2.2

lemma measure_ext_Ioo_rat {Î¼ Î½ : measure â„} [locally_finite_measure Î¼]
  (h : âˆ€ a b : â„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=
begin
  refine measure.ext_of_generate_from_of_cover_subset borel_eq_generate_from_Ioo_rat _
    (subset.refl _) _ _ _ _,
  { simp only [is_pi_system, mem_Union, mem_singleton_iff],
    rintros _ _ âŸ¨aâ‚, bâ‚, hâ‚, rflâŸ© âŸ¨aâ‚‚, bâ‚‚, hâ‚‚, rflâŸ© ne,
    simp only [Ioo_inter_Ioo, sup_eq_max, inf_eq_min, â† rat.cast_max, â† rat.cast_min,
      nonempty_Ioo] at ne âŠ¢,
    refine âŸ¨_, _, _, rflâŸ©,
    assumption_mod_cast },
  { exact countable_Union (Î» a, (countable_encodable _).bUnion $ Î» _ _, countable_singleton _) },
  { exact is_topological_basis_Ioo_rat.2.1 },
  { simp only [mem_Union, mem_singleton_iff],
    rintros _ âŸ¨a, b, h, rflâŸ©,
    refine (measure_mono subset_closure).trans_lt _,
    rw [closure_Ioo],
    exacts [compact_Icc.finite_measure, rat.cast_lt.2 h] },
  { simp only [mem_Union, mem_singleton_iff],
    rintros _ âŸ¨a, b, hab, rflâŸ©,
    exact h a b }
end

lemma borel_eq_generate_from_Iio_rat :
  borel â„ = generate_from (â‹ƒa:â„š, {Iio a}) :=
begin
  let g, swap,
  apply le_antisymm (_ : _ â‰¤ g) (measurable_space.generate_from_le (Î» t, _)),
  { rw borel_eq_generate_from_Ioo_rat,
    refine generate_from_le (Î» t, _),
    simp only [mem_Union], rintro âŸ¨a, b, h, HâŸ©,
    rw [mem_singleton_iff.1 H],
    rw (set.ext (Î» x, _) : Ioo (a:â„) b = (â‹ƒc>a, (Iio c)á¶œ) âˆ© Iio b),
    { have hg : âˆ€ q : â„š, g.is_measurable' (Iio q) :=
        Î» q, generate_measurable.basic (Iio q) (by { simp, exact âŸ¨_, rflâŸ© }),
      refine @is_measurable.inter _ g _ _ _ (hg _),
      refine @is_measurable.bUnion _ _ g _ _ (countable_encodable _) (Î» c h, _),
      exact @is_measurable.compl _ _ g (hg _) },
    { simp [Ioo, Iio],
      refine and_congr _ iff.rfl,
      exact âŸ¨Î» h,
        let âŸ¨c, ac, cxâŸ© := exists_rat_btwn h in
        âŸ¨c, rat.cast_lt.1 ac, le_of_lt cxâŸ©,
       Î» âŸ¨c, ac, cxâŸ©, lt_of_lt_of_le (rat.cast_lt.2 ac) cxâŸ© } },
  { simp, rintro r rfl, exact is_open_Iio.is_measurable }
end

end real

variable [measurable_space Î±]

lemma measurable.sub_nnreal {f g : Î± â†’ nnreal} :
  measurable f â†’ measurable g â†’ measurable (Î» a, f a - g a) :=
nnreal.continuous_sub.measurable2

lemma measurable.nnreal_of_real {f : Î± â†’ â„} (hf : measurable f) :
  measurable (Î» x, nnreal.of_real (f x)) :=
nnreal.continuous_of_real.measurable.comp hf

lemma nnreal.measurable_coe : measurable (coe : nnreal â†’ â„) :=
nnreal.continuous_coe.measurable

lemma measurable.nnreal_coe {f : Î± â†’ nnreal} (hf : measurable f) :
  measurable (Î» x, (f x : â„)) :=
nnreal.measurable_coe.comp hf

lemma measurable.ennreal_coe {f : Î± â†’ nnreal} (hf : measurable f) :
  measurable (Î» x, (f x : ennreal)) :=
ennreal.continuous_coe.measurable.comp hf

lemma measurable.ennreal_of_real {f : Î± â†’ â„} (hf : measurable f) :
  measurable (Î» x, ennreal.of_real (f x)) :=
ennreal.continuous_of_real.measurable.comp hf

/-- The set of finite `ennreal` numbers is `measurable_equiv` to `nnreal`. -/
def measurable_equiv.ennreal_equiv_nnreal : measurable_equiv {r : ennreal | r â‰  âŠ¤} nnreal :=
ennreal.ne_top_homeomorph_nnreal.to_measurable_equiv

namespace ennreal
open filter

lemma measurable_coe : measurable (coe : nnreal â†’ ennreal) :=
measurable_id.ennreal_coe

lemma measurable_of_measurable_nnreal {f : ennreal â†’ Î±}
  (h : measurable (Î»p:nnreal, f p)) : measurable f :=
measurable_of_measurable_on_compl_singleton âŠ¤
  (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_coe_iff.1 h)

/-- `ennreal` is `measurable_equiv` to `nnreal âŠ• unit`. -/
def ennreal_equiv_sum :
  measurable_equiv ennreal (nnreal âŠ• unit) :=
{ measurable_to_fun  := measurable_of_measurable_nnreal measurable_inl,
  measurable_inv_fun := measurable_sum measurable_coe (@measurable_const ennreal unit _ _ âŠ¤),
  .. equiv.option_equiv_sum_punit nnreal }

open function (uncurry)

lemma measurable_of_measurable_nnreal_prod [measurable_space Î²] [measurable_space Î³]
  {f : ennreal Ã— Î² â†’ Î³} (Hâ‚ : measurable (Î» p : nnreal Ã— Î², f (p.1, p.2)))
  (Hâ‚‚ : measurable (Î» x, f (âŠ¤, x))) :
  measurable f :=
let e : measurable_equiv (ennreal Ã— Î²) (nnreal Ã— Î² âŠ• unit Ã— Î²) :=
  (ennreal_equiv_sum.prod_congr (measurable_equiv.refl Î²)).trans
    (measurable_equiv.sum_prod_distrib _ _ _) in
e.symm.measurable_coe_iff.1 $ measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)

lemma measurable_of_measurable_nnreal_nnreal [measurable_space Î²]
  {f : ennreal Ã— ennreal â†’ Î²} (hâ‚ : measurable (Î»p:nnreal Ã— nnreal, f (p.1, p.2)))
  (hâ‚‚ : measurable (Î»r:nnreal, f (âŠ¤, r))) (hâ‚ƒ : measurable (Î»r:nnreal, f (r, âŠ¤))) :
  measurable f :=
measurable_of_measurable_nnreal_prod
  (measurable_swap_iff.1 $ measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)
  (measurable_of_measurable_nnreal hâ‚‚)

lemma measurable_of_real : measurable ennreal.of_real :=
ennreal.continuous_of_real.measurable

lemma measurable_to_real : measurable ennreal.to_real :=
ennreal.measurable_of_measurable_nnreal nnreal.measurable_coe

lemma measurable_to_nnreal : measurable ennreal.to_nnreal :=
ennreal.measurable_of_measurable_nnreal measurable_id

lemma measurable_mul : measurable (Î» p : ennreal Ã— ennreal, p.1 * p.2) :=
begin
  apply measurable_of_measurable_nnreal_nnreal,
  { simp only [â† ennreal.coe_mul, measurable_mul.ennreal_coe] },
  { simp only [ennreal.top_mul, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (is_measurable_singleton _) measurable_const },
  { simp only [ennreal.mul_top, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (is_measurable_singleton _) measurable_const }
end

lemma measurable_sub : measurable (Î» p : ennreal Ã— ennreal, p.1 - p.2) :=
by apply measurable_of_measurable_nnreal_nnreal;
  simp [â† ennreal.coe_sub, nnreal.continuous_sub.measurable.ennreal_coe]

end ennreal

lemma measurable.to_nnreal {f : Î± â†’ ennreal} (hf : measurable f) :
  measurable (Î» x, (f x).to_nnreal) :=
ennreal.measurable_to_nnreal.comp hf

lemma measurable_ennreal_coe_iff {f : Î± â†’ nnreal} :
  measurable (Î» x, (f x : ennreal)) â†” measurable f :=
âŸ¨Î» h, h.to_nnreal, Î» h, h.ennreal_coeâŸ©

lemma measurable.to_real {f : Î± â†’ ennreal} (hf : measurable f) :
  measurable (Î» x, ennreal.to_real (f x)) :=
ennreal.measurable_to_real.comp hf

lemma measurable.ennreal_mul {f g : Î± â†’ ennreal} (hf : measurable f) (hg : measurable g) :
  measurable (Î»a, f a * g a) :=
ennreal.measurable_mul.comp (hf.prod_mk hg)

lemma measurable.ennreal_add {f g : Î± â†’ ennreal}
  (hf : measurable f) (hg : measurable g) : measurable (Î»a, f a + g a) :=
hf.add hg

lemma measurable.ennreal_sub {f g : Î± â†’ ennreal} (hf : measurable f) (hg : measurable g) :
  measurable (Î»a, f a - g a) :=
ennreal.measurable_sub.comp (hf.prod_mk hg)

/-- note: `ennreal` can probably be generalized in a future version of this lemma. -/
lemma measurable.ennreal_tsum {Î¹} [encodable Î¹] {f : Î¹ â†’ Î± â†’ ennreal} (h : âˆ€ i, measurable (f i)) :
  measurable (Î» x, âˆ‘' i, f i x) :=
by { simp_rw [ennreal.tsum_eq_supr_sum], apply measurable_supr, exact Î» s, s.measurable_sum h }

section normed_group

variables [normed_group Î±] [opens_measurable_space Î±] [measurable_space Î²]

lemma measurable_norm : measurable (norm : Î± â†’ â„) :=
continuous_norm.measurable

lemma measurable.norm {f : Î² â†’ Î±} (hf : measurable f) : measurable (Î»a, norm (f a)) :=
measurable_norm.comp hf

lemma measurable_nnnorm : measurable (nnnorm : Î± â†’ nnreal) :=
continuous_nnnorm.measurable

lemma measurable.nnnorm {f : Î² â†’ Î±} (hf : measurable f) : measurable (Î»a, nnnorm (f a)) :=
measurable_nnnorm.comp hf

lemma measurable_ennnorm : measurable (Î» x : Î±, (nnnorm x : ennreal)) :=
measurable_nnnorm.ennreal_coe

lemma measurable.ennnorm {f : Î² â†’ Î±} (hf : measurable f) :
  measurable (Î»a, (nnnorm (f a) : ennreal)) :=
hf.nnnorm.ennreal_coe

end normed_group

namespace continuous_linear_map

variables {ğ•œ : Type*} [normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E] [measurable_space E]
variables [opens_measurable_space E]
variables {F : Type*} [normed_group F] [normed_space ğ•œ F] [measurable_space F] [borel_space F]

protected lemma measurable (L : E â†’L[ğ•œ] F) : measurable L :=
L.continuous.measurable

lemma measurable_comp (L : E â†’L[ğ•œ] F) {Ï† : Î± â†’ E} (Ï†_meas : measurable Ï†) :
  measurable (Î» (a : Î±), L (Ï† a)) :=
L.measurable.comp Ï†_meas

end continuous_linear_map

section normed_space
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] [measurable_space ğ•œ]
variables [borel_space ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E] [measurable_space E] [borel_space E]

lemma measurable_smul_const {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) :
  measurable (Î» x, f x â€¢ c) â†” measurable f :=
measurable_comp_iff_of_closed_embedding (Î» y : ğ•œ, y â€¢ c) (closed_embedding_smul_left hc)

end normed_space

namespace measure_theory
namespace measure

variables [topological_space Î±]

/-- A measure `Î¼` is regular if
  - it is finite on all compact sets;
  - it is outer regular: `Î¼(A) = inf { Î¼(U) | A âŠ† U open }` for `A` measurable;
  - it is inner regular: `Î¼(U) = sup { Î¼(K) | K âŠ† U compact }` for `U` open. -/
structure regular (Î¼ : measure Î±) : Prop :=
(lt_top_of_is_compact : âˆ€ {{K : set Î±}}, is_compact K â†’ Î¼ K < âŠ¤)
(outer_regular : âˆ€ {{A : set Î±}}, is_measurable A â†’
  (â¨… (U : set Î±) (h : is_open U) (h2 : A âŠ† U), Î¼ U) â‰¤ Î¼ A)
(inner_regular : âˆ€ {{U : set Î±}}, is_open U â†’
  Î¼ U â‰¤ â¨† (K : set Î±) (h : is_compact K) (h2 : K âŠ† U), Î¼ K)

namespace regular

lemma outer_regular_eq {Î¼ : measure Î±} (hÎ¼ : Î¼.regular) {{A : set Î±}}
  (hA : is_measurable A) : (â¨… (U : set Î±) (h : is_open U) (h2 : A âŠ† U), Î¼ U) = Î¼ A :=
le_antisymm (hÎ¼.outer_regular hA) $ le_infi $ Î» s, le_infi $ Î» hs, le_infi $ Î» h2s, Î¼.mono h2s

lemma inner_regular_eq {Î¼ : measure Î±} (hÎ¼ : Î¼.regular) {{U : set Î±}}
  (hU : is_open U) : (â¨† (K : set Î±) (h : is_compact K) (h2 : K âŠ† U), Î¼ K) = Î¼ U :=
le_antisymm (supr_le $ Î» s, supr_le $ Î» hs, supr_le $ Î» h2s, Î¼.mono h2s) (hÎ¼.inner_regular hU)

protected lemma map [opens_measurable_space Î±] [measurable_space Î²] [topological_space Î²]
  [t2_space Î²] [borel_space Î²] {Î¼ : measure Î±} (hÎ¼ : Î¼.regular) (f : Î± â‰ƒâ‚œ Î²) :
  (measure.map f Î¼).regular :=
begin
  have hf := f.continuous.measurable,
  have h2f := f.to_equiv.injective.preimage_surjective,
  have h3f := f.to_equiv.surjective,
  split,
  { intros K hK, rw [map_apply hf hK.is_measurable],
    apply hÎ¼.lt_top_of_is_compact, rwa f.compact_preimage },
  { intros A hA, rw [map_apply hf hA, â† hÎ¼.outer_regular_eq (hf hA)],
    refine le_of_eq _, apply infi_congr (preimage f) h2f,
    intro U, apply infi_congr_Prop f.is_open_preimage, intro hU,
    apply infi_congr_Prop h3f.preimage_subset_preimage_iff, intro h2U,
    rw [map_apply hf hU.is_measurable], },
  { intros U hU, rw [map_apply hf hU.is_measurable, â† hÎ¼.inner_regular_eq (f.continuous U hU)],
    refine ge_of_eq _, apply supr_congr (preimage f) h2f,
    intro K, apply supr_congr_Prop f.compact_preimage, intro hK,
    apply supr_congr_Prop h3f.preimage_subset_preimage_iff, intro h2U,
    rw [map_apply hf hK.is_measurable] }
end

protected lemma smul {Î¼ : measure Î±} (hÎ¼ : Î¼.regular) {x : ennreal} (hx : x < âŠ¤) :
  (x â€¢ Î¼).regular :=
begin
  split,
  { intros K hK, exact ennreal.mul_lt_top hx (hÎ¼.lt_top_of_is_compact hK) },
  { intros A hA, rw [coe_smul],
    refine le_trans _ (ennreal.mul_left_mono $ hÎ¼.outer_regular hA),
    simp only [infi_and'], simp only [infi_subtype'],
    haveI : nonempty {s : set Î± // is_open s âˆ§ A âŠ† s} := âŸ¨âŸ¨set.univ, is_open_univ, subset_univ _âŸ©âŸ©,
    rw [ennreal.mul_infi], refl', exact ne_of_lt hx },
  { intros U hU, rw [coe_smul], refine le_trans (ennreal.mul_left_mono $ hÎ¼.inner_regular hU) _,
    simp only [supr_and'], simp only [supr_subtype'],
    rw [ennreal.mul_supr], refl' }
end

end regular

end measure
end measure_theory
