/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Yury Kudryashov
-/
import measure_theory.function.ae_measurable_sequence
import analysis.complex.basic
import analysis.normed_space.finite_dimension
import topology.G_delta
import measure_theory.group.arithmetic
import topology.semicontinuous
import topology.instances.ereal

/-!
# Borel (measurable) space

## Main definitions

* `borel Œ±` : the least `œÉ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `‚Äπmeasurable_space Œ±‚Ä∫ = borel Œ±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Œ± ‚â§ ‚Äπmeasurable_space Œ±‚Ä∫`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `‚Ñù`, `‚Ñù‚â•0`, `‚Ñù‚â•0‚àû`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Œ± ‚Üí Œ≤` and `g : Œ± ‚Üí Œ≥` are measurable and `op : Œ≤ √ó Œ≥ ‚Üí Œ¥`
  is continuous, then `Œª x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `‚Ñù‚â•0‚àû`.
-/

noncomputable theory

open classical set filter measure_theory
open_locale classical big_operators topological_space nnreal ennreal

universes u v w x y
variables {Œ± Œ≤ Œ≥ Œ≥‚ÇÇ Œ¥ : Type*} {Œπ : Sort y} {s t u : set Œ±}

open measurable_space topological_space

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Œ± : Type u) [topological_space Œ±] : measurable_space Œ± :=
generate_from {s : set Œ± | is_open s}

lemma borel_eq_top_of_discrete [topological_space Œ±] [discrete_topology Œ±] :
  borel Œ± = ‚ä§ :=
top_le_iff.1 $ Œª s hs, generate_measurable.basic s (is_open_discrete s)

lemma borel_eq_top_of_encodable [topological_space Œ±] [t1_space Œ±] [encodable Œ±] :
  borel Œ± = ‚ä§ :=
begin
  refine (top_le_iff.1 $ Œª s hs, bUnion_of_singleton s ‚ñ∏ _),
  apply measurable_set.bUnion s.countable_encodable,
  intros x hx,
  apply measurable_set.of_compl,
  apply generate_measurable.basic,
  exact is_closed_singleton.is_open_compl
end

lemma borel_eq_generate_from_of_subbasis {s : set (set Œ±)}
  [t : topological_space Œ±] [second_countable_topology Œ±] (hs : t = generate_from s) :
  borel Œ± = generate_from s :=
le_antisymm
  (generate_from_le $ assume u (hu : t.is_open u),
    begin
      rw [hs] at hu,
      induction hu,
      case generate_open.basic : u hu
      { exact generate_measurable.basic u hu },
      case generate_open.univ
      { exact @measurable_set.univ Œ± (generate_from s) },
      case generate_open.inter : s‚ÇÅ s‚ÇÇ _ _ hs‚ÇÅ hs‚ÇÇ
      { exact @measurable_set.inter Œ± (generate_from s) _ _ hs‚ÇÅ hs‚ÇÇ },
      case generate_open.sUnion : f hf ih {
        rcases is_open_sUnion_countable f (by rwa hs) with ‚ü®v, hv, vf, vu‚ü©,
        rw ‚Üê vu,
        exact @measurable_set.sUnion Œ± (generate_from s) _ hv
          (Œª x xv, ih _ (vf xv)) }
    end)
  (generate_from_le $ assume u hu, generate_measurable.basic _ $
    show t.is_open u, by rw [hs]; exact generate_open.basic _ hu)

lemma topological_space.is_topological_basis.borel_eq_generate_from [topological_space Œ±]
  [second_countable_topology Œ±] {s : set (set Œ±)} (hs : is_topological_basis s) :
  borel Œ± = generate_from s :=
borel_eq_generate_from_of_subbasis hs.eq_generate_from

lemma is_pi_system_is_open [topological_space Œ±] : is_pi_system (is_open : set Œ± ‚Üí Prop) :=
Œª s t hs ht hst, is_open.inter hs ht

lemma borel_eq_generate_from_is_closed [topological_space Œ±] :
  borel Œ± = generate_from {s | is_closed s} :=
le_antisymm
  (generate_from_le $ Œª t ht, @measurable_set.of_compl Œ± _ (generate_from {s | is_closed s})
    (generate_measurable.basic _ $ is_closed_compl_iff.2 ht))
  (generate_from_le $ Œª t ht, @measurable_set.of_compl Œ± _ (borel Œ±)
    (generate_measurable.basic _ $ is_open_compl_iff.2 ht))

section order_topology

variable (Œ±)
variables [topological_space Œ±] [second_countable_topology Œ±] [linear_order Œ±] [order_topology Œ±]

lemma is_pi_system_Ioo_mem {Œ± : Type*} [linear_order Œ±] (s t : set Œ±) :
  is_pi_system {S | ‚àÉ (l ‚àà s) (u ‚àà t), l < u ‚àß Ioo l u = S} :=
begin
  rintro _ _ ‚ü®l‚ÇÅ, hls‚ÇÅ, u‚ÇÅ, hut‚ÇÅ, hlu‚ÇÅ, rfl‚ü© ‚ü®l‚ÇÇ, hls‚ÇÇ, u‚ÇÇ, hut‚ÇÇ, hlu‚ÇÇ, rfl‚ü©
    ‚ü®x, ‚ü®hlx‚ÇÅ : l‚ÇÅ < x, hxu‚ÇÅ : x < u‚ÇÅ‚ü©, ‚ü®hlx‚ÇÇ : l‚ÇÇ < x, hxu‚ÇÇ : x < u‚ÇÇ‚ü©‚ü©,
  refine ‚ü®l‚ÇÅ ‚äî l‚ÇÇ, sup_ind l‚ÇÅ l‚ÇÇ hls‚ÇÅ hls‚ÇÇ, u‚ÇÅ ‚äì u‚ÇÇ, inf_ind u‚ÇÅ u‚ÇÇ hut‚ÇÅ hut‚ÇÇ, _,
    Ioo_inter_Ioo.symm‚ü©,
  simp [hlx‚ÇÇ.trans hxu‚ÇÅ, hlx‚ÇÅ.trans hxu‚ÇÇ, *]
end

lemma is_pi_system_Ioo {Œ± Œ≤ : Type*} [linear_order Œ≤] (f : Œ± ‚Üí Œ≤) :
  @is_pi_system Œ≤ (‚ãÉ l u (h : f l < f u), {Ioo (f l) (f u)})  :=
begin
  convert is_pi_system_Ioo_mem (range f) (range f),
  ext s,
  simp [@eq_comm _ _ s]
end

lemma borel_eq_generate_Iio : borel Œ± = generate_from (range Iio) :=
begin
  refine le_antisymm _ (generate_from_le _),
  { rw borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals Œ± _ _ _),
    letI : measurable_space Œ± := measurable_space.generate_from (range Iio),
    have H : ‚àÄ a : Œ±, measurable_set (Iio a) := Œª a, generate_measurable.basic _ ‚ü®_, rfl‚ü©,
    refine generate_from_le _, rintro _ ‚ü®a, rfl | rfl‚ü©; [skip, apply H],
    by_cases h : ‚àÉ a', ‚àÄ b, a < b ‚Üî a' ‚â§ b,
    { rcases h with ‚ü®a', ha'‚ü©,
      rw (_ : Ioi a = (Iio a')·∂ú), { exact (H _).compl },
      simp [set.ext_iff, ha'] },
    { rcases is_open_Union_countable
        (Œª a' : {a' : Œ± // a < a'}, {b | a'.1 < b})
        (Œª a', is_open_lt' _) with ‚ü®v, ‚ü®hv‚ü©, vu‚ü©,
      simp [set.ext_iff] at vu,
      have : Ioi a = ‚ãÉ x : v, (Iio x.1.1)·∂ú,
      { simp [set.ext_iff],
        refine Œª x, ‚ü®Œª ax, _, Œª ‚ü®a', ‚ü®h, av‚ü©, ax‚ü©, lt_of_lt_of_le h ax‚ü©,
        rcases (vu x).2 _ with ‚ü®a', h‚ÇÅ, h‚ÇÇ‚ü©,
        { exact ‚ü®a', h‚ÇÅ, le_of_lt h‚ÇÇ‚ü© },
        refine not_imp_comm.1 (Œª h, _) h,
        exact ‚ü®x, Œª b, ‚ü®Œª ab, le_of_not_lt (Œª h', h ‚ü®b, ab, h'‚ü©),
          lt_of_lt_of_le ax‚ü©‚ü© },
      rw this, resetI,
      apply measurable_set.Union,
      exact Œª _, (H _).compl } },
  { rw forall_range_iff,
    intro a,
    exact generate_measurable.basic _ is_open_Iio }
end

lemma borel_eq_generate_Ioi : borel Œ± = generate_from (range Ioi) :=
@borel_eq_generate_Iio (order_dual Œ±) _ (by apply_instance : second_countable_topology Œ±) _ _

end order_topology

lemma borel_comap {f : Œ± ‚Üí Œ≤} {t : topological_space Œ≤} :
  @borel Œ± (t.induced f) = (@borel Œ≤ t).comap f :=
comap_generate_from.symm

lemma continuous.borel_measurable [topological_space Œ±] [topological_space Œ≤]
  {f : Œ± ‚Üí Œ≤} (hf : continuous f) :
  @measurable Œ± Œ≤ (borel Œ±) (borel Œ≤) f :=
measurable.of_le_map $ generate_from_le $
  Œª s hs, generate_measurable.basic (f ‚Åª¬π' s) (hs.preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class opens_measurable_space (Œ± : Type*) [topological_space Œ±] [h : measurable_space Œ±] : Prop :=
(borel_le : borel Œ± ‚â§ h)

/-- A space with `measurable_space` and `topological_space` structures such that
the `œÉ`-algebra of measurable sets is exactly the `œÉ`-algebra generated by open sets. -/
class borel_space (Œ± : Type*) [topological_space Œ±] [measurable_space Œ±] : Prop :=
(measurable_eq : ‚Äπmeasurable_space Œ±‚Ä∫ = borel Œ±)

/-- In a `borel_space` all open sets are measurable. -/
@[priority 100]
instance borel_space.opens_measurable {Œ± : Type*} [topological_space Œ±] [measurable_space Œ±]
  [borel_space Œ±] : opens_measurable_space Œ± :=
‚ü®ge_of_eq $ borel_space.measurable_eq‚ü©

instance subtype.borel_space {Œ± : Type*} [topological_space Œ±] [measurable_space Œ±]
  [hŒ± : borel_space Œ±] (s : set Œ±) :
  borel_space s :=
‚ü®by { rw [hŒ±.1, subtype.measurable_space, ‚Üê borel_comap], refl }‚ü©

instance subtype.opens_measurable_space {Œ± : Type*} [topological_space Œ±] [measurable_space Œ±]
  [h : opens_measurable_space Œ±] (s : set Œ±) :
  opens_measurable_space s :=
‚ü®by { rw [borel_comap], exact comap_mono h.1 }‚ü©

section
variables [topological_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±]
   [topological_space Œ≤] [measurable_space Œ≤] [opens_measurable_space Œ≤]
   [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥]
   [topological_space Œ≥‚ÇÇ] [measurable_space Œ≥‚ÇÇ] [borel_space Œ≥‚ÇÇ]
   [measurable_space Œ¥]

lemma is_open.measurable_set (h : is_open s) : measurable_set s :=
opens_measurable_space.borel_le _ $ generate_measurable.basic _ h

@[measurability]
lemma measurable_set_interior : measurable_set (interior s) := is_open_interior.measurable_set

lemma is_GŒ¥.measurable_set (h : is_GŒ¥ s) : measurable_set s :=
begin
  rcases h with ‚ü®S, hSo, hSc, rfl‚ü©,
  exact measurable_set.sInter hSc (Œª t ht, (hSo t ht).measurable_set)
end

lemma measurable_set_of_continuous_at {Œ≤} [emetric_space Œ≤] (f : Œ± ‚Üí Œ≤) :
  measurable_set {x | continuous_at f x} :=
(is_GŒ¥_set_of_continuous_at f).measurable_set

lemma is_closed.measurable_set (h : is_closed s) : measurable_set s :=
h.is_open_compl.measurable_set.of_compl

lemma is_compact.measurable_set [t2_space Œ±] (h : is_compact s) : measurable_set s :=
h.is_closed.measurable_set

@[measurability]
lemma measurable_set_closure : measurable_set (closure s) :=
is_closed_closure.measurable_set

lemma measurable_of_is_open {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, is_open s ‚Üí measurable_set (f ‚Åª¬π' s)) :
  measurable f :=
by { rw [‚Äπborel_space Œ≥‚Ä∫.measurable_eq], exact measurable_generate_from hf }

lemma measurable_of_is_closed {f : Œ¥ ‚Üí Œ≥} (hf : ‚àÄ s, is_closed s ‚Üí measurable_set (f ‚Åª¬π' s)) :
  measurable f :=
begin
  apply measurable_of_is_open, intros s hs,
  rw [‚Üê measurable_set.compl_iff, ‚Üê preimage_compl], apply hf, rw [is_closed_compl_iff], exact hs
end

lemma measurable_of_is_closed' {f : Œ¥ ‚Üí Œ≥}
  (hf : ‚àÄ s, is_closed s ‚Üí s.nonempty ‚Üí s ‚â† univ ‚Üí measurable_set (f ‚Åª¬π' s)) : measurable f :=
begin
  apply measurable_of_is_closed, intros s hs,
  cases eq_empty_or_nonempty s with h1 h1, { simp [h1] },
  by_cases h2 : s = univ, { simp [h2] },
  exact hf s hs h1 h2
end

instance nhds_is_measurably_generated (a : Œ±) : (ùìù a).is_measurably_generated :=
begin
  rw [nhds, infi_subtype'],
  refine @filter.infi_is_measurably_generated _ _ _ _ (Œª i, _),
  exact i.2.2.measurable_set.principal_is_measurably_generated
end

/-- If `s` is a measurable set, then `ùìù[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
lemma measurable_set.nhds_within_is_measurably_generated {s : set Œ±} (hs : measurable_set s)
  (a : Œ±) :
  (ùìù[s] a).is_measurably_generated :=
by haveI := hs.principal_is_measurably_generated; exact filter.inf_is_measurably_generated _ _

@[priority 100] -- see Note [lower instance priority]
instance opens_measurable_space.to_measurable_singleton_class [t1_space Œ±] :
  measurable_singleton_class Œ± :=
‚ü®Œª x, is_closed_singleton.measurable_set‚ü©

instance pi.opens_measurable_space {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [fintype Œπ]
  [t' : Œ† i, topological_space (œÄ i)]
  [Œ† i, measurable_space (œÄ i)] [‚àÄ i, second_countable_topology (œÄ i)]
  [‚àÄ i, opens_measurable_space (œÄ i)] :
  opens_measurable_space (Œ† i, œÄ i) :=
begin
  constructor,
  have : Pi.topological_space =
    generate_from {t | ‚àÉ(s:Œ†a, set (œÄ a)) (i : finset Œπ), (‚àÄa‚àài, s a ‚àà countable_basis (œÄ a)) ‚àß
      t = pi ‚Üëi s},
  { rw [funext (Œª a, @eq_generate_from_countable_basis (œÄ a) _ _), pi_generate_from_eq] },
  rw [borel_eq_generate_from_of_subbasis this],
  apply generate_from_le,
  rintros _ ‚ü®s, i, hi, rfl‚ü©,
  refine measurable_set.pi i.countable_to_set (Œª a ha, is_open.measurable_set _),
  rw [eq_generate_from_countable_basis (œÄ a)],
  exact generate_open.basic _ (hi a ha)
end

instance prod.opens_measurable_space [second_countable_topology Œ±] [second_countable_topology Œ≤] :
  opens_measurable_space (Œ± √ó Œ≤) :=
begin
  constructor,
  rw [((is_basis_countable_basis Œ±).prod (is_basis_countable_basis Œ≤)).borel_eq_generate_from],
  apply generate_from_le,
  rintros _ ‚ü®u, v, hu, hv, rfl‚ü©,
  exact (is_open_of_mem_countable_basis hu).measurable_set.prod
    (is_open_of_mem_countable_basis hv).measurable_set
end

variables {Œ±' : Type*} [topological_space Œ±'] [measurable_space Œ±']

lemma meas_interior_of_null_bdry {Œº : measure Œ±'} {s : set Œ±'}
  (h_nullbdry : Œº (frontier s) = 0) : Œº (interior s) = Œº s :=
meas_eq_meas_smaller_of_between_null_diff
  interior_subset subset_closure h_nullbdry

lemma meas_closure_of_null_bdry {Œº : measure Œ±'} {s : set Œ±'}
  (h_nullbdry : Œº (frontier s) = 0) : Œº (closure s) = Œº s :=
(meas_eq_meas_larger_of_between_null_diff
  interior_subset subset_closure h_nullbdry).symm

section preorder
variables [preorder Œ±] [order_closed_topology Œ±] {a b : Œ±}

@[simp, measurability]
lemma measurable_set_Ici : measurable_set (Ici a) := is_closed_Ici.measurable_set
@[simp, measurability]
lemma measurable_set_Iic : measurable_set (Iic a) := is_closed_Iic.measurable_set
@[simp, measurability]
lemma measurable_set_Icc : measurable_set (Icc a b) := is_closed_Icc.measurable_set

instance nhds_within_Ici_is_measurably_generated :
  (ùìù[Ici b] a).is_measurably_generated :=
measurable_set_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated :
  (ùìù[Iic b] a).is_measurably_generated :=
measurable_set_Iic.nhds_within_is_measurably_generated _

instance at_top_is_measurably_generated : (filter.at_top : filter Œ±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Œª a, (measurable_set_Ici : measurable_set (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (filter.at_bot : filter Œ±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Œª a, (measurable_set_Iic : measurable_set (Iic a)).principal_is_measurably_generated

end preorder

section partial_order
variables [partial_order Œ±] [order_closed_topology Œ±] [second_countable_topology Œ±]
  {a b : Œ±}

@[measurability]
lemma measurable_set_le' : measurable_set {p : Œ± √ó Œ± | p.1 ‚â§ p.2} :=
order_closed_topology.is_closed_le'.measurable_set

@[measurability]
lemma measurable_set_le {f g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable_set {a | f a ‚â§ g a} :=
hf.prod_mk hg measurable_set_le'

end partial_order

section linear_order
variables [linear_order Œ±] [order_closed_topology Œ±] {a b : Œ±}

@[simp, measurability]
lemma measurable_set_Iio : measurable_set (Iio a) := is_open_Iio.measurable_set
@[simp, measurability]
lemma measurable_set_Ioi : measurable_set (Ioi a) := is_open_Ioi.measurable_set
@[simp, measurability]
lemma measurable_set_Ioo : measurable_set (Ioo a b) := is_open_Ioo.measurable_set

@[simp, measurability] lemma measurable_set_Ioc : measurable_set (Ioc a b) :=
measurable_set_Ioi.inter measurable_set_Iic

@[simp, measurability] lemma measurable_set_Ico : measurable_set (Ico a b) :=
measurable_set_Ici.inter measurable_set_Iio

instance nhds_within_Ioi_is_measurably_generated :
  (ùìù[Ioi b] a).is_measurably_generated :=
measurable_set_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated :
  (ùìù[Iio b] a).is_measurably_generated :=
measurable_set_Iio.nhds_within_is_measurably_generated _

@[measurability]
lemma measurable_set_lt' [second_countable_topology Œ±] : measurable_set {p : Œ± √ó Œ± | p.1 < p.2} :=
(is_open_lt continuous_fst continuous_snd).measurable_set

@[measurability]
lemma measurable_set_lt [second_countable_topology Œ±] {f g : Œ¥ ‚Üí Œ±} (hf : measurable f)
  (hg : measurable g) : measurable_set {a | f a < g a} :=
hf.prod_mk hg measurable_set_lt'

lemma set.ord_connected.measurable_set (h : ord_connected s) : measurable_set s :=
begin
  let u := ‚ãÉ (x ‚àà s) (y ‚àà s), Ioo x y,
  have huopen : is_open u := is_open_bUnion (Œª x hx, is_open_bUnion (Œª y hy, is_open_Ioo)),
  have humeas : measurable_set u := huopen.measurable_set,
  have hfinite : (s \ u).finite,
  { refine set.finite_of_forall_between_eq_endpoints (s \ u) (Œª x hx y hy z hz hxy hyz, _),
    by_contra h,
    push_neg at h,
    exact hy.2 (mem_bUnion_iff.mpr ‚ü®x, hx.1,
      mem_bUnion_iff.mpr ‚ü®z, hz.1, lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2‚ü©‚ü©) },
  have : u ‚äÜ s :=
    bUnion_subset (Œª x hx, bUnion_subset (Œª y hy, Ioo_subset_Icc_self.trans (h.out hx hy))),
  rw ‚Üê union_diff_cancel this,
  exact humeas.union hfinite.measurable_set
end

lemma is_preconnected.measurable_set
  (h : is_preconnected s) : measurable_set s :=
h.ord_connected.measurable_set

end linear_order

section linear_order

variables [linear_order Œ±] [order_closed_topology Œ±]

@[measurability]
lemma measurable_set_interval {a b : Œ±} : measurable_set (interval a b) :=
measurable_set_Icc

variables [second_countable_topology Œ±]

@[measurability]
lemma measurable.max {f g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable (Œª a, max (f a) (g a)) :=
hf.piecewise (measurable_set_le hg hf) hg

@[measurability]
lemma ae_measurable.max {f g : Œ¥ ‚Üí Œ±} {Œº : measure Œ¥}
  (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) : ae_measurable (Œª a, max (f a) (g a)) Œº :=
‚ü®Œª a, max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
  eventually_eq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

@[measurability]
lemma measurable.min {f g : Œ¥ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable (Œª a, min (f a) (g a)) :=
hf.piecewise (measurable_set_le hf hg) hg

@[measurability]
lemma ae_measurable.min {f g : Œ¥ ‚Üí Œ±} {Œº : measure Œ¥}
  (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) : ae_measurable (Œª a, min (f a) (g a)) Œº :=
‚ü®Œª a, min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
  eventually_eq.comp‚ÇÇ hf.ae_eq_mk _ hg.ae_eq_mk‚ü©

end linear_order

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
lemma continuous.measurable {f : Œ± ‚Üí Œ≥} (hf : continuous f) :
  measurable f :=
hf.borel_measurable.mono opens_measurable_space.borel_le
  (le_of_eq $ borel_space.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
lemma continuous.ae_measurable {f : Œ± ‚Üí Œ≥} (h : continuous f) (Œº : measure Œ±) : ae_measurable f Œº :=
h.measurable.ae_measurable

lemma closed_embedding.measurable {f : Œ± ‚Üí Œ≥} (hf : closed_embedding f) :
  measurable f :=
hf.continuous.measurable

@[priority 100, to_additive]
instance has_continuous_mul.has_measurable_mul [has_mul Œ≥] [has_continuous_mul Œ≥] :
  has_measurable_mul Œ≥ :=
{ measurable_const_mul := Œª c, (continuous_const.mul continuous_id).measurable,
  measurable_mul_const := Œª c, (continuous_id.mul continuous_const).measurable }

@[priority 100]
instance has_continuous_sub.has_measurable_sub [has_sub Œ≥] [has_continuous_sub Œ≥] :
  has_measurable_sub Œ≥ :=
{ measurable_const_sub := Œª c, (continuous_const.sub continuous_id).measurable,
  measurable_sub_const := Œª c, (continuous_id.sub continuous_const).measurable }

@[priority 100, to_additive]
instance topological_group.has_measurable_inv [group Œ≥] [topological_group Œ≥] :
  has_measurable_inv Œ≥ :=
‚ü®continuous_inv.measurable‚ü©

@[priority 100]
instance has_continuous_smul.has_measurable_smul {M Œ±} [topological_space M]
  [topological_space Œ±] [measurable_space M] [measurable_space Œ±]
  [opens_measurable_space M] [borel_space Œ±] [has_scalar M Œ±] [has_continuous_smul M Œ±] :
  has_measurable_smul M Œ± :=
‚ü®Œª c, (continuous_const.smul continuous_id).measurable,
  Œª y, (continuous_id.smul continuous_const).measurable‚ü©

section homeomorph

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def homeomorph.to_measurable_equiv (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : Œ≥ ‚âÉ·µê Œ≥‚ÇÇ :=
{ measurable_to_fun := h.continuous_to_fun.measurable,
  measurable_inv_fun := h.continuous_inv_fun.measurable,
  .. h }

@[simp]
lemma homeomorph.to_measurable_equiv_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) : (h.to_measurable_equiv : Œ≥ ‚Üí Œ≥‚ÇÇ) = h :=
rfl

@[simp] lemma homeomorph.to_measurable_equiv_symm_coe (h : Œ≥ ‚âÉ‚Çú Œ≥‚ÇÇ) :
  (h.to_measurable_equiv.symm : Œ≥‚ÇÇ ‚Üí Œ≥) = h.symm :=
rfl

@[measurability]
lemma homeomorph.measurable (h : Œ± ‚âÉ‚Çú Œ≥) : measurable h :=
h.continuous.measurable

end homeomorph

lemma measurable_of_continuous_on_compl_singleton [t1_space Œ±] {f : Œ± ‚Üí Œ≥} (a : Œ±)
  (hf : continuous_on f {a}·∂ú) :
  measurable f :=
measurable_of_measurable_on_compl_singleton a
  (continuous_on_iff_continuous_restrict.1 hf).measurable

lemma continuous.measurable2 [second_countable_topology Œ±] [second_countable_topology Œ≤]
  {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
  (h : continuous (Œª p : Œ± √ó Œ≤, c p.1 p.2)) (hf : measurable f) (hg : measurable g) :
  measurable (Œª a, c (f a) (g a)) :=
h.measurable.comp (hf.prod_mk hg)

lemma continuous.ae_measurable2 [second_countable_topology Œ±] [second_countable_topology Œ≤]
  {f : Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} {c : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {Œº : measure Œ¥}
  (h : continuous (Œª p : Œ± √ó Œ≤, c p.1 p.2)) (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) :
  ae_measurable (Œª a, c (f a) (g a)) Œº :=
h.measurable.comp_ae_measurable (hf.prod_mk hg)

@[priority 100]
instance has_continuous_inv'.has_measurable_inv [group_with_zero Œ≥] [t1_space Œ≥]
  [has_continuous_inv' Œ≥] :
  has_measurable_inv Œ≥ :=
‚ü®measurable_of_continuous_on_compl_singleton 0 continuous_on_inv'‚ü©

@[priority 100, to_additive]
instance has_continuous_mul.has_measurable_mul‚ÇÇ [second_countable_topology Œ≥] [has_mul Œ≥]
  [has_continuous_mul Œ≥] : has_measurable_mul‚ÇÇ Œ≥ :=
‚ü®continuous_mul.measurable‚ü©

@[priority 100]
instance has_continuous_sub.has_measurable_sub‚ÇÇ [second_countable_topology Œ≥] [has_sub Œ≥]
  [has_continuous_sub Œ≥] : has_measurable_sub‚ÇÇ Œ≥ :=
‚ü®continuous_sub.measurable‚ü©

@[priority 100]
instance has_continuous_smul.has_measurable_smul‚ÇÇ {M Œ±} [topological_space M]
  [second_countable_topology M] [measurable_space M] [opens_measurable_space M]
  [topological_space Œ±] [second_countable_topology Œ±] [measurable_space Œ±]
  [borel_space Œ±] [has_scalar M Œ±] [has_continuous_smul M Œ±] :
  has_measurable_smul‚ÇÇ M Œ± :=
‚ü®continuous_smul.measurable‚ü©

end

section borel_space
variables [topological_space Œ±] [measurable_space Œ±] [borel_space Œ±]
  [topological_space Œ≤] [measurable_space Œ≤] [borel_space Œ≤]
  [topological_space Œ≥] [measurable_space Œ≥] [borel_space Œ≥]
  [measurable_space Œ¥]

lemma pi_le_borel_pi {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [Œ† i, topological_space (œÄ i)]
  [Œ† i, measurable_space (œÄ i)] [‚àÄ i, borel_space (œÄ i)] :
  measurable_space.pi ‚â§ borel (Œ† i, œÄ i) :=
begin
  have : ‚ÄπŒ† i, measurable_space (œÄ i)‚Ä∫ = Œª i, borel (œÄ i) :=
    funext (Œª i, borel_space.measurable_eq),
  rw [this],
  exact supr_le (Œª i, comap_le_iff_le_map.2 $ (continuous_apply i).borel_measurable)
end

lemma prod_le_borel_prod : prod.measurable_space ‚â§ borel (Œ± √ó Œ≤) :=
begin
  rw [‚Äπborel_space Œ±‚Ä∫.measurable_eq, ‚Äπborel_space Œ≤‚Ä∫.measurable_eq],
  refine sup_le _ _,
  { exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable },
  { exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable }
end

instance pi.borel_space {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [fintype Œπ]
  [t' : Œ† i, topological_space (œÄ i)]
  [Œ† i, measurable_space (œÄ i)] [‚àÄ i, second_countable_topology (œÄ i)]
  [‚àÄ i, borel_space (œÄ i)] :
  borel_space (Œ† i, œÄ i) :=
‚ü®le_antisymm pi_le_borel_pi opens_measurable_space.borel_le‚ü©

instance prod.borel_space [second_countable_topology Œ±] [second_countable_topology Œ≤] :
  borel_space (Œ± √ó Œ≤) :=
‚ü®le_antisymm prod_le_borel_prod opens_measurable_space.borel_le‚ü©

lemma closed_embedding.measurable_inv_fun [n : nonempty Œ≤] {g : Œ≤ ‚Üí Œ≥} (hg : closed_embedding g) :
  measurable (function.inv_fun g) :=
begin
  refine measurable_of_is_closed (Œª s hs, _),
  by_cases h : classical.choice n ‚àà s,
  { rw preimage_inv_fun_of_mem hg.to_embedding.inj h,
    exact (hg.closed_iff_image_closed.mp hs).measurable_set.union
      hg.closed_range.measurable_set.compl },
  { rw preimage_inv_fun_of_not_mem hg.to_embedding.inj h,
    exact (hg.closed_iff_image_closed.mp hs).measurable_set }
end

lemma measurable_comp_iff_of_closed_embedding {f : Œ¥ ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ≥) (hg : closed_embedding g) :
  measurable (g ‚àò f) ‚Üî measurable f :=
begin
  refine ‚ü®Œª hf, _, Œª hf, hg.measurable.comp hf‚ü©,
  apply measurable_of_is_closed, intros s hs,
  convert hf (hg.is_closed_map s hs).measurable_set,
  rw [@preimage_comp _ _ _ f g, preimage_image_eq _ hg.to_embedding.inj]
end

lemma ae_measurable_comp_iff_of_closed_embedding {f : Œ¥ ‚Üí Œ≤} {Œº : measure Œ¥}
  (g : Œ≤ ‚Üí Œ≥) (hg : closed_embedding g) : ae_measurable (g ‚àò f) Œº ‚Üî ae_measurable f Œº :=
begin
  casesI is_empty_or_nonempty Œ≤,
  { haveI := function.is_empty f,
    simp only [(measurable_of_empty (g ‚àò f)).ae_measurable,
      (measurable_of_empty f).ae_measurable] },
  { refine ‚ü®Œª hf, _, Œª hf, hg.measurable.comp_ae_measurable hf‚ü©,
    convert hg.measurable_inv_fun.comp_ae_measurable hf,
    ext x,
    exact (function.left_inverse_inv_fun hg.to_embedding.inj (f x)).symm },
end

lemma ae_measurable_comp_right_iff_of_closed_embedding {g : Œ± ‚Üí Œ≤} {Œº : measure Œ±}
  {f : Œ≤ ‚Üí Œ¥} (hg : closed_embedding g) :
  ae_measurable (f ‚àò g) Œº ‚Üî ae_measurable f (measure.map g Œº) :=
begin
  refine ‚ü®Œª h, _, Œª h, h.comp_measurable hg.measurable‚ü©,
  casesI is_empty_or_nonempty Œ±, { simp [Œº.eq_zero_of_is_empty] },
  refine ‚ü®(h.mk _) ‚àò (function.inv_fun g), h.measurable_mk.comp hg.measurable_inv_fun, _‚ü©,
  have : Œº = measure.map (function.inv_fun g) (measure.map g Œº),
    by rw [measure.map_map hg.measurable_inv_fun hg.measurable,
           (function.left_inverse_inv_fun hg.to_embedding.inj).comp_eq_id, measure.map_id],
  rw this at h,
  filter_upwards [ae_of_ae_map hg.measurable_inv_fun h.ae_eq_mk,
    ae_map_mem_range g hg.closed_range.measurable_set Œº],
  assume x hx‚ÇÅ hx‚ÇÇ,
  convert hx‚ÇÅ,
  exact ((function.left_inverse_inv_fun hg.to_embedding.inj).right_inv_on_range hx‚ÇÇ).symm,
end

section linear_order

variables [linear_order Œ±] [order_topology Œ±] [second_countable_topology Œ±]

lemma measurable_of_Iio {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (f ‚Åª¬π' Iio x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_Iio _),
  rintro _ ‚ü®x, rfl‚ü©, exact hf x
end

lemma upper_semicontinuous.measurable [topological_space Œ¥] [opens_measurable_space Œ¥]
  {f : Œ¥ ‚Üí Œ±} (hf : upper_semicontinuous f) : measurable f :=
measurable_of_Iio (Œª y, (hf.is_open_preimage y).measurable_set)

lemma measurable_of_Ioi {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (f ‚Åª¬π' Ioi x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_Ioi _),
  rintro _ ‚ü®x, rfl‚ü©, exact hf x
end

lemma lower_semicontinuous.measurable [topological_space Œ¥] [opens_measurable_space Œ¥]
  {f : Œ¥ ‚Üí Œ±} (hf : lower_semicontinuous f) : measurable f :=
measurable_of_Ioi (Œª y, (hf.is_open_preimage y).measurable_set)

lemma measurable_of_Iic {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (f ‚Åª¬π' Iic x)) : measurable f :=
begin
  apply measurable_of_Ioi,
  simp_rw [‚Üê compl_Iic, preimage_compl, measurable_set.compl_iff],
  assumption
end

lemma measurable_of_Ici {f : Œ¥ ‚Üí Œ±} (hf : ‚àÄ x, measurable_set (f ‚Åª¬π' Ici x)) : measurable f :=
begin
  apply measurable_of_Iio,
  simp_rw [‚Üê compl_Ici, preimage_compl, measurable_set.compl_iff],
  assumption
end

lemma measurable.is_lub {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i))
  (hg : ‚àÄ b, is_lub {a | ‚àÉ i, f i b = a} (g b)) :
  measurable g :=
begin
  change ‚àÄ b, is_lub (range $ Œª i, f i b) (g b) at hg,
  rw [‚Äπborel_space Œ±‚Ä∫.measurable_eq, borel_eq_generate_Ioi Œ±],
  apply measurable_generate_from,
  rintro _ ‚ü®a, rfl‚ü©,
  simp_rw [set.preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists],
  exact measurable_set.Union (Œª i, hf i (is_open_lt' _).measurable_set)
end

private lemma ae_measurable.is_lub_of_nonempty {Œπ} (hŒπ : nonempty Œπ)
  {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, is_lub {a | ‚àÉ i, f i b = a} (g b)) :
  ae_measurable g Œº :=
begin
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := Œª x f', is_lub {a | ‚àÉ i, f' i = a} (g x),
  let g_seq := Œª x, ite (x ‚àà ae_seq_set hf p) (g x) (‚ü®g x‚ü© : nonempty Œ±).some,
  have hg_seq : ‚àÄ b, is_lub {a | ‚àÉ i, ae_seq hf p i b = a} (g_seq b),
  { intro b,
    haveI hŒ± : nonempty Œ± := nonempty.map g ‚ü®b‚ü©,
    simp only [ae_seq, g_seq],
    split_ifs,
    { have h_set_eq : {a : Œ± | ‚àÉ (i : Œπ), (hf i).mk (f i) b = a} = {a : Œ± | ‚àÉ (i : Œπ), f i b = a},
      { ext x,
        simp_rw [set.mem_set_of_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h], },
      rw h_set_eq,
      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h, },
    { have h_singleton : {a : Œ± | ‚àÉ (i : Œπ), hŒ±.some = a} = {hŒ±.some},
      { ext1 x,
        exact ‚ü®Œª hx, hx.some_spec.symm, Œª hx, ‚ü®hŒπ.some, hx.symm‚ü©‚ü©, },
      rw h_singleton,
      exact is_lub_singleton, }, },
  refine ‚ü®g_seq, measurable.is_lub (ae_seq.measurable hf p) hg_seq, _‚ü©,
  exact (ite_ae_eq_of_measure_compl_zero g (Œª x, (‚ü®g x‚ü© : nonempty Œ±).some) (ae_seq_set hf p)
    (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm,
end

lemma ae_measurable.is_lub {Œπ} {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, is_lub {a | ‚àÉ i, f i b = a} (g b)) :
  ae_measurable g Œº :=
begin
  by_cases hŒº : Œº = 0, { rw hŒº, exact ae_measurable_zero_measure },
  haveI : Œº.ae.ne_bot, { simpa [ne_bot_iff] },
  by_cases hŒπ : nonempty Œπ, { exact ae_measurable.is_lub_of_nonempty hŒπ hf hg, },
  suffices : ‚àÉ x, g =·µê[Œº] Œª y, g x,
  by { exact ‚ü®(Œª y, g this.some), measurable_const, this.some_spec‚ü©, },
  have h_empty : ‚àÄ x, {a : Œ± | ‚àÉ (i : Œπ), f i x = a} = ‚àÖ,
  { intro x,
    ext1 y,
    rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false],
    exact Œª hi, hŒπ (nonempty_of_exists hi), },
  simp_rw h_empty at hg,
  exact ‚ü®hg.exists.some, hg.mono (Œª y hy, is_lub.unique hy hg.exists.some_spec)‚ü©,
end

lemma measurable.is_glb {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i))
  (hg : ‚àÄ b, is_glb {a | ‚àÉ i, f i b = a} (g b)) :
  measurable g :=
begin
  change ‚àÄ b, is_glb (range $ Œª i, f i b) (g b) at hg,
  rw [‚Äπborel_space Œ±‚Ä∫.measurable_eq, borel_eq_generate_Iio Œ±],
  apply measurable_generate_from,
  rintro _ ‚ü®a, rfl‚ü©,
  simp_rw [set.preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists],
  exact measurable_set.Union (Œª i, hf i (is_open_gt' _).measurable_set)
end

private lemma ae_measurable.is_glb_of_nonempty {Œπ} (hŒπ : nonempty Œπ)
  {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, is_glb {a | ‚àÉ i, f i b = a} (g b)) :
  ae_measurable g Œº :=
begin
  let p : Œ¥ ‚Üí (Œπ ‚Üí Œ±) ‚Üí Prop := Œª x f', is_glb {a | ‚àÉ i, f' i = a} (g x),
  let g_seq := Œª x, ite (x ‚àà ae_seq_set hf p) (g x) (‚ü®g x‚ü© : nonempty Œ±).some,
  have hg_seq : ‚àÄ b, is_glb {a | ‚àÉ i, ae_seq hf p i b = a} (g_seq b),
  { intro b,
    haveI hŒ± : nonempty Œ± := nonempty.map g ‚ü®b‚ü©,
    simp only [ae_seq, g_seq],
    split_ifs,
    { have h_set_eq : {a : Œ± | ‚àÉ (i : Œπ), (hf i).mk (f i) b = a} = {a : Œ± | ‚àÉ (i : Œπ), f i b = a},
      { ext x,
        simp_rw [set.mem_set_of_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h], },
      rw h_set_eq,
      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h, },
    { have h_singleton : {a : Œ± | ‚àÉ (i : Œπ), hŒ±.some = a} = {hŒ±.some},
      { ext1 x,
        exact ‚ü®Œª hx, hx.some_spec.symm, Œª hx, ‚ü®hŒπ.some, hx.symm‚ü©‚ü©, },
      rw h_singleton,
      exact is_glb_singleton, }, },
  refine ‚ü®g_seq, measurable.is_glb (ae_seq.measurable hf p) hg_seq, _‚ü©,
  exact (ite_ae_eq_of_measure_compl_zero g (Œª x, (‚ü®g x‚ü© : nonempty Œ±).some) (ae_seq_set hf p)
    (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm,
end

lemma ae_measurable.is_glb {Œπ} {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) (hg : ‚àÄ·µê b ‚àÇŒº, is_glb {a | ‚àÉ i, f i b = a} (g b)) :
  ae_measurable g Œº :=
begin
  by_cases hŒº : Œº = 0, { rw hŒº, exact ae_measurable_zero_measure },
  haveI : Œº.ae.ne_bot, { simpa [ne_bot_iff] },
  by_cases hŒπ : nonempty Œπ, { exact ae_measurable.is_glb_of_nonempty hŒπ hf hg, },
  suffices : ‚àÉ x, g =·µê[Œº] Œª y, g x,
  by { exact ‚ü®(Œª y, g this.some), measurable_const, this.some_spec‚ü©, },
  have h_empty : ‚àÄ x, {a : Œ± | ‚àÉ (i : Œπ), f i x = a} = ‚àÖ,
  { intro x,
    ext1 y,
    rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false],
    exact Œª hi, hŒπ (nonempty_of_exists hi), },
  simp_rw h_empty at hg,
  exact ‚ü®hg.exists.some, hg.mono (Œª y hy, is_glb.unique hy hg.exists.some_spec)‚ü©,
end

lemma measurable_of_monotone [linear_order Œ≤] [order_closed_topology Œ≤] {f : Œ≤ ‚Üí Œ±}
  (hf : monotone f) : measurable f :=
suffices h : ‚àÄ x, ord_connected (f ‚Åª¬π' Ioi x),
  from measurable_of_Ioi (Œª x, (h x).measurable_set),
Œª x, ord_connected_def.mpr (Œª a ha b hb c hc, lt_of_lt_of_le ha (hf hc.1))

alias measurable_of_monotone ‚Üê monotone.measurable

lemma ae_measurable_restrict_of_monotone_on [linear_order Œ≤] [order_closed_topology Œ≤]
  {Œº : measure Œ≤} {s : set Œ≤} (hs : measurable_set s) {f : Œ≤ ‚Üí Œ±}
  (hf : ‚àÄ ‚¶Éx y‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x ‚â§ y ‚Üí f x ‚â§ f y) : ae_measurable f (Œº.restrict s) :=
have this : monotone (f ‚àò coe : s ‚Üí Œ±), from Œª ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© (hxy : x ‚â§ y), hf hx hy hxy,
ae_measurable_restrict_of_measurable_subtype hs this.measurable

lemma measurable_of_antimono [linear_order Œ≤] [order_closed_topology Œ≤] {f : Œ≤ ‚Üí Œ±}
  (hf : ‚àÄ ‚¶Éx y : Œ≤‚¶Ñ, x ‚â§ y ‚Üí f y ‚â§ f x) :
  measurable f :=
@measurable_of_monotone (order_dual Œ±) Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ hf

lemma ae_measurable_restrict_of_antimono_on [linear_order Œ≤] [order_closed_topology Œ≤]
  {Œº : measure Œ≤} {s : set Œ≤} (hs : measurable_set s) {f : Œ≤ ‚Üí Œ±}
  (hf : ‚àÄ ‚¶Éx y‚¶Ñ, x ‚àà s ‚Üí y ‚àà s ‚Üí x ‚â§ y ‚Üí f y ‚â§ f x) : ae_measurable f (Œº.restrict s) :=
@ae_measurable_restrict_of_monotone_on (order_dual Œ±) Œ≤ _ _ ‚Äπ_‚Ä∫ _ _ _ _ _ ‚Äπ_‚Ä∫ _ _ _ _ hs _ hf

end linear_order

@[measurability]
lemma measurable.supr_Prop {Œ±} [measurable_space Œ±] [complete_lattice Œ±]
  (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) :
  measurable (Œª b, ‚®Ü h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact supr_pos h end)
  (assume h : ¬¨p, begin convert measurable_const, funext, exact supr_neg h end)

@[measurability]
lemma measurable.infi_Prop {Œ±} [measurable_space Œ±] [complete_lattice Œ±]
  (p : Prop) {f : Œ¥ ‚Üí Œ±} (hf : measurable f) :
  measurable (Œª b, ‚®Ö h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact infi_pos h end )
  (assume h : ¬¨p, begin convert measurable_const, funext, exact infi_neg h end)

section complete_linear_order

variables [complete_linear_order Œ±] [order_topology Œ±] [second_countable_topology Œ±]

@[measurability]
lemma measurable_supr {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :
  measurable (Œª b, ‚®Ü i, f i b) :=
measurable.is_lub hf $ Œª b, is_lub_supr

@[measurability]
lemma ae_measurable_supr {Œπ} {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) :
  ae_measurable (Œª b, ‚®Ü i, f i b) Œº :=
ae_measurable.is_lub hf $ (ae_of_all Œº (Œª b, is_lub_supr))

@[measurability]
lemma measurable_infi {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :
  measurable (Œª b, ‚®Ö i, f i b) :=
measurable.is_glb hf $ Œª b, is_glb_infi

@[measurability]
lemma ae_measurable_infi {Œπ} {Œº : measure Œ¥} [encodable Œπ] {f : Œπ ‚Üí Œ¥ ‚Üí Œ±}
  (hf : ‚àÄ i, ae_measurable (f i) Œº) :
  ae_measurable (Œª b, ‚®Ö i, f i b) Œº :=
ae_measurable.is_glb hf $ (ae_of_all Œº (Œª b, is_glb_infi))

lemma measurable_bsupr {Œπ} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : countable s)
  (hf : ‚àÄ i, measurable (f i)) : measurable (Œª b, ‚®Ü i ‚àà s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [supr_subtype'],
     exact measurable_supr (Œª i, hf i) }

lemma ae_measurable_bsupr {Œπ} {Œº : measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : countable s)
  (hf : ‚àÄ i, ae_measurable (f i) Œº) : ae_measurable (Œª b, ‚®Ü i ‚àà s, f i b) Œº :=
begin
  haveI : encodable s := hs.to_encodable,
  simp only [supr_subtype'],
  exact ae_measurable_supr (Œª i, hf i),
end

lemma measurable_binfi {Œπ} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : countable s)
  (hf : ‚àÄ i, measurable (f i)) : measurable (Œª b, ‚®Ö i ‚àà s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [infi_subtype'],
     exact measurable_infi (Œª i, hf i) }

lemma ae_measurable_binfi {Œπ} {Œº : measure Œ¥} (s : set Œπ) {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} (hs : countable s)
  (hf : ‚àÄ i, ae_measurable (f i) Œº) : ae_measurable (Œª b, ‚®Ö i ‚àà s, f i b) Œº :=
begin
  haveI : encodable s := hs.to_encodable,
  simp only [infi_subtype'],
  exact ae_measurable_infi (Œª i, hf i),
end

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `‚Ñï`.
-/
lemma measurable_liminf' {Œπ Œπ'} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ i, measurable (f i))
  {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) :
  measurable (Œª x, liminf u (Œª i, f i x)) :=
begin
  simp_rw [hu.to_has_basis.liminf_eq_supr_infi],
  refine measurable_bsupr _ hu.countable _,
  exact Œª i, measurable_binfi _ (hs i) hf
end

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `‚Ñï`.
-/
lemma measurable_limsup' {Œπ Œπ'}  {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {u : filter Œπ} (hf : ‚àÄ i, measurable (f i))
  {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) :
  measurable (Œª x, limsup u (Œª i, f i x)) :=
begin
  simp_rw [hu.to_has_basis.limsup_eq_infi_supr],
  refine measurable_binfi _ hu.countable _,
  exact Œª i, measurable_bsupr _ (hs i) hf
end

/-- `liminf` over `‚Ñï` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
lemma measurable_liminf {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :
  measurable (Œª x, liminf at_top (Œª i, f i x)) :=
measurable_liminf' hf at_top_countable_basis (Œª i, countable_encodable _)

/-- `limsup` over `‚Ñï` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
lemma measurable_limsup {f : ‚Ñï ‚Üí Œ¥ ‚Üí Œ±} (hf : ‚àÄ i, measurable (f i)) :
  measurable (Œª x, limsup at_top (Œª i, f i x)) :=
measurable_limsup' hf at_top_countable_basis (Œª i, countable_encodable _)


end complete_linear_order

section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Œ±] [order_topology Œ±] [second_countable_topology Œ±]

lemma measurable_cSup {Œπ} {f : Œπ ‚Üí Œ¥ ‚Üí Œ±} {s : set Œπ} (hs : s.countable)
  (hf : ‚àÄ i, measurable (f i)) (bdd : ‚àÄ x, bdd_above ((Œª i, f i x) '' s)) :
  measurable (Œª x, Sup ((Œª i, f i x) '' s)) :=
begin
  cases eq_empty_or_nonempty s with h2s h2s,
  { simp [h2s, measurable_const] },
  { apply measurable_of_Iic, intro y,
    simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall],
    exact measurable_set.bInter hs (Œª i hi, measurable_set_le (hf i) measurable_const) }
end

end conditionally_complete_linear_order

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def homemorph.to_measurable_equiv (h : Œ± ‚âÉ‚Çú Œ≤) : Œ± ‚âÉ·µê Œ≤ :=
{ to_equiv := h.to_equiv,
  measurable_to_fun := h.continuous_to_fun.measurable,
  measurable_inv_fun := h.continuous_inv_fun.measurable }

end borel_space

instance empty.borel_space : borel_space empty := ‚ü®borel_eq_top_of_discrete.symm‚ü©
instance unit.borel_space : borel_space unit := ‚ü®borel_eq_top_of_discrete.symm‚ü©
instance bool.borel_space : borel_space bool := ‚ü®borel_eq_top_of_discrete.symm‚ü©
instance nat.borel_space : borel_space ‚Ñï := ‚ü®borel_eq_top_of_discrete.symm‚ü©
instance int.borel_space : borel_space ‚Ñ§ := ‚ü®borel_eq_top_of_discrete.symm‚ü©
instance rat.borel_space : borel_space ‚Ñö := ‚ü®borel_eq_top_of_encodable.symm‚ü©

instance real.measurable_space : measurable_space ‚Ñù := borel ‚Ñù
instance real.borel_space : borel_space ‚Ñù := ‚ü®rfl‚ü©

instance nnreal.measurable_space : measurable_space ‚Ñù‚â•0 := subtype.measurable_space
instance nnreal.borel_space : borel_space ‚Ñù‚â•0 := subtype.borel_space _

instance ennreal.measurable_space : measurable_space ‚Ñù‚â•0‚àû := borel ‚Ñù‚â•0‚àû
instance ennreal.borel_space : borel_space ‚Ñù‚â•0‚àû := ‚ü®rfl‚ü©

instance ereal.measurable_space : measurable_space ereal := borel ereal
instance ereal.borel_space : borel_space ereal := ‚ü®rfl‚ü©

instance complex.measurable_space : measurable_space ‚ÑÇ := borel ‚ÑÇ
instance complex.borel_space : borel_space ‚ÑÇ := ‚ü®rfl‚ü©

section metric_space

variables [metric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±]
variables [measurable_space Œ≤] {x : Œ±} {Œµ : ‚Ñù}

open metric

@[measurability]
lemma measurable_set_ball : measurable_set (metric.ball x Œµ) :=
metric.is_open_ball.measurable_set

@[measurability]
lemma measurable_set_closed_ball : measurable_set (metric.closed_ball x Œµ) :=
metric.is_closed_ball.measurable_set

@[measurability]
lemma measurable_inf_dist {s : set Œ±} : measurable (Œª x, inf_dist x s) :=
(continuous_inf_dist_pt s).measurable

@[measurability]
lemma measurable.inf_dist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} :
  measurable (Œª x, inf_dist (f x) s) :=
measurable_inf_dist.comp hf

@[measurability]
lemma measurable_inf_nndist {s : set Œ±} : measurable (Œª x, inf_nndist x s) :=
(continuous_inf_nndist_pt s).measurable

@[measurability]
lemma measurable.inf_nndist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} :
  measurable (Œª x, inf_nndist (f x) s) :=
measurable_inf_nndist.comp hf

variables [second_countable_topology Œ±]

@[measurability]
lemma measurable_dist : measurable (Œª p : Œ± √ó Œ±, dist p.1 p.2) :=
continuous_dist.measurable

@[measurability]
lemma measurable.dist {f g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable (Œª b, dist (f b) (g b)) :=
(@continuous_dist Œ± _).measurable2 hf hg

@[measurability]
lemma measurable_nndist : measurable (Œª p : Œ± √ó Œ±, nndist p.1 p.2) :=
continuous_nndist.measurable

@[measurability]
lemma measurable.nndist {f g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable (Œª b, nndist (f b) (g b)) :=
(@continuous_nndist Œ± _).measurable2 hf hg

end metric_space

section emetric_space

variables [emetric_space Œ±] [measurable_space Œ±] [opens_measurable_space Œ±]
variables [measurable_space Œ≤] {x : Œ±} {Œµ : ‚Ñù‚â•0‚àû}

open emetric

@[measurability]
lemma measurable_set_eball : measurable_set (emetric.ball x Œµ) :=
emetric.is_open_ball.measurable_set

@[measurability]
lemma measurable_edist_right : measurable (edist x) :=
(continuous_const.edist continuous_id).measurable

@[measurability]
lemma measurable_edist_left : measurable (Œª y, edist y x) :=
(continuous_id.edist continuous_const).measurable

@[measurability]
lemma measurable_inf_edist {s : set Œ±} : measurable (Œª x, inf_edist x s) :=
continuous_inf_edist.measurable

@[measurability]
lemma measurable.inf_edist {f : Œ≤ ‚Üí Œ±} (hf : measurable f) {s : set Œ±} :
  measurable (Œª x, inf_edist (f x) s) :=
measurable_inf_edist.comp hf

variables [second_countable_topology Œ±]

@[measurability]
lemma measurable_edist : measurable (Œª p : Œ± √ó Œ±, edist p.1 p.2) :=
continuous_edist.measurable

@[measurability]
lemma measurable.edist {f g : Œ≤ ‚Üí Œ±} (hf : measurable f) (hg : measurable g) :
  measurable (Œª b, edist (f b) (g b)) :=
(@continuous_edist Œ± _).measurable2 hf hg

@[measurability]
lemma ae_measurable.edist {f g : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤}
  (hf : ae_measurable f Œº) (hg : ae_measurable g Œº) : ae_measurable (Œª a, edist (f a) (g a)) Œº :=
(@continuous_edist Œ± _).ae_measurable2 hf hg

end emetric_space

namespace real
open measurable_space measure_theory

lemma borel_eq_generate_from_Ioo_rat :
  borel ‚Ñù = generate_from (‚ãÉ(a b : ‚Ñö) (h : a < b), {Ioo a b}) :=
is_topological_basis_Ioo_rat.borel_eq_generate_from

lemma is_pi_system_Ioo_rat : @is_pi_system ‚Ñù (‚ãÉ (a b : ‚Ñö) (h : a < b), {Ioo a b})  :=
by simpa using is_pi_system_Ioo (coe : ‚Ñö ‚Üí ‚Ñù)

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Œº` on `‚Ñù`. -/
def finite_spanning_sets_in_Ioo_rat (Œº : measure ‚Ñù) [locally_finite_measure Œº] :
  Œº.finite_spanning_sets_in (‚ãÉ (a b : ‚Ñö) (h : a < b), {Ioo a b}) :=
{ set := Œª n, Ioo (-(n + 1)) (n + 1),
  set_mem := Œª n,
    begin
      simp only [mem_Union, mem_singleton_iff],
      refine ‚ü®-(n + 1), n + 1, _, by norm_cast‚ü©,
      exact (neg_nonpos.2 (@nat.cast_nonneg ‚Ñö _ (n + 1))).trans_lt n.cast_add_one_pos
    end,
  finite := Œª n,
    calc Œº (Ioo _ _) ‚â§ Œº (Icc _ _) : Œº.mono Ioo_subset_Icc_self
                 ... < ‚àû           : is_compact_Icc.finite_measure,
  spanning := Union_eq_univ_iff.2 $ Œª x,
    ‚ü®‚åäabs x‚åã‚Çä, neg_lt.1 ((neg_le_abs_self x).trans_lt (lt_nat_floor_add_one _)),
      (le_abs_self x).trans_lt (lt_nat_floor_add_one _)‚ü© }

lemma measure_ext_Ioo_rat {Œº ŒΩ : measure ‚Ñù} [locally_finite_measure Œº]
  (h : ‚àÄ a b : ‚Ñö, Œº (Ioo a b) = ŒΩ (Ioo a b)) : Œº = ŒΩ :=
(finite_spanning_sets_in_Ioo_rat Œº).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat $
  by { simp only [mem_Union, mem_singleton_iff], rintro _ ‚ü®a, b, -, rfl‚ü©, apply h }

lemma borel_eq_generate_from_Iio_rat :
  borel ‚Ñù = generate_from (‚ãÉ a : ‚Ñö, {Iio a}) :=
begin
  let g : measurable_space ‚Ñù := generate_from (‚ãÉ a : ‚Ñö, {Iio a}),
  apply le_antisymm _ (measurable_space.generate_from_le (Œª t, _)),
  { rw borel_eq_generate_from_Ioo_rat,
    refine generate_from_le (Œª t, _),
    simp only [mem_Union, mem_singleton_iff], rintro ‚ü®a, b, h, rfl‚ü©,
    rw (set.ext (Œª x, _) : Ioo (a : ‚Ñù) b = (‚ãÉc>a, (Iio c)·∂ú) ‚à© Iio b),
    { have hg : ‚àÄ q : ‚Ñö, g.measurable_set' (Iio q) :=
        Œª q, generate_measurable.basic (Iio q) (by { simp, exact ‚ü®_, rfl‚ü© }),
      refine @measurable_set.inter _ g _ _ _ (hg _),
      refine @measurable_set.bUnion _ _ g _ _ (countable_encodable _) (Œª c h, _),
      exact @measurable_set.compl _ _ g (hg _) },
    { suffices : x < ‚Üëb ‚Üí (‚Üëa < x ‚Üî ‚àÉ (i : ‚Ñö), a < i ‚àß ‚Üëi ‚â§ x), by simpa,
      refine Œª _, ‚ü®Œª h, _, Œª ‚ü®i, hai, hix‚ü©, (rat.cast_lt.2 hai).trans_le hix‚ü©,
      rcases exists_rat_btwn h with ‚ü®c, ac, cx‚ü©,
      exact ‚ü®c, rat.cast_lt.1 ac, cx.le‚ü© } },
  { simp only [mem_Union, mem_singleton_iff], rintro ‚ü®r, rfl‚ü©, exact measurable_set_Iio }
end

end real

variable [measurable_space Œ±]

@[measurability]
lemma measurable_real_to_nnreal : measurable (real.to_nnreal) :=
nnreal.continuous_of_real.measurable

@[measurability]
lemma measurable.real_to_nnreal {f : Œ± ‚Üí ‚Ñù} (hf : measurable f) :
  measurable (Œª x, real.to_nnreal (f x)) :=
measurable_real_to_nnreal.comp hf

@[measurability]
lemma ae_measurable.real_to_nnreal {f : Œ± ‚Üí ‚Ñù} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, real.to_nnreal (f x)) Œº :=
measurable_real_to_nnreal.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_nnreal_real : measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù) :=
nnreal.continuous_coe.measurable

@[measurability]
lemma measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : measurable f) :
  measurable (Œª x, (f x : ‚Ñù)) :=
measurable_coe_nnreal_real.comp hf

@[measurability]
lemma ae_measurable.coe_nnreal_real {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x : ‚Ñù)) Œº :=
measurable_coe_nnreal_real.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_nnreal_ennreal : measurable (coe : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
ennreal.continuous_coe.measurable

@[measurability]
lemma measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : measurable f) :
  measurable (Œª x, (f x : ‚Ñù‚â•0‚àû)) :=
ennreal.continuous_coe.measurable.comp hf

@[measurability]
lemma ae_measurable.coe_nnreal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x : ‚Ñù‚â•0‚àû)) Œº :=
ennreal.continuous_coe.measurable.comp_ae_measurable hf

@[measurability]
lemma measurable.ennreal_of_real {f : Œ± ‚Üí ‚Ñù} (hf : measurable f) :
  measurable (Œª x, ennreal.of_real (f x)) :=
ennreal.continuous_of_real.measurable.comp hf

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is `measurable_equiv` to `‚Ñù‚â•0`. -/
def measurable_equiv.ennreal_equiv_nnreal : {r : ‚Ñù‚â•0‚àû | r ‚â† ‚àû} ‚âÉ·µê ‚Ñù‚â•0 :=
ennreal.ne_top_homeomorph_nnreal.to_measurable_equiv

namespace ennreal

lemma measurable_of_measurable_nnreal {f : ‚Ñù‚â•0‚àû ‚Üí Œ±}
  (h : measurable (Œª p : ‚Ñù‚â•0, f p)) : measurable f :=
measurable_of_measurable_on_compl_singleton ‚àû
  (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_coe_iff.1 h)

/-- `‚Ñù‚â•0‚àû` is `measurable_equiv` to `‚Ñù‚â•0 ‚äï unit`. -/
def ennreal_equiv_sum : ‚Ñù‚â•0‚àû ‚âÉ·µê ‚Ñù‚â•0 ‚äï unit :=
{ measurable_to_fun  := measurable_of_measurable_nnreal measurable_inl,
  measurable_inv_fun := measurable_sum measurable_coe_nnreal_ennreal
    (@measurable_const ‚Ñù‚â•0‚àû unit _ _ ‚àû),
  .. equiv.option_equiv_sum_punit ‚Ñù‚â•0 }

open function (uncurry)

lemma measurable_of_measurable_nnreal_prod [measurable_space Œ≤] [measurable_space Œ≥]
  {f : ‚Ñù‚â•0‚àû √ó Œ≤ ‚Üí Œ≥} (H‚ÇÅ : measurable (Œª p : ‚Ñù‚â•0 √ó Œ≤, f (p.1, p.2)))
  (H‚ÇÇ : measurable (Œª x, f (‚àû, x))) :
  measurable f :=
let e : ‚Ñù‚â•0‚àû √ó Œ≤ ‚âÉ·µê ‚Ñù‚â•0 √ó Œ≤ ‚äï unit √ó Œ≤ :=
  (ennreal_equiv_sum.prod_congr (measurable_equiv.refl Œ≤)).trans
    (measurable_equiv.sum_prod_distrib _ _ _) in
e.symm.measurable_coe_iff.1 $ measurable_sum H‚ÇÅ (H‚ÇÇ.comp measurable_id.snd)

lemma measurable_of_measurable_nnreal_nnreal [measurable_space Œ≤]
  {f : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû ‚Üí Œ≤} (h‚ÇÅ : measurable (Œª p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0, f (p.1, p.2)))
  (h‚ÇÇ : measurable (Œª r : ‚Ñù‚â•0, f (‚àû, r))) (h‚ÇÉ : measurable (Œª r : ‚Ñù‚â•0, f (r, ‚àû))) :
  measurable f :=
measurable_of_measurable_nnreal_prod
  (measurable_swap_iff.1 $ measurable_of_measurable_nnreal_prod (h‚ÇÅ.comp measurable_swap) h‚ÇÉ)
  (measurable_of_measurable_nnreal h‚ÇÇ)

@[measurability]
lemma measurable_of_real : measurable ennreal.of_real :=
ennreal.continuous_of_real.measurable

@[measurability]
lemma measurable_to_real : measurable ennreal.to_real :=
ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
lemma measurable_to_nnreal : measurable ennreal.to_nnreal :=
ennreal.measurable_of_measurable_nnreal measurable_id

instance : has_measurable_mul‚ÇÇ ‚Ñù‚â•0‚àû :=
begin
  refine ‚ü®measurable_of_measurable_nnreal_nnreal _ _ _‚ü©,
  { simp only [‚Üê ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal] },
  { simp only [ennreal.top_mul, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const },
  { simp only [ennreal.mul_top, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const }
end

instance : has_measurable_sub‚ÇÇ ‚Ñù‚â•0‚àû :=
‚ü®by apply measurable_of_measurable_nnreal_nnreal;
  simp [‚Üê ennreal.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]‚ü©

instance : has_measurable_inv ‚Ñù‚â•0‚àû := ‚ü®ennreal.continuous_inv.measurable‚ü©

end ennreal

@[measurability]
lemma measurable.ennreal_to_nnreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : measurable f) :
  measurable (Œª x, (f x).to_nnreal) :=
ennreal.measurable_to_nnreal.comp hf

@[measurability]
lemma ae_measurable.ennreal_to_nnreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x).to_nnreal) Œº :=
ennreal.measurable_to_nnreal.comp_ae_measurable hf

lemma measurable_coe_nnreal_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0} :
  measurable (Œª x, (f x : ‚Ñù‚â•0‚àû)) ‚Üî measurable f :=
‚ü®Œª h, h.ennreal_to_nnreal, Œª h, h.coe_nnreal_ennreal‚ü©

@[measurability]
lemma measurable.ennreal_to_real {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : measurable f) :
  measurable (Œª x, ennreal.to_real (f x)) :=
ennreal.measurable_to_real.comp hf

@[measurability]
lemma ae_measurable.ennreal_to_real {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, ennreal.to_real (f x)) Œº :=
ennreal.measurable_to_real.comp_ae_measurable hf

/-- note: `‚Ñù‚â•0‚àû` can probably be generalized in a future version of this lemma. -/
@[measurability]
lemma measurable.ennreal_tsum {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, measurable (f i)) :
  measurable (Œª x, ‚àë' i, f i x) :=
by { simp_rw [ennreal.tsum_eq_supr_sum], apply measurable_supr,
  exact Œª s, s.measurable_sum (Œª i _, h i) }

@[measurability]
lemma measurable.ennreal_tsum' {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i, measurable (f i)) :
  measurable (‚àë' i, f i) :=
begin
  convert measurable.ennreal_tsum h,
  ext1 x,
  exact tsum_apply (pi.summable.2 (Œª _, ennreal.summable)),
end

@[measurability]
lemma measurable.nnreal_tsum {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} (h : ‚àÄ i, measurable (f i)) :
  measurable (Œª x, ‚àë' i, f i x) :=
begin
  simp_rw [nnreal.tsum_eq_to_nnreal_tsum],
  exact (measurable.ennreal_tsum (Œª i, (h i).coe_nnreal_ennreal)).ennreal_to_nnreal,
end

@[measurability]
lemma ae_measurable.ennreal_tsum {Œπ} [encodable Œπ] {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : measure Œ±}
  (h : ‚àÄ i, ae_measurable (f i) Œº) :
  ae_measurable (Œª x, ‚àë' i, f i x) Œº :=
by { simp_rw [ennreal.tsum_eq_supr_sum], apply ae_measurable_supr,
  exact Œª s, finset.ae_measurable_sum s (Œª i _, h i) }

@[measurability]
lemma measurable_coe_real_ereal : measurable (coe : ‚Ñù ‚Üí ereal) :=
continuous_coe_real_ereal.measurable

@[measurability]
lemma measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} (hf : measurable f) :
  measurable (Œª x, (f x : ereal)) :=
measurable_coe_real_ereal.comp hf

@[measurability]
lemma ae_measurable.coe_real_ereal {f : Œ± ‚Üí ‚Ñù} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x : ereal)) Œº :=
measurable_coe_real_ereal.comp_ae_measurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `‚Ñù`. -/
def measurable_equiv.ereal_equiv_real : ({‚ä•, ‚ä§} : set ereal).compl ‚âÉ·µê ‚Ñù :=
ereal.ne_bot_top_homeomorph_real.to_measurable_equiv

lemma ereal.measurable_of_measurable_real {f : ereal ‚Üí Œ±}
  (h : measurable (Œª p : ‚Ñù, f p)) : measurable f :=
measurable_of_measurable_on_compl_finite {‚ä•, ‚ä§} (by simp)
  (measurable_equiv.ereal_equiv_real.symm.measurable_coe_iff.1 h)

@[measurability]
lemma measurable_ereal_to_real : measurable ereal.to_real :=
ereal.measurable_of_measurable_real (by simpa using measurable_id)

@[measurability]
lemma measurable.ereal_to_real {f : Œ± ‚Üí ereal} (hf : measurable f) :
  measurable (Œª x, (f x).to_real) :=
measurable_ereal_to_real.comp hf

@[measurability]
lemma ae_measurable.ereal_to_real {f : Œ± ‚Üí ereal} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x).to_real) Œº :=
measurable_ereal_to_real.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_ennreal_ereal : measurable (coe : ‚Ñù‚â•0‚àû ‚Üí ereal) :=
continuous_coe_ennreal_ereal.measurable

@[measurability]
lemma measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : measurable f) :
  measurable (Œª x, (f x : ereal)) :=
measurable_coe_ennreal_ereal.comp hf

@[measurability]
lemma ae_measurable.coe_ereal_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} {Œº : measure Œ±} (hf : ae_measurable f Œº) :
  ae_measurable (Œª x, (f x : ereal)) Œº :=
measurable_coe_ennreal_ereal.comp_ae_measurable hf

section normed_group

variables [normed_group Œ±] [opens_measurable_space Œ±] [measurable_space Œ≤]

@[measurability]
lemma measurable_norm : measurable (norm : Œ± ‚Üí ‚Ñù) :=
continuous_norm.measurable

@[measurability]
lemma measurable.norm {f : Œ≤ ‚Üí Œ±} (hf : measurable f) : measurable (Œª a, norm (f a)) :=
measurable_norm.comp hf

@[measurability]
lemma ae_measurable.norm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :
  ae_measurable (Œª a, norm (f a)) Œº :=
measurable_norm.comp_ae_measurable hf

@[measurability]
lemma measurable_nnnorm : measurable (nnnorm : Œ± ‚Üí ‚Ñù‚â•0) :=
continuous_nnnorm.measurable

@[measurability]
lemma measurable.nnnorm {f : Œ≤ ‚Üí Œ±} (hf : measurable f) : measurable (Œª a, nnnorm (f a)) :=
measurable_nnnorm.comp hf

@[measurability]
lemma ae_measurable.nnnorm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :
  ae_measurable (Œª a, nnnorm (f a)) Œº :=
measurable_nnnorm.comp_ae_measurable hf

@[measurability]
lemma measurable_ennnorm : measurable (Œª x : Œ±, (nnnorm x : ‚Ñù‚â•0‚àû)) :=
measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
lemma measurable.ennnorm {f : Œ≤ ‚Üí Œ±} (hf : measurable f) :
  measurable (Œª a, (nnnorm (f a) : ‚Ñù‚â•0‚àû)) :=
hf.nnnorm.coe_nnreal_ennreal

@[measurability]
lemma ae_measurable.ennnorm {f : Œ≤ ‚Üí Œ±} {Œº : measure Œ≤} (hf : ae_measurable f Œº) :
  ae_measurable (Œª a, (nnnorm (f a) : ‚Ñù‚â•0‚àû)) Œº :=
measurable_ennnorm.comp_ae_measurable hf

end normed_group

section limits

variables [measurable_space Œ≤] [metric_space Œ≤] [borel_space Œ≤]

open metric

/-- A limit (over a general filter) of measurable `‚Ñù‚â•0` valued functions is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
lemma measurable_of_tendsto_nnreal' {Œπ Œπ'} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0} (u : filter Œπ)
  [ne_bot u] (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f u (ùìù g)) {p : Œπ' ‚Üí Prop}
  {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) : measurable g :=
begin
  rw [tendsto_pi] at lim, rw [‚Üê measurable_coe_nnreal_ennreal_iff],
  have : ‚àÄ x, liminf u (Œª n, (f n x : ‚Ñù‚â•0‚àû)) = (g x : ‚Ñù‚â•0‚àû) :=
  Œª x, ((ennreal.continuous_coe.tendsto (g x)).comp (lim x)).liminf_eq,
  simp_rw [‚Üê this],
  show measurable (Œª x, liminf u (Œª n, (f n x : ‚Ñù‚â•0‚àû))),
  exact measurable_liminf' (Œª i, (hf i).coe_nnreal_ennreal) hu hs,
end

/-- A sequential limit of measurable `‚Ñù‚â•0` valued functions is measurable. -/
lemma measurable_of_tendsto_nnreal {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0} {g : Œ± ‚Üí ‚Ñù‚â•0}
  (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f at_top (ùìù g)) : measurable g :=
measurable_of_tendsto_nnreal' at_top hf lim at_top_countable_basis (Œª i, countable_encodable _)

/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
The assumption `hs` can be dropped using `filter.is_countably_generated.has_antimono_basis`, but we
don't need that case yet. -/
lemma measurable_of_tendsto_metric' {Œπ Œπ'} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
  (u : filter Œπ) [ne_bot u] (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f u (ùìù g)) {p : Œπ' ‚Üí Prop}
  {s : Œπ' ‚Üí set Œπ} (hu : u.has_countable_basis p s) (hs : ‚àÄ i, (s i).countable) :
  measurable g :=
begin
  apply measurable_of_is_closed', intros s h1s h2s h3s,
  have : measurable (Œª x, inf_nndist (g x) s),
  { refine measurable_of_tendsto_nnreal' u (Œª i, (hf i).inf_nndist) _ hu hs, swap,
    rw [tendsto_pi], rw [tendsto_pi] at lim, intro x,
    exact ((continuous_inf_nndist_pt s).tendsto (g x)).comp (lim x) },
  have h4s : g ‚Åª¬π' s = (Œª x, inf_nndist (g x) s) ‚Åª¬π' {0},
  { ext x, simp [h1s, ‚Üê mem_iff_inf_dist_zero_of_closed h1s h2s, ‚Üê nnreal.coe_eq_zero] },
  rw [h4s], exact this (measurable_set_singleton 0),
end

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
lemma measurable_of_tendsto_metric {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
  (hf : ‚àÄ i, measurable (f i)) (lim : tendsto f at_top (ùìù g)) :
  measurable g :=
measurable_of_tendsto_metric' at_top hf lim at_top_countable_basis (Œª i, countable_encodable _)

lemma ae_measurable_of_tendsto_metric_ae {Œº : measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
  (hf : ‚àÄ n, ae_measurable (f n) Œº)
  (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, filter.at_top.tendsto (Œª n, f n x) (ùìù (g x))) :
  ae_measurable g Œº :=
begin
  let p : Œ± ‚Üí (‚Ñï ‚Üí Œ≤) ‚Üí Prop := Œª x f', filter.at_top.tendsto (Œª n, f' n) (ùìù (g x)),
  let hp : ‚àÄ·µê x ‚àÇŒº, p x (Œª n, f n x), from h_ae_tendsto,
  let ae_seq_lim := Œª x, ite (x ‚àà ae_seq_set hf p) (g x) (‚ü®f 0 x‚ü© : nonempty Œ≤).some,
  refine ‚ü®ae_seq_lim, _, (ite_ae_eq_of_measure_compl_zero g (Œª x, (‚ü®f 0 x‚ü© : nonempty Œ≤).some)
    (ae_seq_set hf p) (ae_seq.measure_compl_ae_seq_set_eq_zero hf hp)).symm‚ü©,
  refine measurable_of_tendsto_metric (@ae_seq.measurable Œ± Œ≤ _ _ _ f Œº hf p) _,
  refine tendsto_pi.mpr (Œª x, _),
  simp_rw [ae_seq, ae_seq_lim],
  split_ifs with hx,
  { simp_rw ae_seq.mk_eq_fun_of_mem_ae_seq_set hf hx,
    exact @ae_seq.fun_prop_of_mem_ae_seq_set Œ± Œ≤ _ _ _ _ _ _ hf x hx, },
  { exact tendsto_const_nhds, },
end

lemma measurable_of_tendsto_metric_ae {Œº : measure Œ±} [Œº.is_complete] {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤}
  (hf : ‚àÄ n, measurable (f n))
  (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, filter.at_top.tendsto (Œª n, f n x) (ùìù (g x))) :
  measurable g :=
ae_measurable_iff_measurable.mp
  (ae_measurable_of_tendsto_metric_ae (Œª i, (hf i).ae_measurable) h_ae_tendsto)

lemma measurable_limit_of_tendsto_metric_ae {Œº : measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤}
  (hf : ‚àÄ n, ae_measurable (f n) Œº)
  (h_ae_tendsto : ‚àÄ·µê x ‚àÇŒº, ‚àÉ l : Œ≤, filter.at_top.tendsto (Œª n, f n x) (ùìù l)) :
  ‚àÉ (f_lim : Œ± ‚Üí Œ≤) (hf_lim_meas : measurable f_lim),
    ‚àÄ·µê x ‚àÇŒº, filter.at_top.tendsto (Œª n, f n x) (ùìù (f_lim x)) :=
begin
  let p : Œ± ‚Üí (‚Ñï ‚Üí Œ≤) ‚Üí Prop := Œª x f', ‚àÉ l : Œ≤, filter.at_top.tendsto (Œª n, f' n) (ùìù l),
  have hp_mem : ‚àÄ x, x ‚àà ae_seq_set hf p ‚Üí p x (Œª n, f n x),
    from Œª x hx, ae_seq.fun_prop_of_mem_ae_seq_set hf hx,
  have hŒº_compl : Œº (ae_seq_set hf p)·∂ú = 0,
    from ae_seq.measure_compl_ae_seq_set_eq_zero hf h_ae_tendsto,
  let f_lim : Œ± ‚Üí Œ≤ := Œª x, dite (x ‚àà ae_seq_set hf p) (Œª h, (hp_mem x h).some)
    (Œª h, (‚ü®f 0 x‚ü© : nonempty Œ≤).some),
  have hf_lim_conv : ‚àÄ x, x ‚àà ae_seq_set hf p ‚Üí filter.at_top.tendsto (Œª n, f n x) (ùìù (f_lim x)),
  { intros x hx_conv,
    simp only [f_lim, hx_conv, dif_pos],
    exact (hp_mem x hx_conv).some_spec, },
  have hf_lim : ‚àÄ x, filter.at_top.tendsto (Œª n, ae_seq hf p n x) (ùìù (f_lim x)),
  { intros x,
    simp only [f_lim, ae_seq],
    split_ifs,
    { rw funext (Œª n, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h n),
      exact (hp_mem x h).some_spec, },
    { exact tendsto_const_nhds, }, },
  have h_ae_tendsto_f_lim : ‚àÄ·µê x ‚àÇŒº, filter.at_top.tendsto (Œª n, f n x) (ùìù (f_lim x)),
  { refine le_antisymm (le_of_eq (measure_mono_null _ hŒº_compl)) (zero_le _),
    exact set.compl_subset_compl.mpr (Œª x hx, hf_lim_conv x hx), },
  have h_f_lim_meas : measurable f_lim,
    from measurable_of_tendsto_metric (ae_seq.measurable hf p) (tendsto_pi.mpr (Œª x, hf_lim x)),
  exact ‚ü®f_lim, h_f_lim_meas, h_ae_tendsto_f_lim‚ü©,
end

end limits

namespace continuous_linear_map

variables {ùïú : Type*} [normed_field ùïú]
variables {E : Type*} [normed_group E] [normed_space ùïú E] [measurable_space E]
variables [opens_measurable_space E]
variables {F : Type*} [normed_group F] [normed_space ùïú F] [measurable_space F] [borel_space F]

@[measurability]
protected lemma measurable (L : E ‚ÜíL[ùïú] F) : measurable L :=
L.continuous.measurable

lemma measurable_comp (L : E ‚ÜíL[ùïú] F) {œÜ : Œ± ‚Üí E} (œÜ_meas : measurable œÜ) :
  measurable (Œª (a : Œ±), L (œÜ a)) :=
L.measurable.comp œÜ_meas

end continuous_linear_map

namespace continuous_linear_map

variables {ùïú : Type*} [nondiscrete_normed_field ùïú]
variables {E : Type*} [normed_group E] [normed_space ùïú E]
          {F : Type*} [normed_group F] [normed_space ùïú F]

instance : measurable_space (E ‚ÜíL[ùïú] F) := borel _

instance : borel_space (E ‚ÜíL[ùïú] F) := ‚ü®rfl‚ü©

@[measurability]
lemma measurable_apply [measurable_space F] [borel_space F] (x : E) :
  measurable (Œª f : E ‚ÜíL[ùïú] F, f x) :=
(apply ùïú F x).continuous.measurable

@[measurability]
lemma measurable_apply' [measurable_space E] [opens_measurable_space E]
  [measurable_space F] [borel_space F] :
  measurable (Œª (x : E) (f : E ‚ÜíL[ùïú] F), f x) :=
measurable_pi_lambda _ $ Œª f, f.measurable

@[measurability]
lemma measurable_coe [measurable_space F] [borel_space F] :
  measurable (Œª (f : E ‚ÜíL[ùïú] F) (x : E), f x) :=
measurable_pi_lambda _ measurable_apply

end continuous_linear_map

section continuous_linear_map_nondiscrete_normed_field

variables {ùïú : Type*} [nondiscrete_normed_field ùïú]
variables {E : Type*} [normed_group E] [normed_space ùïú E] [measurable_space E] [borel_space E]
variables {F : Type*} [normed_group F] [normed_space ùïú F]

@[measurability]
lemma measurable.apply_continuous_linear_map  {œÜ : Œ± ‚Üí F ‚ÜíL[ùïú] E} (hœÜ : measurable œÜ) (v : F) :
  measurable (Œª a, œÜ a v) :=
(continuous_linear_map.apply ùïú E v).measurable.comp hœÜ

@[measurability]
lemma ae_measurable.apply_continuous_linear_map {œÜ : Œ± ‚Üí F ‚ÜíL[ùïú] E} {Œº : measure Œ±}
  (hœÜ : ae_measurable œÜ Œº) (v : F) : ae_measurable (Œª a, œÜ a v) Œº :=
(continuous_linear_map.apply ùïú E v).measurable.comp_ae_measurable hœÜ

end continuous_linear_map_nondiscrete_normed_field

section normed_space
variables {ùïú : Type*} [nondiscrete_normed_field ùïú] [complete_space ùïú] [measurable_space ùïú]
variables [borel_space ùïú]
variables {E : Type*} [normed_group E] [normed_space ùïú E] [measurable_space E] [borel_space E]

lemma measurable_smul_const {f : Œ± ‚Üí ùïú} {c : E} (hc : c ‚â† 0) :
  measurable (Œª x, f x ‚Ä¢ c) ‚Üî measurable f :=
measurable_comp_iff_of_closed_embedding (Œª y : ùïú, y ‚Ä¢ c) (closed_embedding_smul_left hc)

lemma ae_measurable_smul_const {f : Œ± ‚Üí ùïú} {Œº : measure Œ±} {c : E} (hc : c ‚â† 0) :
  ae_measurable (Œª x, f x ‚Ä¢ c) Œº ‚Üî ae_measurable f Œº :=
ae_measurable_comp_iff_of_closed_embedding (Œª y : ùïú, y ‚Ä¢ c) (closed_embedding_smul_left hc)

end normed_space

lemma is_compact.measure_lt_top_of_nhds_within [topological_space Œ±]
  {s : set Œ±} {Œº : measure Œ±} (h : is_compact s) (hŒº : ‚àÄ x ‚àà s, Œº.finite_at_filter (ùìù[s] x)) :
  Œº s < ‚àû :=
is_compact.induction_on h (by simp) (Œª s t hst ht, (measure_mono hst).trans_lt ht)
  (Œª s t hs ht, (measure_union_le s t).trans_lt (ennreal.add_lt_top.2 ‚ü®hs, ht‚ü©)) hŒº

lemma is_compact.measure_lt_top [topological_space Œ±] {s : set Œ±} {Œº : measure Œ±}
  [locally_finite_measure Œº] (h : is_compact s) :
  Œº s < ‚àû :=
h.measure_lt_top_of_nhds_within $ Œª x hx, Œº.finite_at_nhds_within _ _
