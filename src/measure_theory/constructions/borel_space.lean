/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Yury Kudryashov
-/
import analysis.complex.basic
import analysis.normed_space.finite_dimension
import measure_theory.function.ae_measurable_sequence
import measure_theory.group.arithmetic
import measure_theory.lattice
import measure_theory.measure.open_pos
import topology.algebra.order.liminf_limsup
import topology.continuous_function.basic
import topology.instances.ereal
import topology.G_delta
import topology.order.lattice
import topology.semicontinuous
import topology.metric_space.metrizable

/-!
# Borel (measurable) space

## Main definitions

* `borel Î±` : the least `Ïƒ`-algebra that contains all open sets;
* `class borel_space` : a space with `topological_space` and `measurable_space` structures
  such that `â€¹measurable_space Î±â€º = borel Î±`;
* `class opens_measurable_space` : a space with `topological_space` and `measurable_space`
  structures such that all open sets are measurable; equivalently, `borel Î± â‰¤ â€¹measurable_space Î±â€º`.
* `borel_space` instances on `empty`, `unit`, `bool`, `nat`, `int`, `rat`;
* `measurable` and `borel_space` instances on `â„`, `â„â‰¥0`, `â„â‰¥0âˆ`.

## Main statements

* `is_open.measurable_set`, `is_closed.measurable_set`: open and closed sets are measurable;
* `continuous.measurable` : a continuous function is measurable;
* `continuous.measurable2` : if `f : Î± â†’ Î²` and `g : Î± â†’ Î³` are measurable and `op : Î² Ã— Î³ â†’ Î´`
  is continuous, then `Î» x, op (f x, g y)` is measurable;
* `measurable.add` etc : dot notation for arithmetic operations on `measurable` predicates,
  and similarly for `dist` and `edist`;
* `ae_measurable.add` : similar dot notation for almost everywhere measurable functions;
* `measurable.ennreal*` : special cases for arithmetic operations on `â„â‰¥0âˆ`.
-/

noncomputable theory

open classical set filter measure_theory
open_locale classical big_operators topological_space nnreal ennreal measure_theory

universes u v w x y
variables {Î± Î² Î³ Î³â‚‚ Î´ : Type*} {Î¹ : Sort y} {s t u : set Î±}

open measurable_space topological_space

/-- `measurable_space` structure generated by `topological_space`. -/
def borel (Î± : Type u) [topological_space Î±] : measurable_space Î± :=
generate_from {s : set Î± | is_open s}

lemma borel_eq_top_of_discrete [topological_space Î±] [discrete_topology Î±] :
  borel Î± = âŠ¤ :=
top_le_iff.1 $ Î» s hs, generate_measurable.basic s (is_open_discrete s)

lemma borel_eq_top_of_encodable [topological_space Î±] [t1_space Î±] [encodable Î±] :
  borel Î± = âŠ¤ :=
begin
  refine (top_le_iff.1 $ Î» s hs, bUnion_of_singleton s â–¸ _),
  apply measurable_set.bUnion s.countable_encodable,
  intros x hx,
  apply measurable_set.of_compl,
  apply generate_measurable.basic,
  exact is_closed_singleton.is_open_compl
end

lemma borel_eq_generate_from_of_subbasis {s : set (set Î±)}
  [t : topological_space Î±] [second_countable_topology Î±] (hs : t = generate_from s) :
  borel Î± = generate_from s :=
le_antisymm
  (generate_from_le $ assume u (hu : t.is_open u),
    begin
      rw [hs] at hu,
      induction hu,
      case generate_open.basic : u hu
      { exact generate_measurable.basic u hu },
      case generate_open.univ
      { exact @measurable_set.univ Î± (generate_from s) },
      case generate_open.inter : sâ‚ sâ‚‚ _ _ hsâ‚ hsâ‚‚
      { exact @measurable_set.inter Î± (generate_from s) _ _ hsâ‚ hsâ‚‚ },
      case generate_open.sUnion : f hf ih
      { rcases is_open_sUnion_countable f (by rwa hs) with âŸ¨v, hv, vf, vuâŸ©,
        rw â† vu,
        exact @measurable_set.sUnion Î± (generate_from s) _ hv
          (Î» x xv, ih _ (vf xv)) }
    end)
  (generate_from_le $ assume u hu, generate_measurable.basic _ $
    show t.is_open u, by rw [hs]; exact generate_open.basic _ hu)

lemma topological_space.is_topological_basis.borel_eq_generate_from [topological_space Î±]
  [second_countable_topology Î±] {s : set (set Î±)} (hs : is_topological_basis s) :
  borel Î± = generate_from s :=
borel_eq_generate_from_of_subbasis hs.eq_generate_from

lemma is_pi_system_is_open [topological_space Î±] : is_pi_system (is_open : set Î± â†’ Prop) :=
Î» s hs t ht hst, is_open.inter hs ht

lemma borel_eq_generate_from_is_closed [topological_space Î±] :
  borel Î± = generate_from {s | is_closed s} :=
le_antisymm
  (generate_from_le $ Î» t ht, @measurable_set.of_compl Î± _ (generate_from {s | is_closed s})
    (generate_measurable.basic _ $ is_closed_compl_iff.2 ht))
  (generate_from_le $ Î» t ht, @measurable_set.of_compl Î± _ (borel Î±)
    (generate_measurable.basic _ $ is_open_compl_iff.2 ht))

section order_topology

variable (Î±)
variables [topological_space Î±] [second_countable_topology Î±] [linear_order Î±] [order_topology Î±]

lemma borel_eq_generate_from_Iio : borel Î± = generate_from (range Iio) :=
begin
  refine le_antisymm _ (generate_from_le _),
  { rw borel_eq_generate_from_of_subbasis (@order_topology.topology_eq_generate_intervals Î± _ _ _),
    letI : measurable_space Î± := measurable_space.generate_from (range Iio),
    have H : âˆ€ a : Î±, measurable_set (Iio a) := Î» a, generate_measurable.basic _ âŸ¨_, rflâŸ©,
    refine generate_from_le _, rintro _ âŸ¨a, rfl | rflâŸ©; [skip, apply H],
    by_cases h : âˆƒ a', âˆ€ b, a < b â†” a' â‰¤ b,
    { rcases h with âŸ¨a', ha'âŸ©,
      rw (_ : Ioi a = (Iio a')á¶œ), { exact (H _).compl },
      simp [set.ext_iff, ha'] },
    { rcases is_open_Union_countable
        (Î» a' : {a' : Î± // a < a'}, {b | a'.1 < b})
        (Î» a', is_open_lt' _) with âŸ¨v, âŸ¨hvâŸ©, vuâŸ©,
      simp [set.ext_iff] at vu,
      have : Ioi a = â‹ƒ x : v, (Iio x.1.1)á¶œ,
      { simp [set.ext_iff],
        refine Î» x, âŸ¨Î» ax, _, Î» âŸ¨a', âŸ¨h, avâŸ©, axâŸ©, lt_of_lt_of_le h axâŸ©,
        rcases (vu x).2 _ with âŸ¨a', hâ‚, hâ‚‚âŸ©,
        { exact âŸ¨a', hâ‚, le_of_lt hâ‚‚âŸ© },
        refine not_imp_comm.1 (Î» h, _) h,
        exact âŸ¨x, Î» b, âŸ¨Î» ab, le_of_not_lt (Î» h', h âŸ¨b, ab, h'âŸ©),
          lt_of_lt_of_le axâŸ©âŸ© },
      rw this, resetI,
      apply measurable_set.Union,
      exact Î» _, (H _).compl } },
  { rw forall_range_iff,
    intro a,
    exact generate_measurable.basic _ is_open_Iio }
end

lemma borel_eq_generate_from_Ioi : borel Î± = generate_from (range Ioi) :=
@borel_eq_generate_from_Iio (order_dual Î±) _ (by apply_instance : second_countable_topology Î±) _ _

end order_topology

lemma borel_comap {f : Î± â†’ Î²} {t : topological_space Î²} :
  @borel Î± (t.induced f) = (@borel Î² t).comap f :=
comap_generate_from.symm

lemma continuous.borel_measurable [topological_space Î±] [topological_space Î²]
  {f : Î± â†’ Î²} (hf : continuous f) :
  @measurable Î± Î² (borel Î±) (borel Î²) f :=
measurable.of_le_map $ generate_from_le $
  Î» s hs, generate_measurable.basic (f â»Â¹' s) (hs.preimage hf)

/-- A space with `measurable_space` and `topological_space` structures such that
all open sets are measurable. -/
class opens_measurable_space (Î± : Type*) [topological_space Î±] [h : measurable_space Î±] : Prop :=
(borel_le : borel Î± â‰¤ h)

/-- A space with `measurable_space` and `topological_space` structures such that
the `Ïƒ`-algebra of measurable sets is exactly the `Ïƒ`-algebra generated by open sets. -/
class borel_space (Î± : Type*) [topological_space Î±] [measurable_space Î±] : Prop :=
(measurable_eq : â€¹measurable_space Î±â€º = borel Î±)

namespace tactic

/-- Add instances `borel Î± : measurable_space Î±` and `âŸ¨rflâŸ© : borel_space Î±`. -/
meta def add_borel_instance (Î± : expr) : tactic unit :=
do
  n1 â† get_unused_name "_inst",
  to_expr ``(borel %%Î±) >>= pose n1,
  reset_instance_cache,
  n2 â† get_unused_name "_inst",
  v â† to_expr ``(borel_space.mk rfl : borel_space %%Î±),
  note n2 none v,
  reset_instance_cache

/-- Given a type `Î±`, an assumption `i : measurable_space Î±`, and an instance `[borel_space Î±]`,
replace `i` with `borel Î±`. -/
meta def borel_to_refl (Î± i : expr) : tactic unit :=
do
  n â† get_unused_name "h",
  to_expr ``(%%i = borel %%Î±) >>= assert n,
  applyc `borel_space.measurable_eq,
  unfreezing (tactic.subst i),
  n1 â† get_unused_name "_inst",
  to_expr ``(borel %%Î±) >>= pose n1,
  reset_instance_cache

/-- Given a type `Î±`, if there is an assumption `[i : measurable_space Î±]`, then try to prove
`[borel_space Î±]` and replace `i` with `borel Î±`. Otherwise, add instances
`borel Î± : measurable_space Î±` and `âŸ¨rflâŸ© : borel_space Î±`. -/
meta def borelize (Î± : expr) : tactic unit :=
do
  i â† optional (to_expr ``(measurable_space %%Î±) >>= find_assumption),
  i.elim (add_borel_instance Î±) (borel_to_refl Î±)

namespace interactive

setup_tactic_parser

/-- The behaviour of `borelize Î±` depends on the existing assumptions on `Î±`.

- if `Î±` is a topological space with instances `[measurable_space Î±] [borel_space Î±]`, then
  `borelize Î±` replaces the former instance by `borel Î±`;
- otherwise, `borelize Î±` adds instances `borel Î± : measurable_space Î±` and `âŸ¨rflâŸ© : borel_space Î±`.

Finally, `borelize [Î±, Î², Î³]` runs `borelize Î±, borelize Î², borelize Î³`.
-/
meta def borelize (ts : parse pexpr_list_or_texpr) : tactic unit :=
mmap' (Î» t, to_expr t >>= tactic.borelize) ts

add_tactic_doc
{ name := "borelize",
  category := doc_category.tactic,
  decl_names := [`tactic.interactive.borelize],
  tags := ["type class"] }

end interactive

end tactic

@[priority 100]
instance order_dual.opens_measurable_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [h : opens_measurable_space Î±] :
  opens_measurable_space (order_dual Î±) :=
{ borel_le := h.borel_le }

@[priority 100]
instance order_dual.borel_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [h : borel_space Î±] :
  borel_space (order_dual Î±) :=
{ measurable_eq := h.measurable_eq }

/-- In a `borel_space` all open sets are measurable. -/
@[priority 100]
instance borel_space.opens_measurable {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [borel_space Î±] : opens_measurable_space Î± :=
âŸ¨ge_of_eq $ borel_space.measurable_eqâŸ©

instance subtype.borel_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [hÎ± : borel_space Î±] (s : set Î±) :
  borel_space s :=
âŸ¨by { rw [hÎ±.1, subtype.measurable_space, â† borel_comap], refl }âŸ©

instance subtype.opens_measurable_space {Î± : Type*} [topological_space Î±] [measurable_space Î±]
  [h : opens_measurable_space Î±] (s : set Î±) :
  opens_measurable_space s :=
âŸ¨by { rw [borel_comap], exact comap_mono h.1 }âŸ©

theorem _root_.measurable_set.induction_on_open [topological_space Î±] [measurable_space Î±]
  [borel_space Î±] {C : set Î± â†’ Prop} (h_open : âˆ€ U, is_open U â†’ C U)
  (h_compl : âˆ€ t, measurable_set t â†’ C t â†’ C tá¶œ)
  (h_union : âˆ€ f : â„• â†’ set Î±, pairwise (disjoint on f) â†’
    (âˆ€ i, measurable_set (f i)) â†’ (âˆ€ i, C (f i)) â†’ C (â‹ƒ i, f i)) :
  âˆ€ â¦ƒtâ¦„, measurable_set t â†’ C t :=
measurable_space.induction_on_inter borel_space.measurable_eq is_pi_system_is_open
  (h_open _ is_open_empty) h_open h_compl h_union

section
variables [topological_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
   [topological_space Î²] [measurable_space Î²] [opens_measurable_space Î²]
   [topological_space Î³] [measurable_space Î³] [borel_space Î³]
   [topological_space Î³â‚‚] [measurable_space Î³â‚‚] [borel_space Î³â‚‚]
   [measurable_space Î´]

lemma is_open.measurable_set (h : is_open s) : measurable_set s :=
opens_measurable_space.borel_le _ $ generate_measurable.basic _ h

@[measurability]
lemma measurable_set_interior : measurable_set (interior s) := is_open_interior.measurable_set

lemma is_GÎ´.measurable_set (h : is_GÎ´ s) : measurable_set s :=
begin
  rcases h with âŸ¨S, hSo, hSc, rflâŸ©,
  exact measurable_set.sInter hSc (Î» t ht, (hSo t ht).measurable_set)
end

lemma measurable_set_of_continuous_at {Î²} [emetric_space Î²] (f : Î± â†’ Î²) :
  measurable_set {x | continuous_at f x} :=
(is_GÎ´_set_of_continuous_at f).measurable_set

lemma is_closed.measurable_set (h : is_closed s) : measurable_set s :=
h.is_open_compl.measurable_set.of_compl

lemma is_compact.measurable_set [t2_space Î±] (h : is_compact s) : measurable_set s :=
h.is_closed.measurable_set

@[measurability]
lemma measurable_set_closure : measurable_set (closure s) :=
is_closed_closure.measurable_set

lemma measurable_of_is_open {f : Î´ â†’ Î³} (hf : âˆ€ s, is_open s â†’ measurable_set (f â»Â¹' s)) :
  measurable f :=
by { rw [â€¹borel_space Î³â€º.measurable_eq], exact measurable_generate_from hf }

lemma measurable_of_is_closed {f : Î´ â†’ Î³} (hf : âˆ€ s, is_closed s â†’ measurable_set (f â»Â¹' s)) :
  measurable f :=
begin
  apply measurable_of_is_open, intros s hs,
  rw [â† measurable_set.compl_iff, â† preimage_compl], apply hf, rw [is_closed_compl_iff], exact hs
end

lemma measurable_of_is_closed' {f : Î´ â†’ Î³}
  (hf : âˆ€ s, is_closed s â†’ s.nonempty â†’ s â‰  univ â†’ measurable_set (f â»Â¹' s)) : measurable f :=
begin
  apply measurable_of_is_closed, intros s hs,
  cases eq_empty_or_nonempty s with h1 h1, { simp [h1] },
  by_cases h2 : s = univ, { simp [h2] },
  exact hf s hs h1 h2
end

instance nhds_is_measurably_generated (a : Î±) : (ğ“ a).is_measurably_generated :=
begin
  rw [nhds, infi_subtype'],
  refine @filter.infi_is_measurably_generated _ _ _ _ (Î» i, _),
  exact i.2.2.measurable_set.principal_is_measurably_generated
end

/-- If `s` is a measurable set, then `ğ“[s] a` is a measurably generated filter for
each `a`. This cannot be an `instance` because it depends on a non-instance `hs : measurable_set s`.
-/
lemma measurable_set.nhds_within_is_measurably_generated {s : set Î±} (hs : measurable_set s)
  (a : Î±) :
  (ğ“[s] a).is_measurably_generated :=
by haveI := hs.principal_is_measurably_generated; exact filter.inf_is_measurably_generated _ _

@[priority 100] -- see Note [lower instance priority]
instance opens_measurable_space.to_measurable_singleton_class [t1_space Î±] :
  measurable_singleton_class Î± :=
âŸ¨Î» x, is_closed_singleton.measurable_setâŸ©

instance pi.opens_measurable_space_encodable {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [encodable Î¹]
  [t' : Î  i, topological_space (Ï€ i)]
  [Î  i, measurable_space (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)]
  [âˆ€ i, opens_measurable_space (Ï€ i)] :
  opens_measurable_space (Î  i, Ï€ i) :=
begin
  constructor,
  have : Pi.topological_space =
    generate_from {t | âˆƒ(s:Î a, set (Ï€ a)) (i : finset Î¹), (âˆ€aâˆˆi, s a âˆˆ countable_basis (Ï€ a)) âˆ§
      t = pi â†‘i s},
  { rw [funext (Î» a, @eq_generate_from_countable_basis (Ï€ a) _ _), pi_generate_from_eq] },
  rw [borel_eq_generate_from_of_subbasis this],
  apply generate_from_le,
  rintros _ âŸ¨s, i, hi, rflâŸ©,
  refine measurable_set.pi i.countable_to_set (Î» a ha, is_open.measurable_set _),
  rw [eq_generate_from_countable_basis (Ï€ a)],
  exact generate_open.basic _ (hi a ha)
end

instance pi.opens_measurable_space_fintype {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [fintype Î¹]
  [t' : Î  i, topological_space (Ï€ i)]
  [Î  i, measurable_space (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)]
  [âˆ€ i, opens_measurable_space (Ï€ i)] :
  opens_measurable_space (Î  i, Ï€ i) :=
by { letI := fintype.encodable Î¹, apply_instance }

instance prod.opens_measurable_space [second_countable_topology Î±] [second_countable_topology Î²] :
  opens_measurable_space (Î± Ã— Î²) :=
begin
  constructor,
  rw [((is_basis_countable_basis Î±).prod (is_basis_countable_basis Î²)).borel_eq_generate_from],
  apply generate_from_le,
  rintros _ âŸ¨u, v, hu, hv, rflâŸ©,
  exact (is_open_of_mem_countable_basis hu).measurable_set.prod
    (is_open_of_mem_countable_basis hv).measurable_set
end

variables {Î±' : Type*} [topological_space Î±'] [measurable_space Î±']

lemma measure_interior_of_null_bdry {Î¼ : measure Î±'} {s : set Î±'}
  (h_nullbdry : Î¼ (frontier s) = 0) : Î¼ (interior s) = Î¼ s :=
measure_eq_measure_smaller_of_between_null_diff
  interior_subset subset_closure h_nullbdry

lemma measure_closure_of_null_bdry {Î¼ : measure Î±'} {s : set Î±'}
  (h_nullbdry : Î¼ (frontier s) = 0) : Î¼ (closure s) = Î¼ s :=
(measure_eq_measure_larger_of_between_null_diff
  interior_subset subset_closure h_nullbdry).symm

section preorder
variables [preorder Î±] [order_closed_topology Î±] {a b x : Î±}

@[simp, measurability]
lemma measurable_set_Ici : measurable_set (Ici a) := is_closed_Ici.measurable_set
@[simp, measurability]
lemma measurable_set_Iic : measurable_set (Iic a) := is_closed_Iic.measurable_set
@[simp, measurability]
lemma measurable_set_Icc : measurable_set (Icc a b) := is_closed_Icc.measurable_set

instance nhds_within_Ici_is_measurably_generated :
  (ğ“[Ici b] a).is_measurably_generated :=
measurable_set_Ici.nhds_within_is_measurably_generated _

instance nhds_within_Iic_is_measurably_generated :
  (ğ“[Iic b] a).is_measurably_generated :=
measurable_set_Iic.nhds_within_is_measurably_generated _

instance nhds_within_Icc_is_measurably_generated :
  is_measurably_generated (ğ“[Icc a b] x) :=
by { rw [â† Ici_inter_Iic, nhds_within_inter], apply_instance }

instance at_top_is_measurably_generated : (filter.at_top : filter Î±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Î» a, (measurable_set_Ici : measurable_set (Ici a)).principal_is_measurably_generated

instance at_bot_is_measurably_generated : (filter.at_bot : filter Î±).is_measurably_generated :=
@filter.infi_is_measurably_generated _ _ _ _ $
  Î» a, (measurable_set_Iic : measurable_set (Iic a)).principal_is_measurably_generated

end preorder

section partial_order
variables [partial_order Î±] [order_closed_topology Î±] [second_countable_topology Î±]
  {a b : Î±}

@[measurability]
lemma measurable_set_le' : measurable_set {p : Î± Ã— Î± | p.1 â‰¤ p.2} :=
order_closed_topology.is_closed_le'.measurable_set

@[measurability]
lemma measurable_set_le {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable_set {a | f a â‰¤ g a} :=
hf.prod_mk hg measurable_set_le'

end partial_order

section linear_order
variables [linear_order Î±] [order_closed_topology Î±] {a b x : Î±}

-- we open this locale only here to avoid issues with list being treated as intervals above
open_locale interval

@[simp, measurability]
lemma measurable_set_Iio : measurable_set (Iio a) := is_open_Iio.measurable_set
@[simp, measurability]
lemma measurable_set_Ioi : measurable_set (Ioi a) := is_open_Ioi.measurable_set
@[simp, measurability]
lemma measurable_set_Ioo : measurable_set (Ioo a b) := is_open_Ioo.measurable_set

@[simp, measurability] lemma measurable_set_Ioc : measurable_set (Ioc a b) :=
measurable_set_Ioi.inter measurable_set_Iic

@[simp, measurability] lemma measurable_set_Ico : measurable_set (Ico a b) :=
measurable_set_Ici.inter measurable_set_Iio

instance nhds_within_Ioi_is_measurably_generated :
  (ğ“[Ioi b] a).is_measurably_generated :=
measurable_set_Ioi.nhds_within_is_measurably_generated _

instance nhds_within_Iio_is_measurably_generated :
  (ğ“[Iio b] a).is_measurably_generated :=
measurable_set_Iio.nhds_within_is_measurably_generated _

instance nhds_within_interval_is_measurably_generated :
  is_measurably_generated (ğ“[[a, b]] x) :=
nhds_within_Icc_is_measurably_generated

@[measurability]
lemma measurable_set_lt' [second_countable_topology Î±] : measurable_set {p : Î± Ã— Î± | p.1 < p.2} :=
(is_open_lt continuous_fst continuous_snd).measurable_set

@[measurability]
lemma measurable_set_lt [second_countable_topology Î±] {f g : Î´ â†’ Î±} (hf : measurable f)
  (hg : measurable g) : measurable_set {a | f a < g a} :=
hf.prod_mk hg measurable_set_lt'

lemma set.ord_connected.measurable_set (h : ord_connected s) : measurable_set s :=
begin
  let u := â‹ƒ (x âˆˆ s) (y âˆˆ s), Ioo x y,
  have huopen : is_open u := is_open_bUnion (Î» x hx, is_open_bUnion (Î» y hy, is_open_Ioo)),
  have humeas : measurable_set u := huopen.measurable_set,
  have hfinite : (s \ u).finite,
  { refine set.finite_of_forall_between_eq_endpoints (s \ u) (Î» x hx y hy z hz hxy hyz, _),
    by_contra' h,
    exact hy.2 (mem_Unionâ‚‚.mpr âŸ¨x, hx.1,
      mem_Unionâ‚‚.mpr âŸ¨z, hz.1, lt_of_le_of_ne hxy h.1, lt_of_le_of_ne hyz h.2âŸ©âŸ©) },
  have : u âŠ† s :=
    Unionâ‚‚_subset (Î» x hx, Unionâ‚‚_subset (Î» y hy, Ioo_subset_Icc_self.trans (h.out hx hy))),
  rw â† union_diff_cancel this,
  exact humeas.union hfinite.measurable_set
end

lemma is_preconnected.measurable_set
  (h : is_preconnected s) : measurable_set s :=
h.ord_connected.measurable_set

lemma generate_from_Ico_mem_le_borel {Î± : Type*} [topological_space Î±] [linear_order Î±]
  [order_closed_topology Î±] (s t : set Î±) :
  measurable_space.generate_from {S | âˆƒ (l âˆˆ s) (u âˆˆ t) (h : l < u), Ico l u = S} â‰¤ borel Î± :=
begin
  apply generate_from_le,
  borelize Î±,
  rintro _ âŸ¨a, -, b, -, -, rflâŸ©,
  exact measurable_set_Ico
end

lemma dense.borel_eq_generate_from_Ico_mem_aux {Î± : Type*} [topological_space Î±] [linear_order Î±]
  [order_topology Î±] [second_countable_topology Î±] {s : set Î±} (hd : dense s)
  (hbot : âˆ€ x, is_bot x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ y âˆˆ s) :
  borel Î± = generate_from {S : set Î± | âˆƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), Ico l u = S} :=
begin
  set S : set (set Î±) := {S | âˆƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), Ico l u = S},
  refine le_antisymm _ (generate_from_Ico_mem_le_borel _ _),
  letI : measurable_space Î± := generate_from S,
  rw borel_eq_generate_from_Iio,
  refine generate_from_le (forall_range_iff.2 $ Î» a, _),
  rcases hd.exists_countable_dense_subset_bot_top with âŸ¨t, hts, hc, htd, htb, httâŸ©,
  by_cases ha : âˆ€ b < a, (Ioo b a).nonempty,
  { convert_to measurable_set (â‹ƒ (l âˆˆ t) (u âˆˆ t) (hlu : l < u) (hu : u â‰¤ a), Ico l u),
    { ext y, simp only [mem_Union, mem_Iio, mem_Ico], split,
      { intro hy,
        rcases htd.exists_le' (Î» b hb, htb _ hb (hbot b hb)) y with âŸ¨l, hlt, hlyâŸ©,
        rcases htd.exists_mem_open is_open_Ioo (ha y hy) with âŸ¨u, hut, hyu, huaâŸ©,
        exact âŸ¨l, hlt, u, hut, hly.trans_lt hyu, hua.le, hly, hyuâŸ© },
      { rintro âŸ¨l, -, u, -, -, hua, -, hyuâŸ©,
        exact hyu.trans_le hua } },
    { refine measurable_set.bUnion hc (Î» a ha, measurable_set.bUnion hc $ Î» b hb, _),
      refine measurable_set.Union_Prop (Î» hab, measurable_set.Union_Prop $ Î» hb', _),
      exact generate_measurable.basic _ âŸ¨a, hts ha, b, hts hb, hab, mem_singleton _âŸ© } },
  { simp only [not_forall, not_nonempty_iff_eq_empty] at ha,
    replace ha : a âˆˆ s := hIoo ha.some a ha.some_spec.fst ha.some_spec.snd,
    convert_to measurable_set (â‹ƒ (l âˆˆ t) (hl : l < a), Ico l a),
    { symmetry,
      simp only [â† Ici_inter_Iio, â† Union_inter, inter_eq_right_iff_subset, subset_def, mem_Union,
        mem_Ici, mem_Iio],
      intros x hx, rcases htd.exists_le' (Î» b hb, htb _ hb (hbot b hb)) x with âŸ¨z, hzt, hzxâŸ©,
      exact âŸ¨z, hzt, hzx.trans_lt hx, hzxâŸ© },
    { refine measurable_set.bUnion hc (Î» x hx, measurable_set.Union_Prop $ Î» hlt, _),
      exact generate_measurable.basic _ âŸ¨x, hts hx, a, ha, hlt, mem_singleton _âŸ© } }
end

lemma dense.borel_eq_generate_from_Ico_mem {Î± : Type*} [topological_space Î±] [linear_order Î±]
  [order_topology Î±] [second_countable_topology Î±] [densely_ordered Î±] [no_min_order Î±]
  {s : set Î±} (hd : dense s) :
  borel Î± = generate_from {S : set Î± | âˆƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), Ico l u = S} :=
hd.borel_eq_generate_from_Ico_mem_aux (by simp) $
  Î» x y hxy H, ((nonempty_Ioo.2 hxy).ne_empty H).elim

lemma borel_eq_generate_from_Ico (Î± : Type*) [topological_space Î±]
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] :
  borel Î± = generate_from {S : set Î± | âˆƒ l u (h : l < u), Ico l u = S} :=
by simpa only [exists_prop, mem_univ, true_and]
  using (@dense_univ Î± _).borel_eq_generate_from_Ico_mem_aux (Î» _ _, mem_univ _)
      (Î» _ _ _ _, mem_univ _)

lemma dense.borel_eq_generate_from_Ioc_mem_aux {Î± : Type*} [topological_space Î±] [linear_order Î±]
  [order_topology Î±] [second_countable_topology Î±] {s : set Î±} (hd : dense s)
  (hbot : âˆ€ x, is_top x â†’ x âˆˆ s) (hIoo : âˆ€ x y : Î±, x < y â†’ Ioo x y = âˆ… â†’ x âˆˆ s) :
  borel Î± = generate_from {S : set Î± | âˆƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), Ioc l u = S} :=
begin
  convert hd.order_dual.borel_eq_generate_from_Ico_mem_aux hbot (Î» x y hlt he, hIoo y x hlt _),
  { ext s,
    split; rintro âŸ¨l, hl, u, hu, hlt, rflâŸ©,
    exacts [âŸ¨u, hu, l, hl, hlt, dual_IcoâŸ©, âŸ¨u, hu, l, hl, hlt, dual_IocâŸ©] },
  { erw dual_Ioo,
    exact he }
end

lemma dense.borel_eq_generate_from_Ioc_mem {Î± : Type*} [topological_space Î±] [linear_order Î±]
  [order_topology Î±] [second_countable_topology Î±] [densely_ordered Î±] [no_max_order Î±]
  {s : set Î±} (hd : dense s) :
  borel Î± = generate_from {S : set Î± | âˆƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), Ioc l u = S} :=
hd.borel_eq_generate_from_Ioc_mem_aux (by simp) $
  Î» x y hxy H, ((nonempty_Ioo.2 hxy).ne_empty H).elim

lemma borel_eq_generate_from_Ioc (Î± : Type*) [topological_space Î±]
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] :
  borel Î± = generate_from {S : set Î± | âˆƒ l u (h : l < u), Ioc l u = S} :=
by simpa only [exists_prop, mem_univ, true_and]
  using (@dense_univ Î± _).borel_eq_generate_from_Ioc_mem_aux (Î» _ _, mem_univ _)
      (Î» _ _ _ _, mem_univ _)

namespace measure_theory.measure

/-- Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ico` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
lemma ext_of_Ico_finite {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±]
  [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
begin
  refine ext_of_generate_finite _
    (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))
    (is_pi_system_Ico (id : Î± â†’ Î±) id) _ hÎ¼Î½,
  { rintro - âŸ¨a, b, hlt, rflâŸ©,
    exact h hlt }
end

/-- Two finite measures on a Borel space are equal if they agree on all open-closed intervals.  If
`Î±` is a conditionally complete linear order with no top element,
`measure_theory.measure..ext_of_Ioc` is an extensionality lemma with weaker assumptions on `Î¼` and
`Î½`. -/
lemma ext_of_Ioc_finite {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±]
  [borel_space Î±] (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (hÎ¼Î½ : Î¼ univ = Î½ univ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
begin
  refine @ext_of_Ico_finite (order_dual Î±) _ _ _ _ _ â€¹_â€º Î¼ Î½ _ hÎ¼Î½ (Î» a b hab, _),
  erw dual_Ico,
  exact h hab
end

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
lemma ext_of_Ico' {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±]
  [no_max_order Î±] (Î¼ Î½ : measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) â‰  âˆ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
begin
  rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, hsb, hstâŸ©,
  have : countable (â‹ƒ (l âˆˆ s) (u âˆˆ s) (h : l < u), {Ico l u} : set (set Î±)),
    from hsc.bUnion (Î» l hl, hsc.bUnion
      (Î» u hu, countable_Union_Prop $ Î» _, countable_singleton _)),
  simp only [â† set_of_eq_eq_singleton, â† set_of_exists] at this,
  refine measure.ext_of_generate_from_of_cover_subset
    (borel_space.measurable_eq.trans (borel_eq_generate_from_Ico Î±))
    (is_pi_system_Ico id id) _ this _ _ _,
  { rintro _ âŸ¨l, -, u, -, h, rflâŸ©, exact âŸ¨l, u, h, rflâŸ© },
  { refine sUnion_eq_univ_iff.2 (Î» x, _),
    rcases hsd.exists_le' hsb x with âŸ¨l, hls, hlxâŸ©,
    rcases hsd.exists_gt x with âŸ¨u, hus, hxuâŸ©,
    exact âŸ¨_, âŸ¨l, hls, u, hus, hlx.trans_lt hxu, rflâŸ©, hlx, hxuâŸ© },
  { rintro _ âŸ¨l, -, u, -, hlt, rflâŸ©, exact hÎ¼ hlt },
  { rintro _ âŸ¨l, u, hlt, rflâŸ©, exact h hlt }
end

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
lemma ext_of_Ioc' {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±]
  [no_min_order Î±] (Î¼ Î½ : measure Î±) (hÎ¼ : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) â‰  âˆ)
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
begin
  refine @ext_of_Ico' (order_dual Î±) _ _ _ _ _ â€¹_â€º _ Î¼ Î½ _ _;
    intros a b hab; erw dual_Ico,
  exacts [hÎ¼ hab, h hab]
end

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
closed-open intervals. -/
lemma ext_of_Ico {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±]
  [borel_space Î±] [no_max_order Î±] (Î¼ Î½ : measure Î±) [is_locally_finite_measure Î¼]
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ico a b) = Î½ (Ico a b)) : Î¼ = Î½ :=
Î¼.ext_of_Ico' Î½ (Î» a b hab, measure_Ico_lt_top.ne) h

/-- Two measures which are finite on closed-open intervals are equal if the agree on all
open-closed intervals. -/
lemma ext_of_Ioc {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [conditionally_complete_linear_order Î±] [order_topology Î±]
  [borel_space Î±] [no_min_order Î±] (Î¼ Î½ : measure Î±) [is_locally_finite_measure Î¼]
  (h : âˆ€ â¦ƒa bâ¦„, a < b â†’ Î¼ (Ioc a b) = Î½ (Ioc a b)) : Î¼ = Î½ :=
Î¼.ext_of_Ioc' Î½ (Î» a b hab, measure_Ioc_lt_top.ne) h

/-- Two finite measures on a Borel space are equal if they agree on all left-infinite right-closed
intervals. -/
lemma ext_of_Iic {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±]
  (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (h : âˆ€ a, Î¼ (Iic a) = Î½ (Iic a)) : Î¼ = Î½ :=
begin
  refine ext_of_Ioc_finite Î¼ Î½ _ (Î» a b hlt, _),
  { rcases exists_countable_dense_bot_top Î± with âŸ¨s, hsc, hsd, -, hstâŸ©,
    have : directed_on (â‰¤) s, from directed_on_iff_directed.2 (directed_of_sup $ Î» _ _, id),
    simp only [â† bsupr_measure_Iic hsc (hsd.exists_ge' hst) this, h] },
  rw [â† Iic_diff_Iic, measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic,
      measure_diff (Iic_subset_Iic.2 hlt.le) measurable_set_Iic, h a, h b],
  { rw â† h a, exact (measure_lt_top Î¼ _).ne },
  { exact (measure_lt_top Î¼ _).ne }
end

/-- Two finite measures on a Borel space are equal if they agree on all left-closed right-infinite
intervals. -/
lemma ext_of_Ici {Î± : Type*} [topological_space Î±] {m : measurable_space Î±}
  [second_countable_topology Î±] [linear_order Î±] [order_topology Î±] [borel_space Î±]
  (Î¼ Î½ : measure Î±) [is_finite_measure Î¼] (h : âˆ€ a, Î¼ (Ici a) = Î½ (Ici a)) : Î¼ = Î½ :=
@ext_of_Iic (order_dual Î±) _ _ _ _ _ â€¹_â€º _ _ _ h

end measure_theory.measure

end linear_order

section linear_order

variables [linear_order Î±] [order_closed_topology Î±]

@[measurability]
lemma measurable_set_interval {a b : Î±} : measurable_set (interval a b) :=
measurable_set_Icc

@[measurability]
lemma measurable_set_interval_oc {a b : Î±} : measurable_set (interval_oc a b) :=
measurable_set_Ioc

variables [second_countable_topology Î±]

@[measurability]
lemma measurable.max {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» a, max (f a) (g a)) :=
by simpa only [max_def] using hf.piecewise (measurable_set_le hg hf) hg

@[measurability]
lemma ae_measurable.max {f g : Î´ â†’ Î±} {Î¼ : measure Î´}
  (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : ae_measurable (Î» a, max (f a) (g a)) Î¼ :=
âŸ¨Î» a, max (hf.mk f a) (hg.mk g a), hf.measurable_mk.max hg.measurable_mk,
  eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©

@[measurability]
lemma measurable.min {f g : Î´ â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» a, min (f a) (g a)) :=
by simpa only [min_def] using hf.piecewise (measurable_set_le hf hg) hg

@[measurability]
lemma ae_measurable.min {f g : Î´ â†’ Î±} {Î¼ : measure Î´}
  (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : ae_measurable (Î» a, min (f a) (g a)) Î¼ :=
âŸ¨Î» a, min (hf.mk f a) (hg.mk g a), hf.measurable_mk.min hg.measurable_mk,
  eventually_eq.compâ‚‚ hf.ae_eq_mk _ hg.ae_eq_mkâŸ©

end linear_order

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is measurable. -/
lemma continuous.measurable {f : Î± â†’ Î³} (hf : continuous f) :
  measurable f :=
hf.borel_measurable.mono opens_measurable_space.borel_le
  (le_of_eq $ borel_space.measurable_eq)

/-- A continuous function from an `opens_measurable_space` to a `borel_space`
is ae-measurable. -/
lemma continuous.ae_measurable {f : Î± â†’ Î³} (h : continuous f) (Î¼ : measure Î±) : ae_measurable f Î¼ :=
h.measurable.ae_measurable

lemma closed_embedding.measurable {f : Î± â†’ Î³} (hf : closed_embedding f) :
  measurable f :=
hf.continuous.measurable

lemma continuous.is_open_pos_measure_map {f : Î² â†’ Î³} (hf : continuous f)
  (hf_surj : function.surjective f) {Î¼ : measure Î²} [Î¼.is_open_pos_measure] :
  (measure.map f Î¼).is_open_pos_measure :=
begin
  refine âŸ¨Î» U hUo hUne, _âŸ©,
  rw [measure.map_apply hf.measurable hUo.measurable_set],
  exact (hUo.preimage hf).measure_ne_zero Î¼ (hf_surj.nonempty_preimage.mpr hUne)
end

/-- If a function is defined piecewise in terms of functions which are continuous on their
respective pieces, then it is measurable. -/
lemma continuous_on.measurable_piecewise
  {f g : Î± â†’ Î³} {s : set Î±} [Î  (j : Î±), decidable (j âˆˆ s)]
  (hf : continuous_on f s) (hg : continuous_on g sá¶œ) (hs : measurable_set s) :
  measurable (s.piecewise f g) :=
begin
  refine measurable_of_is_open (Î» t ht, _),
  rw [piecewise_preimage, set.ite],
  apply measurable_set.union,
  { rcases _root_.continuous_on_iff'.1 hf t ht with âŸ¨u, u_open, huâŸ©,
    rw hu,
    exact u_open.measurable_set.inter hs },
  { rcases _root_.continuous_on_iff'.1 hg t ht with âŸ¨u, u_open, huâŸ©,
    rw [diff_eq_compl_inter, inter_comm, hu],
    exact u_open.measurable_set.inter hs.compl }
end

@[priority 100, to_additive]
instance has_continuous_mul.has_measurable_mul [has_mul Î³] [has_continuous_mul Î³] :
  has_measurable_mul Î³ :=
{ measurable_const_mul := Î» c, (continuous_const.mul continuous_id).measurable,
  measurable_mul_const := Î» c, (continuous_id.mul continuous_const).measurable }

@[priority 100]
instance has_continuous_sub.has_measurable_sub [has_sub Î³] [has_continuous_sub Î³] :
  has_measurable_sub Î³ :=
{ measurable_const_sub := Î» c, (continuous_const.sub continuous_id).measurable,
  measurable_sub_const := Î» c, (continuous_id.sub continuous_const).measurable }

@[priority 100, to_additive]
instance topological_group.has_measurable_inv [group Î³] [topological_group Î³] :
  has_measurable_inv Î³ :=
âŸ¨continuous_inv.measurableâŸ©

@[priority 100]
instance has_continuous_smul.has_measurable_smul {M Î±} [topological_space M]
  [topological_space Î±] [measurable_space M] [measurable_space Î±]
  [opens_measurable_space M] [borel_space Î±] [has_scalar M Î±] [has_continuous_smul M Î±] :
  has_measurable_smul M Î± :=
âŸ¨Î» c, (continuous_const_smul _).measurable,
  Î» y, (continuous_id.smul continuous_const).measurableâŸ©

section lattice

@[priority 100]
instance has_continuous_sup.has_measurable_sup [has_sup Î³] [has_continuous_sup Î³] :
  has_measurable_sup Î³ :=
{ measurable_const_sup := Î» c, (continuous_const.sup continuous_id).measurable,
  measurable_sup_const := Î» c, (continuous_id.sup continuous_const).measurable }

@[priority 100]
instance has_continuous_sup.has_measurable_supâ‚‚ [second_countable_topology Î³] [has_sup Î³]
  [has_continuous_sup Î³] :
  has_measurable_supâ‚‚ Î³ :=
âŸ¨continuous_sup.measurableâŸ©

@[priority 100]
instance has_continuous_inf.has_measurable_inf [has_inf Î³] [has_continuous_inf Î³] :
  has_measurable_inf Î³ :=
{ measurable_const_inf := Î» c, (continuous_const.inf continuous_id).measurable,
  measurable_inf_const := Î» c, (continuous_id.inf continuous_const).measurable }

@[priority 100]
instance has_continuous_inf.has_measurable_infâ‚‚ [second_countable_topology Î³] [has_inf Î³]
  [has_continuous_inf Î³] :
  has_measurable_infâ‚‚ Î³ :=
âŸ¨continuous_inf.measurableâŸ©

end lattice

section homeomorph

@[measurability] protected lemma homeomorph.measurable (h : Î± â‰ƒâ‚œ Î³) : measurable h :=
h.continuous.measurable

/-- A homeomorphism between two Borel spaces is a measurable equivalence.-/
def homeomorph.to_measurable_equiv (h : Î³ â‰ƒâ‚œ Î³â‚‚) : Î³ â‰ƒáµ Î³â‚‚ :=
{ measurable_to_fun := h.measurable,
  measurable_inv_fun := h.symm.measurable,
  to_equiv := h.to_equiv }

@[simp]
lemma homeomorph.to_measurable_equiv_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) : (h.to_measurable_equiv : Î³ â†’ Î³â‚‚) = h :=
rfl

@[simp] lemma homeomorph.to_measurable_equiv_symm_coe (h : Î³ â‰ƒâ‚œ Î³â‚‚) :
  (h.to_measurable_equiv.symm : Î³â‚‚ â†’ Î³) = h.symm :=
rfl

end homeomorph

@[measurability] lemma continuous_map.measurable (f : C(Î±, Î³)) : measurable f :=
f.continuous.measurable

lemma measurable_of_continuous_on_compl_singleton [t1_space Î±] {f : Î± â†’ Î³} (a : Î±)
  (hf : continuous_on f {a}á¶œ) :
  measurable f :=
measurable_of_measurable_on_compl_singleton a
  (continuous_on_iff_continuous_restrict.1 hf).measurable

lemma continuous.measurable2 [second_countable_topology Î±] [second_countable_topology Î²]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³}
  (h : continuous (Î» p : Î± Ã— Î², c p.1 p.2)) (hf : measurable f) (hg : measurable g) :
  measurable (Î» a, c (f a) (g a)) :=
h.measurable.comp (hf.prod_mk hg)

lemma continuous.ae_measurable2 [second_countable_topology Î±] [second_countable_topology Î²]
  {f : Î´ â†’ Î±} {g : Î´ â†’ Î²} {c : Î± â†’ Î² â†’ Î³} {Î¼ : measure Î´}
  (h : continuous (Î» p : Î± Ã— Î², c p.1 p.2)) (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) :
  ae_measurable (Î» a, c (f a) (g a)) Î¼ :=
h.measurable.comp_ae_measurable (hf.prod_mk hg)

@[priority 100]
instance has_continuous_invâ‚€.has_measurable_inv [group_with_zero Î³] [t1_space Î³]
  [has_continuous_invâ‚€ Î³] :
  has_measurable_inv Î³ :=
âŸ¨measurable_of_continuous_on_compl_singleton 0 continuous_on_invâ‚€âŸ©

@[priority 100, to_additive]
instance has_continuous_mul.has_measurable_mulâ‚‚ [second_countable_topology Î³] [has_mul Î³]
  [has_continuous_mul Î³] : has_measurable_mulâ‚‚ Î³ :=
âŸ¨continuous_mul.measurableâŸ©

@[priority 100]
instance has_continuous_sub.has_measurable_subâ‚‚ [second_countable_topology Î³] [has_sub Î³]
  [has_continuous_sub Î³] : has_measurable_subâ‚‚ Î³ :=
âŸ¨continuous_sub.measurableâŸ©

@[priority 100]
instance has_continuous_smul.has_measurable_smulâ‚‚ {M Î±} [topological_space M]
  [second_countable_topology M] [measurable_space M] [opens_measurable_space M]
  [topological_space Î±] [second_countable_topology Î±] [measurable_space Î±]
  [borel_space Î±] [has_scalar M Î±] [has_continuous_smul M Î±] :
  has_measurable_smulâ‚‚ M Î± :=
âŸ¨continuous_smul.measurableâŸ©

end

section borel_space
variables [topological_space Î±] [measurable_space Î±] [borel_space Î±]
  [topological_space Î²] [measurable_space Î²] [borel_space Î²]
  [topological_space Î³] [measurable_space Î³] [borel_space Î³]
  [measurable_space Î´]

lemma pi_le_borel_pi {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [Î  i, topological_space (Ï€ i)]
  [Î  i, measurable_space (Ï€ i)] [âˆ€ i, borel_space (Ï€ i)] :
  measurable_space.pi â‰¤ borel (Î  i, Ï€ i) :=
begin
  have : â€¹Î  i, measurable_space (Ï€ i)â€º = Î» i, borel (Ï€ i) :=
    funext (Î» i, borel_space.measurable_eq),
  rw [this],
  exact supr_le (Î» i, comap_le_iff_le_map.2 $ (continuous_apply i).borel_measurable)
end

lemma prod_le_borel_prod : prod.measurable_space â‰¤ borel (Î± Ã— Î²) :=
begin
  rw [â€¹borel_space Î±â€º.measurable_eq, â€¹borel_space Î²â€º.measurable_eq],
  refine sup_le _ _,
  { exact comap_le_iff_le_map.mpr continuous_fst.borel_measurable },
  { exact comap_le_iff_le_map.mpr continuous_snd.borel_measurable }
end

instance pi.borel_space_fintype_encodable {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [encodable Î¹]
  [t' : Î  i, topological_space (Ï€ i)]
  [Î  i, measurable_space (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)]
  [âˆ€ i, borel_space (Ï€ i)] :
  borel_space (Î  i, Ï€ i) :=
âŸ¨le_antisymm pi_le_borel_pi opens_measurable_space.borel_leâŸ©

instance pi.borel_space_fintype {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [fintype Î¹]
  [t' : Î  i, topological_space (Ï€ i)]
  [Î  i, measurable_space (Ï€ i)] [âˆ€ i, second_countable_topology (Ï€ i)]
  [âˆ€ i, borel_space (Ï€ i)] :
  borel_space (Î  i, Ï€ i) :=
âŸ¨le_antisymm pi_le_borel_pi opens_measurable_space.borel_leâŸ©

instance prod.borel_space [second_countable_topology Î±] [second_countable_topology Î²] :
  borel_space (Î± Ã— Î²) :=
âŸ¨le_antisymm prod_le_borel_prod opens_measurable_space.borel_leâŸ©

protected lemma embedding.measurable_embedding {f : Î± â†’ Î²} (hâ‚ : embedding f)
  (hâ‚‚ : measurable_set (range f)) : measurable_embedding f :=
show measurable_embedding (coe âˆ˜ (homeomorph.of_embedding f hâ‚).to_measurable_equiv),
from (measurable_embedding.subtype_coe hâ‚‚).comp (measurable_equiv.measurable_embedding _)

protected lemma closed_embedding.measurable_embedding {f : Î± â†’ Î²} (h : closed_embedding f) :
  measurable_embedding f :=
h.to_embedding.measurable_embedding h.closed_range.measurable_set

protected lemma open_embedding.measurable_embedding {f : Î± â†’ Î²} (h : open_embedding f) :
  measurable_embedding f :=
h.to_embedding.measurable_embedding h.open_range.measurable_set

section linear_order

variables [linear_order Î±] [order_topology Î±] [second_countable_topology Î±]

lemma measurable_of_Iio {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (f â»Â¹' Iio x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Iio _),
  rintro _ âŸ¨x, rflâŸ©, exact hf x
end

lemma upper_semicontinuous.measurable [topological_space Î´] [opens_measurable_space Î´]
  {f : Î´ â†’ Î±} (hf : upper_semicontinuous f) : measurable f :=
measurable_of_Iio (Î» y, (hf.is_open_preimage y).measurable_set)

lemma measurable_of_Ioi {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (f â»Â¹' Ioi x)) : measurable f :=
begin
  convert measurable_generate_from _,
  exact borel_space.measurable_eq.trans (borel_eq_generate_from_Ioi _),
  rintro _ âŸ¨x, rflâŸ©, exact hf x
end

lemma lower_semicontinuous.measurable [topological_space Î´] [opens_measurable_space Î´]
  {f : Î´ â†’ Î±} (hf : lower_semicontinuous f) : measurable f :=
measurable_of_Ioi (Î» y, (hf.is_open_preimage y).measurable_set)

lemma measurable_of_Iic {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (f â»Â¹' Iic x)) : measurable f :=
begin
  apply measurable_of_Ioi,
  simp_rw [â† compl_Iic, preimage_compl, measurable_set.compl_iff],
  assumption
end

lemma measurable_of_Ici {f : Î´ â†’ Î±} (hf : âˆ€ x, measurable_set (f â»Â¹' Ici x)) : measurable f :=
begin
  apply measurable_of_Iio,
  simp_rw [â† compl_Ici, preimage_compl, measurable_set.compl_iff],
  assumption
end

lemma measurable.is_lub {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i))
  (hg : âˆ€ b, is_lub {a | âˆƒ i, f i b = a} (g b)) :
  measurable g :=
begin
  change âˆ€ b, is_lub (range $ Î» i, f i b) (g b) at hg,
  rw [â€¹borel_space Î±â€º.measurable_eq, borel_eq_generate_from_Ioi Î±],
  apply measurable_generate_from,
  rintro _ âŸ¨a, rflâŸ©,
  simp_rw [set.preimage, mem_Ioi, lt_is_lub_iff (hg _), exists_range_iff, set_of_exists],
  exact measurable_set.Union (Î» i, hf i (is_open_lt' _).measurable_set)
end

private lemma ae_measurable.is_lub_of_nonempty {Î¹} (hÎ¹ : nonempty Î¹)
  {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, is_lub {a | âˆƒ i, f i b = a} (g b)) :
  ae_measurable g Î¼ :=
begin
  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := Î» x f', is_lub {a | âˆƒ i, f' i = a} (g x),
  let g_seq := Î» x, ite (x âˆˆ ae_seq_set hf p) (g x) (âŸ¨g xâŸ© : nonempty Î±).some,
  have hg_seq : âˆ€ b, is_lub {a | âˆƒ i, ae_seq hf p i b = a} (g_seq b),
  { intro b,
    haveI hÎ± : nonempty Î± := nonempty.map g âŸ¨bâŸ©,
    simp only [ae_seq, g_seq],
    split_ifs,
    { have h_set_eq : {a : Î± | âˆƒ (i : Î¹), (hf i).mk (f i) b = a} = {a : Î± | âˆƒ (i : Î¹), f i b = a},
      { ext x,
        simp_rw [set.mem_set_of_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h], },
      rw h_set_eq,
      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h, },
    { have h_singleton : {a : Î± | âˆƒ (i : Î¹), hÎ±.some = a} = {hÎ±.some},
      { ext1 x,
        exact âŸ¨Î» hx, hx.some_spec.symm, Î» hx, âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©, },
      rw h_singleton,
      exact is_lub_singleton, }, },
  refine âŸ¨g_seq, measurable.is_lub (ae_seq.measurable hf p) hg_seq, _âŸ©,
  exact (ite_ae_eq_of_measure_compl_zero g (Î» x, (âŸ¨g xâŸ© : nonempty Î±).some) (ae_seq_set hf p)
    (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm,
end

lemma ae_measurable.is_lub {Î¹} {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, is_lub {a | âˆƒ i, f i b = a} (g b)) :
  ae_measurable g Î¼ :=
begin
  by_cases hÎ¼ : Î¼ = 0, { rw hÎ¼, exact ae_measurable_zero_measure },
  haveI : Î¼.ae.ne_bot, { simpa [ne_bot_iff] },
  by_cases hÎ¹ : nonempty Î¹, { exact ae_measurable.is_lub_of_nonempty hÎ¹ hf hg, },
  suffices : âˆƒ x, g =áµ[Î¼] Î» y, g x,
  by { exact âŸ¨(Î» y, g this.some), measurable_const, this.some_specâŸ©, },
  have h_empty : âˆ€ x, {a : Î± | âˆƒ (i : Î¹), f i x = a} = âˆ…,
  { intro x,
    ext1 y,
    rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false],
    exact Î» hi, hÎ¹ (nonempty_of_exists hi), },
  simp_rw h_empty at hg,
  exact âŸ¨hg.exists.some, hg.mono (Î» y hy, is_lub.unique hy hg.exists.some_spec)âŸ©,
end

lemma measurable.is_glb {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i))
  (hg : âˆ€ b, is_glb {a | âˆƒ i, f i b = a} (g b)) :
  measurable g :=
begin
  change âˆ€ b, is_glb (range $ Î» i, f i b) (g b) at hg,
  rw [â€¹borel_space Î±â€º.measurable_eq, borel_eq_generate_from_Iio Î±],
  apply measurable_generate_from,
  rintro _ âŸ¨a, rflâŸ©,
  simp_rw [set.preimage, mem_Iio, is_glb_lt_iff (hg _), exists_range_iff, set_of_exists],
  exact measurable_set.Union (Î» i, hf i (is_open_gt' _).measurable_set)
end

private lemma ae_measurable.is_glb_of_nonempty {Î¹} (hÎ¹ : nonempty Î¹)
  {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, is_glb {a | âˆƒ i, f i b = a} (g b)) :
  ae_measurable g Î¼ :=
begin
  let p : Î´ â†’ (Î¹ â†’ Î±) â†’ Prop := Î» x f', is_glb {a | âˆƒ i, f' i = a} (g x),
  let g_seq := Î» x, ite (x âˆˆ ae_seq_set hf p) (g x) (âŸ¨g xâŸ© : nonempty Î±).some,
  have hg_seq : âˆ€ b, is_glb {a | âˆƒ i, ae_seq hf p i b = a} (g_seq b),
  { intro b,
    haveI hÎ± : nonempty Î± := nonempty.map g âŸ¨bâŸ©,
    simp only [ae_seq, g_seq],
    split_ifs,
    { have h_set_eq : {a : Î± | âˆƒ (i : Î¹), (hf i).mk (f i) b = a} = {a : Î± | âˆƒ (i : Î¹), f i b = a},
      { ext x,
        simp_rw [set.mem_set_of_eq, ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h], },
      rw h_set_eq,
      exact ae_seq.fun_prop_of_mem_ae_seq_set hf h, },
    { have h_singleton : {a : Î± | âˆƒ (i : Î¹), hÎ±.some = a} = {hÎ±.some},
      { ext1 x,
        exact âŸ¨Î» hx, hx.some_spec.symm, Î» hx, âŸ¨hÎ¹.some, hx.symmâŸ©âŸ©, },
      rw h_singleton,
      exact is_glb_singleton, }, },
  refine âŸ¨g_seq, measurable.is_glb (ae_seq.measurable hf p) hg_seq, _âŸ©,
  exact (ite_ae_eq_of_measure_compl_zero g (Î» x, (âŸ¨g xâŸ© : nonempty Î±).some) (ae_seq_set hf p)
    (ae_seq.measure_compl_ae_seq_set_eq_zero hf hg)).symm,
end

lemma ae_measurable.is_glb {Î¹} {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} {g : Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) (hg : âˆ€áµ b âˆ‚Î¼, is_glb {a | âˆƒ i, f i b = a} (g b)) :
  ae_measurable g Î¼ :=
begin
  by_cases hÎ¼ : Î¼ = 0, { rw hÎ¼, exact ae_measurable_zero_measure },
  haveI : Î¼.ae.ne_bot, { simpa [ne_bot_iff] },
  by_cases hÎ¹ : nonempty Î¹, { exact ae_measurable.is_glb_of_nonempty hÎ¹ hf hg, },
  suffices : âˆƒ x, g =áµ[Î¼] Î» y, g x,
  by { exact âŸ¨(Î» y, g this.some), measurable_const, this.some_specâŸ©, },
  have h_empty : âˆ€ x, {a : Î± | âˆƒ (i : Î¹), f i x = a} = âˆ…,
  { intro x,
    ext1 y,
    rw [set.mem_set_of_eq, set.mem_empty_eq, iff_false],
    exact Î» hi, hÎ¹ (nonempty_of_exists hi), },
  simp_rw h_empty at hg,
  exact âŸ¨hg.exists.some, hg.mono (Î» y hy, is_glb.unique hy hg.exists.some_spec)âŸ©,
end

protected lemma monotone.measurable [linear_order Î²] [order_closed_topology Î²] {f : Î² â†’ Î±}
  (hf : monotone f) : measurable f :=
suffices h : âˆ€ x, ord_connected (f â»Â¹' Ioi x),
  from measurable_of_Ioi (Î» x, (h x).measurable_set),
Î» x, ord_connected_def.mpr (Î» a ha b hb c hc, lt_of_lt_of_le ha (hf hc.1))

lemma ae_measurable_restrict_of_monotone_on [linear_order Î²] [order_closed_topology Î²]
  {Î¼ : measure Î²} {s : set Î²} (hs : measurable_set s) {f : Î² â†’ Î±} (hf : monotone_on f s) :
  ae_measurable f (Î¼.restrict s) :=
have this : monotone (f âˆ˜ coe : s â†’ Î±), from Î» âŸ¨x, hxâŸ© âŸ¨y, hyâŸ© (hxy : x â‰¤ y), hf hx hy hxy,
ae_measurable_restrict_of_measurable_subtype hs this.measurable

protected lemma antitone.measurable [linear_order Î²] [order_closed_topology Î²] {f : Î² â†’ Î±}
  (hf : antitone f) :
  measurable f :=
@monotone.measurable (order_dual Î±) Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ hf

lemma ae_measurable_restrict_of_antitone_on [linear_order Î²] [order_closed_topology Î²]
  {Î¼ : measure Î²} {s : set Î²} (hs : measurable_set s) {f : Î² â†’ Î±} (hf : antitone_on f s) :
  ae_measurable f (Î¼.restrict s) :=
@ae_measurable_restrict_of_monotone_on (order_dual Î±) Î² _ _ â€¹_â€º _ _ _ _ _ â€¹_â€º _ _ _ _ hs _ hf

end linear_order

@[measurability]
lemma measurable.supr_Prop {Î±} [measurable_space Î±] [complete_lattice Î±]
  (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î» b, â¨† h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact supr_pos h end)
  (assume h : Â¬p, begin convert measurable_const, funext, exact supr_neg h end)

@[measurability]
lemma measurable.infi_Prop {Î±} [measurable_space Î±] [complete_lattice Î±]
  (p : Prop) {f : Î´ â†’ Î±} (hf : measurable f) :
  measurable (Î» b, â¨… h : p, f b) :=
classical.by_cases
  (assume h : p, begin convert hf, funext, exact infi_pos h end )
  (assume h : Â¬p, begin convert measurable_const, funext, exact infi_neg h end)

section complete_linear_order

variables [complete_linear_order Î±] [order_topology Î±] [second_countable_topology Î±]

@[measurability]
lemma measurable_supr {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» b, â¨† i, f i b) :=
measurable.is_lub hf $ Î» b, is_lub_supr

@[measurability]
lemma ae_measurable_supr {Î¹} {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) :
  ae_measurable (Î» b, â¨† i, f i b) Î¼ :=
ae_measurable.is_lub hf $ (ae_of_all Î¼ (Î» b, is_lub_supr))

@[measurability]
lemma measurable_infi {Î¹} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» b, â¨… i, f i b) :=
measurable.is_glb hf $ Î» b, is_glb_infi

@[measurability]
lemma ae_measurable_infi {Î¹} {Î¼ : measure Î´} [encodable Î¹] {f : Î¹ â†’ Î´ â†’ Î±}
  (hf : âˆ€ i, ae_measurable (f i) Î¼) :
  ae_measurable (Î» b, â¨… i, f i b) Î¼ :=
ae_measurable.is_glb hf $ (ae_of_all Î¼ (Î» b, is_glb_infi))

lemma measurable_bsupr {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, measurable (f i)) : measurable (Î» b, â¨† i âˆˆ s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [supr_subtype'],
     exact measurable_supr (Î» i, hf i) }

lemma ae_measurable_bsupr {Î¹} {Î¼ : measure Î´} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, ae_measurable (f i) Î¼) : ae_measurable (Î» b, â¨† i âˆˆ s, f i b) Î¼ :=
begin
  haveI : encodable s := hs.to_encodable,
  simp only [supr_subtype'],
  exact ae_measurable_supr (Î» i, hf i),
end

lemma measurable_binfi {Î¹} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, measurable (f i)) : measurable (Î» b, â¨… i âˆˆ s, f i b) :=
by { haveI : encodable s := hs.to_encodable, simp only [infi_subtype'],
     exact measurable_infi (Î» i, hf i) }

lemma ae_measurable_binfi {Î¹} {Î¼ : measure Î´} (s : set Î¹) {f : Î¹ â†’ Î´ â†’ Î±} (hs : countable s)
  (hf : âˆ€ i, ae_measurable (f i) Î¼) : ae_measurable (Î» b, â¨… i âˆˆ s, f i b) Î¼ :=
begin
  haveI : encodable s := hs.to_encodable,
  simp only [infi_subtype'],
  exact ae_measurable_infi (Î» i, hf i),
end

/-- `liminf` over a general filter is measurable. See `measurable_liminf` for the version over `â„•`.
-/
lemma measurable_liminf' {Î¹ Î¹'} {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ i, measurable (f i))
  {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).countable) :
  measurable (Î» x, liminf u (Î» i, f i x)) :=
begin
  simp_rw [hu.to_has_basis.liminf_eq_supr_infi],
  refine measurable_bsupr _ hu.countable _,
  exact Î» i, measurable_binfi _ (hs i) hf
end

/-- `limsup` over a general filter is measurable. See `measurable_limsup` for the version over `â„•`.
-/
lemma measurable_limsup' {Î¹ Î¹'}  {f : Î¹ â†’ Î´ â†’ Î±} {u : filter Î¹} (hf : âˆ€ i, measurable (f i))
  {p : Î¹' â†’ Prop} {s : Î¹' â†’ set Î¹} (hu : u.has_countable_basis p s) (hs : âˆ€ i, (s i).countable) :
  measurable (Î» x, limsup u (Î» i, f i x)) :=
begin
  simp_rw [hu.to_has_basis.limsup_eq_infi_supr],
  refine measurable_binfi _ hu.countable _,
  exact Î» i, measurable_bsupr _ (hs i) hf
end

/-- `liminf` over `â„•` is measurable. See `measurable_liminf'` for a version with a general filter.
-/
@[measurability]
lemma measurable_liminf {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» x, liminf at_top (Î» i, f i x)) :=
measurable_liminf' hf at_top_countable_basis (Î» i, countable_encodable _)

/-- `limsup` over `â„•` is measurable. See `measurable_limsup'` for a version with a general filter.
-/
@[measurability]
lemma measurable_limsup {f : â„• â†’ Î´ â†’ Î±} (hf : âˆ€ i, measurable (f i)) :
  measurable (Î» x, limsup at_top (Î» i, f i x)) :=
measurable_limsup' hf at_top_countable_basis (Î» i, countable_encodable _)

end complete_linear_order

section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Î±] [order_topology Î±] [second_countable_topology Î±]

lemma measurable_cSup {Î¹} {f : Î¹ â†’ Î´ â†’ Î±} {s : set Î¹} (hs : s.countable)
  (hf : âˆ€ i, measurable (f i)) (bdd : âˆ€ x, bdd_above ((Î» i, f i x) '' s)) :
  measurable (Î» x, Sup ((Î» i, f i x) '' s)) :=
begin
  cases eq_empty_or_nonempty s with h2s h2s,
  { simp [h2s, measurable_const] },
  { apply measurable_of_Iic, intro y,
    simp_rw [preimage, mem_Iic, cSup_le_iff (bdd _) (h2s.image _), ball_image_iff, set_of_forall],
    exact measurable_set.bInter hs (Î» i hi, measurable_set_le (hf i) measurable_const) }
end

end conditionally_complete_linear_order

/-- Convert a `homeomorph` to a `measurable_equiv`. -/
def homemorph.to_measurable_equiv (h : Î± â‰ƒâ‚œ Î²) : Î± â‰ƒáµ Î² :=
{ to_equiv := h.to_equiv,
  measurable_to_fun := h.continuous_to_fun.measurable,
  measurable_inv_fun := h.continuous_inv_fun.measurable }

protected lemma is_finite_measure_on_compacts.map
  {Î± : Type*} {m0 : measurable_space Î±} [topological_space Î±] [opens_measurable_space Î±]
  {Î² : Type*} [measurable_space Î²] [topological_space Î²] [borel_space Î²]
  [t2_space Î²] (Î¼ : measure Î±) [is_finite_measure_on_compacts Î¼] (f : Î± â‰ƒâ‚œ Î²) :
  is_finite_measure_on_compacts (measure.map f Î¼) :=
âŸ¨begin
  assume K hK,
  rw [measure.map_apply f.measurable hK.measurable_set],
  apply is_compact.measure_lt_top,
  rwa f.compact_preimage
endâŸ©

end borel_space

instance empty.borel_space : borel_space empty := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance unit.borel_space : borel_space unit := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance bool.borel_space : borel_space bool := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance nat.borel_space : borel_space â„• := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance int.borel_space : borel_space â„¤ := âŸ¨borel_eq_top_of_discrete.symmâŸ©
instance rat.borel_space : borel_space â„š := âŸ¨borel_eq_top_of_encodable.symmâŸ©

@[priority 900]
instance is_R_or_C.measurable_space {ğ•œ : Type*} [is_R_or_C ğ•œ] : measurable_space ğ•œ := borel ğ•œ
@[priority 900]
instance is_R_or_C.borel_space {ğ•œ : Type*} [is_R_or_C ğ•œ] : borel_space ğ•œ := âŸ¨rflâŸ©

/- Instances on `real` and `complex` are special cases of `is_R_or_C` but without these instances,
Lean fails to prove `borel_space (Î¹ â†’ â„)`, so we leave them here. -/

instance real.measurable_space : measurable_space â„ := borel â„
instance real.borel_space : borel_space â„ := âŸ¨rflâŸ©

instance nnreal.measurable_space : measurable_space â„â‰¥0 := subtype.measurable_space
instance nnreal.borel_space : borel_space â„â‰¥0 := subtype.borel_space _

instance ennreal.measurable_space : measurable_space â„â‰¥0âˆ := borel â„â‰¥0âˆ
instance ennreal.borel_space : borel_space â„â‰¥0âˆ := âŸ¨rflâŸ©

instance ereal.measurable_space : measurable_space ereal := borel ereal
instance ereal.borel_space : borel_space ereal := âŸ¨rflâŸ©

instance complex.measurable_space : measurable_space â„‚ := borel â„‚
instance complex.borel_space : borel_space â„‚ := âŸ¨rflâŸ©

/-- One can cut out `â„â‰¥0âˆ` into the sets `{0}`, `Ico (t^n) (t^(n+1))` for `n : â„¤` and `{âˆ}`. This
gives a way to compute the measure of a set in terms of sets on which a given function `f` does not
fluctuate by more than `t`. -/
lemma measure_eq_measure_preimage_add_measure_tsum_Ico_zpow [measurable_space Î±] (Î¼ : measure Î±)
  {f : Î± â†’ â„â‰¥0âˆ} (hf : measurable f) {s : set Î±} (hs : measurable_set s) {t : â„â‰¥0} (ht : 1 < t) :
  Î¼ s = Î¼ (s âˆ© fâ»Â¹' {0}) + Î¼ (s âˆ© fâ»Â¹' {âˆ}) + âˆ‘' (n : â„¤), Î¼ (s âˆ© fâ»Â¹' (Ico (t^n) (t^(n+1)))) :=
begin
  have A : Î¼ s = Î¼ (s âˆ© fâ»Â¹' {0}) + Î¼ (s âˆ© fâ»Â¹' (Ioi 0)),
  { rw â† measure_union,
    { congr' 1,
      ext x,
      have : 0 = f x âˆ¨ 0 < f x := eq_or_lt_of_le bot_le,
      rw eq_comm at this,
      simp only [â†and_or_distrib_left, this, mem_singleton_iff, mem_inter_eq, and_true,
        mem_union_eq, mem_Ioi, mem_preimage], },
    { apply disjoint_left.2 (Î» x hx h'x, _),
      have : 0 < f x := h'x.2,
      exact lt_irrefl 0 (this.trans_le hx.2.le) },
    { exact hs.inter (hf measurable_set_Ioi) } },
  have B : Î¼ (s âˆ© fâ»Â¹' (Ioi 0)) = Î¼ (s âˆ© fâ»Â¹' {âˆ}) + Î¼ (s âˆ© fâ»Â¹' (Ioo 0 âˆ)),
  { rw â† measure_union,
    { rw â† inter_union_distrib_left,
      congr,
      ext x,
      simp only [mem_singleton_iff, mem_union_eq, mem_Ioo, mem_Ioi, mem_preimage],
      have H : f x = âˆ âˆ¨ f x < âˆ := eq_or_lt_of_le le_top,
      cases H,
      { simp only [H, eq_self_iff_true, or_false, with_top.zero_lt_top, not_top_lt, and_false] },
      { simp only [H, H.ne, and_true, false_or] } },
    { apply disjoint_left.2 (Î» x hx h'x, _),
      have : f x < âˆ := h'x.2.2,
      exact lt_irrefl _ (this.trans_le (le_of_eq hx.2.symm)) },
    { exact hs.inter (hf measurable_set_Ioo) } },
  have C : Î¼ (s âˆ© fâ»Â¹' (Ioo 0 âˆ)) = âˆ‘' (n : â„¤), Î¼ (s âˆ© fâ»Â¹' (Ico (t^n) (t^(n+1)))),
  { rw [â† measure_Union, ennreal.Ioo_zero_top_eq_Union_Ico_zpow (ennreal.one_lt_coe_iff.2 ht)
         ennreal.coe_ne_top, preimage_Union, inter_Union],
    { assume i j,
      simp only [function.on_fun],
      wlog h : i â‰¤ j := le_total i j using [i j, j i] tactic.skip,
      { assume hij,
        replace hij : i + 1 â‰¤ j := lt_of_le_of_ne h hij,
        apply disjoint_left.2 (Î» x hx h'x, lt_irrefl (f x) _),
        calc f x < t ^ (i + 1) : hx.2.2
        ... â‰¤ t ^ j : ennreal.zpow_le_of_le (ennreal.one_le_coe_iff.2 ht.le) hij
        ... â‰¤ f x : h'x.2.1 },
      { assume hij,
        rw disjoint.comm,
        exact this hij.symm } },
    { assume n,
      exact hs.inter (hf measurable_set_Ico) } },
  rw [A, B, C, add_assoc],
end

section metric_space

variables [metric_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
variables [measurable_space Î²] {x : Î±} {Îµ : â„}

open metric

@[measurability]
lemma measurable_set_ball : measurable_set (metric.ball x Îµ) :=
metric.is_open_ball.measurable_set

@[measurability]
lemma measurable_set_closed_ball : measurable_set (metric.closed_ball x Îµ) :=
metric.is_closed_ball.measurable_set

@[measurability]
lemma measurable_inf_dist {s : set Î±} : measurable (Î» x, inf_dist x s) :=
(continuous_inf_dist_pt s).measurable

@[measurability]
lemma measurable.inf_dist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
  measurable (Î» x, inf_dist (f x) s) :=
measurable_inf_dist.comp hf

@[measurability]
lemma measurable_inf_nndist {s : set Î±} : measurable (Î» x, inf_nndist x s) :=
(continuous_inf_nndist_pt s).measurable

@[measurability]
lemma measurable.inf_nndist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
  measurable (Î» x, inf_nndist (f x) s) :=
measurable_inf_nndist.comp hf

section
variables [second_countable_topology Î±]

@[measurability]
lemma measurable_dist : measurable (Î» p : Î± Ã— Î±, dist p.1 p.2) :=
continuous_dist.measurable

@[measurability]
lemma measurable.dist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, dist (f b) (g b)) :=
(@continuous_dist Î± _).measurable2 hf hg

@[measurability]
lemma measurable_nndist : measurable (Î» p : Î± Ã— Î±, nndist p.1 p.2) :=
continuous_nndist.measurable

@[measurability]
lemma measurable.nndist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, nndist (f b) (g b)) :=
(@continuous_nndist Î± _).measurable2 hf hg

end

/-- If a set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to the measure of its closure as `r` tends to `0`. -/
lemma tendsto_measure_cthickening {Î¼ : measure Î±} {s : set Î±}
  (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  âˆ) :
  tendsto (Î» r, Î¼ (cthickening r s)) (ğ“ 0) (ğ“ (Î¼ (closure s))) :=
begin
  have A : tendsto (Î» r, Î¼ (cthickening r s)) (ğ“[Ioi 0] 0) (ğ“ (Î¼ (closure s))),
  { rw closure_eq_Inter_cthickening,
    exact tendsto_measure_bInter_gt (Î» r hr, is_closed_cthickening.measurable_set)
      (Î» i j ipos ij, cthickening_mono ij _) hs },
  have B : tendsto (Î» r, Î¼ (cthickening r s)) (ğ“[Iic 0] 0) (ğ“ (Î¼ (closure s))),
  { apply tendsto.congr' _ tendsto_const_nhds,
    filter_upwards [self_mem_nhds_within] with _ hr,
    rw cthickening_of_nonpos hr, },
  convert B.sup A,
  exact (nhds_left_sup_nhds_right' 0).symm,
end

/-- If a closed set has a closed thickening with finite measure, then the measure of its `r`-closed
thickenings converges to its measure as `r` tends to `0`. -/
lemma tendsto_measure_cthickening_of_is_closed {Î¼ : measure Î±} {s : set Î±}
  (hs : âˆƒ R > 0, Î¼ (cthickening R s) â‰  âˆ) (h's : is_closed s) :
  tendsto (Î» r, Î¼ (cthickening r s)) (ğ“ 0) (ğ“ (Î¼ s)) :=
begin
  convert tendsto_measure_cthickening hs,
  exact h's.closure_eq.symm
end

/-- Given a compact set in a proper space, the measure of its `r`-closed thickenings converges to
its measure as `r` tends to `0`. -/
lemma tendsto_measure_cthickening_of_is_compact [proper_space Î±] {Î¼ : measure Î±}
  [is_finite_measure_on_compacts Î¼] {s : set Î±} (hs : is_compact s) :
  tendsto (Î» r, Î¼ (cthickening r s)) (ğ“ 0) (ğ“ (Î¼ s)) :=
tendsto_measure_cthickening_of_is_closed
  âŸ¨1, zero_lt_one, (bounded.measure_lt_top hs.bounded.cthickening).neâŸ© hs.is_closed

end metric_space

section emetric_space

variables [emetric_space Î±] [measurable_space Î±] [opens_measurable_space Î±]
variables [measurable_space Î²] {x : Î±} {Îµ : â„â‰¥0âˆ}

open emetric

@[measurability]
lemma measurable_set_eball : measurable_set (emetric.ball x Îµ) :=
emetric.is_open_ball.measurable_set

@[measurability]
lemma measurable_edist_right : measurable (edist x) :=
(continuous_const.edist continuous_id).measurable

@[measurability]
lemma measurable_edist_left : measurable (Î» y, edist y x) :=
(continuous_id.edist continuous_const).measurable

@[measurability]
lemma measurable_inf_edist {s : set Î±} : measurable (Î» x, inf_edist x s) :=
continuous_inf_edist.measurable

@[measurability]
lemma measurable.inf_edist {f : Î² â†’ Î±} (hf : measurable f) {s : set Î±} :
  measurable (Î» x, inf_edist (f x) s) :=
measurable_inf_edist.comp hf

variables [second_countable_topology Î±]

@[measurability]
lemma measurable_edist : measurable (Î» p : Î± Ã— Î±, edist p.1 p.2) :=
continuous_edist.measurable

@[measurability]
lemma measurable.edist {f g : Î² â†’ Î±} (hf : measurable f) (hg : measurable g) :
  measurable (Î» b, edist (f b) (g b)) :=
(@continuous_edist Î± _).measurable2 hf hg

@[measurability]
lemma ae_measurable.edist {f g : Î² â†’ Î±} {Î¼ : measure Î²}
  (hf : ae_measurable f Î¼) (hg : ae_measurable g Î¼) : ae_measurable (Î» a, edist (f a) (g a)) Î¼ :=
(@continuous_edist Î± _).ae_measurable2 hf hg

end emetric_space

namespace real
open measurable_space measure_theory

lemma borel_eq_generate_from_Ioo_rat :
  borel â„ = generate_from (â‹ƒ(a b : â„š) (h : a < b), {Ioo a b}) :=
is_topological_basis_Ioo_rat.borel_eq_generate_from

lemma is_pi_system_Ioo_rat : @is_pi_system â„ (â‹ƒ (a b : â„š) (h : a < b), {Ioo a b})  :=
begin
  convert is_pi_system_Ioo (coe : â„š â†’ â„) (coe : â„š â†’ â„),
  ext x,
  simp [eq_comm]
end

/-- The intervals `(-(n + 1), (n + 1))` form a finite spanning sets in the set of open intervals
with rational endpoints for a locally finite measure `Î¼` on `â„`. -/
def finite_spanning_sets_in_Ioo_rat (Î¼ : measure â„) [is_locally_finite_measure Î¼] :
  Î¼.finite_spanning_sets_in (â‹ƒ (a b : â„š) (h : a < b), {Ioo a b}) :=
{ set := Î» n, Ioo (-(n + 1)) (n + 1),
  set_mem := Î» n,
    begin
      simp only [mem_Union, mem_singleton_iff],
      refine âŸ¨-(n + 1), n + 1, _, by norm_castâŸ©,
      exact (neg_nonpos.2 (@nat.cast_nonneg â„š _ (n + 1))).trans_lt n.cast_add_one_pos
    end,
  finite := Î» n, measure_Ioo_lt_top,
  spanning := Union_eq_univ_iff.2 $ Î» x,
    âŸ¨âŒŠ|x|âŒ‹â‚Š, neg_lt.1 ((neg_le_abs_self x).trans_lt (nat.lt_floor_add_one _)),
      (le_abs_self x).trans_lt (nat.lt_floor_add_one _)âŸ© }

lemma measure_ext_Ioo_rat {Î¼ Î½ : measure â„} [is_locally_finite_measure Î¼]
  (h : âˆ€ a b : â„š, Î¼ (Ioo a b) = Î½ (Ioo a b)) : Î¼ = Î½ :=
(finite_spanning_sets_in_Ioo_rat Î¼).ext borel_eq_generate_from_Ioo_rat is_pi_system_Ioo_rat $
  by { simp only [mem_Union, mem_singleton_iff], rintro _ âŸ¨a, b, -, rflâŸ©, apply h }

lemma borel_eq_generate_from_Iio_rat :
  borel â„ = generate_from (â‹ƒ a : â„š, {Iio a}) :=
begin
  let g : measurable_space â„ := generate_from (â‹ƒ a : â„š, {Iio a}),
  refine le_antisymm _ _,
  { rw borel_eq_generate_from_Ioo_rat,
    refine generate_from_le (Î» t, _),
    simp only [mem_Union, mem_singleton_iff], rintro âŸ¨a, b, h, rflâŸ©,
    rw (set.ext (Î» x, _) : Ioo (a : â„) b = (â‹ƒc>a, (Iio c)á¶œ) âˆ© Iio b),
    { have hg : âˆ€ q : â„š, g.measurable_set' (Iio q) :=
        Î» q, generate_measurable.basic (Iio q) (by simp),
      refine @measurable_set.inter _ g _ _ _ (hg _),
      refine @measurable_set.bUnion _ _ g _ _ (countable_encodable _) (Î» c h, _),
      exact @measurable_set.compl _ _ g (hg _) },
    { suffices : x < â†‘b â†’ (â†‘a < x â†” âˆƒ (i : â„š), a < i âˆ§ â†‘i â‰¤ x), by simpa,
      refine Î» _, âŸ¨Î» h, _, Î» âŸ¨i, hai, hixâŸ©, (rat.cast_lt.2 hai).trans_le hixâŸ©,
      rcases exists_rat_btwn h with âŸ¨c, ac, cxâŸ©,
      exact âŸ¨c, rat.cast_lt.1 ac, cx.leâŸ© } },
  { refine measurable_space.generate_from_le (Î» _, _),
    simp only [mem_Union, mem_singleton_iff], rintro âŸ¨r, rflâŸ©, exact measurable_set_Iio }
end

end real

variable [measurable_space Î±]

@[measurability]
lemma measurable_real_to_nnreal : measurable (real.to_nnreal) :=
continuous_real_to_nnreal.measurable

@[measurability]
lemma measurable.real_to_nnreal {f : Î± â†’ â„} (hf : measurable f) :
  measurable (Î» x, real.to_nnreal (f x)) :=
measurable_real_to_nnreal.comp hf

@[measurability]
lemma ae_measurable.real_to_nnreal {f : Î± â†’ â„} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, real.to_nnreal (f x)) Î¼ :=
measurable_real_to_nnreal.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_nnreal_real : measurable (coe : â„â‰¥0 â†’ â„) :=
nnreal.continuous_coe.measurable

@[measurability]
lemma measurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} (hf : measurable f) :
  measurable (Î» x, (f x : â„)) :=
measurable_coe_nnreal_real.comp hf

@[measurability]
lemma ae_measurable.coe_nnreal_real {f : Î± â†’ â„â‰¥0} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x : â„)) Î¼ :=
measurable_coe_nnreal_real.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_nnreal_ennreal : measurable (coe : â„â‰¥0 â†’ â„â‰¥0âˆ) :=
ennreal.continuous_coe.measurable

@[measurability]
lemma measurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} (hf : measurable f) :
  measurable (Î» x, (f x : â„â‰¥0âˆ)) :=
ennreal.continuous_coe.measurable.comp hf

@[measurability]
lemma ae_measurable.coe_nnreal_ennreal {f : Î± â†’ â„â‰¥0} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x : â„â‰¥0âˆ)) Î¼ :=
ennreal.continuous_coe.measurable.comp_ae_measurable hf

@[measurability]
lemma measurable.ennreal_of_real {f : Î± â†’ â„} (hf : measurable f) :
  measurable (Î» x, ennreal.of_real (f x)) :=
ennreal.continuous_of_real.measurable.comp hf

/-- The set of finite `â„â‰¥0âˆ` numbers is `measurable_equiv` to `â„â‰¥0`. -/
def measurable_equiv.ennreal_equiv_nnreal : {r : â„â‰¥0âˆ | r â‰  âˆ} â‰ƒáµ â„â‰¥0 :=
ennreal.ne_top_homeomorph_nnreal.to_measurable_equiv

namespace ennreal

lemma measurable_of_measurable_nnreal {f : â„â‰¥0âˆ â†’ Î±}
  (h : measurable (Î» p : â„â‰¥0, f p)) : measurable f :=
measurable_of_measurable_on_compl_singleton âˆ
  (measurable_equiv.ennreal_equiv_nnreal.symm.measurable_comp_iff.1 h)

/-- `â„â‰¥0âˆ` is `measurable_equiv` to `â„â‰¥0 âŠ• unit`. -/
def ennreal_equiv_sum : â„â‰¥0âˆ â‰ƒáµ â„â‰¥0 âŠ• unit :=
{ measurable_to_fun  := measurable_of_measurable_nnreal measurable_inl,
  measurable_inv_fun := measurable_sum measurable_coe_nnreal_ennreal
    (@measurable_const â„â‰¥0âˆ unit _ _ âˆ),
  .. equiv.option_equiv_sum_punit â„â‰¥0 }

open function (uncurry)

lemma measurable_of_measurable_nnreal_prod [measurable_space Î²] [measurable_space Î³]
  {f : â„â‰¥0âˆ Ã— Î² â†’ Î³} (Hâ‚ : measurable (Î» p : â„â‰¥0 Ã— Î², f (p.1, p.2)))
  (Hâ‚‚ : measurable (Î» x, f (âˆ, x))) :
  measurable f :=
let e : â„â‰¥0âˆ Ã— Î² â‰ƒáµ â„â‰¥0 Ã— Î² âŠ• unit Ã— Î² :=
  (ennreal_equiv_sum.prod_congr (measurable_equiv.refl Î²)).trans
    (measurable_equiv.sum_prod_distrib _ _ _) in
e.symm.measurable_comp_iff.1 $ measurable_sum Hâ‚ (Hâ‚‚.comp measurable_id.snd)

lemma measurable_of_measurable_nnreal_nnreal [measurable_space Î²]
  {f : â„â‰¥0âˆ Ã— â„â‰¥0âˆ â†’ Î²} (hâ‚ : measurable (Î» p : â„â‰¥0 Ã— â„â‰¥0, f (p.1, p.2)))
  (hâ‚‚ : measurable (Î» r : â„â‰¥0, f (âˆ, r))) (hâ‚ƒ : measurable (Î» r : â„â‰¥0, f (r, âˆ))) :
  measurable f :=
measurable_of_measurable_nnreal_prod
  (measurable_swap_iff.1 $ measurable_of_measurable_nnreal_prod (hâ‚.comp measurable_swap) hâ‚ƒ)
  (measurable_of_measurable_nnreal hâ‚‚)

@[measurability]
lemma measurable_of_real : measurable ennreal.of_real :=
ennreal.continuous_of_real.measurable

@[measurability]
lemma measurable_to_real : measurable ennreal.to_real :=
ennreal.measurable_of_measurable_nnreal measurable_coe_nnreal_real

@[measurability]
lemma measurable_to_nnreal : measurable ennreal.to_nnreal :=
ennreal.measurable_of_measurable_nnreal measurable_id

instance : has_measurable_mulâ‚‚ â„â‰¥0âˆ :=
begin
  refine âŸ¨measurable_of_measurable_nnreal_nnreal _ _ _âŸ©,
  { simp only [â† ennreal.coe_mul, measurable_mul.coe_nnreal_ennreal] },
  { simp only [ennreal.top_mul, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const },
  { simp only [ennreal.mul_top, ennreal.coe_eq_zero],
    exact measurable_const.piecewise (measurable_set_singleton _) measurable_const }
end

instance : has_measurable_subâ‚‚ â„â‰¥0âˆ :=
âŸ¨by apply measurable_of_measurable_nnreal_nnreal;
  simp [â† with_top.coe_sub, continuous_sub.measurable.coe_nnreal_ennreal]âŸ©

instance : has_measurable_inv â„â‰¥0âˆ := âŸ¨continuous_inv.measurableâŸ©

end ennreal

@[measurability]
lemma measurable.ennreal_to_nnreal {f : Î± â†’ â„â‰¥0âˆ} (hf : measurable f) :
  measurable (Î» x, (f x).to_nnreal) :=
ennreal.measurable_to_nnreal.comp hf

@[measurability]
lemma ae_measurable.ennreal_to_nnreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x).to_nnreal) Î¼ :=
ennreal.measurable_to_nnreal.comp_ae_measurable hf

lemma measurable_coe_nnreal_ennreal_iff {f : Î± â†’ â„â‰¥0} :
  measurable (Î» x, (f x : â„â‰¥0âˆ)) â†” measurable f :=
âŸ¨Î» h, h.ennreal_to_nnreal, Î» h, h.coe_nnreal_ennrealâŸ©

@[measurability]
lemma measurable.ennreal_to_real {f : Î± â†’ â„â‰¥0âˆ} (hf : measurable f) :
  measurable (Î» x, ennreal.to_real (f x)) :=
ennreal.measurable_to_real.comp hf

@[measurability]
lemma ae_measurable.ennreal_to_real {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, ennreal.to_real (f x)) Î¼ :=
ennreal.measurable_to_real.comp_ae_measurable hf

/-- note: `â„â‰¥0âˆ` can probably be generalized in a future version of this lemma. -/
@[measurability]
lemma measurable.ennreal_tsum {Î¹} [encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, measurable (f i)) :
  measurable (Î» x, âˆ‘' i, f i x) :=
by { simp_rw [ennreal.tsum_eq_supr_sum], apply measurable_supr,
  exact Î» s, s.measurable_sum (Î» i _, h i) }

@[measurability]
lemma measurable.ennreal_tsum' {Î¹} [encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} (h : âˆ€ i, measurable (f i)) :
  measurable (âˆ‘' i, f i) :=
begin
  convert measurable.ennreal_tsum h,
  ext1 x,
  exact tsum_apply (pi.summable.2 (Î» _, ennreal.summable)),
end

@[measurability]
lemma measurable.nnreal_tsum {Î¹} [encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0} (h : âˆ€ i, measurable (f i)) :
  measurable (Î» x, âˆ‘' i, f i x) :=
begin
  simp_rw [nnreal.tsum_eq_to_nnreal_tsum],
  exact (measurable.ennreal_tsum (Î» i, (h i).coe_nnreal_ennreal)).ennreal_to_nnreal,
end

@[measurability]
lemma ae_measurable.ennreal_tsum {Î¹} [encodable Î¹] {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {Î¼ : measure Î±}
  (h : âˆ€ i, ae_measurable (f i) Î¼) :
  ae_measurable (Î» x, âˆ‘' i, f i x) Î¼ :=
by { simp_rw [ennreal.tsum_eq_supr_sum], apply ae_measurable_supr,
  exact Î» s, finset.ae_measurable_sum s (Î» i _, h i) }

@[measurability]
lemma measurable_coe_real_ereal : measurable (coe : â„ â†’ ereal) :=
continuous_coe_real_ereal.measurable

@[measurability]
lemma measurable.coe_real_ereal {f : Î± â†’ â„} (hf : measurable f) :
  measurable (Î» x, (f x : ereal)) :=
measurable_coe_real_ereal.comp hf

@[measurability]
lemma ae_measurable.coe_real_ereal {f : Î± â†’ â„} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x : ereal)) Î¼ :=
measurable_coe_real_ereal.comp_ae_measurable hf

/-- The set of finite `ereal` numbers is `measurable_equiv` to `â„`. -/
def measurable_equiv.ereal_equiv_real : ({âŠ¥, âŠ¤} : set ereal).compl â‰ƒáµ â„ :=
ereal.ne_bot_top_homeomorph_real.to_measurable_equiv

lemma ereal.measurable_of_measurable_real {f : ereal â†’ Î±}
  (h : measurable (Î» p : â„, f p)) : measurable f :=
measurable_of_measurable_on_compl_finite {âŠ¥, âŠ¤} (by simp)
  (measurable_equiv.ereal_equiv_real.symm.measurable_comp_iff.1 h)

@[measurability]
lemma measurable_ereal_to_real : measurable ereal.to_real :=
ereal.measurable_of_measurable_real (by simpa using measurable_id)

@[measurability]
lemma measurable.ereal_to_real {f : Î± â†’ ereal} (hf : measurable f) :
  measurable (Î» x, (f x).to_real) :=
measurable_ereal_to_real.comp hf

@[measurability]
lemma ae_measurable.ereal_to_real {f : Î± â†’ ereal} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x).to_real) Î¼ :=
measurable_ereal_to_real.comp_ae_measurable hf

@[measurability]
lemma measurable_coe_ennreal_ereal : measurable (coe : â„â‰¥0âˆ â†’ ereal) :=
continuous_coe_ennreal_ereal.measurable

@[measurability]
lemma measurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} (hf : measurable f) :
  measurable (Î» x, (f x : ereal)) :=
measurable_coe_ennreal_ereal.comp hf

@[measurability]
lemma ae_measurable.coe_ereal_ennreal {f : Î± â†’ â„â‰¥0âˆ} {Î¼ : measure Î±} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» x, (f x : ereal)) Î¼ :=
measurable_coe_ennreal_ereal.comp_ae_measurable hf

section normed_group

variables [normed_group Î±] [opens_measurable_space Î±] [measurable_space Î²]

@[measurability]
lemma measurable_norm : measurable (norm : Î± â†’ â„) :=
continuous_norm.measurable

@[measurability]
lemma measurable.norm {f : Î² â†’ Î±} (hf : measurable f) : measurable (Î» a, norm (f a)) :=
measurable_norm.comp hf

@[measurability]
lemma ae_measurable.norm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» a, norm (f a)) Î¼ :=
measurable_norm.comp_ae_measurable hf

@[measurability]
lemma measurable_nnnorm : measurable (nnnorm : Î± â†’ â„â‰¥0) :=
continuous_nnnorm.measurable

@[measurability]
lemma measurable.nnnorm {f : Î² â†’ Î±} (hf : measurable f) : measurable (Î» a, nnnorm (f a)) :=
measurable_nnnorm.comp hf

@[measurability]
lemma ae_measurable.nnnorm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» a, nnnorm (f a)) Î¼ :=
measurable_nnnorm.comp_ae_measurable hf

@[measurability]
lemma measurable_ennnorm : measurable (Î» x : Î±, (nnnorm x : â„â‰¥0âˆ)) :=
measurable_nnnorm.coe_nnreal_ennreal

@[measurability]
lemma measurable.ennnorm {f : Î² â†’ Î±} (hf : measurable f) :
  measurable (Î» a, (nnnorm (f a) : â„â‰¥0âˆ)) :=
hf.nnnorm.coe_nnreal_ennreal

@[measurability]
lemma ae_measurable.ennnorm {f : Î² â†’ Î±} {Î¼ : measure Î²} (hf : ae_measurable f Î¼) :
  ae_measurable (Î» a, (nnnorm (f a) : â„â‰¥0âˆ)) Î¼ :=
measurable_ennnorm.comp_ae_measurable hf

end normed_group

section limits

variables [measurable_space Î²] [metric_space Î²] [borel_space Î²]

open metric

/-- A limit (over a general filter) of measurable `â„â‰¥0âˆ` valued functions is measurable. -/
lemma measurable_of_tendsto_ennreal' {Î¹} {f : Î¹ â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ} (u : filter Î¹)
  [ne_bot u] [is_countably_generated u] (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u (ğ“ g)) :
  measurable g :=
begin
  rcases u.exists_seq_tendsto with âŸ¨x, hxâŸ©,
  rw [tendsto_pi_nhds] at lim,
  have : (Î» y, liminf at_top (Î» n, (f (x n) y : â„â‰¥0âˆ))) = g :=
    by { ext1 y, exact ((lim y).comp hx).liminf_eq, },
  rw â† this,
  show measurable (Î» y, liminf at_top (Î» n, (f (x n) y : â„â‰¥0âˆ))),
  exact measurable_liminf (Î» n, hf (x n)),
end

/-- A sequential limit of measurable `â„â‰¥0âˆ` valued functions is measurable. -/
lemma measurable_of_tendsto_ennreal {f : â„• â†’ Î± â†’ â„â‰¥0âˆ} {g : Î± â†’ â„â‰¥0âˆ}
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f at_top (ğ“ g)) : measurable g :=
measurable_of_tendsto_ennreal' at_top hf lim

/-- A limit (over a general filter) of measurable `â„â‰¥0` valued functions is measurable. -/
lemma measurable_of_tendsto_nnreal' {Î¹} {f : Î¹ â†’ Î± â†’ â„â‰¥0} {g : Î± â†’ â„â‰¥0} (u : filter Î¹)
  [ne_bot u] [is_countably_generated u] (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u (ğ“ g)) :
  measurable g :=
begin
  simp_rw [â† measurable_coe_nnreal_ennreal_iff] at hf âŠ¢,
  refine measurable_of_tendsto_ennreal' u hf _,
  rw tendsto_pi_nhds at lim âŠ¢,
  exact Î» x, (ennreal.continuous_coe.tendsto (g x)).comp (lim x),
end

/-- A sequential limit of measurable `â„â‰¥0` valued functions is measurable. -/
lemma measurable_of_tendsto_nnreal {f : â„• â†’ Î± â†’ â„â‰¥0} {g : Î± â†’ â„â‰¥0}
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f at_top (ğ“ g)) : measurable g :=
measurable_of_tendsto_nnreal' at_top hf lim

/-- A limit (over a general filter) of measurable functions valued in a metric space is measurable.
-/
lemma measurable_of_tendsto_metric' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (u : filter Î¹) [ne_bot u] [is_countably_generated u]
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u (ğ“ g)) :
  measurable g :=
begin
  apply measurable_of_is_closed', intros s h1s h2s h3s,
  have : measurable (Î» x, inf_nndist (g x) s),
  { suffices : tendsto (Î» i x, inf_nndist (f i x) s) u (ğ“ (Î» x, inf_nndist (g x) s)),
      from measurable_of_tendsto_nnreal' u (Î» i, (hf i).inf_nndist) this,
    rw [tendsto_pi_nhds] at lim âŠ¢, intro x,
    exact ((continuous_inf_nndist_pt s).tendsto (g x)).comp (lim x) },
  have h4s : g â»Â¹' s = (Î» x, inf_nndist (g x) s) â»Â¹' {0},
  { ext x, simp [h1s, â† h1s.mem_iff_inf_dist_zero h2s, â† nnreal.coe_eq_zero] },
  rw [h4s], exact this (measurable_set_singleton 0),
end

/-- A sequential limit of measurable functions valued in a metric space is measurable. -/
lemma measurable_of_tendsto_metric {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f at_top (ğ“ g)) :
  measurable g :=
measurable_of_tendsto_metric' at_top hf lim

/-- A limit (over a general filter) of measurable functions valued in a metrizable space is
measurable. -/
lemma measurable_of_tendsto_metrizable'
  {Î² : Type*} [topological_space Î²] [metrizable_space Î²]
  [measurable_space Î²] [borel_space Î²] {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (u : filter Î¹) [ne_bot u] [is_countably_generated u]
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f u (ğ“ g)) :
  measurable g :=
begin
  letI : metric_space Î² := metrizable_space_metric Î²,
  exact measurable_of_tendsto_metric' u hf lim
end

/-- A sequential limit of measurable functions valued in a metrizable space is measurable. -/
lemma measurable_of_tendsto_metrizable {Î² : Type*} [topological_space Î²] [metrizable_space Î²]
  [measurable_space Î²] [borel_space Î²] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (hf : âˆ€ i, measurable (f i)) (lim : tendsto f at_top (ğ“ g)) :
  measurable g :=
measurable_of_tendsto_metrizable' at_top hf lim

lemma ae_measurable_of_tendsto_metric_ae {Î¹ : Type*}
  {Î¼ : measure Î±} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (u : filter Î¹) [hu : ne_bot u] [is_countably_generated u]
  (hf : âˆ€ n, ae_measurable (f n) Î¼) (h_tendsto : âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) u (ğ“ (g x))) :
  ae_measurable g Î¼ :=
begin
  rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©,
  have h'f : âˆ€ n, ae_measurable (f (v n)) Î¼ := Î» n, hf (v n),
  set p : Î± â†’ (â„• â†’ Î²) â†’ Prop := Î» x f', tendsto (Î» n, f' n) at_top (ğ“ (g x)),
  have hp : âˆ€áµ x âˆ‚Î¼, p x (Î» n, f (v n) x),
    by filter_upwards [h_tendsto] with x hx using hx.comp hv,
  set ae_seq_lim := Î» x, ite (x âˆˆ ae_seq_set h'f p) (g x) (âŸ¨f (v 0) xâŸ© : nonempty Î²).some with hs,
  refine âŸ¨ae_seq_lim,
    measurable_of_tendsto_metric' at_top (@ae_seq.measurable Î± Î² _ _ _ (Î» n x, f (v n) x) Î¼ h'f p)
    (tendsto_pi_nhds.mpr (Î» x, _)), _âŸ©,
  { simp_rw [ae_seq, ae_seq_lim],
    split_ifs with hx,
    { simp_rw ae_seq.mk_eq_fun_of_mem_ae_seq_set h'f hx,
      exact @ae_seq.fun_prop_of_mem_ae_seq_set Î± Î² _ _ _ _ _ _ h'f x hx, },
    { exact tendsto_const_nhds } },
  { exact (ite_ae_eq_of_measure_compl_zero g (Î» x, (âŸ¨f (v 0) xâŸ© : nonempty Î²).some)
      (ae_seq_set h'f p) (ae_seq.measure_compl_ae_seq_set_eq_zero h'f hp)).symm },
end

lemma ae_measurable_of_tendsto_metric_ae' {Î¼ : measure Î±} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (hf : âˆ€ n, ae_measurable (f n) Î¼)
  (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) at_top (ğ“ (g x))) :
  ae_measurable g Î¼ :=
ae_measurable_of_tendsto_metric_ae at_top hf h_ae_tendsto

lemma ae_measurable_of_unif_approx {Î¼ : measure Î±} {g : Î± â†’ Î²}
  (hf : âˆ€ Îµ > (0 : â„), âˆƒ (f : Î± â†’ Î²), ae_measurable f Î¼ âˆ§ âˆ€áµ x âˆ‚Î¼, dist (f x) (g x) â‰¤ Îµ) :
  ae_measurable g Î¼ :=
begin
  obtain âŸ¨u, u_anti, u_pos, u_limâŸ© :
    âˆƒ (u : â„• â†’ â„), strict_anti u âˆ§ (âˆ€ (n : â„•), 0 < u n) âˆ§ tendsto u at_top (ğ“ 0) :=
      exists_seq_strict_anti_tendsto (0 : â„),
  choose f Hf using Î» (n : â„•), hf (u n) (u_pos n),
  have : âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) at_top (ğ“ (g x)),
  { have : âˆ€áµ x âˆ‚ Î¼, âˆ€ n, dist (f n x) (g x) â‰¤ u n := ae_all_iff.2 (Î» n, (Hf n).2),
    filter_upwards [this],
    assume x hx,
    rw tendsto_iff_dist_tendsto_zero,
    exact squeeze_zero (Î» n, dist_nonneg) hx u_lim },
  exact ae_measurable_of_tendsto_metric_ae' (Î» n, (Hf n).1) this,
end

lemma measurable_of_tendsto_metric_ae {Î¼ : measure Î±} [Î¼.is_complete] {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}
  (hf : âˆ€ n, measurable (f n))
  (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) at_top (ğ“ (g x))) :
  measurable g :=
ae_measurable_iff_measurable.mp
  (ae_measurable_of_tendsto_metric_ae' (Î» i, (hf i).ae_measurable) h_ae_tendsto)

lemma measurable_limit_of_tendsto_metric_ae {Î¹} [encodable Î¹] [nonempty Î¹] {Î¼ : measure Î±}
  {f : Î¹ â†’ Î± â†’ Î²} {L : filter Î¹} [L.is_countably_generated] (hf : âˆ€ n, ae_measurable (f n) Î¼)
  (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, âˆƒ l : Î², tendsto (Î» n, f n x) L (ğ“ l)) :
  âˆƒ (f_lim : Î± â†’ Î²) (hf_lim_meas : measurable f_lim),
    âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) L (ğ“ (f_lim x)) :=
begin
  inhabit Î¹,
  unfreezingI { rcases eq_or_ne L âŠ¥ with rfl | hL },
  { exact âŸ¨(hf default).mk _, (hf default).measurable_mk,
      eventually_of_forall $ Î» x, tendsto_botâŸ© },
  haveI : ne_bot L := âŸ¨hLâŸ©,
  let p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop := Î» x f', âˆƒ l : Î², tendsto (Î» n, f' n) L (ğ“ l),
  have hp_mem : âˆ€ x âˆˆ ae_seq_set hf p, p x (Î» n, f n x),
    from Î» x hx, ae_seq.fun_prop_of_mem_ae_seq_set hf hx,
  have h_ae_eq : âˆ€áµ x âˆ‚Î¼, âˆ€ n, ae_seq hf p n x = f n x,
    from ae_seq.ae_seq_eq_fun_ae hf h_ae_tendsto,
  let f_lim : Î± â†’ Î² := Î» x, dite (x âˆˆ ae_seq_set hf p) (Î» h, (hp_mem x h).some)
    (Î» h, (âŸ¨f default xâŸ© : nonempty Î²).some),
  have hf_lim : âˆ€ x, tendsto (Î» n, ae_seq hf p n x) L (ğ“ (f_lim x)),
  { intros x,
    simp only [f_lim, ae_seq],
    split_ifs,
    { refine (hp_mem x h).some_spec.congr (Î» n, _),
      exact (ae_seq.mk_eq_fun_of_mem_ae_seq_set hf h n).symm },
    { exact tendsto_const_nhds, }, },
  have h_ae_tendsto_f_lim : âˆ€áµ x âˆ‚Î¼, tendsto (Î» n, f n x) L (ğ“ (f_lim x)),
    from h_ae_eq.mono (Î» x hx, (hf_lim x).congr hx),
  have h_f_lim_meas : measurable f_lim,
    from measurable_of_tendsto_metric' L (ae_seq.measurable hf p)
      (tendsto_pi_nhds.mpr (Î» x, hf_lim x)),
  exact âŸ¨f_lim, h_f_lim_meas, h_ae_tendsto_f_limâŸ©,
end

end limits

namespace continuous_linear_map

variables {ğ•œ : Type*} [normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E] [measurable_space E]
variables [opens_measurable_space E]
variables {F : Type*} [normed_group F] [normed_space ğ•œ F] [measurable_space F] [borel_space F]

@[measurability]
protected lemma measurable (L : E â†’L[ğ•œ] F) : measurable L :=
L.continuous.measurable

lemma measurable_comp (L : E â†’L[ğ•œ] F) {Ï† : Î± â†’ E} (Ï†_meas : measurable Ï†) :
  measurable (Î» (a : Î±), L (Ï† a)) :=
L.measurable.comp Ï†_meas

end continuous_linear_map

namespace continuous_linear_map

variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E]
          {F : Type*} [normed_group F] [normed_space ğ•œ F]

instance : measurable_space (E â†’L[ğ•œ] F) := borel _

instance : borel_space (E â†’L[ğ•œ] F) := âŸ¨rflâŸ©

@[measurability]
lemma measurable_apply [measurable_space F] [borel_space F] (x : E) :
  measurable (Î» f : E â†’L[ğ•œ] F, f x) :=
(apply ğ•œ F x).continuous.measurable

@[measurability]
lemma measurable_apply' [measurable_space E] [opens_measurable_space E]
  [measurable_space F] [borel_space F] :
  measurable (Î» (x : E) (f : E â†’L[ğ•œ] F), f x) :=
measurable_pi_lambda _ $ Î» f, f.measurable

@[measurability]
lemma measurable_coe [measurable_space F] [borel_space F] :
  measurable (Î» (f : E â†’L[ğ•œ] F) (x : E), f x) :=
measurable_pi_lambda _ measurable_apply

end continuous_linear_map

section continuous_linear_map_nondiscrete_normed_field

variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E] [measurable_space E] [borel_space E]
variables {F : Type*} [normed_group F] [normed_space ğ•œ F]

@[measurability]
lemma measurable.apply_continuous_linear_map  {Ï† : Î± â†’ F â†’L[ğ•œ] E} (hÏ† : measurable Ï†) (v : F) :
  measurable (Î» a, Ï† a v) :=
(continuous_linear_map.apply ğ•œ E v).measurable.comp hÏ†

@[measurability]
lemma ae_measurable.apply_continuous_linear_map {Ï† : Î± â†’ F â†’L[ğ•œ] E} {Î¼ : measure Î±}
  (hÏ† : ae_measurable Ï† Î¼) (v : F) : ae_measurable (Î» a, Ï† a v) Î¼ :=
(continuous_linear_map.apply ğ•œ E v).measurable.comp_ae_measurable hÏ†

end continuous_linear_map_nondiscrete_normed_field

section normed_space
variables {ğ•œ : Type*} [nondiscrete_normed_field ğ•œ] [complete_space ğ•œ] [measurable_space ğ•œ]
variables [borel_space ğ•œ]
variables {E : Type*} [normed_group E] [normed_space ğ•œ E] [measurable_space E] [borel_space E]

lemma measurable_smul_const {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) :
  measurable (Î» x, f x â€¢ c) â†” measurable f :=
(closed_embedding_smul_left hc).measurable_embedding.measurable_comp_iff

lemma ae_measurable_smul_const {f : Î± â†’ ğ•œ} {Î¼ : measure Î±} {c : E} (hc : c â‰  0) :
  ae_measurable (Î» x, f x â€¢ c) Î¼ â†” ae_measurable f Î¼ :=
(closed_embedding_smul_left hc).measurable_embedding.ae_measurable_comp_iff

end normed_space
