/-
Copyright (c) 2020 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import measure_theory.measure.giry_monad
import dynamics.ergodic.measure_preserving
import measure_theory.integral.set_integral

/-!
# The product measure

In this file we define and prove properties about the binary product measure. If `Î±` and `Î²` have
Ïƒ-finite measures `Î¼` resp. `Î½` then `Î± Ã— Î²` can be equipped with a Ïƒ-finite measure `Î¼.prod Î½` that
satisfies `(Î¼.prod Î½) s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`.
We also have `(Î¼.prod Î½) (s.prod t) = Î¼ s * Î½ t`, i.e. the measure of a rectangle is the product of
the measures of the sides.

We also prove Tonelli's theorem and Fubini's theorem.

## Main definition

* `measure_theory.measure.prod`: The product of two measures.

## Main results

* `measure_theory.measure.prod_apply` states `Î¼.prod Î½ s = âˆ«â» x, Î½ {y | (x, y) âˆˆ s} âˆ‚Î¼`
  for measurable `s`. `measure_theory.measure.prod_apply_symm` is the reversed version.
* `measure_theory.measure.prod_prod` states `Î¼.prod Î½ (s.prod t) = Î¼ s * Î½ t` for measurable sets
  `s` and `t`.
* `measure_theory.lintegral_prod`: Tonelli's theorem. It states that for a measurable function
  `Î± Ã— Î² â†’ â„â‰¥0âˆ` we have `âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼`. The version
  for functions `Î± â†’ Î² â†’ â„â‰¥0âˆ` is reversed, and called `lintegral_lintegral`. Both versions have
  a variant with `_symm` appended, where the order of integration is reversed.
  The lemma `measurable.lintegral_prod_right'` states that the inner integral of the right-hand side
  is measurable.
* `measure_theory.integrable_prod_iff` states that a binary function is integrable iff both
  * `y â†¦ f (x, y)` is integrable for almost every `x`, and
  * the function `x â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dy` is integrable.
* `measure_theory.integral_prod`: Fubini's theorem. It states that for a integrable function
  `Î± Ã— Î² â†’ E` (where `E` is a second countable Banach space) we have
  `âˆ« z, f z âˆ‚(Î¼.prod Î½) = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼`. This theorem has the same variants as
  Tonelli's theorem. The lemma `measure_theory.integrable.integral_prod_right` states that the
  inner integral of the right-hand side is integrable.

## Implementation Notes

Many results are proven twice, once for functions in curried form (`Î± â†’ Î² â†’ Î³`) and one for
functions in uncurried form (`Î± Ã— Î² â†’ Î³`). The former often has an assumption
`measurable (uncurry f)`, which could be inconvenient to discharge, but for the latter it is more
common that the function has to be given explicitly, since Lean cannot synthesize the function by
itself. We name the lemmas about the uncurried form with a prime.
Tonelli's theorem and Fubini's theorem have a different naming scheme, since the version for the
uncurried version is reversed.

## Tags

product measure, Fubini's theorem, Tonelli's theorem, Fubini-Tonelli theorem
-/

noncomputable theory
open_locale classical topological_space ennreal measure_theory
open set function real ennreal
open measure_theory measurable_space measure_theory.measure
open topological_space (hiding generate_from)
open filter (hiding prod_eq map)

variables {Î± Î±' Î² Î²' Î³ E : Type*}

/-- Rectangles formed by Ï€-systems form a Ï€-system. -/
lemma is_pi_system.prod {C : set (set Î±)} {D : set (set Î²)} (hC : is_pi_system C)
  (hD : is_pi_system D) : is_pi_system (image2 set.prod C D) :=
begin
  rintro _ _ âŸ¨sâ‚, tâ‚, hsâ‚, htâ‚, rflâŸ© âŸ¨sâ‚‚, tâ‚‚, hsâ‚‚, htâ‚‚, rflâŸ© hst,
  rw [prod_inter_prod] at hst âŠ¢, rw [prod_nonempty_iff] at hst,
  exact mem_image2_of_mem (hC _ _ hsâ‚ hsâ‚‚ hst.1) (hD _ _ htâ‚ htâ‚‚ hst.2)
end

/-- Rectangles of countably spanning sets are countably spanning. -/
lemma is_countably_spanning.prod {C : set (set Î±)} {D : set (set Î²)}
  (hC : is_countably_spanning C) (hD : is_countably_spanning D) :
  is_countably_spanning (image2 set.prod C D) :=
begin
  rcases âŸ¨hC, hDâŸ© with âŸ¨âŸ¨s, h1s, h2sâŸ©, t, h1t, h2tâŸ©,
  refine âŸ¨Î» n, (s n.unpair.1).prod (t n.unpair.2), Î» n, mem_image2_of_mem (h1s _) (h1t _), _âŸ©,
  rw [Union_unpair_prod, h2s, h2t, univ_prod_univ]
end

variables [measurable_space Î±] [measurable_space Î±'] [measurable_space Î²] [measurable_space Î²']
variables [measurable_space Î³]
variables {Î¼ : measure Î±} {Î½ : measure Î²} {Ï„ : measure Î³}
variables [normed_group E] [measurable_space E]

/-! ### Measurability

Before we define the product measure, we can talk about the measurability of operations on binary
functions. We show that if `f` is a binary measurable function, then the function that integrates
along one of the variables (using either the Lebesgue or Bochner integral) is measurable.
-/

/-- The product of generated Ïƒ-algebras is the one generated by rectangles, if both generating sets
  are countably spanning. -/
lemma generate_from_prod_eq {Î± Î²} {C : set (set Î±)} {D : set (set Î²)}
  (hC : is_countably_spanning C) (hD : is_countably_spanning D) :
  @prod.measurable_space _ _ (generate_from C) (generate_from D) =
    generate_from (image2 set.prod C D) :=
begin
  apply le_antisymm,
  { refine sup_le _ _; rw [comap_generate_from];
      apply generate_from_le; rintro _ âŸ¨s, hs, rflâŸ©,
    { rcases hD with âŸ¨t, h1t, h2tâŸ©,
      rw [â† prod_univ, â† h2t, prod_Union],
      apply measurable_set.Union,
      intro n, apply measurable_set_generate_from,
      exact âŸ¨s, t n, hs, h1t n, rflâŸ© },
    { rcases hC with âŸ¨t, h1t, h2tâŸ©,
      rw [â† univ_prod, â† h2t, Union_prod_const],
      apply measurable_set.Union,
      rintro n, apply measurable_set_generate_from,
      exact mem_image2_of_mem (h1t n) hs } },
  { apply generate_from_le, rintro _ âŸ¨s, t, hs, ht, rflâŸ©, rw [prod_eq],
    apply (measurable_fst _).inter (measurable_snd _),
    { exact measurable_set_generate_from hs },
    { exact measurable_set_generate_from ht } }
end

/-- If `C` and `D` generate the Ïƒ-algebras on `Î±` resp. `Î²`, then rectangles formed by `C` and `D`
  generate the Ïƒ-algebra on `Î± Ã— Î²`. -/
lemma generate_from_eq_prod {C : set (set Î±)} {D : set (set Î²)} (hC : generate_from C = â€¹_â€º)
  (hD : generate_from D = â€¹_â€º) (h2C : is_countably_spanning C) (h2D : is_countably_spanning D) :
    generate_from (image2 set.prod C D) = prod.measurable_space :=
by rw [â† hC, â† hD, generate_from_prod_eq h2C h2D]

/-- The product Ïƒ-algebra is generated from boxes, i.e. `s.prod t` for sets `s : set Î±` and
  `t : set Î²`. -/
lemma generate_from_prod :
  generate_from (image2 set.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t}) =
  prod.measurable_space :=
generate_from_eq_prod generate_from_measurable_set generate_from_measurable_set
  is_countably_spanning_measurable_set is_countably_spanning_measurable_set

/-- Rectangles form a Ï€-system. -/
lemma is_pi_system_prod :
  is_pi_system (image2 set.prod {s : set Î± | measurable_set s} {t : set Î² | measurable_set t}) :=
is_pi_system_measurable_set.prod is_pi_system_measurable_set

/-- If `Î½` is a finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. `measurable_measure_prod_mk_left` is strictly more general. -/
lemma measurable_measure_prod_mk_left_finite [is_finite_measure Î½] {s : set (Î± Ã— Î²)}
  (hs : measurable_set s) : measurable (Î» x, Î½ (prod.mk x â»Â¹' s)) :=
begin
  refine induction_on_inter generate_from_prod.symm is_pi_system_prod _ _ _ _ hs,
  { simp [measurable_zero, const_def] },
  { rintro _ âŸ¨s, t, hs, ht, rflâŸ©, simp only [mk_preimage_prod_right_eq_if, measure_if],
    exact measurable_const.indicator hs },
  { intros t ht h2t,
    simp_rw [preimage_compl, measure_compl (measurable_prod_mk_left ht) (measure_ne_top Î½ _)],
    exact h2t.const_sub _ },
  { intros f h1f h2f h3f, simp_rw [preimage_Union],
    have : âˆ€ b, Î½ (â‹ƒ i, prod.mk b â»Â¹' f i) = âˆ‘' i, Î½ (prod.mk b â»Â¹' f i) :=
      Î» b, measure_Union (Î» i j hij, disjoint.preimage _ (h1f i j hij))
        (Î» i, measurable_prod_mk_left (h2f i)),
    simp_rw [this], apply measurable.ennreal_tsum h3f },
end

/-- If `Î½` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `x â†¦ Î½ { y | (x, y) âˆˆ s }` is
  a measurable function. -/
lemma measurable_measure_prod_mk_left [sigma_finite Î½] {s : set (Î± Ã— Î²)}
  (hs : measurable_set s) : measurable (Î» x, Î½ (prod.mk x â»Â¹' s)) :=
begin
  have : âˆ€ x, measurable_set (prod.mk x â»Â¹' s) := Î» x, measurable_prod_mk_left hs,
  simp only [â† @supr_restrict_spanning_sets _ _ Î½, this],
  apply measurable_supr, intro i,
  haveI := fact.mk (measure_spanning_sets_lt_top Î½ i),
  exact measurable_measure_prod_mk_left_finite hs
end

/-- If `Î¼` is a Ïƒ-finite measure, and `s âŠ† Î± Ã— Î²` is measurable, then `y â†¦ Î¼ { x | (x, y) âˆˆ s }` is
  a measurable function. -/
lemma measurable_measure_prod_mk_right {Î¼ : measure Î±} [sigma_finite Î¼] {s : set (Î± Ã— Î²)}
  (hs : measurable_set s) : measurable (Î» y, Î¼ ((Î» x, (x, y)) â»Â¹' s)) :=
measurable_measure_prod_mk_left (measurable_set_swap_iff.mpr hs)

lemma measurable.map_prod_mk_left [sigma_finite Î½] : measurable (Î» x : Î±, map (prod.mk x) Î½) :=
begin
  apply measurable_of_measurable_coe, intros s hs,
  simp_rw [map_apply measurable_prod_mk_left hs],
  exact measurable_measure_prod_mk_left hs
end

lemma measurable.map_prod_mk_right {Î¼ : measure Î±} [sigma_finite Î¼] :
  measurable (Î» y : Î², map (Î» x : Î±, (x, y)) Î¼) :=
begin
  apply measurable_of_measurable_coe, intros s hs,
  simp_rw [map_apply measurable_prod_mk_right hs],
  exact measurable_measure_prod_mk_right hs
end

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable. -/
lemma measurable.lintegral_prod_right' [sigma_finite Î½] :
  âˆ€ {f : Î± Ã— Î² â†’ â„â‰¥0âˆ} (hf : measurable f), measurable (Î» x, âˆ«â» y, f (x, y) âˆ‚Î½) :=
begin
  have m := @measurable_prod_mk_left,
  refine measurable.ennreal_induction _ _ _,
  { intros c s hs, simp only [â† indicator_comp_right],
    suffices : measurable (Î» x, c * Î½ (prod.mk x â»Â¹' s)),
    { simpa [lintegral_indicator _ (m hs)] },
    exact (measurable_measure_prod_mk_left hs).const_mul _ },
  { rintro f g - hf hg h2f h2g, simp_rw [pi.add_apply, lintegral_add (hf.comp m) (hg.comp m)],
    exact h2f.add h2g },
  { intros f hf h2f h3f,
    have := measurable_supr h3f,
    have : âˆ€ x, monotone (Î» n y, f n (x, y)) := Î» x i j hij y, h2f hij (x, y),
    simpa [lintegral_supr (Î» n, (hf n).comp m), this] }
end

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
lemma measurable.lintegral_prod_right [sigma_finite Î½] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ}
  (hf : measurable (uncurry f)) : measurable (Î» x, âˆ«â» y, f x y âˆ‚Î½) :=
hf.lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable. -/
lemma measurable.lintegral_prod_left' [sigma_finite Î¼] {f : Î± Ã— Î² â†’ â„â‰¥0âˆ}
  (hf : measurable f) : measurable (Î» y, âˆ«â» x, f (x, y) âˆ‚Î¼) :=
(measurable_swap_iff.mpr hf).lintegral_prod_right'

/-- The Lebesgue integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Tonelli's theorem is measurable.
  This version has the argument `f` in curried form. -/
lemma measurable.lintegral_prod_left [sigma_finite Î¼] {f : Î± â†’ Î² â†’ â„â‰¥0âˆ}
  (hf : measurable (uncurry f)) : measurable (Î» y, âˆ«â» x, f x y âˆ‚Î¼) :=
hf.lintegral_prod_left'

lemma measurable_set_integrable [sigma_finite Î½] [opens_measurable_space E] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„
  (hf : measurable (uncurry f)) : measurable_set { x | integrable (f x) Î½ } :=
begin
  simp_rw [integrable, hf.of_uncurry_left.ae_measurable, true_and],
  exact measurable_set_lt (measurable.lintegral_prod_right hf.ennnorm) measurable_const
end

section
variables [second_countable_topology E] [normed_space â„ E]
  [complete_space E] [borel_space E]

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable.
  This version has `f` in curried form. -/
lemma measurable.integral_prod_right [sigma_finite Î½] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„
  (hf : measurable (uncurry f)) : measurable (Î» x, âˆ« y, f x y âˆ‚Î½) :=
begin
  let s : â„• â†’ simple_func (Î± Ã— Î²) E := simple_func.approx_on _ hf univ _ (mem_univ 0),
  let s' : â„• â†’ Î± â†’ simple_func Î² E := Î» n x, (s n).comp (prod.mk x) measurable_prod_mk_left,
  let f' : â„• â†’ Î± â†’ E := Î» n, {x | integrable (f x) Î½}.indicator
    (Î» x, (s' n x).integral Î½),
  have hf' : âˆ€ n, measurable (f' n),
  { intro n, refine measurable.indicator _ (measurable_set_integrable hf),
    have : âˆ€ x, (s' n x).range.filter (Î» x, x â‰  0) âŠ† (s n).range,
    { intros x, refine finset.subset.trans (finset.filter_subset _ _) _, intro y,
      simp_rw [simple_func.mem_range], rintro âŸ¨z, rflâŸ©, exact âŸ¨(x, z), rflâŸ© },
    simp only [simple_func.integral_eq_sum_of_subset (this _)],
    refine finset.measurable_sum _ (Î» x _, _),
    refine (measurable.ennreal_to_real _).smul_const _,
    simp only [simple_func.coe_comp, preimage_comp] {single_pass := tt},
    apply measurable_measure_prod_mk_left,
    exact (s n).measurable_set_fiber x },
  have h2f' : tendsto f' at_top (ğ“ (Î» (x : Î±), âˆ« (y : Î²), f x y âˆ‚Î½)),
  { rw [tendsto_pi], intro x,
    by_cases hfx : integrable (f x) Î½,
    { have : âˆ€ n, integrable (s' n x) Î½,
      { intro n, apply (hfx.norm.add hfx.norm).mono' (s' n x).measurable.ae_measurable,
        apply eventually_of_forall, intro y,
        simp_rw [s', simple_func.coe_comp], exact simple_func.norm_approx_on_zero_le _ _ (x, y) n },
      simp only [f', hfx, simple_func.integral_eq_integral _ (this _), indicator_of_mem,
        mem_set_of_eq],
      refine tendsto_integral_of_dominated_convergence (Î» y, âˆ¥f x yâˆ¥ + âˆ¥f x yâˆ¥)
        (Î» n, (s' n x).ae_measurable) hf.of_uncurry_left.ae_measurable (hfx.norm.add hfx.norm) _ _,
      { exact Î» n, eventually_of_forall (Î» y, simple_func.norm_approx_on_zero_le _ _ (x, y) n) },
      { exact eventually_of_forall (Î» y, simple_func.tendsto_approx_on _ _ (by simp)) } },
    { simpa [f', hfx, integral_undef] using @tendsto_const_nhds _ _ _ (0 : E) _, } },
  exact measurable_of_tendsto_metric hf' h2f'
end

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  Fubini's theorem is measurable. -/
lemma measurable.integral_prod_right' [sigma_finite Î½] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : measurable f) : measurable (Î» x, âˆ« y, f (x, y) âˆ‚Î½) :=
by { rw [â† uncurry_curry f] at hf, exact hf.integral_prod_right }

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable.
  This version has `f` in curried form. -/
lemma measurable.integral_prod_left [sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ Eâ¦„
  (hf : measurable (uncurry f)) : measurable (Î» y, âˆ« x, f x y âˆ‚Î¼) :=
(hf.comp measurable_swap).integral_prod_right'

/-- The Bochner integral is measurable. This shows that the integrand of (the right-hand-side of)
  the symmetric version of Fubini's theorem is measurable. -/
lemma measurable.integral_prod_left' [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : measurable f) : measurable (Î» y, âˆ« x, f (x, y) âˆ‚Î¼) :=
(hf.comp measurable_swap).integral_prod_right'

end

/-! ### The product measure -/

namespace measure_theory

namespace measure

/-- The binary product of measures. They are defined for arbitrary measures, but we basically
  prove all properties under the assumption that at least one of them is Ïƒ-finite. -/
@[irreducible] protected def prod (Î¼ : measure Î±) (Î½ : measure Î²) : measure (Î± Ã— Î²) :=
bind Î¼ $ Î» x : Î±, map (prod.mk x) Î½

instance prod.measure_space {Î± Î²} [measure_space Î±] [measure_space Î²] : measure_space (Î± Ã— Î²) :=
{ volume := volume.prod volume }

variables {Î¼ Î½} [sigma_finite Î½]

lemma volume_eq_prod (Î± Î²) [measure_space Î±] [measure_space Î²] :
  (volume : measure (Î± Ã— Î²)) = (volume : measure Î±).prod (volume : measure Î²) :=
rfl

lemma prod_apply {s : set (Î± Ã— Î²)} (hs : measurable_set s) :
  Î¼.prod Î½ s = âˆ«â» x, Î½ (prod.mk x â»Â¹' s) âˆ‚Î¼ :=
by simp_rw [measure.prod, bind_apply hs measurable.map_prod_mk_left,
  map_apply measurable_prod_mk_left hs]

@[simp] lemma prod_prod {s : set Î±} {t : set Î²}
  (hs : measurable_set s) (ht : measurable_set t) : Î¼.prod Î½ (s.prod t) = Î¼ s * Î½ t :=
by simp_rw [prod_apply (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,
  lintegral_indicator _ hs, lintegral_const, restrict_apply measurable_set.univ,
  univ_inter, mul_comm]

/-- If we don't assume measurability of `s` and `t`, we can bound the measure of their product. -/
lemma prod_prod_le (s : set Î±) (t : set Î²) : Î¼.prod Î½ (s.prod t) â‰¤ Î¼ s * Î½ t :=
calc Î¼.prod Î½ (s.prod t) â‰¤ Î¼.prod Î½ ((to_measurable Î¼ s).prod (to_measurable Î½ t)) :
  measure_mono $ set.prod_mono (subset_to_measurable _ _) (subset_to_measurable _ _)
... = Î¼ (to_measurable Î¼ s) * Î½ (to_measurable Î½ t) :
  prod_prod (measurable_set_to_measurable _ _) (measurable_set_to_measurable _ _)
... = Î¼ s * Î½ t :
  by rw [measure_to_measurable, measure_to_measurable]

lemma ae_measure_lt_top {s : set (Î± Ã— Î²)} (hs : measurable_set s)
  (h2s : (Î¼.prod Î½) s â‰  âˆ) : âˆ€áµ x âˆ‚Î¼, Î½ (prod.mk x â»Â¹' s) < âˆ :=
by { simp_rw [prod_apply hs] at h2s, refine ae_lt_top (measurable_measure_prod_mk_left hs) h2s }

lemma integrable_measure_prod_mk_left {s : set (Î± Ã— Î²)}
  (hs : measurable_set s) (h2s : (Î¼.prod Î½) s â‰  âˆ) :
  integrable (Î» x, (Î½ (prod.mk x â»Â¹' s)).to_real) Î¼ :=
begin
  refine âŸ¨(measurable_measure_prod_mk_left hs).ennreal_to_real.ae_measurable, _âŸ©,
  simp_rw [has_finite_integral, ennnorm_eq_of_real to_real_nonneg],
  convert h2s.lt_top using 1, simp_rw [prod_apply hs], apply lintegral_congr_ae,
  refine (ae_measure_lt_top hs h2s).mp _, apply eventually_of_forall, intros x hx,
  rw [lt_top_iff_ne_top] at hx, simp [of_real_to_real, hx],
end

/-- Note: the assumption `hs` cannot be dropped. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
lemma measure_prod_null {s : set (Î± Ã— Î²)}
  (hs : measurable_set s) : Î¼.prod Î½ s = 0 â†” (Î» x, Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0 :=
by simp_rw [prod_apply hs, lintegral_eq_zero_iff (measurable_measure_prod_mk_left hs)]

/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,
  see Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
lemma measure_ae_null_of_prod_null {s : set (Î± Ã— Î²)}
  (h : Î¼.prod Î½ s = 0) : (Î» x, Î½ (prod.mk x â»Â¹' s)) =áµ[Î¼] 0 :=
begin
  obtain âŸ¨t, hst, mt, htâŸ© := exists_measurable_superset_of_null h,
  simp_rw [measure_prod_null mt] at ht,
  rw [eventually_le_antisymm_iff],
  exact âŸ¨eventually_le.trans_eq
    (eventually_of_forall $ Î» x, (measure_mono (preimage_mono hst) : _)) ht,
    eventually_of_forall $ Î» x, zero_le _âŸ©
end

/-- Note: the converse is not true. For a counterexample, see
  Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/
lemma ae_ae_of_ae_prod {p : Î± Ã— Î² â†’ Prop} (h : âˆ€áµ z âˆ‚Î¼.prod Î½, p z) :
  âˆ€áµ x âˆ‚ Î¼, âˆ€áµ y âˆ‚ Î½, p (x, y) :=
measure_ae_null_of_prod_null h

/-- `Î¼.prod Î½` has finite spanning sets in rectangles of finite spanning sets. -/
def finite_spanning_sets_in.prod {Î½ : measure Î²} {C : set (set Î±)} {D : set (set Î²)}
  (hÎ¼ : Î¼.finite_spanning_sets_in C) (hÎ½ : Î½.finite_spanning_sets_in D)
  (hC : âˆ€ s âˆˆ C, measurable_set s) (hD : âˆ€ t âˆˆ D, measurable_set t) :
  (Î¼.prod Î½).finite_spanning_sets_in (image2 set.prod C D) :=
begin
  haveI := hÎ½.sigma_finite,
  refine âŸ¨Î» n, (hÎ¼.set n.unpair.1).prod (hÎ½.set n.unpair.2),
    Î» n, mem_image2_of_mem (hÎ¼.set_mem _) (hÎ½.set_mem _), Î» n, _, _âŸ©,
  { simp_rw [prod_prod (hC _ (hÎ¼.set_mem _)) (hD _ (hÎ½.set_mem _))],
    exact mul_lt_top (hÎ¼.finite _).ne (hÎ½.finite _).ne },
  { simp_rw [Union_unpair_prod, hÎ¼.spanning, hÎ½.spanning, univ_prod_univ] }
end

lemma prod_fst_absolutely_continuous : map prod.fst (Î¼.prod Î½) â‰ª Î¼ :=
begin
  refine absolutely_continuous.mk (Î» s hs h2s, _),
  simp_rw [map_apply measurable_fst hs, â† prod_univ, prod_prod hs measurable_set.univ],
  rw [h2s, zero_mul] -- for some reason `simp_rw [h2s]` doesn't work
end

lemma prod_snd_absolutely_continuous : map prod.snd (Î¼.prod Î½) â‰ª Î½ :=
begin
  refine absolutely_continuous.mk (Î» s hs h2s, _),
  simp_rw [map_apply measurable_snd hs, â† univ_prod, prod_prod measurable_set.univ hs],
  rw [h2s, mul_zero] -- for some reason `simp_rw [h2s]` doesn't work
end

variables [sigma_finite Î¼]

instance prod.sigma_finite : sigma_finite (Î¼.prod Î½) :=
(Î¼.to_finite_spanning_sets_in.prod Î½.to_finite_spanning_sets_in (Î» _, id) (Î» _, id)).sigma_finite

/-- A measure on a product space equals the product measure if they are equal on rectangles
  with as sides sets that generate the corresponding Ïƒ-algebras. -/
lemma prod_eq_generate_from {Î¼ : measure Î±} {Î½ : measure Î²} {C : set (set Î±)}
  {D : set (set Î²)} (hC : generate_from C = â€¹_â€º)
  (hD : generate_from D = â€¹_â€º) (h2C : is_pi_system C) (h2D : is_pi_system D)
  (h3C : Î¼.finite_spanning_sets_in C) (h3D : Î½.finite_spanning_sets_in D)
  {Î¼Î½ : measure (Î± Ã— Î²)}
  (hâ‚ : âˆ€ (s âˆˆ C) (t âˆˆ D), Î¼Î½ (set.prod s t) = Î¼ s * Î½ t) : Î¼.prod Î½ = Î¼Î½ :=
begin
  have h4C : âˆ€ (s : set Î±), s âˆˆ C â†’ measurable_set s,
  { intros s hs, rw [â† hC], exact measurable_set_generate_from hs },
  have h4D : âˆ€ (t : set Î²), t âˆˆ D â†’ measurable_set t,
  { intros t ht, rw [â† hD], exact measurable_set_generate_from ht },
  refine (h3C.prod h3D h4C h4D).ext
    (generate_from_eq_prod hC hD h3C.is_countably_spanning h3D.is_countably_spanning).symm
    (h2C.prod h2D) _,
  { rintro _ âŸ¨s, t, hs, ht, rflâŸ©, haveI := h3D.sigma_finite,
    simp_rw [hâ‚ s hs t ht, prod_prod (h4C s hs) (h4D t ht)] }
end

/-- A measure on a product space equals the product measure if they are equal on rectangles. -/
lemma prod_eq {Î¼Î½ : measure (Î± Ã— Î²)}
  (h : âˆ€ s t, measurable_set s â†’ measurable_set t â†’ Î¼Î½ (s.prod t) = Î¼ s * Î½ t) : Î¼.prod Î½ = Î¼Î½ :=
prod_eq_generate_from generate_from_measurable_set generate_from_measurable_set
  is_pi_system_measurable_set is_pi_system_measurable_set
  Î¼.to_finite_spanning_sets_in Î½.to_finite_spanning_sets_in (Î» s hs t ht, h s t hs ht)

lemma prod_swap : map prod.swap (Î¼.prod Î½) = Î½.prod Î¼ :=
begin
  refine (prod_eq _).symm,
  intros s t hs ht,
  simp_rw [map_apply measurable_swap (hs.prod ht), preimage_swap_prod, prod_prod ht hs, mul_comm]
end

lemma prod_apply_symm {s : set (Î± Ã— Î²)} (hs : measurable_set s) :
  Î¼.prod Î½ s = âˆ«â» y, Î¼ ((Î» x, (x, y)) â»Â¹' s) âˆ‚Î½ :=
by { rw [â† prod_swap, map_apply measurable_swap hs],
     simp only [prod_apply (measurable_swap hs)], refl }

lemma prod_assoc_prod [sigma_finite Ï„] :
  map measurable_equiv.prod_assoc ((Î¼.prod Î½).prod Ï„) = Î¼.prod (Î½.prod Ï„) :=
begin
  refine (prod_eq_generate_from generate_from_measurable_set generate_from_prod
    is_pi_system_measurable_set is_pi_system_prod Î¼.to_finite_spanning_sets_in
    (Î½.to_finite_spanning_sets_in.prod Ï„.to_finite_spanning_sets_in (Î» _, id) (Î» _, id)) _).symm,
  rintro s hs _ âŸ¨t, u, ht, hu, rflâŸ©, rw [mem_set_of_eq] at hs ht hu,
  simp_rw [map_apply (measurable_equiv.measurable _) (hs.prod (ht.prod hu)), prod_prod ht hu,
    measurable_equiv.prod_assoc, measurable_equiv.coe_mk, equiv.prod_assoc_preimage,
    prod_prod (hs.prod ht) hu, prod_prod hs ht, mul_assoc]
end

/-! ### The product of specific measures -/

lemma prod_restrict {s : set Î±} {t : set Î²} (hs : measurable_set s) (ht : measurable_set t) :
  (Î¼.restrict s).prod (Î½.restrict t) = (Î¼.prod Î½).restrict (s.prod t) :=
begin
  refine prod_eq (Î» s' t' hs' ht', _),
  simp_rw [restrict_apply (hs'.prod ht'), prod_inter_prod, prod_prod (hs'.inter hs) (ht'.inter ht),
    restrict_apply hs', restrict_apply ht']
end

lemma restrict_prod_eq_prod_univ {s : set Î±} (hs : measurable_set s) :
  (Î¼.restrict s).prod Î½ = (Î¼.prod Î½).restrict (s.prod univ) :=
begin
  have : Î½ = Î½.restrict set.univ := measure.restrict_univ.symm,
  rwa [this, measure.prod_restrict, â† this],
  exact measurable_set.univ,
end

lemma prod_dirac (y : Î²) : Î¼.prod (dirac y) = map (Î» x, (x, y)) Î¼ :=
begin
  refine prod_eq (Î» s t hs ht, _),
  simp_rw [map_apply measurable_prod_mk_right (hs.prod ht), mk_preimage_prod_left_eq_if, measure_if,
    dirac_apply' _ ht, â† indicator_mul_right _ (Î» x, Î¼ s), pi.one_apply, mul_one]
end

lemma dirac_prod (x : Î±) : (dirac x).prod Î½ = map (prod.mk x) Î½ :=
begin
  refine prod_eq (Î» s t hs ht, _),
  simp_rw [map_apply measurable_prod_mk_left (hs.prod ht), mk_preimage_prod_right_eq_if, measure_if,
    dirac_apply' _ hs, â† indicator_mul_left _ _ (Î» x, Î½ t), pi.one_apply, one_mul]
end

lemma dirac_prod_dirac {x : Î±} {y : Î²} : (dirac x).prod (dirac y) = dirac (x, y) :=
by rw [prod_dirac, map_dirac measurable_prod_mk_right]

lemma prod_sum {Î¹ : Type*} [fintype Î¹] (Î½ : Î¹ â†’ measure Î²) [âˆ€ i, sigma_finite (Î½ i)] :
  Î¼.prod (sum Î½) = sum (Î» i, Î¼.prod (Î½ i)) :=
begin
  refine prod_eq (Î» s t hs ht, _),
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ ht, prod_prod hs ht, tsum_fintype, finset.mul_sum]
end

lemma sum_prod {Î¹ : Type*} [fintype Î¹] (Î¼ : Î¹ â†’ measure Î±) [âˆ€ i, sigma_finite (Î¼ i)] :
  (sum Î¼).prod Î½ = sum (Î» i, (Î¼ i).prod Î½) :=
begin
  refine prod_eq (Î» s t hs ht, _),
  simp_rw [sum_apply _ (hs.prod ht), sum_apply _ hs, prod_prod hs ht, tsum_fintype, finset.sum_mul]
end

lemma prod_add (Î½' : measure Î²) [sigma_finite Î½'] : Î¼.prod (Î½ + Î½') = Î¼.prod Î½ + Î¼.prod Î½' :=
by { refine prod_eq (Î» s t hs ht, _), simp_rw [add_apply, prod_prod hs ht, left_distrib] }

lemma add_prod (Î¼' : measure Î±) [sigma_finite Î¼'] : (Î¼ + Î¼').prod Î½ = Î¼.prod Î½ + Î¼'.prod Î½ :=
by { refine prod_eq (Î» s t hs ht, _), simp_rw [add_apply, prod_prod hs ht, right_distrib] }

@[simp] lemma zero_prod (Î½ : measure Î²) : (0 : measure Î±).prod Î½ = 0 :=
by { rw measure.prod, exact bind_zero_left _ }

@[simp] lemma prod_zero (Î¼ : measure Î±) : Î¼.prod (0 : measure Î²) = 0 :=
by simp [measure.prod]

lemma map_prod_map {Î´} [measurable_space Î´] {f : Î± â†’ Î²} {g : Î³ â†’ Î´}
  {Î¼a : measure Î±} {Î¼c : measure Î³} (hfa : sigma_finite (map f Î¼a))
  (hgc : sigma_finite (map g Î¼c)) (hf : measurable f) (hg : measurable g) :
  (map f Î¼a).prod (map g Î¼c) = map (prod.map f g) (Î¼a.prod Î¼c) :=
begin
  haveI := hgc.of_map Î¼c hg,
  refine prod_eq (Î» s t hs ht, _),
  rw [map_apply (hf.prod_map hg) (hs.prod ht), map_apply hf hs, map_apply hg ht],
  exact prod_prod (hf hs) (hg ht)
end

end measure

namespace measure_preserving

open measure

variables {Î´ : Type*} [measurable_space Î´] {Î¼a : measure Î±} {Î¼b : measure Î²}
  {Î¼c : measure Î³} {Î¼d : measure Î´}

lemma skew_product [sigma_finite Î¼b] [sigma_finite Î¼d]
  {f : Î± â†’ Î²} (hf : measure_preserving f Î¼a Î¼b) {g : Î± â†’ Î³ â†’ Î´}
  (hgm : measurable (uncurry g)) (hg : âˆ€áµ x âˆ‚Î¼a, map (g x) Î¼c = Î¼d) :
  measure_preserving (Î» p : Î± Ã— Î³, (f p.1, g p.1 p.2)) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d) :=
begin
  classical,
  have : measurable (Î» p : Î± Ã— Î³, (f p.1, g p.1 p.2)) := (hf.1.comp measurable_fst).prod_mk hgm,
  /- if `Î¼a = 0`, then the lemma is trivial, otherwise we can use `hg`
  to deduce `sigma_finite Î¼c`. -/
  rcases eq_or_ne Î¼a 0 with (rfl|ha),
  { rw [â† hf.map_eq, zero_prod, (map f).map_zero, zero_prod],
    exact âŸ¨this, (map _).map_zeroâŸ© },
  haveI : sigma_finite Î¼c,
  { rcases (ae_ne_bot.2 ha).nonempty_of_mem hg with âŸ¨x, hx : map (g x) Î¼c = Î¼dâŸ©,
    exact sigma_finite.of_map _ hgm.of_uncurry_left (by rwa hx) },
  -- Thus we can apply `measure.prod_eq` to prove equality of measures.
  refine âŸ¨this, (prod_eq $ Î» s t hs ht, _).symmâŸ©,
  rw [map_apply this (hs.prod ht)],
  refine (prod_apply (this $ hs.prod ht)).trans _,
  have : âˆ€áµ x âˆ‚Î¼a, Î¼c ((Î» y, (f x, g x y)) â»Â¹' s.prod t) = indicator (f â»Â¹' s) (Î» y, Î¼d t) x,
  { refine hg.mono (Î» x hx, _), unfreezingI { subst hx },
    simp only [mk_preimage_prod_right_fn_eq_if, indicator_apply, mem_preimage],
    split_ifs,
    exacts [(map_apply hgm.of_uncurry_left ht).symm, measure_empty] },
  simp only [preimage_preimage],
  rw [lintegral_congr_ae this, lintegral_indicator _ (hf.1 hs),
    set_lintegral_const, hf.measure_preimage hs, mul_comm]
end

/-- If `f : Î± â†’ Î²` sends the measure `Î¼a` to `Î¼b` and `g : Î³ â†’ Î´` sends the measure `Î¼c` to `Î¼d`,
then `prod.map f g` sends `Î¼a.prod Î¼c` to `Î¼b.prod Î¼d`. -/
protected lemma prod [sigma_finite Î¼b] [sigma_finite Î¼d] {f : Î± â†’ Î²} {g : Î³ â†’ Î´}
  (hf : measure_preserving f Î¼a Î¼b) (hg : measure_preserving g Î¼c Î¼d) :
  measure_preserving (prod.map f g) (Î¼a.prod Î¼c) (Î¼b.prod Î¼d) :=
have measurable (uncurry $ Î» _ : Î±, g), from (hg.1.comp measurable_snd),
hf.skew_product this $ filter.eventually_of_forall $ Î» _, hg.map_eq

end measure_preserving

end measure_theory

open measure_theory.measure

section

lemma ae_measurable.prod_swap [sigma_finite Î¼] [sigma_finite Î½] {f : Î² Ã— Î± â†’ Î³}
  (hf : ae_measurable f (Î½.prod Î¼)) : ae_measurable (Î» (z : Î± Ã— Î²), f z.swap) (Î¼.prod Î½) :=
by { rw â† prod_swap at hf, exact hf.comp_measurable measurable_swap }

lemma ae_measurable.fst [sigma_finite Î½] {f : Î± â†’ Î³}
  (hf : ae_measurable f Î¼) : ae_measurable (Î» (z : Î± Ã— Î²), f z.1) (Î¼.prod Î½) :=
hf.comp_measurable' measurable_fst prod_fst_absolutely_continuous

lemma ae_measurable.snd [sigma_finite Î½] {f : Î² â†’ Î³}
  (hf : ae_measurable f Î½) : ae_measurable (Î» (z : Î± Ã— Î²), f z.2) (Î¼.prod Î½) :=
hf.comp_measurable' measurable_snd prod_snd_absolutely_continuous

/-- The Bochner integral is a.e.-measurable.
  This shows that the integrand of (the right-hand-side of) Fubini's theorem is a.e.-measurable. -/
lemma ae_measurable.integral_prod_right' [sigma_finite Î½]
  [second_countable_topology E] [normed_space â„ E] [borel_space E] [complete_space E]
  â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : ae_measurable f (Î¼.prod Î½)) : ae_measurable (Î» x, âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=
âŸ¨Î» x, âˆ« y, hf.mk f (x, y) âˆ‚Î½, hf.measurable_mk.integral_prod_right', begin
  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk],
  assume x hx,
  exact integral_congr_ae hx
endâŸ©

lemma ae_measurable.prod_mk_left [sigma_finite Î½] {f : Î± Ã— Î² â†’ Î³}
  (hf : ae_measurable f (Î¼.prod Î½)) : âˆ€áµ x âˆ‚Î¼, ae_measurable (Î» y, f (x, y)) Î½ :=
begin
  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk],
  intros x hx,
  exact âŸ¨Î» y, hf.mk f (x, y), hf.measurable_mk.comp measurable_prod_mk_left, hxâŸ©
end

end

namespace measure_theory

/-! ### The Lebesgue integral on a product -/

variables [sigma_finite Î½]

lemma lintegral_prod_swap [sigma_finite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ)
  (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» z, f z.swap âˆ‚(Î½.prod Î¼) = âˆ«â» z, f z âˆ‚(Î¼.prod Î½) :=
by { rw â† prod_swap at hf, rw [â† lintegral_map' hf measurable_swap, prod_swap] }

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
lemma lintegral_prod_of_measurable :
  âˆ€ (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : measurable f), âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ :=
begin
  have m := @measurable_prod_mk_left,
  refine measurable.ennreal_induction _ _ _,
  { intros c s hs, simp only [â† indicator_comp_right],
    simp [lintegral_indicator, m hs, hs, lintegral_const_mul, measurable_measure_prod_mk_left hs,
      prod_apply] },
  { rintro f g - hf hg h2f h2g,
    simp [lintegral_add, measurable.lintegral_prod_right', hf.comp m, hg.comp m,
      hf, hg, h2f, h2g] },
  { intros f hf h2f h3f,
    have kf : âˆ€ x n, measurable (Î» y, f n (x, y)) := Î» x n, (hf n).comp m,
    have k2f : âˆ€ x, monotone (Î» n y, f n (x, y)) := Î» x i j hij y, h2f hij (x, y),
    have lf : âˆ€ n, measurable (Î» x, âˆ«â» y, f n (x, y) âˆ‚Î½) := Î» n, (hf n).lintegral_prod_right',
    have l2f : monotone (Î» n x, âˆ«â» y, f n (x, y) âˆ‚Î½) := Î» i j hij x, lintegral_mono (k2f x hij),
    simp only [lintegral_supr hf h2f, lintegral_supr (kf _), k2f, lintegral_supr lf l2f, h3f] },
end

/-- **Tonelli's Theorem**: For `â„â‰¥0âˆ`-valued almost everywhere measurable functions on `Î± Ã— Î²`,
  the integral of `f` is equal to the iterated integral. -/
lemma lintegral_prod (f : Î± Ã— Î² â†’ â„â‰¥0âˆ) (hf : ae_measurable f (Î¼.prod Î½)) :
  âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ :=
begin
  have A : âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» z, hf.mk f z âˆ‚(Î¼.prod Î½) :=
    lintegral_congr_ae hf.ae_eq_mk,
  have B : âˆ«â» x, âˆ«â» y, f (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ«â» x, âˆ«â» y, hf.mk f (x, y) âˆ‚Î½ âˆ‚Î¼,
  { apply lintegral_congr_ae,
    filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk],
    assume a ha,
    exact lintegral_congr_ae ha },
  rw [A, B, lintegral_prod_of_measurable _ hf.measurable_mk],
  apply_instance
end

/-- The symmetric verion of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued almost everywhere measurable
functions on `Î± Ã— Î²`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
lemma lintegral_prod_symm [sigma_finite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ)
  (hf : ae_measurable f (Î¼.prod Î½)) : âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ :=
by { simp_rw [â† lintegral_prod_swap f hf], exact lintegral_prod _ hf.prod_swap }

/-- The symmetric verion of Tonelli's Theorem: For `â„â‰¥0âˆ`-valued measurable
functions on `Î± Ã— Î²`,  the integral of `f` is equal to the iterated integral, in reverse order. -/
lemma lintegral_prod_symm' [sigma_finite Î¼] (f : Î± Ã— Î² â†’ â„â‰¥0âˆ)
  (hf : measurable f) : âˆ«â» z, f z âˆ‚(Î¼.prod Î½) = âˆ«â» y, âˆ«â» x, f (x, y) âˆ‚Î¼ âˆ‚Î½ :=
lintegral_prod_symm f hf.ae_measurable

/-- The reversed version of **Tonelli's Theorem**. In this version `f` is in curried form, which
makes it easier for the elaborator to figure out `f` automatically. -/
lemma lintegral_lintegral â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„
  (hf : ae_measurable (uncurry f) (Î¼.prod Î½)) :
  âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» z, f z.1 z.2 âˆ‚(Î¼.prod Î½) :=
(lintegral_prod _ hf).symm

/-- The reversed version of **Tonelli's Theorem** (symmetric version). In this version `f` is in
curried form, which makes it easier for the elaborator to figure out `f` automatically. -/
lemma lintegral_lintegral_symm [sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„
  (hf : ae_measurable (uncurry f) (Î¼.prod Î½)) :
  âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» z, f z.2 z.1 âˆ‚(Î½.prod Î¼) :=
(lintegral_prod_symm _ hf.prod_swap).symm

/-- Change the order of Lebesgue integration. -/
lemma lintegral_lintegral_swap [sigma_finite Î¼] â¦ƒf : Î± â†’ Î² â†’ â„â‰¥0âˆâ¦„
  (hf : ae_measurable (uncurry f) (Î¼.prod Î½)) :
  âˆ«â» x, âˆ«â» y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ«â» y, âˆ«â» x, f x y âˆ‚Î¼ âˆ‚Î½ :=
(lintegral_lintegral hf).trans (lintegral_prod_symm _ hf)

lemma lintegral_prod_mul {f : Î± â†’ â„â‰¥0âˆ} {g : Î² â†’ â„â‰¥0âˆ}
  (hf : ae_measurable f Î¼) (hg : ae_measurable g Î½) :
  âˆ«â» z, f z.1 * g z.2 âˆ‚(Î¼.prod Î½) = âˆ«â» x, f x âˆ‚Î¼ * âˆ«â» y, g y âˆ‚Î½ :=
by simp [lintegral_prod _ (hf.fst.mul hg.snd), lintegral_lintegral_mul hf hg]

/-! ### Integrability on a product -/
section

variables [opens_measurable_space E]

lemma integrable.swap [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : integrable (f âˆ˜ prod.swap) (Î½.prod Î¼) :=
âŸ¨hf.ae_measurable.prod_swap,
  (lintegral_prod_swap _ hf.ae_measurable.ennnorm : _).le.trans_lt hf.has_finite_integralâŸ©

lemma integrable_swap_iff [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ :
  integrable (f âˆ˜ prod.swap) (Î½.prod Î¼) â†” integrable f (Î¼.prod Î½) :=
âŸ¨Î» hf, by { convert hf.swap, ext âŸ¨x, yâŸ©, refl }, Î» hf, hf.swapâŸ©

lemma has_finite_integral_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : measurable f) :
  has_finite_integral f (Î¼.prod Î½) â†” (âˆ€áµ x âˆ‚ Î¼, has_finite_integral (Î» y, f (x, y)) Î½) âˆ§
    has_finite_integral (Î» x, âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
begin
  simp only [has_finite_integral, lintegral_prod_of_measurable _ h1f.ennnorm],
  have : âˆ€ x, âˆ€áµ y âˆ‚Î½, 0 â‰¤ âˆ¥f (x, y)âˆ¥ := Î» x, eventually_of_forall (Î» y, norm_nonneg _),
  simp_rw [integral_eq_lintegral_of_nonneg_ae (this _)
    (h1f.norm.comp measurable_prod_mk_left).ae_measurable,
    ennnorm_eq_of_real to_real_nonneg, of_real_norm_eq_coe_nnnorm],
  -- this fact is probably too specialized to be its own lemma
  have : âˆ€ {p q r : Prop} (h1 : r â†’ p), (r â†” p âˆ§ q) â†” (p â†’ (r â†” q)) :=
  Î» p q r h1, by rw [â† and.congr_right_iff, and_iff_right_of_imp h1],
  rw [this],
  { intro h2f, rw lintegral_congr_ae,
    refine h2f.mp _, apply eventually_of_forall, intros x hx, dsimp only,
    rw [of_real_to_real], rw [â† lt_top_iff_ne_top], exact hx },
  { intro h2f, refine ae_lt_top _ h2f.ne, exact h1f.ennnorm.lintegral_prod_right' },
end

lemma has_finite_integral_prod_iff' â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : ae_measurable f (Î¼.prod Î½)) :
  has_finite_integral f (Î¼.prod Î½) â†” (âˆ€áµ x âˆ‚ Î¼, has_finite_integral (Î» y, f (x, y)) Î½) âˆ§
    has_finite_integral (Î» x, âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
begin
  rw [has_finite_integral_congr h1f.ae_eq_mk, has_finite_integral_prod_iff h1f.measurable_mk],
  apply and_congr,
  { apply eventually_congr,
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm],
    assume x hx,
    exact has_finite_integral_congr hx },
  { apply has_finite_integral_congr,
    filter_upwards [ae_ae_of_ae_prod h1f.ae_eq_mk.symm],
    assume x hx,
    exact integral_congr_ae (eventually_eq.fun_comp hx _) },
  { apply_instance }
end


/-- A binary function is integrable if the function `y â†¦ f (x, y)` is integrable for almost every
  `x` and the function `x â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dy` is integrable. -/
lemma integrable_prod_iff â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : ae_measurable f (Î¼.prod Î½)) :
  integrable f (Î¼.prod Î½) â†”
    (âˆ€áµ x âˆ‚ Î¼, integrable (Î» y, f (x, y)) Î½) âˆ§ integrable (Î» x, âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
by simp [integrable, h1f, has_finite_integral_prod_iff', h1f.norm.integral_prod_right',
         h1f.prod_mk_left]

/-- A binary function is integrable if the function `x â†¦ f (x, y)` is integrable for almost every
  `y` and the function `y â†¦ âˆ« âˆ¥f (x, y)âˆ¥ dx` is integrable. -/
lemma integrable_prod_iff' [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (h1f : ae_measurable f (Î¼.prod Î½)) :
  integrable f (Î¼.prod Î½) â†”
    (âˆ€áµ y âˆ‚ Î½, integrable (Î» x, f (x, y)) Î¼) âˆ§ integrable (Î» y, âˆ« x, âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½ :=
by { convert integrable_prod_iff (h1f.prod_swap) using 1, rw [integrable_swap_iff] }

lemma integrable.prod_left_ae [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : âˆ€áµ y âˆ‚ Î½, integrable (Î» x, f (x, y)) Î¼ :=
((integrable_prod_iff' hf.ae_measurable).mp hf).1

lemma integrable.prod_right_ae [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : âˆ€áµ x âˆ‚ Î¼, integrable (Î» y, f (x, y)) Î½ :=
hf.swap.prod_left_ae

lemma integrable.integral_norm_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : integrable (Î» x, âˆ« y, âˆ¥f (x, y)âˆ¥ âˆ‚Î½) Î¼ :=
((integrable_prod_iff hf.ae_measurable).mp hf).2

lemma integrable.integral_norm_prod_right [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : integrable (Î» y, âˆ« x, âˆ¥f (x, y)âˆ¥ âˆ‚Î¼) Î½ :=
hf.swap.integral_norm_prod_left

end

variables [second_countable_topology E] [normed_space â„ E]
  [complete_space E] [borel_space E]

lemma integrable.integral_prod_left â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : integrable (Î» x, âˆ« y, f (x, y) âˆ‚Î½) Î¼ :=
integrable.mono hf.integral_norm_prod_left hf.ae_measurable.integral_prod_right' $
  eventually_of_forall $ Î» x, (norm_integral_le_integral_norm _).trans_eq $
  (norm_of_nonneg $ integral_nonneg_of_ae $ eventually_of_forall $
  Î» y, (norm_nonneg (f (x, y)) : _)).symm

lemma integrable.integral_prod_right [sigma_finite Î¼] â¦ƒf : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) : integrable (Î» y, âˆ« x, f (x, y) âˆ‚Î¼) Î½ :=
hf.swap.integral_prod_left

/-! ### The Bochner integral on a product -/

variables [sigma_finite Î¼]

lemma integral_prod_swap (f : Î± Ã— Î² â†’ E)
  (hf : ae_measurable f (Î¼.prod Î½)) : âˆ« z, f z.swap âˆ‚(Î½.prod Î¼) = âˆ« z, f z âˆ‚(Î¼.prod Î½) :=
begin
  rw â† prod_swap at hf,
  rw [â† integral_map measurable_swap hf, prod_swap]
end

variables {E' : Type*} [measurable_space E'] [normed_group E'] [borel_space E'] [complete_space E']
  [normed_space â„ E'] [second_countable_topology E']

/-! Some rules about the sum/difference of double integrals. They follow from `integral_add`, but
  we separate them out as separate lemmas, because they involve quite some steps. -/

/-- Integrals commute with addition inside another integral. `F` can be any function. -/
lemma integral_fn_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E')
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, F (âˆ« y, f (x, y) + g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« x, F (âˆ« y, f (x, y) âˆ‚Î½ + âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae],
  intros x h2f h2g, simp [integral_add h2f h2g],
end

/-- Integrals commute with subtraction inside another integral.
  `F` can be any measurable function. -/
lemma integral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„ (F : E â†’ E')
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ« x, F (âˆ« y, f (x, y) âˆ‚Î½ - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ :=
begin
  refine integral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae],
  intros x h2f h2g, simp [integral_sub h2f h2g]
end

/-- Integrals commute with subtraction inside a lower Lebesgue integral.
  `F` can be any function. -/
lemma lintegral_fn_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„
  (F : E â†’ â„â‰¥0âˆ) (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ«â» x, F (âˆ« y, f (x, y) - g (x, y) âˆ‚Î½) âˆ‚Î¼ = âˆ«â» x, F (âˆ« y, f (x, y) âˆ‚Î½ - âˆ« y, g (x, y) âˆ‚Î½) âˆ‚Î¼ :=
begin
  refine lintegral_congr_ae _,
  filter_upwards [hf.prod_right_ae, hg.prod_right_ae],
  intros x h2f h2g, simp [integral_sub h2f h2g]
end

/-- Double integrals commute with addition. -/
lemma integral_integral_add â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, f (x, y) + g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
(integral_fn_integral_add id hf hg).trans $
  integral_add hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with addition. This is the version with `(f + g) (x, y)`
  (instead of `f (x, y) + g (x, y)`) in the LHS. -/
lemma integral_integral_add' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, (f + g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ + âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
integral_integral_add hf hg

/-- Double integrals commute with subtraction. -/
lemma integral_integral_sub â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, f (x, y) - g (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
(integral_fn_integral_sub id hf hg).trans $
  integral_sub hf.integral_prod_left hg.integral_prod_left

/-- Double integrals commute with subtraction. This is the version with `(f - g) (x, y)`
  (instead of `f (x, y) - g (x, y)`) in the LHS. -/
lemma integral_integral_sub' â¦ƒf g : Î± Ã— Î² â†’ Eâ¦„
  (hf : integrable f (Î¼.prod Î½)) (hg : integrable g (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, (f - g) (x, y) âˆ‚Î½ âˆ‚Î¼ = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ - âˆ« x, âˆ« y, g (x, y) âˆ‚Î½ âˆ‚Î¼ :=
integral_integral_sub hf hg

/-- The map that sends an LÂ¹-function `f : Î± Ã— Î² â†’ E` to `âˆ«âˆ«f` is continuous. -/
lemma continuous_integral_integral :
  continuous (Î» (f : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E), âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼) :=
begin
  rw [continuous_iff_continuous_at], intro g,
  refine tendsto_integral_of_L1 _ (L1.integrable_coe_fn g).integral_prod_left
    (eventually_of_forall $ Î» h, (L1.integrable_coe_fn h).integral_prod_left) _,
  simp_rw [â† lintegral_fn_integral_sub (Î» x, (nnnorm x : â„â‰¥0âˆ)) (L1.integrable_coe_fn _)
    (L1.integrable_coe_fn g)],
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds _ (Î» i, zero_le _) _,
  { exact Î» i, âˆ«â» x, âˆ«â» y, nnnorm (i (x, y) - g (x, y)) âˆ‚Î½ âˆ‚Î¼ },
  swap, { exact Î» i, lintegral_mono (Î» x, ennnorm_integral_le_lintegral_ennnorm _) },
  show tendsto (Î» (i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E),
    âˆ«â» x, âˆ«â» (y : Î²), nnnorm (i (x, y) - g (x, y)) âˆ‚Î½ âˆ‚Î¼) (ğ“ g) (ğ“ 0),
  have : âˆ€ (i : Î± Ã— Î² â†’â‚[Î¼.prod Î½] E), measurable (Î» z, (nnnorm (i z - g z) : â„â‰¥0âˆ)) :=
  Î» i, ((Lp.measurable i).sub (Lp.measurable g)).ennnorm,
  simp_rw [â† lintegral_prod_of_measurable _ (this _), â† L1.of_real_norm_sub_eq_lintegral,
    â† of_real_zero],
  refine (continuous_of_real.tendsto 0).comp _,
  rw [â† tendsto_iff_norm_tendsto_zero], exact tendsto_id
end

/-- **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  `integrable_prod_iff` can be useful to show that the function in question in integrable.
  `measure_theory.integrable.integral_prod_right` is useful to show that the inner integral
  of the right-hand side is integrable. -/
lemma integral_prod : âˆ€ (f : Î± Ã— Î² â†’ E) (hf : integrable f (Î¼.prod Î½)),
  âˆ« z, f z âˆ‚(Î¼.prod Î½) = âˆ« x, âˆ« y, f (x, y) âˆ‚Î½ âˆ‚Î¼ :=
begin
  apply integrable.induction,
  { intros c s hs h2s,
    simp_rw [integral_indicator hs, â† indicator_comp_right,
      function.comp, integral_indicator (measurable_prod_mk_left hs),
      set_integral_const, integral_smul_const,
      integral_to_real (measurable_measure_prod_mk_left hs).ae_measurable
      (ae_measure_lt_top hs h2s.ne), prod_apply hs] },
  { intros f g hfg i_f i_g hf hg,
    simp_rw [integral_add' i_f i_g, integral_integral_add' i_f i_g, hf, hg] },
  { exact is_closed_eq continuous_integral continuous_integral_integral },
  { intros f g hfg i_f hf, convert hf using 1,
    { exact integral_congr_ae hfg.symm },
    { refine integral_congr_ae _,
      refine (ae_ae_of_ae_prod hfg).mp _,
      apply eventually_of_forall, intros x hfgx,
      exact integral_congr_ae (ae_eq_symm hfgx) } }
end

/-- Symmetric version of **Fubini's Theorem**: For integrable functions on `Î± Ã— Î²`,
  the Bochner integral of `f` is equal to the iterated Bochner integral.
  This version has the integrals on the right-hand side in the other order. -/
lemma integral_prod_symm (f : Î± Ã— Î² â†’ E) (hf : integrable f (Î¼.prod Î½)) :
  âˆ« z, f z âˆ‚(Î¼.prod Î½) = âˆ« y, âˆ« x, f (x, y) âˆ‚Î¼ âˆ‚Î½ :=
by { simp_rw [â† integral_prod_swap f hf.ae_measurable], exact integral_prod _ hf.swap }

/-- Reversed version of **Fubini's Theorem**. -/
lemma integral_integral {f : Î± â†’ Î² â†’ E} (hf : integrable (uncurry f) (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« z, f z.1 z.2 âˆ‚(Î¼.prod Î½) :=
(integral_prod _ hf).symm

/-- Reversed version of **Fubini's Theorem** (symmetric version). -/
lemma integral_integral_symm {f : Î± â†’ Î² â†’ E} (hf : integrable (uncurry f) (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« z, f z.2 z.1 âˆ‚(Î½.prod Î¼) :=
(integral_prod_symm _ hf.swap).symm

/-- Change the order of Bochner integration. -/
lemma integral_integral_swap â¦ƒf : Î± â†’ Î² â†’ Eâ¦„ (hf : integrable (uncurry f) (Î¼.prod Î½)) :
  âˆ« x, âˆ« y, f x y âˆ‚Î½ âˆ‚Î¼ = âˆ« y, âˆ« x, f x y âˆ‚Î¼ âˆ‚Î½ :=
(integral_integral hf).trans (integral_prod_symm _ hf)

end measure_theory
