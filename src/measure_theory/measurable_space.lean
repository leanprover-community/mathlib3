/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Mario Carneiro
-/
import data.set.disjointed
import data.set.countable
import data.indicator_function
import data.equiv.encodable.lattice
import order.filter.basic

/-!
# Measurable spaces and measurable functions

This file defines measurable spaces and the functions and isomorphisms
between them.

A measurable space is a set equipped with a Ïƒ-algebra, a collection of
subsets closed under complementation and countable union. A function
between measurable spaces is measurable if the preimage of each
measurable subset is measurable.

Ïƒ-algebras on a fixed set `Î±` form a complete lattice. Here we order
Ïƒ-algebras by writing `mâ‚ â‰¤ mâ‚‚` if every set which is `mâ‚`-measurable is
also `mâ‚‚`-measurable (that is, `mâ‚` is a subset of `mâ‚‚`). In particular, any
collection of subsets of `Î±` generates a smallest Ïƒ-algebra which
contains all of them. A function `f : Î± â†’ Î²` induces a Galois connection
between the lattices of Ïƒ-algebras on `Î±` and `Î²`.

A measurable equivalence between measurable spaces is an equivalence
which respects the Ïƒ-algebras, that is, for which both directions of
the equivalence are measurable functions.

We say that a filter `f` is measurably generated if every set `s âˆˆ f` includes a measurable
set `t âˆˆ f`. This property is useful, e.g., to extract a measurable witness of `filter.eventually`.

## Main statements

The main theorem of this file is Dynkin's Ï€-Î» theorem, which appears
here as an induction principle `induction_on_inter`. Suppose `s` is a
collection of subsets of `Î±` such that the intersection of two members
of `s` belongs to `s` whenever it is nonempty. Let `m` be the Ïƒ-algebra
generated by `s`. In order to check that a predicate `C` holds on every
member of `m`, it suffices to check that `C` holds on the members of `s` and
that `C` is preserved by complementation and *disjoint* countable
unions.

## Implementation notes

Measurability of a function `f : Î± â†’ Î²` between measurable spaces is
defined in terms of the Galois connection induced by f.

## References

* <https://en.wikipedia.org/wiki/Measurable_space>
* <https://en.wikipedia.org/wiki/Sigma-algebra>
* <https://en.wikipedia.org/wiki/Dynkin_system>

## Tags

measurable space, measurable function, dynkin system
-/

local attribute [instance] classical.prop_decidable
open set encodable
open_locale classical filter

universes u v w x
variables {Î± : Type u} {Î² : Type v} {Î³ : Type w} {Î´ : Type x} {Î¹ : Sort x}
  {s t u : set Î±}

/-- A measurable space is a space equipped with a Ïƒ-algebra. -/
structure measurable_space (Î± : Type u) :=
(is_measurable : set Î± â†’ Prop)
(is_measurable_empty : is_measurable âˆ…)
(is_measurable_compl : âˆ€s, is_measurable s â†’ is_measurable sá¶œ)
(is_measurable_Union : âˆ€f:â„• â†’ set Î±, (âˆ€i, is_measurable (f i)) â†’ is_measurable (â‹ƒi, f i))

attribute [class] measurable_space

section
variable [measurable_space Î±]

/-- `is_measurable s` means that `s` is measurable (in the ambient measure space on `Î±`) -/
def is_measurable : set Î± â†’ Prop := â€¹measurable_space Î±â€º.is_measurable

@[simp] lemma is_measurable.empty : is_measurable (âˆ… : set Î±) :=
â€¹measurable_space Î±â€º.is_measurable_empty

lemma is_measurable.compl : is_measurable s â†’ is_measurable sá¶œ :=
â€¹measurable_space Î±â€º.is_measurable_compl s

lemma is_measurable.of_compl (h : is_measurable sá¶œ) : is_measurable s :=
s.compl_compl â–¸ h.compl

@[simp] lemma is_measurable.compl_iff : is_measurable sá¶œ â†” is_measurable s :=
âŸ¨is_measurable.of_compl, is_measurable.complâŸ©

@[simp] lemma is_measurable.univ : is_measurable (univ : set Î±) :=
by simpa using (@is_measurable.empty Î± _).compl

lemma subsingleton.is_measurable [subsingleton Î±] {s : set Î±} : is_measurable s :=
subsingleton.set_cases is_measurable.empty is_measurable.univ s

lemma is_measurable.congr {s t : set Î±} (hs : is_measurable s) (h : s = t) :
  is_measurable t :=
by rwa â† h

lemma is_measurable.Union [encodable Î²] {f : Î² â†’ set Î±} (h : âˆ€b, is_measurable (f b)) :
  is_measurable (â‹ƒb, f b) :=
by { rw â† encodable.Union_decode2, exact
â€¹measurable_space Î±â€º.is_measurable_Union
  (Î» n, â‹ƒ b âˆˆ decode2 Î² n, f b)
  (Î» n, encodable.Union_decode2_cases is_measurable.empty h) }

lemma is_measurable.bUnion {f : Î² â†’ set Î±} {s : set Î²} (hs : countable s)
  (h : âˆ€bâˆˆs, is_measurable (f b)) : is_measurable (â‹ƒbâˆˆs, f b) :=
begin
  rw bUnion_eq_Union,
  haveI := hs.to_encodable,
  exact is_measurable.Union (by simpa using h)
end

lemma is_measurable.sUnion {s : set (set Î±)} (hs : countable s) (h : âˆ€tâˆˆs, is_measurable t) :
  is_measurable (â‹ƒâ‚€ s) :=
by rw sUnion_eq_bUnion; exact is_measurable.bUnion hs h

lemma is_measurable.Union_Prop {p : Prop} {f : p â†’ set Î±} (hf : âˆ€b, is_measurable (f b)) :
  is_measurable (â‹ƒb, f b) :=
by by_cases p; simp [h, hf, is_measurable.empty]

lemma is_measurable.Inter [encodable Î²] {f : Î² â†’ set Î±} (h : âˆ€b, is_measurable (f b)) :
  is_measurable (â‹‚b, f b) :=
is_measurable.compl_iff.1 $
by rw compl_Inter; exact is_measurable.Union (Î» b, (h b).compl)

lemma is_measurable.bInter {f : Î² â†’ set Î±} {s : set Î²} (hs : countable s)
  (h : âˆ€bâˆˆs, is_measurable (f b)) : is_measurable (â‹‚bâˆˆs, f b) :=
is_measurable.compl_iff.1 $
by rw compl_bInter; exact is_measurable.bUnion hs (Î» b hb, (h b hb).compl)

lemma is_measurable.sInter {s : set (set Î±)} (hs : countable s) (h : âˆ€tâˆˆs, is_measurable t) :
  is_measurable (â‹‚â‚€ s) :=
by rw sInter_eq_bInter; exact is_measurable.bInter hs h

lemma is_measurable.Inter_Prop {p : Prop} {f : p â†’ set Î±} (hf : âˆ€b, is_measurable (f b)) :
  is_measurable (â‹‚b, f b) :=
by by_cases p; simp [h, hf, is_measurable.univ]

lemma is_measurable.union {sâ‚ sâ‚‚ : set Î±}
  (hâ‚ : is_measurable sâ‚) (hâ‚‚ : is_measurable sâ‚‚) : is_measurable (sâ‚ âˆª sâ‚‚) :=
by rw union_eq_Union; exact
is_measurable.Union (bool.forall_bool.2 âŸ¨hâ‚‚, hâ‚âŸ©)

lemma is_measurable.inter {sâ‚ sâ‚‚ : set Î±}
  (hâ‚ : is_measurable sâ‚) (hâ‚‚ : is_measurable sâ‚‚) : is_measurable (sâ‚ âˆ© sâ‚‚) :=
by rw inter_eq_compl_compl_union_compl; exact
(hâ‚.compl.union hâ‚‚.compl).compl

lemma is_measurable.diff {sâ‚ sâ‚‚ : set Î±}
  (hâ‚ : is_measurable sâ‚) (hâ‚‚ : is_measurable sâ‚‚) : is_measurable (sâ‚ \ sâ‚‚) :=
hâ‚.inter hâ‚‚.compl

lemma is_measurable.disjointed {f : â„• â†’ set Î±} (h : âˆ€i, is_measurable (f i)) (n) :
  is_measurable (disjointed f n) :=
disjointed_induct (h n) (assume t i ht, is_measurable.diff ht $ h _)

lemma is_measurable.const (p : Prop) : is_measurable {a : Î± | p} :=
by by_cases p; simp [h, is_measurable.empty]; apply is_measurable.univ

end

@[ext] lemma measurable_space.ext :
  âˆ€{mâ‚ mâ‚‚ : measurable_space Î±}, (âˆ€s:set Î±, mâ‚.is_measurable s â†” mâ‚‚.is_measurable s) â†’ mâ‚ = mâ‚‚
| âŸ¨sâ‚, _, _, _âŸ© âŸ¨sâ‚‚, _, _, _âŸ© h :=
  have sâ‚ = sâ‚‚, from funext $ assume x, propext $ h x,
  by subst this

/-- A typeclass mixin for `measurable_space`s such that each singleton is measurable. -/
class measurable_singleton_class (Î± : Type*) [measurable_space Î±] : Prop :=
(is_measurable_singleton : âˆ€ x, is_measurable ({x} : set Î±))

export measurable_singleton_class (is_measurable_singleton)

attribute [simp] is_measurable_singleton

section measurable_singleton_class

variables [measurable_space Î±] [measurable_singleton_class Î±]

lemma is_measurable_eq {a : Î±} : is_measurable {x | x = a} :=
is_measurable_singleton a

lemma is_measurable.insert {s : set Î±} (hs : is_measurable s) (a : Î±) :
  is_measurable (insert a s) :=
(is_measurable_singleton a).union hs

@[simp] lemma is_measurable_insert {a : Î±} {s : set Î±} :
  is_measurable (insert a s) â†” is_measurable s :=
âŸ¨Î» h, if ha : a âˆˆ s then by rwa â† insert_eq_of_mem ha
  else insert_diff_self_of_not_mem ha â–¸ h.diff (is_measurable_singleton _),
  Î» h, h.insert aâŸ©

lemma set.finite.is_measurable {s : set Î±} (hs : finite s) : is_measurable s :=
finite.induction_on hs is_measurable.empty $ Î» a s ha hsf hsm, hsm.insert _

protected lemma finset.is_measurable (s : finset Î±) : is_measurable (â†‘s : set Î±) :=
s.finite_to_set.is_measurable

end measurable_singleton_class

namespace measurable_space

section complete_lattice

instance : partial_order (measurable_space Î±) :=
{ le          := Î»mâ‚ mâ‚‚, mâ‚.is_measurable â‰¤ mâ‚‚.is_measurable,
  le_refl     := assume a b, le_refl _,
  le_trans    := assume a b c, le_trans,
  le_antisymm := assume a b hâ‚ hâ‚‚, measurable_space.ext $ assume s, âŸ¨hâ‚ s, hâ‚‚ sâŸ© }

/-- The smallest Ïƒ-algebra containing a collection `s` of basic sets -/
inductive generate_measurable (s : set (set Î±)) : set Î± â†’ Prop
| basic : âˆ€uâˆˆs, generate_measurable u
| empty : generate_measurable âˆ…
| compl : âˆ€s, generate_measurable s â†’ generate_measurable sá¶œ
| union : âˆ€f:â„• â†’ set Î±, (âˆ€n, generate_measurable (f n)) â†’ generate_measurable (â‹ƒi, f i)

/-- Construct the smallest measure space containing a collection of basic sets -/
def generate_from (s : set (set Î±)) : measurable_space Î± :=
{ is_measurable       := generate_measurable s,
  is_measurable_empty := generate_measurable.empty,
  is_measurable_compl := generate_measurable.compl,
  is_measurable_Union := generate_measurable.union }

lemma is_measurable_generate_from {s : set (set Î±)} {t : set Î±} (ht : t âˆˆ s) :
  (generate_from s).is_measurable t :=
generate_measurable.basic t ht

lemma generate_from_le {s : set (set Î±)} {m : measurable_space Î±} (h : âˆ€tâˆˆs, m.is_measurable t) :
  generate_from s â‰¤ m :=
assume t (ht : generate_measurable s t), ht.rec_on h
  (is_measurable_empty m)
  (assume s _ hs, is_measurable_compl m s hs)
  (assume f _ hf, is_measurable_Union m f hf)

lemma generate_from_le_iff {s : set (set Î±)} {m : measurable_space Î±} :
  generate_from s â‰¤ m â†” s âŠ† {t | m.is_measurable t} :=
iff.intro
  (assume h u hu, h _ $ is_measurable_generate_from hu)
  (assume h, generate_from_le h)

/-- If `g` is a collection of subsets of `Î±` such that the `Ïƒ`-algebra generated from `g` contains the
  same sets as `g`, then `g` was already a `Ïƒ`-algebra. -/
protected def mk_of_closure (g : set (set Î±)) (hg : {t | (generate_from g).is_measurable t} = g) :
  measurable_space Î± :=
{ is_measurable := Î»s, s âˆˆ g,
  is_measurable_empty := hg â–¸ is_measurable_empty _,
  is_measurable_compl := hg â–¸ is_measurable_compl _,
  is_measurable_Union := hg â–¸ is_measurable_Union _ }

lemma mk_of_closure_sets {s : set (set Î±)}
  {hs : {t | (generate_from s).is_measurable t} = s} :
  measurable_space.mk_of_closure s hs = generate_from s :=
measurable_space.ext $ assume t, show t âˆˆ s â†” _, by rw [â† hs] {occs := occurrences.pos [1] }; refl

/-- We get a Galois insertion between `Ïƒ`-algebras on `Î±` and `set (set Î±)` by using `generate_from`
  on one side and the collection of measurable sets on the other side. -/
def gi_generate_from : galois_insertion (@generate_from Î±) (Î»m, {t | @is_measurable Î± m t}) :=
{ gc        := assume s m, generate_from_le_iff,
  le_l_u    := assume m s, is_measurable_generate_from,
  choice    :=
    Î»g hg, measurable_space.mk_of_closure g $ le_antisymm hg $ generate_from_le_iff.1 $ le_refl _,
  choice_eq := assume g hg, mk_of_closure_sets }

instance : complete_lattice (measurable_space Î±) :=
gi_generate_from.lift_complete_lattice

instance : inhabited (measurable_space Î±) := âŸ¨âŠ¤âŸ©

lemma is_measurable_bot_iff {s : set Î±} : @is_measurable Î± âŠ¥ s â†” (s = âˆ… âˆ¨ s = univ) :=
let b : measurable_space Î± :=
{ is_measurable       := Î»s, s = âˆ… âˆ¨ s = univ,
  is_measurable_empty := or.inl rfl,
  is_measurable_compl := by simp [or_imp_distrib] {contextual := tt},
  is_measurable_Union := assume f hf, classical.by_cases
    (assume h : âˆƒi, f i = univ,
      let âŸ¨i, hiâŸ© := h in
      or.inr $ eq_univ_of_univ_subset $ hi â–¸ le_supr f i)
    (assume h : Â¬ âˆƒi, f i = univ,
      or.inl $ eq_empty_of_subset_empty $ Union_subset $ assume i,
        (hf i).elim (by simp {contextual := tt}) (assume hi, false.elim $ h âŸ¨i, hiâŸ©)) } in
have b = âŠ¥, from bot_unique $ assume s hs,
  hs.elim (assume s, s.symm â–¸ @is_measurable_empty _ âŠ¥) (assume s, s.symm â–¸ @is_measurable.univ _ âŠ¥),
this â–¸ iff.rfl

@[simp] theorem is_measurable_top {s : set Î±} : @is_measurable _ âŠ¤ s := trivial

@[simp] theorem is_measurable_inf {mâ‚ mâ‚‚ : measurable_space Î±} {s : set Î±} :
  @is_measurable _ (mâ‚ âŠ“ mâ‚‚) s â†” @is_measurable _ mâ‚ s âˆ§ @is_measurable _ mâ‚‚ s :=
iff.rfl

@[simp] theorem is_measurable_Inf {ms : set (measurable_space Î±)} {s : set Î±} :
  @is_measurable _ (Inf ms) s â†” âˆ€ m âˆˆ ms, @is_measurable _ m s :=
show s âˆˆ (â‹‚mâˆˆms, {t | @is_measurable _ m t }) â†” _, by simp

@[simp] theorem is_measurable_infi {Î¹} {m : Î¹ â†’ measurable_space Î±} {s : set Î±} :
  @is_measurable _ (infi m) s â†” âˆ€ i, @is_measurable _ (m i) s :=
show s âˆˆ (Î»m, {s | @is_measurable _ m s }) (infi m) â†” _, by rw (@gi_generate_from Î±).gc.u_infi; simp; refl

theorem is_measurable_sup {mâ‚ mâ‚‚ : measurable_space Î±} {s : set Î±} :
  @is_measurable _ (mâ‚ âŠ” mâ‚‚) s â†” generate_measurable (mâ‚.is_measurable âˆª mâ‚‚.is_measurable) s :=
iff.refl _

theorem is_measurable_Sup {ms : set (measurable_space Î±)} {s : set Î±} :
  @is_measurable _ (Sup ms) s â†” generate_measurable (â‹ƒâ‚€ (measurable_space.is_measurable '' ms)) s :=
begin
  change @is_measurable _ (generate_from _) _ â†” _,
  dsimp [generate_from],
  rw (show (â¨† (b : measurable_space Î±) (H : b âˆˆ ms), set_of (is_measurable b)) = (â‹ƒâ‚€(is_measurable '' ms)),
  { ext,
    simp only [exists_prop, mem_Union, sUnion_image, mem_set_of_eq],
    refl, })
end

theorem is_measurable_supr {Î¹} {m : Î¹ â†’ measurable_space Î±} {s : set Î±} :
  @is_measurable _ (supr m) s â†” generate_measurable (â‹ƒi, (m i).is_measurable) s :=
begin
  convert @is_measurable_Sup _ (range m) s,
  simp,
end

end complete_lattice

section functors
variables {m mâ‚ mâ‚‚ : measurable_space Î±} {m' : measurable_space Î²} {f : Î± â†’ Î²} {g : Î² â†’ Î±}

/-- The forward image of a measure space under a function. `map f m` contains the sets `s : set Î²`
  whose preimage under `f` is measurable. -/
protected def map (f : Î± â†’ Î²) (m : measurable_space Î±) : measurable_space Î² :=
{ is_measurable       := Î»s, m.is_measurable $ f â»Â¹' s,
  is_measurable_empty := m.is_measurable_empty,
  is_measurable_compl := assume s hs, m.is_measurable_compl _ hs,
  is_measurable_Union := assume f hf, by rw [preimage_Union]; exact m.is_measurable_Union _ hf }

@[simp] lemma map_id : m.map id = m :=
measurable_space.ext $ assume s, iff.rfl

@[simp] lemma map_comp {f : Î± â†’ Î²} {g : Î² â†’ Î³} : (m.map f).map g = m.map (g âˆ˜ f) :=
measurable_space.ext $ assume s, iff.rfl

/-- The reverse image of a measure space under a function. `comap f m` contains the sets `s : set Î±`
  such that `s` is the `f`-preimage of a measurable set in `Î²`. -/
protected def comap (f : Î± â†’ Î²) (m : measurable_space Î²) : measurable_space Î± :=
{ is_measurable       := Î»s, âˆƒs', m.is_measurable s' âˆ§ f â»Â¹' s' = s,
  is_measurable_empty := âŸ¨âˆ…, m.is_measurable_empty, rflâŸ©,
  is_measurable_compl := assume s âŸ¨s', hâ‚, hâ‚‚âŸ©, âŸ¨s'á¶œ, m.is_measurable_compl _ hâ‚, hâ‚‚ â–¸ rflâŸ©,
  is_measurable_Union := assume s hs,
    let âŸ¨s', hs'âŸ© := classical.axiom_of_choice hs in
    âŸ¨â‹ƒi, s' i, m.is_measurable_Union _ (Î»i, (hs' i).left), by simp [hs'] âŸ© }

@[simp] lemma comap_id : m.comap id = m :=
measurable_space.ext $ assume s, âŸ¨assume âŸ¨s', hs', hâŸ©, h â–¸ hs', assume h, âŸ¨s, h, rflâŸ©âŸ©

@[simp] lemma comap_comp {f : Î² â†’ Î±} {g : Î³ â†’ Î²} : (m.comap f).comap g = m.comap (f âˆ˜ g) :=
measurable_space.ext $ assume s,
  âŸ¨assume âŸ¨t, âŸ¨u, h, huâŸ©, htâŸ©, âŸ¨u, h, ht â–¸ hu â–¸ rflâŸ©, assume âŸ¨t, h, htâŸ©, âŸ¨f â»Â¹' t, âŸ¨_, h, rflâŸ©, htâŸ©âŸ©

lemma comap_le_iff_le_map {f : Î± â†’ Î²} : m'.comap f â‰¤ m â†” m' â‰¤ m.map f :=
âŸ¨assume h s hs, h _ âŸ¨_, hs, rflâŸ©, assume h s âŸ¨t, ht, heqâŸ©, heq â–¸ h _ htâŸ©

lemma gc_comap_map (f : Î± â†’ Î²) :
  galois_connection (measurable_space.comap f) (measurable_space.map f) :=
assume f g, comap_le_iff_le_map

lemma map_mono (h : mâ‚ â‰¤ mâ‚‚) : mâ‚.map f â‰¤ mâ‚‚.map f := (gc_comap_map f).monotone_u h
lemma monotone_map : monotone (measurable_space.map f) := assume a b h, map_mono h
lemma comap_mono (h : mâ‚ â‰¤ mâ‚‚) : mâ‚.comap g â‰¤ mâ‚‚.comap g := (gc_comap_map g).monotone_l h
lemma monotone_comap : monotone (measurable_space.comap g) := assume a b h, comap_mono h

@[simp] lemma comap_bot : (âŠ¥:measurable_space Î±).comap g = âŠ¥ := (gc_comap_map g).l_bot
@[simp] lemma comap_sup : (mâ‚ âŠ” mâ‚‚).comap g = mâ‚.comap g âŠ” mâ‚‚.comap g := (gc_comap_map g).l_sup
@[simp] lemma comap_supr {m : Î¹ â†’ measurable_space Î±} :(â¨†i, m i).comap g = (â¨†i, (m i).comap g) :=
(gc_comap_map g).l_supr

@[simp] lemma map_top : (âŠ¤:measurable_space Î±).map f = âŠ¤ := (gc_comap_map f).u_top
@[simp] lemma map_inf : (mâ‚ âŠ“ mâ‚‚).map f = mâ‚.map f âŠ“ mâ‚‚.map f := (gc_comap_map f).u_inf
@[simp] lemma map_infi {m : Î¹ â†’ measurable_space Î±} : (â¨…i, m i).map f = (â¨…i, (m i).map f) :=
(gc_comap_map f).u_infi

lemma comap_map_le : (m.map f).comap f â‰¤ m := (gc_comap_map f).l_u_le _
lemma le_map_comap : m â‰¤ (m.comap g).map g := (gc_comap_map g).le_u_l _

end functors

lemma generate_from_le_generate_from {s t : set (set Î±)} (h : s âŠ† t) :
  generate_from s â‰¤ generate_from t :=
gi_generate_from.gc.monotone_l h

lemma generate_from_sup_generate_from {s t : set (set Î±)} :
  generate_from s âŠ” generate_from t = generate_from (s âˆª t) :=
(@gi_generate_from Î±).gc.l_sup.symm

lemma comap_generate_from {f : Î± â†’ Î²} {s : set (set Î²)} :
  (generate_from s).comap f = generate_from (preimage f '' s) :=
le_antisymm
  (comap_le_iff_le_map.2 $ generate_from_le $ assume t hts,
    generate_measurable.basic _ $ mem_image_of_mem _ $ hts)
  (generate_from_le $ assume t âŸ¨u, hu, eqâŸ©, eq â–¸ âŸ¨u, generate_measurable.basic _ hu, rflâŸ©)

end measurable_space

section measurable_functions
open measurable_space

/-- A function `f` between measurable spaces is measurable if the preimage of every
  measurable set is measurable. -/
def measurable [measurable_space Î±] [ measurable_space Î²] (f : Î± â†’ Î²) : Prop :=
âˆ€ â¦ƒt : set Î²â¦„, is_measurable t â†’ is_measurable (f â»Â¹' t)

lemma measurable_iff_le_map {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} :
  measurable f â†” mâ‚‚ â‰¤ mâ‚.map f :=
iff.rfl

alias measurable_iff_le_map â†” measurable.le_map measurable.of_le_map

lemma measurable_iff_comap_le {mâ‚ : measurable_space Î±} {mâ‚‚ : measurable_space Î²} {f : Î± â†’ Î²} :
  measurable f â†” mâ‚‚.comap f â‰¤ mâ‚ :=
comap_le_iff_le_map.symm

alias measurable_iff_comap_le â†” measurable.comap_le measurable.of_comap_le

lemma subsingleton.measurable [measurable_space Î±] [measurable_space Î²] [subsingleton Î±]
  {f : Î± â†’ Î²} : measurable f :=
Î» s hs, @subsingleton.is_measurable Î± _ _ _

lemma measurable_id [measurable_space Î±] : measurable (@id Î±) := Î» t, id

lemma measurable.comp [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {g : Î² â†’ Î³} {f : Î± â†’ Î²} (hg : measurable g) (hf : measurable f) : measurable (g âˆ˜ f) :=
Î» t ht, hf (hg ht)

lemma measurable_from_top [measurable_space Î²] {f : Î± â†’ Î²} :
  @measurable _ _ âŠ¤ _ f :=
Î» s hs, trivial

lemma measurable.mono {ma ma' : measurable_space Î±} {mb mb' : measurable_space Î²} {f : Î± â†’ Î²}
  (hf : @measurable Î± Î² ma mb f) (ha : ma â‰¤ ma') (hb : mb' â‰¤ mb) :
  @measurable Î± Î² ma' mb' f :=
Î» t ht, ha _ $ hf $ hb _ ht

lemma measurable_generate_from [measurable_space Î±] {s : set (set Î²)} {f : Î± â†’ Î²}
  (h : âˆ€tâˆˆs, is_measurable (f â»Â¹' t)) : @measurable _ _ _ (generate_from s) f :=
measurable.of_le_map $ generate_from_le h

lemma measurable.piecewise [measurable_space Î±] [measurable_space Î²]
  {s : set Î±} {_ : decidable_pred s} {f g : Î± â†’ Î²}
  (hs : is_measurable s) (hf : measurable f) (hg : measurable g) :
  measurable (piecewise s f g) :=
begin
  intros t ht,
  simp only [piecewise_preimage],
  exact (hs.inter $ hf ht).union (hs.compl.inter $ hg ht)
end

lemma measurable_const {Î± Î²} [measurable_space Î±] [measurable_space Î²] {a : Î±} :
  measurable (Î»b:Î², a) :=
by { intros s hs, by_cases a âˆˆ s; simp [*, preimage] }

lemma measurable.indicator [measurable_space Î±] [measurable_space Î²] [has_zero Î²]
  {s : set Î±} {f : Î± â†’ Î²} (hf : measurable f) (hs : is_measurable s) :
  measurable (s.indicator f) :=
hf.piecewise hs measurable_const

@[to_additive]
lemma measurable_one {Î± Î²} [measurable_space Î±] [has_one Î±] [measurable_space Î²] :
  measurable (1 : Î² â†’ Î±) := @measurable_const _ _ _ _ 1

end measurable_functions

section constructions

instance : measurable_space empty := âŠ¤
instance : measurable_space unit := âŠ¤
instance : measurable_space bool := âŠ¤
instance : measurable_space â„• := âŠ¤
instance : measurable_space â„¤ := âŠ¤
instance : measurable_space â„š := âŠ¤

lemma measurable_to_encodable [encodable Î±] [measurable_space Î±] [measurable_space Î²] {f : Î² â†’ Î±}
  (h : âˆ€ y, is_measurable {x | f x = y}) : measurable f :=
begin
  assume s hs, show is_measurable {x | f x âˆˆ s},
  have : {x | f x âˆˆ s} = â‹ƒ (n âˆˆ s), {x | f x = n}, { ext, simp },
  rw this, simp [is_measurable.Union, is_measurable.Union_Prop, h]
end

lemma measurable_unit [measurable_space Î±] (f : unit â†’ Î±) : measurable f :=
have f = (Î»u, f ()) := funext $ assume âŸ¨âŸ©, rfl,
by rw this; exact measurable_const

section nat

lemma measurable_from_nat [measurable_space Î±] {f : â„• â†’ Î±} : measurable f :=
measurable_from_top

lemma measurable_to_nat [measurable_space Î±] {f : Î± â†’ â„•} :
  (âˆ€ k, is_measurable {x | f x = k}) â†’ measurable f :=
measurable_to_encodable

lemma measurable_find_greatest [measurable_space Î±] {p : â„• â†’ Î± â†’ Prop} :
  âˆ€ {N}, (âˆ€ k â‰¤ N, is_measurable {x | nat.find_greatest (Î» n, p n x) N = k}) â†’
  measurable (Î» x, nat.find_greatest (Î» n, p n x) N)
| 0 := assume h s hs, show is_measurable {x : Î± | (nat.find_greatest (Î» n, p n x) 0) âˆˆ s},
begin
  by_cases h : 0 âˆˆ s,
  { convert is_measurable.univ, simp only [nat.find_greatest_zero, h] },
  { convert is_measurable.empty, simp only [nat.find_greatest_zero, h], refl }
end
| (n + 1) := assume h,
begin
  apply measurable_to_nat, assume k, by_cases hk : k â‰¤ n + 1,
  { exact h k hk },
  { have := is_measurable.empty, rw â† set_of_false at this, convert this, funext, rw eq_false,
    assume h, rw â† h at hk, have := nat.find_greatest_le, contradiction }
end

end nat

section subtype

instance {p : Î± â†’ Prop} [m : measurable_space Î±] : measurable_space (subtype p) :=
m.comap (coe : _ â†’ Î±)

lemma measurable_subtype_coe [measurable_space Î±] {p : Î± â†’ Prop} :
  measurable (coe : subtype p â†’ Î±) :=
measurable_space.le_map_comap

lemma measurable.subtype_coe [measurable_space Î±] [measurable_space Î²] {p : Î² â†’ Prop}
  {f : Î± â†’ subtype p} (hf : measurable f) : measurable (Î»a:Î±, (f a : Î²)) :=
measurable_subtype_coe.comp hf

lemma measurable.subtype_mk [measurable_space Î±] [measurable_space Î²] {p : Î² â†’ Prop}
  {f : Î± â†’ Î²} (hf : measurable f) {h : âˆ€ x, p (f x)} :
  measurable (Î» x, (âŸ¨f x, h xâŸ© : subtype p)) :=
Î» t âŸ¨s, hsâŸ©, hs.2 â–¸ by simp only [â† preimage_comp, (âˆ˜), subtype.coe_mk, hf hs.1]

lemma is_measurable.subtype_image [measurable_space Î±] {s : set Î±} {t : set s}
  (hs : is_measurable s) : is_measurable t â†’ is_measurable ((coe : s â†’ Î±) '' t)
| âŸ¨u, (hu : is_measurable u), (eq : coe â»Â¹' u = t)âŸ© :=
  begin
    rw [â† eq, subtype.image_preimage_coe],
    exact hu.inter hs
  end

lemma measurable_of_measurable_union_cover
  [measurable_space Î±] [measurable_space Î²]
  {f : Î± â†’ Î²} (s t : set Î±) (hs : is_measurable s) (ht : is_measurable t) (h : univ âŠ† s âˆª t)
  (hc : measurable (Î»a:s, f a)) (hd : measurable (Î»a:t, f a)) :
  measurable f :=
begin
  intros u hu,
  convert (hs.subtype_image (hc hu)).union (ht.subtype_image (hd hu)),
  change f â»Â¹' u = coe '' (coe â»Â¹' (f â»Â¹' u) : set s) âˆª coe '' (coe â»Â¹' (f â»Â¹' u) : set t),
  rw [image_preimage_eq_inter_range, image_preimage_eq_inter_range, subtype.range_coe,
      subtype.range_coe, â† inter_distrib_left, univ_subset_iff.1 h, inter_univ],
end

lemma measurable_of_measurable_on_compl_singleton [measurable_space Î±] [measurable_space Î²]
  [measurable_singleton_class Î±]
  {f : Î± â†’ Î²} (a : Î±) (hf : measurable (set.restrict f {x | x â‰  a})) :
  measurable f :=
measurable_of_measurable_union_cover _ _ is_measurable_eq is_measurable_eq.compl
  (Î» x hx, classical.em _)
  (@subsingleton.measurable {x | x = a} _ _ _ âŸ¨Î» x y, subtype.eq $ x.2.trans y.2.symmâŸ© _) hf

end subtype

section prod

instance [mâ‚ : measurable_space Î±] [mâ‚‚ : measurable_space Î²] : measurable_space (Î± Ã— Î²) :=
mâ‚.comap prod.fst âŠ” mâ‚‚.comap prod.snd

lemma measurable_fst [measurable_space Î±] [measurable_space Î²] :
  measurable (prod.fst : Î± Ã— Î² â†’ Î±) :=
measurable.of_comap_le le_sup_left

lemma measurable.fst [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {f : Î± â†’ Î² Ã— Î³} (hf : measurable f) : measurable (Î»a:Î±, (f a).1) :=
measurable_fst.comp hf

lemma measurable_snd [measurable_space Î±] [measurable_space Î²] :
  measurable (prod.snd : Î± Ã— Î² â†’ Î²) :=
measurable.of_comap_le le_sup_right

lemma measurable.snd [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {f : Î± â†’ Î² Ã— Î³} (hf : measurable f) : measurable (Î»a:Î±, (f a).2) :=
measurable_snd.comp hf

lemma measurable.prod [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {f : Î± â†’ Î² Ã— Î³} (hfâ‚ : measurable (Î»a, (f a).1)) (hfâ‚‚ : measurable (Î»a, (f a).2)) :
  measurable f :=
measurable.of_le_map $ sup_le
  (by rw [measurable_space.comap_le_iff_le_map, measurable_space.map_comp]; exact hfâ‚)
  (by rw [measurable_space.comap_le_iff_le_map, measurable_space.map_comp]; exact hfâ‚‚)

lemma measurable.prod_mk [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : measurable f) (hg : measurable g) : measurable (Î»a:Î±, (f a, g a)) :=
measurable.prod hf hg

lemma is_measurable.prod [measurable_space Î±] [measurable_space Î²] {s : set Î±} {t : set Î²}
  (hs : is_measurable s) (ht : is_measurable t) : is_measurable (set.prod s t) :=
is_measurable.inter (measurable_fst hs) (measurable_snd ht)

end prod

section pi

instance measurable_space.pi {Î± : Type u} {Î² : Î± â†’ Type v} [m : Î a, measurable_space (Î² a)] :
  measurable_space (Î a, Î² a) :=
â¨†a, (m a).comap (Î»b, b a)

lemma measurable_pi_apply {Î± : Type u} {Î² : Î± â†’ Type v} [Î a, measurable_space (Î² a)] (a : Î±) :
  measurable (Î»f:Î a, Î² a, f a) :=
measurable.of_comap_le $ le_supr _ a

lemma measurable_pi_lambda {Î± : Type u} {Î² : Î± â†’ Type v} {Î³ : Type w}
  [Î a, measurable_space (Î² a)] [measurable_space Î³]
  (f : Î³ â†’ Î a, Î² a) (hf : âˆ€a, measurable (Î»c, f c a)) :
  measurable f :=
measurable.of_le_map $ supr_le $ assume a, measurable_space.comap_le_iff_le_map.2 (hf a)

end pi

instance [mâ‚ : measurable_space Î±] [mâ‚‚ : measurable_space Î²] : measurable_space (Î± âŠ• Î²) :=
mâ‚.map sum.inl âŠ“ mâ‚‚.map sum.inr

section sum
variables [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]

lemma measurable_inl : measurable (@sum.inl Î± Î²) := measurable.of_le_map inf_le_left

lemma measurable_inr : measurable (@sum.inr Î± Î²) := measurable.of_le_map inf_le_right

lemma measurable_sum {f : Î± âŠ• Î² â†’ Î³}
  (hl : measurable (f âˆ˜ sum.inl)) (hr : measurable (f âˆ˜ sum.inr)) : measurable f :=
measurable.of_comap_le $ le_inf
  (measurable_space.comap_le_iff_le_map.2 $ hl)
  (measurable_space.comap_le_iff_le_map.2 $ hr)

lemma measurable.sum_rec {f : Î± â†’ Î³} {g : Î² â†’ Î³}
  (hf : measurable f) (hg : measurable g) : @measurable (Î± âŠ• Î²) Î³ _ _ (@sum.rec Î± Î² (Î»_, Î³) f g) :=
measurable_sum hf hg

lemma is_measurable.inl_image {s : set Î±} (hs : is_measurable s) :
  is_measurable (sum.inl '' s : set (Î± âŠ• Î²)) :=
âŸ¨show is_measurable (sum.inl â»Â¹' _), by rwa [preimage_image_eq]; exact (assume a b, sum.inl.inj),
  have sum.inr â»Â¹' (sum.inl '' s : set (Î± âŠ• Î²)) = âˆ… :=
    eq_empty_of_subset_empty $ assume x âŸ¨y, hy, eqâŸ©, by contradiction,
  show is_measurable (sum.inr â»Â¹' _), by rw [this]; exact is_measurable.emptyâŸ©

lemma is_measurable_range_inl : is_measurable (range sum.inl : set (Î± âŠ• Î²)) :=
by rw [â† image_univ]; exact is_measurable.univ.inl_image

lemma is_measurable_inr_image {s : set Î²} (hs : is_measurable s) :
  is_measurable (sum.inr '' s : set (Î± âŠ• Î²)) :=
âŸ¨ have sum.inl â»Â¹' (sum.inr '' s : set (Î± âŠ• Î²)) = âˆ… :=
    eq_empty_of_subset_empty $ assume x âŸ¨y, hy, eqâŸ©, by contradiction,
  show is_measurable (sum.inl â»Â¹' _), by rw [this]; exact is_measurable.empty,
  show is_measurable (sum.inr â»Â¹' _), by rwa [preimage_image_eq]; exact (assume a b, sum.inr.inj)âŸ©

lemma is_measurable_range_inr : is_measurable (range sum.inr : set (Î± âŠ• Î²)) :=
by rw [â† image_univ]; exact is_measurable_inr_image is_measurable.univ

end sum

instance {Î² : Î± â†’ Type v} [m : Î a, measurable_space (Î² a)] : measurable_space (sigma Î²) :=
â¨…a, (m a).map (sigma.mk a)

end constructions

/-- Equivalences between measurable spaces. Main application is the simplification of measurability
statements along measurable equivalences. -/
structure measurable_equiv (Î± Î² : Type*) [measurable_space Î±] [measurable_space Î²] extends Î± â‰ƒ Î² :=
(measurable_to_fun : measurable to_fun)
(measurable_inv_fun : measurable inv_fun)


namespace measurable_equiv

instance (Î± Î²) [measurable_space Î±] [measurable_space Î²] : has_coe_to_fun (measurable_equiv Î± Î²) :=
âŸ¨Î»_, Î± â†’ Î², Î»e, e.to_equivâŸ©

lemma coe_eq {Î± Î²} [measurable_space Î±] [measurable_space Î²] (e : measurable_equiv Î± Î²) :
  (e : Î± â†’ Î²) = e.to_equiv := rfl

/-- Any measurable space is equivalent to itself. -/
def refl (Î± : Type*) [measurable_space Î±] : measurable_equiv Î± Î± :=
{ to_equiv := equiv.refl Î±,
  measurable_to_fun := measurable_id, measurable_inv_fun := measurable_id }

/-- The composition of equivalences between measurable spaces. -/
def trans [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  (ab : measurable_equiv Î± Î²) (bc : measurable_equiv Î² Î³) :
  measurable_equiv Î± Î³ :=
{ to_equiv := ab.to_equiv.trans bc.to_equiv,
  measurable_to_fun := bc.measurable_to_fun.comp ab.measurable_to_fun,
  measurable_inv_fun := ab.measurable_inv_fun.comp bc.measurable_inv_fun }

lemma trans_to_equiv {Î± Î²} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  (e : measurable_equiv Î± Î²) (f : measurable_equiv Î² Î³) :
  (e.trans f).to_equiv = e.to_equiv.trans f.to_equiv := rfl

/-- The inverse of an equivalence between measurable spaces. -/
def symm [measurable_space Î±] [measurable_space Î²] (ab : measurable_equiv Î± Î²) :
  measurable_equiv Î² Î± :=
{ to_equiv := ab.to_equiv.symm,
  measurable_to_fun := ab.measurable_inv_fun,
  measurable_inv_fun := ab.measurable_to_fun }

lemma symm_to_equiv {Î± Î²} [measurable_space Î±] [measurable_space Î²] (e : measurable_equiv Î± Î²) :
  e.symm.to_equiv = e.to_equiv.symm := rfl

/-- Equal measurable spaces are equivalent. -/
protected def cast {Î± Î²} [iâ‚ : measurable_space Î±] [iâ‚‚ : measurable_space Î²]
  (h : Î± = Î²) (hi : iâ‚ == iâ‚‚) : measurable_equiv Î± Î² :=
{ to_equiv := equiv.cast h,
  measurable_to_fun  := by substI h; substI hi; exact measurable_id,
  measurable_inv_fun := by substI h; substI hi; exact measurable_id }

protected lemma measurable {Î± Î²} [measurable_space Î±] [measurable_space Î²]
  (e : measurable_equiv Î± Î²) : measurable (e : Î± â†’ Î²) :=
e.measurable_to_fun

protected lemma measurable_coe_iff {Î± Î² Î³} [measurable_space Î±] [measurable_space Î²] [measurable_space Î³]
  {f : Î² â†’ Î³} (e : measurable_equiv Î± Î²) : measurable (f âˆ˜ e) â†” measurable f :=
iff.intro
  (assume hfe,
    have measurable (f âˆ˜ (e.symm.trans e).to_equiv) := hfe.comp e.symm.measurable,
    by rwa [trans_to_equiv, symm_to_equiv, equiv.symm_trans] at this)
  (Î»h, h.comp e.measurable)

/-- Products of equivalent measurable spaces are equivalent. -/
def prod_congr [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] [measurable_space Î´]
  (ab : measurable_equiv Î± Î²) (cd : measurable_equiv Î³ Î´) :
  measurable_equiv (Î± Ã— Î³) (Î² Ã— Î´) :=
{ to_equiv := equiv.prod_congr ab.to_equiv cd.to_equiv,
  measurable_to_fun := measurable.prod_mk
    (ab.measurable_to_fun.comp (measurable.fst measurable_id))
    (cd.measurable_to_fun.comp (measurable.snd measurable_id)),
  measurable_inv_fun := measurable.prod_mk
    (ab.measurable_inv_fun.comp (measurable.fst measurable_id))
    (cd.measurable_inv_fun.comp (measurable.snd measurable_id)) }

/-- Products of measurable spaces are symmetric. -/
def prod_comm [measurable_space Î±] [measurable_space Î²] : measurable_equiv (Î± Ã— Î²) (Î² Ã— Î±) :=
{ to_equiv := equiv.prod_comm Î± Î²,
  measurable_to_fun  := measurable.prod_mk (measurable.snd measurable_id) (measurable.fst measurable_id),
  measurable_inv_fun := measurable.prod_mk (measurable.snd measurable_id) (measurable.fst measurable_id) }

/-- Sums of measurable spaces are symmetric. -/
def sum_congr [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] [measurable_space Î´]
  (ab : measurable_equiv Î± Î²) (cd : measurable_equiv Î³ Î´) :
  measurable_equiv (Î± âŠ• Î³) (Î² âŠ• Î´) :=
{ to_equiv := equiv.sum_congr ab.to_equiv cd.to_equiv,
  measurable_to_fun :=
    begin
      cases ab with ab' abm, cases ab', cases cd with cd' cdm, cases cd',
      refine measurable_sum (measurable_inl.comp abm) (measurable_inr.comp cdm)
    end,
  measurable_inv_fun :=
    begin
      cases ab with ab' _ abm, cases ab', cases cd with cd' _ cdm, cases cd',
      refine measurable_sum (measurable_inl.comp abm) (measurable_inr.comp cdm)
    end }

/-- `set.prod s t â‰ƒ (s Ã— t)` as measurable spaces. -/
def set.prod [measurable_space Î±] [measurable_space Î²] (s : set Î±) (t : set Î²) :
  measurable_equiv (s.prod t) (s Ã— t) :=
{ to_equiv := equiv.set.prod s t,
  measurable_to_fun := measurable.prod_mk
    measurable_id.subtype_coe.fst.subtype_mk
    measurable_id.subtype_coe.snd.subtype_mk,
  measurable_inv_fun := measurable.subtype_mk $ measurable.prod_mk
    measurable_id.fst.subtype_coe
    measurable_id.snd.subtype_coe }

/-- `univ Î± â‰ƒ Î±` as measurable spaces. -/
def set.univ (Î± : Type*) [measurable_space Î±] : measurable_equiv (univ : set Î±) Î± :=
{ to_equiv := equiv.set.univ Î±,
  measurable_to_fun := measurable_id.subtype_coe,
  measurable_inv_fun := measurable_id.subtype_mk }

/-- `{a} â‰ƒ unit` as measurable spaces. -/
def set.singleton [measurable_space Î±] (a:Î±) : measurable_equiv ({a} : set Î±) unit :=
{ to_equiv := equiv.set.singleton a,
  measurable_to_fun := measurable_const,
  measurable_inv_fun := measurable_const }

/-- A set is equivalent to its image under a function `f` as measurable spaces,
  if `f` is an injective measurable function that sends measurable sets to measurable sets. -/
noncomputable def set.image [measurable_space Î±] [measurable_space Î²]
  (f : Î± â†’ Î²) (s : set Î±)
  (hf : function.injective f)
  (hfm : measurable f) (hfi : âˆ€s, is_measurable s â†’ is_measurable (f '' s)) :
  measurable_equiv s (f '' s) :=
{ to_equiv := equiv.set.image f s hf,
  measurable_to_fun  := (hfm.comp measurable_id.subtype_coe).subtype_mk,
  measurable_inv_fun :=
    assume t âŸ¨u, (hu : is_measurable u), eqâŸ©,
    begin
      clear_, subst eq,
      show is_measurable {x : f '' s | ((equiv.set.image f s hf).inv_fun x).val âˆˆ u},
      have : âˆ€(a âˆˆ s) (h : âˆƒa', a' âˆˆ s âˆ§ a' = a), classical.some h = a :=
        Î»a ha h, (classical.some_spec h).2,
      rw show {x:f '' s | ((equiv.set.image f s hf).inv_fun x).val âˆˆ u} = subtype.val â»Â¹' (f '' u),
        by ext âŸ¨b, a, hbs, rflâŸ©; simp [equiv.set.image, equiv.set.image_of_inj_on, hf, this _ hbs],
      exact measurable_subtype_coe (hfi u hu)
    end }

/-- The domain of `f` is equivalent to its range as measurable spaces,
  if `f` is an injective measurable function that sends measurable sets to measurable sets. -/
noncomputable def set.range [measurable_space Î±] [measurable_space Î²]
  (f : Î± â†’ Î²) (hf : function.injective f) (hfm : measurable f)
  (hfi : âˆ€s, is_measurable s â†’ is_measurable (f '' s)) :
  measurable_equiv Î± (range f) :=
(measurable_equiv.set.univ _).symm.trans $
  (measurable_equiv.set.image f univ hf hfm hfi).trans $
  measurable_equiv.cast (by rw image_univ) (by rw image_univ)

/-- `Î±` is equivalent to its image in `Î± âŠ• Î²` as measurable spaces. -/
def set.range_inl [measurable_space Î±] [measurable_space Î²] :
  measurable_equiv (range sum.inl : set (Î± âŠ• Î²)) Î± :=
{ to_fun    := Î»ab, match ab with
    | âŸ¨sum.inl a, _âŸ© := a
    | âŸ¨sum.inr b, pâŸ© := have false, by cases p; contradiction, this.elim
    end,
  inv_fun   := Î»a, âŸ¨sum.inl a, a, rflâŸ©,
  left_inv  := assume âŸ¨ab, a, eqâŸ©, by subst eq; refl,
  right_inv := assume a, rfl,
  measurable_to_fun  := assume s (hs : is_measurable s),
    begin
      refine âŸ¨_, hs.inl_image, set.ext _âŸ©,
      rintros âŸ¨ab, a, rflâŸ©,
      simp [set.range_inl._match_1]
    end,
  measurable_inv_fun := measurable.subtype_mk measurable_inl }

/-- `Î²` is equivalent to its image in `Î± âŠ• Î²` as measurable spaces. -/
def set.range_inr [measurable_space Î±] [measurable_space Î²] :
  measurable_equiv (range sum.inr : set (Î± âŠ• Î²)) Î² :=
{ to_fun    := Î»ab, match ab with
    | âŸ¨sum.inr b, _âŸ© := b
    | âŸ¨sum.inl a, pâŸ© := have false, by cases p; contradiction, this.elim
    end,
  inv_fun   := Î»b, âŸ¨sum.inr b, b, rflâŸ©,
  left_inv  := assume âŸ¨ab, b, eqâŸ©, by subst eq; refl,
  right_inv := assume b, rfl,
  measurable_to_fun  := assume s (hs : is_measurable s),
    begin
      refine âŸ¨_, is_measurable_inr_image hs, set.ext _âŸ©,
      rintros âŸ¨ab, b, rflâŸ©,
      simp [set.range_inr._match_1]
    end,
  measurable_inv_fun := measurable.subtype_mk measurable_inr }

/-- Products distribute over sums (on the right) as measurable spaces. -/
def sum_prod_distrib (Î± Î² Î³) [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] :
  measurable_equiv ((Î± âŠ• Î²) Ã— Î³) ((Î± Ã— Î³) âŠ• (Î² Ã— Î³)) :=
{ to_equiv := equiv.sum_prod_distrib Î± Î² Î³,
  measurable_to_fun  :=
  begin
    refine measurable_of_measurable_union_cover
      ((range sum.inl).prod univ)
      ((range sum.inr).prod univ)
      (is_measurable_range_inl.prod is_measurable.univ)
      (is_measurable_range_inr.prod is_measurable.univ)
      (assume âŸ¨ab, câŸ© s, by cases ab; simp [set.prod_eq])
      _
      _,
    { refine (set.prod (range sum.inl) univ).symm.measurable_coe_iff.1 _,
      refine (prod_congr set.range_inl (set.univ _)).symm.measurable_coe_iff.1 _,
      dsimp [(âˆ˜)],
      convert measurable_inl,
      ext âŸ¨a, câŸ©, refl },
    { refine (set.prod (range sum.inr) univ).symm.measurable_coe_iff.1 _,
      refine (prod_congr set.range_inr (set.univ _)).symm.measurable_coe_iff.1 _,
      dsimp [(âˆ˜)],
      convert measurable_inr,
      ext âŸ¨b, câŸ©, refl }
  end,
  measurable_inv_fun :=
    measurable_sum
      ((measurable_inl.comp (measurable.fst measurable_id)).prod_mk (measurable.snd measurable_id))
      ((measurable_inr.comp (measurable.fst measurable_id)).prod_mk (measurable.snd measurable_id)) }

/-- Products distribute over sums (on the left) as measurable spaces. -/
def prod_sum_distrib (Î± Î² Î³) [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] :
  measurable_equiv (Î± Ã— (Î² âŠ• Î³)) ((Î± Ã— Î²) âŠ• (Î± Ã— Î³)) :=
prod_comm.trans $ (sum_prod_distrib _ _ _).trans $ sum_congr prod_comm prod_comm

/-- Products distribute over sums as measurable spaces. -/
def sum_prod_sum (Î± Î² Î³ Î´)
  [measurable_space Î±] [measurable_space Î²] [measurable_space Î³] [measurable_space Î´] :
  measurable_equiv ((Î± âŠ• Î²) Ã— (Î³ âŠ• Î´)) (((Î± Ã— Î³) âŠ• (Î± Ã— Î´)) âŠ• ((Î² Ã— Î³) âŠ• (Î² Ã— Î´))) :=
(sum_prod_distrib _ _ _).trans $ sum_congr (prod_sum_distrib _ _ _) (prod_sum_distrib _ _ _)

end measurable_equiv


namespace measurable_equiv

end measurable_equiv

namespace measurable_space

/-- A Dynkin system is a collection of subsets of a type `Î±` that contains the empty set,
  is closed under complementation and under countable union of pairwise disjoint sets.
  The disjointness condition is the only difference with `Ïƒ`-algebras.

  The main purpose of Dynkin systems is to provide a powerful induction rule for Ïƒ-algebras
  generated by intersection stable set systems.
-/
structure dynkin_system (Î± : Type*) :=
(has : set Î± â†’ Prop)
(has_empty : has âˆ…)
(has_compl : âˆ€{a}, has a â†’ has aá¶œ)
(has_Union_nat : âˆ€{f:â„• â†’ set Î±}, pairwise (disjoint on f) â†’ (âˆ€i, has (f i)) â†’ has (â‹ƒi, f i))

namespace dynkin_system

@[ext] lemma ext :
  âˆ€{dâ‚ dâ‚‚ : dynkin_system Î±}, (âˆ€s:set Î±, dâ‚.has s â†” dâ‚‚.has s) â†’ dâ‚ = dâ‚‚
| âŸ¨sâ‚, _, _, _âŸ© âŸ¨sâ‚‚, _, _, _âŸ© h :=
  have sâ‚ = sâ‚‚, from funext $ assume x, propext $ h x,
  by subst this

variable (d : dynkin_system Î±)

lemma has_compl_iff {a} : d.has aá¶œ â†” d.has a :=
âŸ¨Î» h, by simpa using d.has_compl h, Î» h, d.has_compl hâŸ©

lemma has_univ : d.has univ :=
by simpa using d.has_compl d.has_empty

theorem has_Union {Î²} [encodable Î²] {f : Î² â†’ set Î±}
  (hd : pairwise (disjoint on f)) (h : âˆ€i, d.has (f i)) : d.has (â‹ƒi, f i) :=
by { rw â† encodable.Union_decode2, exact
d.has_Union_nat (Union_decode2_disjoint_on hd)
  (Î» n, encodable.Union_decode2_cases d.has_empty h) }

theorem has_union {sâ‚ sâ‚‚ : set Î±}
  (hâ‚ : d.has sâ‚) (hâ‚‚ : d.has sâ‚‚) (h : sâ‚ âˆ© sâ‚‚ âŠ† âˆ…) : d.has (sâ‚ âˆª sâ‚‚) :=
by rw union_eq_Union; exact
d.has_Union (pairwise_disjoint_on_bool.2 h)
  (bool.forall_bool.2 âŸ¨hâ‚‚, hâ‚âŸ©)

lemma has_diff {sâ‚ sâ‚‚ : set Î±} (hâ‚ : d.has sâ‚) (hâ‚‚ : d.has sâ‚‚) (h : sâ‚‚ âŠ† sâ‚) : d.has (sâ‚ \ sâ‚‚) :=
d.has_compl_iff.1 begin
  simp [diff_eq, compl_inter],
  exact d.has_union (d.has_compl hâ‚) hâ‚‚ (Î» x âŸ¨hâ‚, hâ‚‚âŸ©, hâ‚ (h hâ‚‚)),
end

instance : partial_order (dynkin_system Î±) :=
{ le          := Î»mâ‚ mâ‚‚, mâ‚.has â‰¤ mâ‚‚.has,
  le_refl     := assume a b, le_refl _,
  le_trans    := assume a b c, le_trans,
  le_antisymm := assume a b hâ‚ hâ‚‚, ext $ assume s, âŸ¨hâ‚ s, hâ‚‚ sâŸ© }

/-- Every measurable space (Ïƒ-algebra) forms a Dynkin system -/
def of_measurable_space (m : measurable_space Î±) : dynkin_system Î± :=
{ has       := m.is_measurable,
  has_empty := m.is_measurable_empty,
  has_compl := m.is_measurable_compl,
  has_Union_nat := assume f _ hf, m.is_measurable_Union f hf }

lemma of_measurable_space_le_of_measurable_space_iff {mâ‚ mâ‚‚ : measurable_space Î±} :
  of_measurable_space mâ‚ â‰¤ of_measurable_space mâ‚‚ â†” mâ‚ â‰¤ mâ‚‚ :=
iff.rfl

/-- The least Dynkin system containing a collection of basic sets.
  This inductive type gives the underlying collection of sets. -/
inductive generate_has (s : set (set Î±)) : set Î± â†’ Prop
| basic : âˆ€tâˆˆs, generate_has t
| empty : generate_has âˆ…
| compl : âˆ€{a}, generate_has a â†’ generate_has aá¶œ
| Union : âˆ€{f:â„• â†’ set Î±}, pairwise (disjoint on f) â†’
    (âˆ€i, generate_has (f i)) â†’ generate_has (â‹ƒi, f i)

/-- The least Dynkin system containing a collection of basic sets. -/
def generate (s : set (set Î±)) : dynkin_system Î± :=
{ has := generate_has s,
  has_empty := generate_has.empty,
  has_compl := assume a, generate_has.compl,
  has_Union_nat := assume f, generate_has.Union }

instance : inhabited (dynkin_system Î±) := âŸ¨generate univâŸ©

/-- If a Dynkin system is closed under binary intersection, then it forms a `Ïƒ`-algebra. -/
def to_measurable_space (h_inter : âˆ€sâ‚ sâ‚‚, d.has sâ‚ â†’ d.has sâ‚‚ â†’ d.has (sâ‚ âˆ© sâ‚‚)) :=
{ measurable_space .
  is_measurable := d.has,
  is_measurable_empty := d.has_empty,
  is_measurable_compl := assume s h, d.has_compl h,
  is_measurable_Union := assume f hf,
    have âˆ€n, d.has (disjointed f n),
      from assume n, disjointed_induct (hf n)
        (assume t i h, h_inter _ _ h $ d.has_compl $ hf i),
    have d.has (â‹ƒn, disjointed f n), from d.has_Union disjoint_disjointed this,
    by rwa [Union_disjointed] at this }

lemma of_measurable_space_to_measurable_space
  (h_inter : âˆ€sâ‚ sâ‚‚, d.has sâ‚ â†’ d.has sâ‚‚ â†’ d.has (sâ‚ âˆ© sâ‚‚)) :
  of_measurable_space (d.to_measurable_space h_inter) = d :=
ext $ assume s, iff.rfl

/-- If `s` is in a Dynkin system `d`, we can form the new Dynkin system `{s âˆ© t | t âˆˆ d}`. -/
def restrict_on {s : set Î±} (h : d.has s) : dynkin_system Î± :=
{ has       := Î»t, d.has (t âˆ© s),
  has_empty := by simp [d.has_empty],
  has_compl := assume t hts,
    have tá¶œ âˆ© s = ((t âˆ© s)á¶œ) \ sá¶œ,
      from set.ext $ assume x, by by_cases x âˆˆ s; simp [h],
    by rw [this]; from d.has_diff (d.has_compl hts) (d.has_compl h)
      (compl_subset_compl.mpr $ inter_subset_right _ _),
  has_Union_nat := assume f hd hf,
    begin
      rw [inter_comm, inter_Union],
      apply d.has_Union_nat,
      { exact Î» i j h x âŸ¨âŸ¨_, hâ‚âŸ©, _, hâ‚‚âŸ©, hd i j h âŸ¨hâ‚, hâ‚‚âŸ© },
      { simpa [inter_comm] using hf },
    end }

lemma generate_le {s : set (set Î±)} (h : âˆ€tâˆˆs, d.has t) : generate s â‰¤ d :=
Î» t ht, ht.rec_on h d.has_empty
  (assume a _ h, d.has_compl h)
  (assume f hd _ hf, d.has_Union hd hf)

lemma generate_inter {s : set (set Î±)}
  (hs : âˆ€tâ‚ tâ‚‚ : set Î±, tâ‚ âˆˆ s â†’ tâ‚‚ âˆˆ s â†’ (tâ‚ âˆ© tâ‚‚).nonempty â†’ tâ‚ âˆ© tâ‚‚ âˆˆ s) {tâ‚ tâ‚‚ : set Î±}
  (htâ‚ : (generate s).has tâ‚) (htâ‚‚ : (generate s).has tâ‚‚) : (generate s).has (tâ‚ âˆ© tâ‚‚) :=
have generate s â‰¤ (generate s).restrict_on htâ‚‚,
  from generate_le _ $ assume sâ‚ hsâ‚,
  have (generate s).has sâ‚, from generate_has.basic sâ‚ hsâ‚,
  have generate s â‰¤ (generate s).restrict_on this,
    from generate_le _ $ assume sâ‚‚ hsâ‚‚,
      show (generate s).has (sâ‚‚ âˆ© sâ‚), from
        (sâ‚‚ âˆ© sâ‚).eq_empty_or_nonempty.elim
        (Î» h,  h.symm â–¸ generate_has.empty)
        (Î» h, generate_has.basic _ (hs _ _ hsâ‚‚ hsâ‚ h)),
  have (generate s).has (tâ‚‚ âˆ© sâ‚), from this _ htâ‚‚,
  show (generate s).has (sâ‚ âˆ© tâ‚‚), by rwa [inter_comm],
this _ htâ‚

lemma generate_from_eq {s : set (set Î±)}
  (hs : âˆ€tâ‚ tâ‚‚ : set Î±, tâ‚ âˆˆ s â†’ tâ‚‚ âˆˆ s â†’ (tâ‚ âˆ© tâ‚‚).nonempty â†’ tâ‚ âˆ© tâ‚‚ âˆˆ s) :
generate_from s = (generate s).to_measurable_space (assume tâ‚ tâ‚‚, generate_inter hs) :=
le_antisymm
  (generate_from_le $ assume t ht, generate_has.basic t ht)
  (of_measurable_space_le_of_measurable_space_iff.mp $
    by rw [of_measurable_space_to_measurable_space];
    from (generate_le _ $ assume t ht, is_measurable_generate_from ht))

end dynkin_system

lemma induction_on_inter {C : set Î± â†’ Prop} {s : set (set Î±)} {m : measurable_space Î±}
  (h_eq : m = generate_from s)
  (h_inter : âˆ€tâ‚ tâ‚‚ : set Î±, tâ‚ âˆˆ s â†’ tâ‚‚ âˆˆ s â†’ (tâ‚ âˆ© tâ‚‚).nonempty â†’ tâ‚ âˆ© tâ‚‚ âˆˆ s)
  (h_empty : C âˆ…) (h_basic : âˆ€tâˆˆs, C t) (h_compl : âˆ€t, m.is_measurable t â†’ C t â†’ C tá¶œ)
  (h_union : âˆ€f:â„• â†’ set Î±, (âˆ€i j, i â‰  j â†’ f i âˆ© f j âŠ† âˆ…) â†’
    (âˆ€i, m.is_measurable (f i)) â†’ (âˆ€i, C (f i)) â†’ C (â‹ƒi, f i)) :
  âˆ€{t}, m.is_measurable t â†’ C t :=
have eq : m.is_measurable = dynkin_system.generate_has s,
  by rw [h_eq, dynkin_system.generate_from_eq h_inter]; refl,
assume t ht,
have dynkin_system.generate_has s t, by rwa [eq] at ht,
this.rec_on h_basic h_empty
  (assume t ht, h_compl t $ by rw [eq]; exact ht)
  (assume f hf ht, h_union f hf $ assume i, by rw [eq]; exact ht _)

end measurable_space

namespace filter

variables [measurable_space Î±]

/-- A filter `f` is measurably generates if each `s âˆˆ f` includes a measurable `t âˆˆ f`. -/
class is_measurably_generated (f : filter Î±) : Prop :=
(exists_measurable_subset : âˆ€ â¦ƒsâ¦„, s âˆˆ f â†’ âˆƒ t âˆˆ f, is_measurable t âˆ§ t âŠ† s)

lemma eventually.exists_measurable_mem {f : filter Î±} [is_measurably_generated f]
  {p : Î± â†’ Prop} (h : âˆ€á¶  x in f, p x) :
  âˆƒ s âˆˆ f, is_measurable s âˆ§ âˆ€ x âˆˆ s, p x :=
is_measurably_generated.exists_measurable_subset h

instance inf_is_measurably_generated (f g : filter Î±) [is_measurably_generated f]
  [is_measurably_generated g] :
  is_measurably_generated (f âŠ“ g) :=
begin
  refine âŸ¨_âŸ©,
  rintros t âŸ¨sf, hsf, sg, hsg, htâŸ©,
  rcases is_measurably_generated.exists_measurable_subset hsf with âŸ¨s'f, hs'f, hmf, hs'sfâŸ©,
  rcases is_measurably_generated.exists_measurable_subset hsg with âŸ¨s'g, hs'g, hmg, hs'sgâŸ©,
  refine âŸ¨s'f âˆ© s'g, inter_mem_inf_sets hs'f hs'g, hmf.inter hmg, _âŸ©,
  exact subset.trans (inter_subset_inter hs'sf hs'sg) ht
end

lemma principal_is_measurably_generated_iff {s : set Î±} :
  is_measurably_generated (ğ“Ÿ s) â†” is_measurable s :=
begin
  refine âŸ¨_, Î» hs, âŸ¨Î» t ht, âŸ¨s, mem_principal_self s, hs, htâŸ©âŸ©âŸ©,
  rintros âŸ¨hsâŸ©,
  rcases hs (mem_principal_self s) with âŸ¨t, ht, htm, htsâŸ©,
  have : t = s := subset.antisymm hts ht,
  rwa â† this
end

alias principal_is_measurably_generated_iff â†”
  _ is_measurable.principal_is_measurably_generated

instance infi_is_measurably_generated {f : Î¹ â†’ filter Î±} [âˆ€ i, is_measurably_generated (f i)] :
  is_measurably_generated (â¨… i, f i) :=
begin
  refine âŸ¨Î» s hs, _âŸ©,
  rw [â† equiv.plift.surjective.infi_comp, mem_infi_iff] at hs,
  rcases hs with âŸ¨t, ht, âŸ¨V, hVf, hVsâŸ©âŸ©,
  choose U hUf hU using Î» i, is_measurably_generated.exists_measurable_subset (hVf i),
  refine âŸ¨â‹‚ i : t, U i, _, _, _âŸ©,
  { rw [â† equiv.plift.surjective.infi_comp, mem_infi_iff],
    refine âŸ¨t, ht, U, hUf, subset.refl _âŸ© },
  { haveI := ht.countable.to_encodable,
    refine is_measurable.Inter (Î» i, (hU i).1) },
  { exact subset.trans (Inter_subset_Inter $ Î» i, (hU i).2) hVs }
end

end filter
