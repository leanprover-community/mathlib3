/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro
-/
import measure_theory.outer_measure

/-!
# Measure spaces

Measures are restricted to a measurable space (associated by the type class `measurable_space`).
This allows us to prove equalities between measures by restricting to a generating set of the
measurable space.

On the other hand, the `Œº.measure s` projection (i.e. the measure of `s` on the measure space `Œº`)
is the _outer_ measure generated by `Œº`. This gives us a unrestricted monotonicity rule and it is
somehow well-behaved on non-measurable sets.

This allows us for the `lebesgue` measure space to have the `borel` measurable space, but still be
a complete measure.
-/

noncomputable theory

open classical set filter finset function
open_locale classical topological_space

universes u v w x

namespace measure_theory

section of_measurable
parameters {Œ± : Type*} [measurable_space Œ±]
parameters (m : Œ† (s : set Œ±), is_measurable s ‚Üí ennreal)
parameters (m0 : m ‚àÖ is_measurable.empty = 0)
include m0

/-- Measure projection which is ‚àû for non-measurable sets.

`measure'` is mainly used to derive the outer measure, for the main `measure` projection. -/
def measure' (s : set Œ±) : ennreal := ‚®Ö h : is_measurable s, m s h

lemma measure'_eq {s} (h : is_measurable s) : measure' s = m s h :=
by simp [measure', h]

lemma measure'_empty : measure' ‚àÖ = 0 :=
(measure'_eq is_measurable.empty).trans m0

lemma measure'_Union_nat
  {f : ‚Ñï ‚Üí set Œ±}
  (hm : ‚àÄi, is_measurable (f i))
  (mU : m (‚ãÉi, f i) (is_measurable.Union hm) = (‚àë'i, m (f i) (hm i))) :
  measure' (‚ãÉi, f i) = (‚àë'i, measure' (f i)) :=
(measure'_eq _).trans $ mU.trans $
by congr; funext i; rw measure'_eq

/-- outer measure of a measure -/
def outer_measure' : outer_measure Œ± :=
outer_measure.of_function measure' measure'_empty

lemma measure'_Union_le_tsum_nat'
  (mU : ‚àÄ {f : ‚Ñï ‚Üí set Œ±} (hm : ‚àÄi, is_measurable (f i)),
    m (‚ãÉi, f i) (is_measurable.Union hm) ‚â§ (‚àë'i, m (f i) (hm i)))
  (s : ‚Ñï ‚Üí set Œ±) :
  measure' (‚ãÉi, s i) ‚â§ (‚àë'i, measure' (s i)) :=
begin
  by_cases h : ‚àÄi, is_measurable (s i),
  { rw [measure'_eq _ _ (is_measurable.Union h),
        congr_arg tsum _], {apply mU h},
    funext i, apply measure'_eq _ _ (h i) },
  { cases not_forall.1 h with i hi,
    exact le_trans (le_infi $ Œª h, hi.elim h) (ennreal.le_tsum i) }
end

parameter (mU : ‚àÄ {f : ‚Ñï ‚Üí set Œ±} (hm : ‚àÄi, is_measurable (f i)),
  pairwise (disjoint on f) ‚Üí
  m (‚ãÉi, f i) (is_measurable.Union hm) = (‚àë'i, m (f i) (hm i)))
include mU

lemma measure'_Union
  {Œ≤} [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±}
  (hd : pairwise (disjoint on f)) (hm : ‚àÄi, is_measurable (f i)) :
  measure' (‚ãÉi, f i) = (‚àë'i, measure' (f i)) :=
begin
  rw [encodable.Union_decode2, outer_measure.Union_aux],
  { exact measure'_Union_nat _ _
      (Œª n, encodable.Union_decode2_cases is_measurable.empty hm)
      (mU _ (measurable_space.Union_decode2_disjoint_on hd)) },
  { apply measure'_empty },
end

lemma measure'_union {s‚ÇÅ s‚ÇÇ : set Œ±}
  (hd : disjoint s‚ÇÅ s‚ÇÇ) (h‚ÇÅ : is_measurable s‚ÇÅ) (h‚ÇÇ : is_measurable s‚ÇÇ) :
  measure' (s‚ÇÅ ‚à™ s‚ÇÇ) = measure' s‚ÇÅ + measure' s‚ÇÇ :=
begin
  rw [union_eq_Union, measure'_Union _ _ @mU
      (pairwise_disjoint_on_bool.2 hd) (bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©),
    tsum_fintype],
  change _+_ = _, simp
end

lemma measure'_mono {s‚ÇÅ s‚ÇÇ : set Œ±} (h‚ÇÅ : is_measurable s‚ÇÅ) (hs : s‚ÇÅ ‚äÜ s‚ÇÇ) :
  measure' s‚ÇÅ ‚â§ measure' s‚ÇÇ :=
le_infi $ Œª h‚ÇÇ, begin
  have := measure'_union _ _ @mU disjoint_diff h‚ÇÅ (h‚ÇÇ.diff h‚ÇÅ),
  rw union_diff_cancel hs at this,
  rw ‚Üê measure'_eq m m0 _,
  exact le_iff_exists_add.2 ‚ü®_, this‚ü©
end

lemma measure'_Union_le_tsum_nat : ‚àÄ (s : ‚Ñï ‚Üí set Œ±),
  measure' (‚ãÉi, s i) ‚â§ (‚àë'i, measure' (s i)) :=
measure'_Union_le_tsum_nat' $ Œª f h, begin
  simp [Union_disjointed.symm] {single_pass := tt},
  rw [mU (is_measurable.disjointed h) disjoint_disjointed],
  refine ennreal.tsum_le_tsum (Œª i, _),
  rw [‚Üê measure'_eq m m0, ‚Üê measure'_eq m m0],
  exact measure'_mono _ _ @mU (is_measurable.disjointed h _) (inter_subset_left _ _)
end

lemma outer_measure'_eq {s : set Œ±} (hs : is_measurable s) :
  outer_measure' s = m s hs :=
by rw ‚Üê measure'_eq m m0 hs; exact
(le_antisymm (outer_measure.of_function_le _ _ _) $
  le_infi $ Œª f, le_infi $ Œª hf,
  le_trans (measure'_mono _ _ @mU hs hf) $
  measure'_Union_le_tsum_nat _ _ @mU _)

lemma outer_measure'_eq_measure' {s : set Œ±} (hs : is_measurable s) :
  outer_measure' s = measure' s :=
by rw [measure'_eq m m0 hs, outer_measure'_eq m m0 @mU hs]

end of_measurable

namespace outer_measure
variables {Œ± : Type*} [measurable_space Œ±] (m : outer_measure Œ±)

def trim : outer_measure Œ± :=
outer_measure' (Œª s _, m s) m.empty

theorem trim_ge : m ‚â§ m.trim :=
Œª s, le_infi $ Œª f, le_infi $ Œª hs,
le_trans (m.mono hs) $ le_trans (m.Union_nat f) $
ennreal.tsum_le_tsum $ Œª i, le_infi $ Œª hf, le_refl _

theorem trim_eq {s : set Œ±} (hs : is_measurable s) : m.trim s = m s :=
le_antisymm (le_trans (of_function_le _ _ _) (infi_le _ hs)) (trim_ge _ _)

theorem trim_congr {m‚ÇÅ m‚ÇÇ : outer_measure Œ±}
  (H : ‚àÄ {s : set Œ±}, is_measurable s ‚Üí m‚ÇÅ s = m‚ÇÇ s) :
  m‚ÇÅ.trim = m‚ÇÇ.trim :=
by unfold trim; congr; funext s hs; exact H hs

theorem trim_le_trim {m‚ÇÅ m‚ÇÇ : outer_measure Œ±} (H : m‚ÇÅ ‚â§ m‚ÇÇ) : m‚ÇÅ.trim ‚â§ m‚ÇÇ.trim :=
Œª s, infi_le_infi $ Œª f, infi_le_infi $ Œª hs,
ennreal.tsum_le_tsum $ Œª b, infi_le_infi $ Œª hf, H _

theorem le_trim_iff {m‚ÇÅ m‚ÇÇ : outer_measure Œ±} : m‚ÇÅ ‚â§ m‚ÇÇ.trim ‚Üî
  ‚àÄ s, is_measurable s ‚Üí m‚ÇÅ s ‚â§ m‚ÇÇ s :=
le_of_function.trans $ forall_congr $ Œª s, le_infi_iff

theorem trim_eq_infi (s : set Œ±) : m.trim s = ‚®Ö t (st : s ‚äÜ t) (ht : is_measurable t), m t :=
begin
  refine le_antisymm
    (le_infi $ Œª t, le_infi $ Œª st, le_infi $ Œª ht, _)
    (le_infi $ Œª f, le_infi $ Œª hf, _),
  { rw ‚Üê trim_eq m ht, exact (trim m).mono st },
  { by_cases h : ‚àÄi, is_measurable (f i),
    { refine infi_le_of_le _ (infi_le_of_le hf $
        infi_le_of_le (is_measurable.Union h) _),
      rw congr_arg tsum _, {exact m.Union_nat _},
      funext i, exact measure'_eq _ _ (h i) },
    { cases not_forall.1 h with i hi,
      exact le_trans (le_infi $ Œª h, hi.elim h) (ennreal.le_tsum i) } }
end

theorem trim_eq_infi' (s : set Œ±) : m.trim s = ‚®Ö t : {t // s ‚äÜ t ‚àß is_measurable t}, m t.1 :=
by simp [infi_subtype, infi_and, trim_eq_infi]

theorem trim_trim (m : outer_measure Œ±) : m.trim.trim = m.trim :=
le_antisymm (le_trim_iff.2 $ Œª s hs, by simp [trim_eq _ hs, le_refl]) (trim_ge _)

theorem trim_zero : (0 : outer_measure Œ±).trim = 0 :=
ext $ Œª s, le_antisymm
  (le_trans ((trim 0).mono (subset_univ s)) $
    le_of_eq $ trim_eq _ is_measurable.univ)
  (zero_le _)

theorem trim_add (m‚ÇÅ m‚ÇÇ : outer_measure Œ±) : (m‚ÇÅ + m‚ÇÇ).trim = m‚ÇÅ.trim + m‚ÇÇ.trim :=
ext $ Œª s, begin
  simp [trim_eq_infi'],
  rw ennreal.infi_add_infi,
  rintro ‚ü®t‚ÇÅ, st‚ÇÅ, ht‚ÇÅ‚ü© ‚ü®t‚ÇÇ, st‚ÇÇ, ht‚ÇÇ‚ü©,
  exact ‚ü®‚ü®_, subset_inter_iff.2 ‚ü®st‚ÇÅ, st‚ÇÇ‚ü©, ht‚ÇÅ.inter ht‚ÇÇ‚ü©,
    add_le_add'
      (m‚ÇÅ.mono' (inter_subset_left _ _))
      (m‚ÇÇ.mono' (inter_subset_right _ _))‚ü©,
end

theorem trim_sum_ge {Œπ} (m : Œπ ‚Üí outer_measure Œ±) : sum (Œª i, (m i).trim) ‚â§ (sum m).trim :=
Œª s, by simp [trim_eq_infi]; exact
Œª t st ht, ennreal.tsum_le_tsum (Œª i,
  infi_le_of_le t $ infi_le_of_le st $ infi_le _ ht)

end outer_measure

structure measure (Œ± : Type*) [measurable_space Œ±] extends outer_measure Œ± :=
(m_Union {f : ‚Ñï ‚Üí set Œ±} :
  (‚àÄi, is_measurable (f i)) ‚Üí pairwise (disjoint on f) ‚Üí
  measure_of (‚ãÉi, f i) = (‚àë'i, measure_of (f i)))
(trimmed : to_outer_measure.trim = to_outer_measure)

/-- Measure projections for a measure space.

For measurable sets this returns the measure assigned by the `measure_of` field in `measure`.
But we can extend this to _all_ sets, but using the outer measure. This gives us monotonicity and
subadditivity for all sets.
-/
instance measure.has_coe_to_fun {Œ±} [measurable_space Œ±] : has_coe_to_fun (measure Œ±) :=
‚ü®Œª _, set Œ± ‚Üí ennreal, Œª m, m.to_outer_measure‚ü©

namespace measure

def of_measurable {Œ±} [measurable_space Œ±]
  (m : Œ† (s : set Œ±), is_measurable s ‚Üí ennreal)
  (m0 : m ‚àÖ is_measurable.empty = 0)
  (mU : ‚àÄ {f : ‚Ñï ‚Üí set Œ±} (h : ‚àÄi, is_measurable (f i)),
    pairwise (disjoint on f) ‚Üí
    m (‚ãÉi, f i) (is_measurable.Union h) = (‚àë'i, m (f i) (h i))) :
  measure Œ± :=
{ m_Union := Œª f hf hd,
  show outer_measure' m m0 (Union f) =
      ‚àë' i, outer_measure' m m0 (f i), begin
    rw [outer_measure'_eq m m0 @mU, mU hf hd],
    congr, funext n, rw outer_measure'_eq m m0 @mU
  end,
  trimmed :=
  show (outer_measure' m m0).trim = outer_measure' m m0, begin
    unfold outer_measure.trim,
    congr, funext s hs,
    exact outer_measure'_eq m m0 @mU hs
  end,
  ..outer_measure' m m0 }

lemma of_measurable_apply {Œ±} [measurable_space Œ±]
  {m : Œ† (s : set Œ±), is_measurable s ‚Üí ennreal}
  {m0 : m ‚àÖ is_measurable.empty = 0}
  {mU : ‚àÄ {f : ‚Ñï ‚Üí set Œ±} (h : ‚àÄi, is_measurable (f i)),
    pairwise (disjoint on f) ‚Üí
    m (‚ãÉi, f i) (is_measurable.Union h) = (‚àë'i, m (f i) (h i))}
  (s : set Œ±) (hs : is_measurable s) :
  of_measurable m m0 @mU s = m s hs :=
outer_measure'_eq m m0 @mU hs

@[ext] lemma ext {Œ±} [measurable_space Œ±] :
  ‚àÄ {Œº‚ÇÅ Œº‚ÇÇ : measure Œ±}, (‚àÄs, is_measurable s ‚Üí Œº‚ÇÅ s = Œº‚ÇÇ s) ‚Üí Œº‚ÇÅ = Œº‚ÇÇ
| ‚ü®m‚ÇÅ, u‚ÇÅ, h‚ÇÅ‚ü© ‚ü®m‚ÇÇ, u‚ÇÇ, h‚ÇÇ‚ü© h := by congr; rw [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ];
  exact outer_measure.trim_congr h

end measure

section
variables {Œ± : Type*} {Œ≤ : Type*} [measurable_space Œ±] {Œº Œº‚ÇÅ Œº‚ÇÇ : measure Œ±} {s s‚ÇÅ s‚ÇÇ : set Œ±}

@[simp] lemma to_outer_measure_apply (s) : Œº.to_outer_measure s = Œº s := rfl

lemma measure_eq_trim (s) : Œº s = Œº.to_outer_measure.trim s :=
by rw Œº.trimmed; refl

lemma measure_eq_infi (s) : Œº s = ‚®Ö t (st : s ‚äÜ t) (ht : is_measurable t), Œº t :=
by rw [measure_eq_trim, outer_measure.trim_eq_infi]; refl

lemma measure_eq_outer_measure' :
  Œº s = outer_measure' (Œª s _, Œº s) Œº.empty s :=
measure_eq_trim _

lemma to_outer_measure_eq_outer_measure' :
  Œº.to_outer_measure = outer_measure' (Œª s _, Œº s) Œº.empty :=
Œº.trimmed.symm

lemma measure_eq_measure' (hs : is_measurable s) :
  Œº s = measure' (Œª s _, Œº s) Œº.empty s :=
by rw [measure_eq_outer_measure',
  outer_measure'_eq_measure' (Œª s _, Œº s) _ Œº.m_Union hs]

@[simp] lemma measure_empty : Œº ‚àÖ = 0 := Œº.empty

lemma measure_mono (h : s‚ÇÅ ‚äÜ s‚ÇÇ) : Œº s‚ÇÅ ‚â§ Œº s‚ÇÇ := Œº.mono h

lemma measure_mono_null (h : s‚ÇÅ ‚äÜ s‚ÇÇ) (h‚ÇÇ : Œº s‚ÇÇ = 0) : Œº s‚ÇÅ = 0 :=
by rw [‚Üê le_zero_iff_eq, ‚Üê h‚ÇÇ]; exact measure_mono h

lemma exists_is_measurable_superset_of_measure_eq_zero {s : set Œ±} (h : Œº s = 0) :
  ‚àÉt, s ‚äÜ t ‚àß is_measurable t ‚àß Œº t = 0 :=
begin
  rw [measure_eq_infi] at h,
  have h := (infi_eq_bot _).1 h,
  choose t ht using show ‚àÄn:‚Ñï, ‚àÉt, s ‚äÜ t ‚àß is_measurable t ‚àß Œº t < n‚Åª¬π,
  { assume n,
    have : (0 : ennreal) < n‚Åª¬π :=
      (zero_lt_iff_ne_zero.2 $ ennreal.inv_ne_zero.2 $ ennreal.nat_ne_top _),
    rcases h _ this with ‚ü®t, ht‚ü©,
    use [t],
    simpa [(>), infi_lt_iff, -add_comm] using ht },
  refine ‚ü®‚ãÇn, t n, subset_Inter (Œªn, (ht n).1), is_measurable.Inter (Œªn, (ht n).2.1), _‚ü©,
  refine eq_of_le_of_forall_le_of_dense bot_le (assume r hr, _),
  rcases ennreal.exists_inv_nat_lt (ne_of_gt hr) with ‚ü®n, hn‚ü©,
  calc Œº (‚ãÇn, t n) ‚â§ Œº (t n) : measure_mono (Inter_subset _ _)
    ... ‚â§ n‚Åª¬π : le_of_lt (ht n).2.2
    ... ‚â§ r : le_of_lt hn
end

theorem measure_Union_le {Œ≤} [encodable Œ≤] (s : Œ≤ ‚Üí set Œ±) : Œº (‚ãÉi, s i) ‚â§ (‚àë'i, Œº (s i)) :=
Œº.to_outer_measure.Union _

lemma measure_Union_null {Œ≤} [encodable Œ≤] {s : Œ≤ ‚Üí set Œ±} :
  (‚àÄ i, Œº (s i) = 0) ‚Üí Œº (‚ãÉi, s i) = 0 :=
Œº.to_outer_measure.Union_null

theorem measure_union_le (s‚ÇÅ s‚ÇÇ : set Œ±) : Œº (s‚ÇÅ ‚à™ s‚ÇÇ) ‚â§ Œº s‚ÇÅ + Œº s‚ÇÇ :=
Œº.to_outer_measure.union _ _

lemma measure_union_null {s‚ÇÅ s‚ÇÇ : set Œ±} : Œº s‚ÇÅ = 0 ‚Üí Œº s‚ÇÇ = 0 ‚Üí Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = 0 :=
Œº.to_outer_measure.union_null

lemma measure_Union {Œ≤} [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±}
  (hn : pairwise (disjoint on f)) (h : ‚àÄi, is_measurable (f i)) :
  Œº (‚ãÉi, f i) = (‚àë'i, Œº (f i)) :=
by rw [measure_eq_measure' (is_measurable.Union h),
     measure'_Union (Œª s _, Œº s) _ Œº.m_Union hn h];
   simp [measure_eq_measure', h]

lemma measure_union (hd : disjoint s‚ÇÅ s‚ÇÇ) (h‚ÇÅ : is_measurable s‚ÇÅ) (h‚ÇÇ : is_measurable s‚ÇÇ) :
  Œº (s‚ÇÅ ‚à™ s‚ÇÇ) = Œº s‚ÇÅ + Œº s‚ÇÇ :=
by rw [measure_eq_measure' (h‚ÇÅ.union h‚ÇÇ),
     measure'_union (Œª s _, Œº s) _ Œº.m_Union hd h‚ÇÅ h‚ÇÇ];
   simp [measure_eq_measure', h‚ÇÅ, h‚ÇÇ]

lemma measure_bUnion {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hs : countable s)
  (hd : pairwise_on s (disjoint on f)) (h : ‚àÄb‚ààs, is_measurable (f b)) :
  Œº (‚ãÉb‚ààs, f b) = ‚àë'p:s, Œº (f p.1) :=
begin
  haveI := hs.to_encodable,
  rw [‚Üê measure_Union, bUnion_eq_Union],
  { rintro ‚ü®i, hi‚ü© ‚ü®j, hj‚ü© ij x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    exact hd i hi j hj (mt subtype.eq' ij:_) ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© },
  { simpa }
end

lemma measure_sUnion {S : set (set Œ±)} (hs : countable S)
  (hd : pairwise_on S disjoint) (h : ‚àÄs‚ààS, is_measurable s) :
  Œº (‚ãÉ‚ÇÄ S) = ‚àë's:S, Œº s.1 :=
by rw [sUnion_eq_bUnion, measure_bUnion hs hd h]

lemma measure_diff {s‚ÇÅ s‚ÇÇ : set Œ±} (h : s‚ÇÇ ‚äÜ s‚ÇÅ)
  (h‚ÇÅ : is_measurable s‚ÇÅ) (h‚ÇÇ : is_measurable s‚ÇÇ)
  (h_fin : Œº s‚ÇÇ < ‚ä§) : Œº (s‚ÇÅ \ s‚ÇÇ) = Œº s‚ÇÅ - Œº s‚ÇÇ :=
begin
  refine (ennreal.add_sub_self' h_fin).symm.trans _,
  rw [‚Üê measure_union disjoint_diff h‚ÇÇ (h‚ÇÅ.diff h‚ÇÇ), union_diff_cancel h]
end

lemma measure_Union_eq_supr_nat {s : ‚Ñï ‚Üí set Œ±} (h : ‚àÄi, is_measurable (s i)) (hs : monotone s) :
  Œº (‚ãÉi, s i) = (‚®Üi, Œº (s i)) :=
begin
  refine le_antisymm _ (supr_le $ Œª i, measure_mono $ subset_Union _ _),
  rw [‚Üê Union_disjointed,
    measure_Union disjoint_disjointed (is_measurable.disjointed h),
    ennreal.tsum_eq_supr_nat],
  refine supr_le (Œª n, _),
  cases n, {apply zero_le _},
  suffices : (finset.range n.succ).sum (Œª i, Œº (disjointed s i)) = Œº (s n),
  { rw this, exact le_supr _ n },
  rw [‚Üê Union_disjointed_of_mono hs, measure_Union, tsum_eq_sum],
  { apply sum_congr rfl, intros i hi,
    simp [finset.mem_range.1 hi] },
  { intros i hi, simp [mt finset.mem_range.2 hi] },
  { rintro i j ij x ‚ü®‚ü®_, ‚ü®_, rfl‚ü©, h‚ÇÅ‚ü©, ‚ü®_, ‚ü®_, rfl‚ü©, h‚ÇÇ‚ü©‚ü©,
    exact disjoint_disjointed i j ij ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© },
  { intro i,
    by_cases h' : i < n.succ; simp [h', is_measurable.empty],
    apply is_measurable.disjointed h }
end

lemma measure_Inter_eq_infi_nat {s : ‚Ñï ‚Üí set Œ±}
  (h : ‚àÄi, is_measurable (s i)) (hs : ‚àÄi j, i ‚â§ j ‚Üí s j ‚äÜ s i)
  (hfin : ‚àÉi, Œº (s i) < ‚ä§) :
  Œº (‚ãÇi, s i) = (‚®Öi, Œº (s i)) :=
begin
  rcases hfin with ‚ü®k, hk‚ü©,
  rw [‚Üê ennreal.sub_sub_cancel (by exact hk) (infi_le _ k),
    ennreal.sub_infi,
    ‚Üê ennreal.sub_sub_cancel (by exact hk) (measure_mono (Inter_subset _ k)),
    ‚Üê measure_diff (Inter_subset _ k) (h k) (is_measurable.Inter h)
      (lt_of_le_of_lt (measure_mono (Inter_subset _ k)) hk),
    diff_Inter, measure_Union_eq_supr_nat],
  { congr, funext i,
    cases le_total k i with ik ik,
    { exact measure_diff (hs _ _ ik) (h k) (h i)
        (lt_of_le_of_lt (measure_mono (hs _ _ ik)) hk) },
    { rw [diff_eq_empty.2 (hs _ _ ik), measure_empty,
      ennreal.sub_eq_zero_of_le (measure_mono (hs _ _ ik))] } },
  { exact Œª i, (h k).diff (h i) },
  { exact Œª i j ij, diff_subset_diff_right (hs _ _ ij) }
end

lemma measure_eq_inter_diff {Œº : measure Œ±} {s t : set Œ±}
  (hs : is_measurable s) (ht : is_measurable t) :
  Œº s = Œº (s ‚à© t) + Œº (s \ t) :=
have hd : disjoint (s ‚à© t) (s \ t) := assume a ‚ü®‚ü®_, hs‚ü©, _, hns‚ü©, hns hs ,
by rw [‚Üê measure_union hd (hs.inter ht) (hs.diff ht), inter_union_diff s t]

lemma tendsto_measure_Union {Œº : measure Œ±} {s : ‚Ñï ‚Üí set Œ±}
  (hs : ‚àÄn, is_measurable (s n)) (hm : monotone s) :
  tendsto (Œº ‚àò s) at_top (ùìù (Œº (‚ãÉn, s n))) :=
begin
  rw measure_Union_eq_supr_nat hs hm,
  exact tendsto_at_top_supr_nat (Œº ‚àò s) (assume n m hnm, measure_mono $ hm $ hnm)
end

lemma tendsto_measure_Inter {Œº : measure Œ±} {s : ‚Ñï ‚Üí set Œ±}
  (hs : ‚àÄn, is_measurable (s n)) (hm : ‚àÄn m, n ‚â§ m ‚Üí s m ‚äÜ s n) (hf : ‚àÉi, Œº (s i) < ‚ä§) :
  tendsto (Œº ‚àò s) at_top (ùìù (Œº (‚ãÇn, s n))) :=
begin
  rw measure_Inter_eq_infi_nat hs hm hf,
  exact tendsto_at_top_infi_nat (Œº ‚àò s) (assume n m hnm, measure_mono $ hm _ _ $ hnm),
end

end

def outer_measure.to_measure {Œ±} (m : outer_measure Œ±)
  [ms : measurable_space Œ±] (h : ms ‚â§ m.caratheodory) :
  measure Œ± :=
measure.of_measurable (Œª s _, m s) m.empty
  (Œª f hf hd, m.Union_eq_of_caratheodory (Œª i, h _ (hf i)) hd)

lemma le_to_outer_measure_caratheodory {Œ±} [ms : measurable_space Œ±]
  (Œº : measure Œ±) : ms ‚â§ Œº.to_outer_measure.caratheodory :=
begin
  assume s hs,
  rw to_outer_measure_eq_outer_measure',
  refine outer_measure.caratheodory_is_measurable (Œª t, le_infi $ Œª ht, _),
  rw [‚Üê measure_eq_measure' (ht.inter hs),
    ‚Üê measure_eq_measure' (ht.diff hs),
    ‚Üê measure_union _ (ht.inter hs) (ht.diff hs),
    inter_union_diff],
  exact le_refl _,
  exact Œª x ‚ü®‚ü®_, h‚ÇÅ‚ü©, _, h‚ÇÇ‚ü©, h‚ÇÇ h‚ÇÅ
end

lemma to_measure_to_outer_measure {Œ±} (m : outer_measure Œ±)
  [ms : measurable_space Œ±] (h : ms ‚â§ m.caratheodory) :
  (m.to_measure h).to_outer_measure = m.trim := rfl

@[simp] lemma to_measure_apply {Œ±} (m : outer_measure Œ±)
  [ms : measurable_space Œ±] (h : ms ‚â§ m.caratheodory)
  {s : set Œ±} (hs : is_measurable s) :
  m.to_measure h s = m s := m.trim_eq hs

lemma to_outer_measure_to_measure {Œ± : Type*} [ms : measurable_space Œ±] {Œº : measure Œ±} :
  Œº.to_outer_measure.to_measure (le_to_outer_measure_caratheodory _) = Œº :=
measure.ext $ Œª s, Œº.to_outer_measure.trim_eq

namespace measure
variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*}
  [measurable_space Œ±] [measurable_space Œ≤] [measurable_space Œ≥]

instance : has_zero (measure Œ±) :=
‚ü®{ to_outer_measure := 0,
   m_Union := Œª f hf hd, tsum_zero.symm,
   trimmed := outer_measure.trim_zero }‚ü©

@[simp] theorem zero_to_outer_measure :
  (0 : measure Œ±).to_outer_measure = 0 := rfl

@[simp] theorem zero_apply (s : set Œ±) : (0 : measure Œ±) s = 0 := rfl

instance : inhabited (measure Œ±) := ‚ü®0‚ü©

instance : has_add (measure Œ±) :=
‚ü®ŒªŒº‚ÇÅ Œº‚ÇÇ, {
  to_outer_measure := Œº‚ÇÅ.to_outer_measure + Œº‚ÇÇ.to_outer_measure,
  m_Union := Œªs hs hd,
    show Œº‚ÇÅ (‚ãÉ i, s i) + Œº‚ÇÇ (‚ãÉ i, s i) = ‚àë' i, Œº‚ÇÅ (s i) + Œº‚ÇÇ (s i),
    by rw [ennreal.tsum_add, measure_Union hd hs, measure_Union hd hs],
  trimmed := by rw [outer_measure.trim_add, Œº‚ÇÅ.trimmed, Œº‚ÇÇ.trimmed] }‚ü©

@[simp] theorem add_to_outer_measure (Œº‚ÇÅ Œº‚ÇÇ : measure Œ±) :
  (Œº‚ÇÅ + Œº‚ÇÇ).to_outer_measure = Œº‚ÇÅ.to_outer_measure + Œº‚ÇÇ.to_outer_measure := rfl

@[simp] theorem add_apply (Œº‚ÇÅ Œº‚ÇÇ : measure Œ±) (s : set Œ±) :
  (Œº‚ÇÅ + Œº‚ÇÇ) s = Œº‚ÇÅ s + Œº‚ÇÇ s := rfl

instance add_comm_monoid : add_comm_monoid (measure Œ±) :=
{ zero      := 0,
  add       := (+),
  add_assoc := assume a b c, ext $ assume s hs, add_assoc _ _ _,
  add_comm  := assume a b, ext $ assume s hs, add_comm _ _,
  zero_add  := assume a, ext $ by simp,
  add_zero  := assume a, ext $ assume s hs, add_zero _ }

instance : partial_order (measure Œ±) :=
{ le          := Œªm‚ÇÅ m‚ÇÇ, ‚àÄ s, is_measurable s ‚Üí m‚ÇÅ s ‚â§ m‚ÇÇ s,
  le_refl     := assume m s hs, le_refl _,
  le_trans    := assume m‚ÇÅ m‚ÇÇ m‚ÇÉ h‚ÇÅ h‚ÇÇ s hs, le_trans (h‚ÇÅ s hs) (h‚ÇÇ s hs),
  le_antisymm := assume m‚ÇÅ m‚ÇÇ h‚ÇÅ h‚ÇÇ, ext $
    assume s hs, le_antisymm (h‚ÇÅ s hs) (h‚ÇÇ s hs) }

theorem le_iff {Œº‚ÇÅ Œº‚ÇÇ : measure Œ±} :
  Œº‚ÇÅ ‚â§ Œº‚ÇÇ ‚Üî ‚àÄ s, is_measurable s ‚Üí Œº‚ÇÅ s ‚â§ Œº‚ÇÇ s := iff.rfl

theorem to_outer_measure_le {Œº‚ÇÅ Œº‚ÇÇ : measure Œ±} :
  Œº‚ÇÅ.to_outer_measure ‚â§ Œº‚ÇÇ.to_outer_measure ‚Üî Œº‚ÇÅ ‚â§ Œº‚ÇÇ :=
by rw [‚Üê Œº‚ÇÇ.trimmed, outer_measure.le_trim_iff]; refl

theorem le_iff' {Œº‚ÇÅ Œº‚ÇÇ : measure Œ±} :
  Œº‚ÇÅ ‚â§ Œº‚ÇÇ ‚Üî ‚àÄ s, Œº‚ÇÅ s ‚â§ Œº‚ÇÇ s :=
to_outer_measure_le.symm

section
variables {m : set (measure Œ±)} {Œº : measure Œ±}

lemma Inf_caratheodory (s : set Œ±) (hs : is_measurable s) :
  (Inf (measure.to_outer_measure '' m)).caratheodory.is_measurable s :=
begin
  rw [outer_measure.Inf_eq_of_function_Inf_gen],
  refine outer_measure.caratheodory_is_measurable (assume t, _),
  cases t.eq_empty_or_nonempty with ht ht, by simp [ht],
  simp only [outer_measure.Inf_gen_nonempty1 _ _ ht, le_infi_iff, ball_image_iff,
    to_outer_measure_apply, measure_eq_infi t],
  assume Œº hŒº u htu hu,
  have hm : ‚àÄ{s t}, s ‚äÜ t ‚Üí outer_measure.Inf_gen (to_outer_measure '' m) s ‚â§ Œº t,
  { assume s t hst,
    rw [outer_measure.Inf_gen_nonempty2 _ _ (mem_image_of_mem _ hŒº)],
    refine infi_le_of_le (Œº.to_outer_measure) (infi_le_of_le (mem_image_of_mem _ hŒº) _),
    rw [to_outer_measure_apply],
    refine measure_mono hst },
  rw [measure_eq_inter_diff hu hs],
  refine add_le_add' (hm $ inter_subset_inter_left _ htu) (hm $ diff_subset_diff_left htu)
end

instance : has_Inf (measure Œ±) :=
‚ü®Œªm, (Inf (to_outer_measure '' m)).to_measure $ Inf_caratheodory‚ü©

lemma Inf_apply {m : set (measure Œ±)} {s : set Œ±} (hs : is_measurable s) :
  Inf m s = Inf (to_outer_measure '' m) s :=
to_measure_apply _ _ hs

private lemma Inf_le (h : Œº ‚àà m) : Inf m ‚â§ Œº :=
have Inf (to_outer_measure '' m) ‚â§ Œº.to_outer_measure := Inf_le (mem_image_of_mem _ h),
assume s hs, by rw [Inf_apply hs, ‚Üê to_outer_measure_apply]; exact this s

private lemma le_Inf (h : ‚àÄŒº' ‚àà m, Œº ‚â§ Œº') : Œº ‚â§ Inf m :=
have Œº.to_outer_measure ‚â§ Inf (to_outer_measure '' m) :=
  le_Inf $ ball_image_of_ball $ assume Œº hŒº, to_outer_measure_le.2 $ h _ hŒº,
assume s hs, by rw [Inf_apply hs, ‚Üê to_outer_measure_apply]; exact this s

instance : has_Sup (measure Œ±) := ‚ü®Œªs, Inf {Œº' | ‚àÄŒº‚ààs, Œº ‚â§ Œº' }‚ü©
private lemma le_Sup (h : Œº ‚àà m) : Œº ‚â§ Sup m := le_Inf $ assume Œº' h', h' _ h
private lemma Sup_le (h : ‚àÄŒº' ‚àà m, Œº' ‚â§ Œº) : Sup m ‚â§ Œº := Inf_le h

instance : order_bot (measure Œ±) :=
{ bot := 0, bot_le := assume a s hs, by exact bot_le, .. measure.partial_order }

instance : order_top (measure Œ±) :=
{ top := (‚ä§ : outer_measure Œ±).to_measure (by rw [outer_measure.top_caratheodory]; exact le_top),
  le_top := assume a s hs,
    by cases s.eq_empty_or_nonempty with h  h;
      simp [h, to_measure_apply ‚ä§ _ hs, outer_measure.top_apply],
  .. measure.partial_order }

instance : complete_lattice (measure Œ±) :=
{ Inf          := Inf,
  Sup          := Sup,
  inf          := Œªa b, Inf {a, b},
  sup          := Œªa b, Sup {a, b},
  le_Sup       := assume s Œº h, le_Sup h,
  Sup_le       := assume s Œº h, Sup_le h,
  Inf_le       := assume s Œº h, Inf_le h,
  le_Inf       := assume s Œº h, le_Inf h,
  le_sup_left  := assume a b, le_Sup $ by simp,
  le_sup_right := assume a b, le_Sup $ by simp,
  sup_le       := assume a b c hac hbc, Sup_le $ by simp [*, or_imp_distrib] {contextual := tt},
  inf_le_left  := assume a b, Inf_le $ by simp,
  inf_le_right := assume a b, Inf_le $ by simp,
  le_inf       := assume a b c hac hbc, le_Inf $ by simp [*, or_imp_distrib] {contextual := tt},
  .. measure.partial_order, .. measure.order_top, .. measure.order_bot }

end

def map (f : Œ± ‚Üí Œ≤) (Œº : measure Œ±) : measure Œ≤ :=
if hf : measurable f then
  (Œº.to_outer_measure.map f).to_measure $ Œª s hs t,
  le_to_outer_measure_caratheodory Œº _ (hf _ hs) (f ‚Åª¬π' t)
else 0

variables {Œº ŒΩ : measure Œ±}

@[simp] theorem map_apply {f : Œ± ‚Üí Œ≤} (hf : measurable f)
  {s : set Œ≤} (hs : is_measurable s) :
  (map f Œº : measure Œ≤) s = Œº (f ‚Åª¬π' s) :=
by rw [map, dif_pos hf, to_measure_apply _ _ hs]; refl

@[simp] lemma map_id : map id Œº = Œº :=
ext $ Œª s, map_apply measurable_id

lemma map_map {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} (hg : measurable g) (hf : measurable f) :
  map g (map f Œº) = map (g ‚àò f) Œº :=
ext $ Œª s hs,
by simp [hf, hg, hs, hg.preimage hs, hg.comp hf];
   rw ‚Üê preimage_comp

/-- The dirac measure. -/
def dirac (a : Œ±) : measure Œ± :=
(outer_measure.dirac a).to_measure (by simp)

@[simp] lemma dirac_apply (a : Œ±) {s : set Œ±} (hs : is_measurable s) :
  (dirac a : measure Œ±) s = ‚®Ü h : a ‚àà s, 1 :=
to_measure_apply _ _ hs

/-- Sum of an indexed family of measures. -/
def sum {Œπ : Type*} (f : Œπ ‚Üí measure Œ±) : measure Œ± :=
(outer_measure.sum (Œª i, (f i).to_outer_measure)).to_measure $
le_trans
  (by exact le_infi (Œª i, le_to_outer_measure_caratheodory _))
  (outer_measure.le_sum_caratheodory _)

/-- Counting measure on any measurable space. -/
def count : measure Œ± := sum dirac

@[class] def is_complete {Œ±} {_:measurable_space Œ±} (Œº : measure Œ±) : Prop :=
‚àÄ s, Œº s = 0 ‚Üí is_measurable s

/-- The "almost everywhere" filter of co-null sets. -/
def a_e (Œº : measure Œ±) : filter Œ± :=
{ sets := {s | Œº (-s) = 0},
  univ_sets := by simp [measure_empty],
  inter_sets := Œª s t hs ht, by simp [compl_inter]; exact measure_union_null hs ht,
  sets_of_superset := Œª s t hs hst, measure_mono_null (set.compl_subset_compl.2 hst) hs }

lemma mem_a_e_iff (s : set Œ±) : s ‚àà Œº.a_e.sets ‚Üî Œº (- s) = 0 := iff.rfl

end measure

end measure_theory

section is_complete
open measure_theory

variables {Œ± : Type*} [measurable_space Œ±] (Œº : measure Œ±)

def is_null_measurable (s : set Œ±) : Prop :=
‚àÉ t z, s = t ‚à™ z ‚àß is_measurable t ‚àß Œº z = 0

theorem is_null_measurable_iff {Œº : measure Œ±} {s : set Œ±} :
  is_null_measurable Œº s ‚Üî
  ‚àÉ t, t ‚äÜ s ‚àß is_measurable t ‚àß Œº (s \ t) = 0 :=
begin
  split,
  { rintro ‚ü®t, z, rfl, ht, hz‚ü©,
    refine ‚ü®t, set.subset_union_left _ _, ht, measure_mono_null _ hz‚ü©,
    simp [union_diff_left, diff_subset] },
  { rintro ‚ü®t, st, ht, hz‚ü©,
    exact ‚ü®t, _, (union_diff_cancel st).symm, ht, hz‚ü© }
end

theorem is_null_measurable_measure_eq {Œº : measure Œ±} {s t : set Œ±}
  (st : t ‚äÜ s) (hz : Œº (s \ t) = 0) : Œº s = Œº t :=
begin
  refine le_antisymm _ (measure_mono st),
  have := measure_union_le t (s \ t),
  rw [union_diff_cancel st, hz] at this, simpa
end

theorem is_measurable.is_null_measurable
  {s : set Œ±} (hs : is_measurable s) : is_null_measurable Œº s :=
‚ü®s, ‚àÖ, by simp, hs, Œº.empty‚ü©

theorem is_null_measurable_of_complete [c : Œº.is_complete]
  {s : set Œ±} : is_null_measurable Œº s ‚Üî is_measurable s :=
‚ü®by rintro ‚ü®t, z, rfl, ht, hz‚ü©; exact
  is_measurable.union ht (c _ hz),
 Œª h, h.is_null_measurable _‚ü©

variables {Œº}
theorem is_null_measurable.union_null {s z : set Œ±}
  (hs : is_null_measurable Œº s) (hz : Œº z = 0) :
  is_null_measurable Œº (s ‚à™ z) :=
begin
  rcases hs with ‚ü®t, z', rfl, ht, hz'‚ü©,
  exact ‚ü®t, z' ‚à™ z, set.union_assoc _ _ _, ht, le_zero_iff_eq.1
    (le_trans (measure_union_le _ _) $ by simp [hz, hz'])‚ü©
end

theorem null_is_null_measurable {z : set Œ±}
  (hz : Œº z = 0) : is_null_measurable Œº z :=
by simpa using (is_measurable.empty.is_null_measurable _).union_null hz

theorem is_null_measurable.Union_nat {s : ‚Ñï ‚Üí set Œ±}
  (hs : ‚àÄ i, is_null_measurable Œº (s i)) :
  is_null_measurable Œº (Union s) :=
begin
  choose t ht using assume i, is_null_measurable_iff.1 (hs i),
  simp [forall_and_distrib] at ht,
  rcases ht with ‚ü®st, ht, hz‚ü©,
  refine is_null_measurable_iff.2
    ‚ü®Union t, Union_subset_Union st, is_measurable.Union ht,
      measure_mono_null _ (measure_Union_null hz)‚ü©,
  rw [diff_subset_iff, ‚Üê Union_union_distrib],
  exact Union_subset_Union (Œª i, by rw ‚Üê diff_subset_iff)
end

theorem is_measurable.diff_null {s z : set Œ±}
  (hs : is_measurable s) (hz : Œº z = 0) :
  is_null_measurable Œº (s \ z) :=
begin
  rw measure_eq_infi at hz,
  choose f hf using show ‚àÄ q : {q:‚Ñö//q>0}, ‚àÉ t:set Œ±,
    z ‚äÜ t ‚àß is_measurable t ‚àß Œº t < (nnreal.of_real q.1 : ennreal),
  { rintro ‚ü®Œµ, Œµ0‚ü©,
    have : 0 < (nnreal.of_real Œµ : ennreal), { simpa using Œµ0 },
    rw ‚Üê hz at this, simpa [infi_lt_iff] },
  refine is_null_measurable_iff.2 ‚ü®s \ Inter f,
    diff_subset_diff_right (subset_Inter (Œª i, (hf i).1)),
    hs.diff (is_measurable.Inter (Œª i, (hf i).2.1)),
    measure_mono_null _ (le_zero_iff_eq.1 $ le_of_not_lt $ Œª h, _)‚ü©,
  { exact Inter f },
  { rw [diff_subset_iff, diff_union_self],
    exact subset.trans (diff_subset _ _) (subset_union_left _ _) },
  rcases ennreal.lt_iff_exists_rat_btwn.1 h with ‚ü®Œµ, Œµ0', Œµ0, h‚ü©,
  simp at Œµ0,
  apply not_le_of_lt (lt_trans (hf ‚ü®Œµ, Œµ0‚ü©).2.2 h),
  exact measure_mono (Inter_subset _ _)
end

theorem is_null_measurable.diff_null {s z : set Œ±}
  (hs : is_null_measurable Œº s) (hz : Œº z = 0) :
  is_null_measurable Œº (s \ z) :=
begin
  rcases hs with ‚ü®t, z', rfl, ht, hz'‚ü©,
  rw [set.union_diff_distrib],
  exact (ht.diff_null hz).union_null (measure_mono_null (diff_subset _ _) hz')
end

theorem is_null_measurable.compl {s : set Œ±}
  (hs : is_null_measurable Œº s) :
  is_null_measurable Œº (-s) :=
begin
  rcases hs with ‚ü®t, z, rfl, ht, hz‚ü©,
  rw compl_union,
  exact ht.compl.diff_null hz
end

def null_measurable {Œ± : Type u} [measurable_space Œ±]
  (Œº : measure Œ±) : measurable_space Œ± :=
{ is_measurable := is_null_measurable Œº,
  is_measurable_empty := is_measurable.empty.is_null_measurable _,
  is_measurable_compl := Œª s hs, hs.compl,
  is_measurable_Union := Œª f, is_null_measurable.Union_nat }

def completion {Œ± : Type u} [measurable_space Œ±] (Œº : measure Œ±) :
  @measure_theory.measure Œ± (null_measurable Œº) :=
{ to_outer_measure := Œº.to_outer_measure,
  m_Union := Œª s hs hd, show Œº (Union s) = ‚àë' i, Œº (s i), begin
    choose t ht using assume i, is_null_measurable_iff.1 (hs i),
    simp [forall_and_distrib] at ht, rcases ht with ‚ü®st, ht, hz‚ü©,
    rw is_null_measurable_measure_eq (Union_subset_Union st),
    { rw measure_Union _ ht,
      { congr, funext i,
        exact (is_null_measurable_measure_eq (st i) (hz i)).symm },
      { rintro i j ij x ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
        exact hd i j ij ‚ü®st i h‚ÇÅ, st j h‚ÇÇ‚ü© } },
    { refine measure_mono_null _ (measure_Union_null hz),
      rw [diff_subset_iff, ‚Üê Union_union_distrib],
      exact Union_subset_Union (Œª i, by rw ‚Üê diff_subset_iff) }
  end,
  trimmed := begin
    letI := null_measurable Œº,
    refine le_antisymm (Œª s, _) (outer_measure.trim_ge _),
    rw outer_measure.trim_eq_infi,
    dsimp, clear _inst,
    rw measure_eq_infi s,
    exact infi_le_infi (Œª t, infi_le_infi $ Œª st,
      infi_le_infi2 $ Œª ht, ‚ü®ht.is_null_measurable _, le_refl _‚ü©)
  end }

instance completion.is_complete {Œ± : Type u} [measurable_space Œ±] (Œº : measure Œ±) :
  (completion Œº).is_complete :=
Œª z hz, null_is_null_measurable hz

end is_complete

namespace measure_theory

section prio
set_option default_priority 100 -- see Note [default priority]
/-- A measure space is a measurable space equipped with a
  measure, referred to as `volume`. -/
class measure_space (Œ± : Type*) extends measurable_space Œ± :=
(Œº : measure Œ±)
end prio

section measure_space
variables {Œ± : Type*} [measure_space Œ±] {s‚ÇÅ s‚ÇÇ : set Œ±}
open measure_space

/-- `volume s` is the measure of `s : set Œ±` with respect to the canonical measure on `Œ±`. -/
def volume : set Œ± ‚Üí ennreal := @Œº Œ± _

@[simp] lemma volume_empty : volume (‚àÖ : set Œ±) = 0 := Œº.empty

lemma volume_mono : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí volume s‚ÇÅ ‚â§ volume s‚ÇÇ := measure_mono

lemma volume_mono_null : s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí volume s‚ÇÇ = 0 ‚Üí volume s‚ÇÅ = 0 :=
measure_mono_null

theorem volume_Union_le {Œ≤} [encodable Œ≤] :
  ‚àÄ (s : Œ≤ ‚Üí set Œ±), volume (‚ãÉi, s i) ‚â§ (‚àë'i, volume (s i)) :=
measure_Union_le

lemma volume_Union_null {Œ≤} [encodable Œ≤] {s : Œ≤ ‚Üí set Œ±} :
  (‚àÄ i, volume (s i) = 0) ‚Üí volume (‚ãÉi, s i) = 0 :=
measure_Union_null

theorem volume_union_le : ‚àÄ (s‚ÇÅ s‚ÇÇ : set Œ±), volume (s‚ÇÅ ‚à™ s‚ÇÇ) ‚â§ volume s‚ÇÅ + volume s‚ÇÇ :=
measure_union_le

lemma volume_union_null : volume s‚ÇÅ = 0 ‚Üí volume s‚ÇÇ = 0 ‚Üí volume (s‚ÇÅ ‚à™ s‚ÇÇ) = 0 :=
measure_union_null

lemma volume_Union {Œ≤} [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} :
  pairwise (disjoint on f) ‚Üí (‚àÄi, is_measurable (f i)) ‚Üí
  volume (‚ãÉi, f i) = (‚àë'i, volume (f i)) :=
measure_Union

lemma volume_union : disjoint s‚ÇÅ s‚ÇÇ ‚Üí is_measurable s‚ÇÅ ‚Üí is_measurable s‚ÇÇ ‚Üí
  volume (s‚ÇÅ ‚à™ s‚ÇÇ) = volume s‚ÇÅ + volume s‚ÇÇ :=
measure_union

lemma volume_bUnion {Œ≤} {s : set Œ≤} {f : Œ≤ ‚Üí set Œ±} : countable s ‚Üí
  pairwise_on s (disjoint on f) ‚Üí (‚àÄb‚ààs, is_measurable (f b)) ‚Üí
  volume (‚ãÉb‚ààs, f b) = ‚àë'p:s, volume (f p.1) :=
measure_bUnion

lemma volume_sUnion {S : set (set Œ±)} : countable S ‚Üí
  pairwise_on S disjoint ‚Üí (‚àÄs‚ààS, is_measurable s) ‚Üí
  volume (‚ãÉ‚ÇÄ S) = ‚àë's:S, volume s.1 :=
measure_sUnion

lemma volume_bUnion_finset {Œ≤} {s : finset Œ≤} {f : Œ≤ ‚Üí set Œ±}
  (hd : pairwise_on ‚Üës (disjoint on f)) (hm : ‚àÄb‚ààs, is_measurable (f b)) :
  volume (‚ãÉb‚ààs, f b) = s.sum (Œªp, volume (f p)) :=
show volume (‚ãÉb‚àà(‚Üës : set Œ≤), f b) = s.sum (Œªp, volume (f p)),
begin
  rw [volume_bUnion s.countable_to_set hd hm, tsum_eq_sum],
  { show s.attach.sum (Œªb:(‚Üës : set Œ≤), volume (f b)) = s.sum (Œªb, volume (f b)),
    exact @finset.sum_attach _ _ s _ (Œªb, volume (f b)) },
  simp
end

lemma volume_diff : s‚ÇÇ ‚äÜ s‚ÇÅ ‚Üí is_measurable s‚ÇÅ ‚Üí is_measurable s‚ÇÇ ‚Üí
  volume s‚ÇÇ < ‚ä§ ‚Üí volume (s‚ÇÅ \ s‚ÇÇ) = volume s‚ÇÅ - volume s‚ÇÇ :=
measure_diff

variable {Œπ : Type*}

lemma sum_volume_le_volume_univ {s : finset Œπ} {t : Œπ ‚Üí set Œ±} (h : ‚àÄ i ‚àà s, is_measurable (t i))
  (H : pairwise_on ‚Üës (disjoint on t)) : s.sum (Œª i, volume (t i)) ‚â§ volume (univ : set Œ±) :=
volume_bUnion_finset H h ‚ñ∏ volume_mono (subset_univ _)

lemma tsum_volume_le_volume_univ {s : Œπ ‚Üí set Œ±} (hs : ‚àÄ i, is_measurable (s i))
  (H : pairwise (disjoint on s)) :
  (‚àë' i, volume (s i)) ‚â§ volume (univ : set Œ±) :=
begin
  rw [ennreal.tsum_eq_supr_sum],
  exact supr_le (Œª s, sum_volume_le_volume_univ (Œª i hi, hs i) (Œª i hi j hj hij, H i j hij))
end

/-- Pigeonhole principle for measure spaces: if `‚àë' i, Œº (s i) > Œº univ`, then
one of the intersections `s i ‚à© s j` is not empty. -/
lemma exists_nonempty_inter_of_volume_univ_lt_tsum_volume {s : Œπ ‚Üí set Œ±}
  (hs : ‚àÄ i, is_measurable (s i)) (H : volume (univ : set Œ±) < ‚àë' i, volume (s i)) :
  ‚àÉ i j (h : i ‚â† j), (s i ‚à© s j).nonempty :=
begin
  contrapose! H,
  apply tsum_volume_le_volume_univ hs,
  exact Œª i j hij x hx, H i j hij ‚ü®x, hx‚ü©
end

/-- Pigeonhole principle for measure spaces: if `s` is a `finset` and
`s.sum (Œª i, Œº (t i)) > Œº univ`, then one of the intersections `t i ‚à© t j` is not empty. -/
lemma exists_nonempty_inter_of_volume_univ_lt_sum_volume {s : finset Œπ} {t : Œπ ‚Üí set Œ±}
  (h : ‚àÄ i ‚àà s, is_measurable (t i)) (H : volume (univ : set Œ±) < s.sum (Œª i, volume (t i))) :
  ‚àÉ (i ‚àà s) (j ‚àà s) (h : i ‚â† j), (t i ‚à© t j).nonempty :=
begin
  contrapose! H,
  apply sum_volume_le_volume_univ h,
  exact Œª i hi j hj hij x hx, H i hi j hj hij ‚ü®x, hx‚ü©
end


/-- `‚àÄ‚Çò a:Œ±, p a` states that the property `p` is almost everywhere true in the measure space
associated with `Œ±`. This means that the measure of the complementary of `p` is `0`.

In a probability measure, the measure of `p` is `1`, when `p` is measurable.
-/
def all_ae (p : Œ± ‚Üí Prop) : Prop :=
‚àÄ·∂† a in Œº.a_e, p a

notation `‚àÄ‚Çò` binders `, ` r:(scoped P, all_ae P) := r

lemma all_ae_congr {p q : Œ± ‚Üí Prop} (h : ‚àÄ‚Çò a, p a ‚Üî q a) : (‚àÄ‚Çò a, p a) ‚Üî (‚àÄ‚Çò a, q a) :=
iff.intro
  (assume h', by filter_upwards [h, h'] assume a hpq hp, hpq.1 hp)
  (assume h', by filter_upwards [h, h'] assume a hpq hq, hpq.2 hq)

lemma all_ae_iff {p : Œ± ‚Üí Prop} : (‚àÄ‚Çò a, p a) ‚Üî volume { a | ¬¨ p a } = 0 := iff.rfl

lemma volume_zero_iff_all_ae_nmem {s : set Œ±} : volume s = 0 ‚Üî ‚àÄ‚Çò a, a ‚àâ s :=
by simp only [all_ae_iff, not_not, set_of_mem_eq]

lemma all_ae_of_all {p : Œ± ‚Üí Prop} : (‚àÄa, p a) ‚Üí ‚àÄ‚Çò a, p a := univ_mem_sets'

lemma all_ae_all_iff {Œπ : Type*} [encodable Œπ] {p : Œ± ‚Üí Œπ ‚Üí Prop} :
  (‚àÄ‚Çò a, ‚àÄi, p a i) ‚Üî (‚àÄi, ‚àÄ‚Çò a, p a i) :=
begin
  refine iff.intro (assume h i, _) (assume h, _),
  { filter_upwards [h] assume a ha, ha i },
  { have h := measure_Union_null h,
    rw [‚Üê compl_Inter] at h,
    filter_upwards [h] assume a, mem_Inter.1 }
end

@[simp] lemma all_ae_and_iff {p q : Œ± ‚Üí Prop} : (‚àÄ‚Çò a, p a ‚àß q a) ‚Üî (‚àÄ‚Çò a, p a) ‚àß ‚àÄ‚Çò a, q a :=
eventually_and

@[simp] lemma all_ae_imp_distrib_left {p : Prop} {q : Œ± ‚Üí Prop} :
  (‚àÄ‚Çò a, p ‚Üí q a) ‚Üî (p ‚Üí ‚àÄ‚Çò a, q a) :=
eventually_imp_distrib_left

@[simp] lemma all_ae_or_distrib_left {p : Prop} {q : Œ± ‚Üí Prop} :
  (‚àÄ‚Çò a, p ‚à® q a) ‚Üî (p ‚à® ‚àÄ‚Çò a, q a) :=
eventually_or_distrib_left

@[simp] lemma all_ae_or_distrib_right {p : Œ± ‚Üí Prop} {q : Prop} :
  (‚àÄ‚Çò a, p a ‚à® q) ‚Üî ((‚àÄ‚Çò a, p a) ‚à® q) :=
eventually_or_distrib_right

variables {Œ≤ : Type*}

lemma all_ae_eq_refl (f : Œ± ‚Üí Œ≤) : ‚àÄ‚Çò a, f a = f a :=
by { filter_upwards [], assume a, apply eq.refl }

lemma all_ae_eq_symm {f g : Œ± ‚Üí Œ≤} : (‚àÄ‚Çò a, f a = g a) ‚Üí (‚àÄ‚Çò a, g a = f a) :=
by { assume h, filter_upwards [h], assume a, apply eq.symm }

lemma all_ae_eq_trans {f g h: Œ± ‚Üí Œ≤} (h‚ÇÅ : ‚àÄ‚Çò a, f a = g a) (h‚ÇÇ : ‚àÄ‚Çò a, g a = h a) :
  ‚àÄ‚Çò a, f a = h a :=
by { filter_upwards [h‚ÇÅ, h‚ÇÇ], intro a, exact eq.trans }

end measure_space

end measure_theory
