/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import order.filter.basic

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n â†’ +âˆž`;
* `at_bot`: corresponds to `n â†’ -âˆž`.

Then we prove many lemmas like â€œif `f â†’ +âˆž`, then `f Â± c â†’ +âˆž`â€.
-/

variables {Î¹ Î¹' Î± Î² Î³ : Type*}

open set
open_locale classical filter big_operators

namespace filter
/-- `at_top` is the filter representing the limit `â†’ âˆž` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top [preorder Î±] : filter Î± := â¨… a, ð“Ÿ {b | a â‰¤ b}

/-- `at_bot` is the filter representing the limit `â†’ -âˆž` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot [preorder Î±] : filter Î± := â¨… a, ð“Ÿ {b | b â‰¤ a}

lemma mem_at_top [preorder Î±] (a : Î±) : {b : Î± | a â‰¤ b} âˆˆ @at_top Î± _ :=
mem_infi_sets a $ subset.refl _

lemma Ioi_mem_at_top [preorder Î±] [no_top_order Î±] (x : Î±) : Ioi x âˆˆ (at_top : filter Î±) :=
let âŸ¨z, hzâŸ© := no_top x in mem_sets_of_superset (mem_at_top z) $ Î» y h,  lt_of_lt_of_le hz h

lemma mem_at_bot [preorder Î±] (a : Î±) : {b : Î± | b â‰¤ a} âˆˆ @at_bot Î± _ :=
mem_infi_sets a $ subset.refl _

lemma Iio_mem_at_bot [preorder Î±] [no_bot_order Î±] (x : Î±) : Iio x âˆˆ (at_bot : filter Î±) :=
let âŸ¨z, hzâŸ© := no_bot x in mem_sets_of_superset (mem_at_bot z) $ Î» y h, lt_of_le_of_lt h hz

@[instance]
lemma at_top_ne_bot [nonempty Î±] [semilattice_sup Î±] : ne_bot (at_top : filter Î±) :=
infi_ne_bot_of_directed
  (assume a b, âŸ¨a âŠ” b, by simp only [ge, le_principal_iff, forall_const, set_of_subset_set_of,
    mem_principal_sets, and_self, sup_le_iff, forall_true_iff] {contextual := tt}âŸ©)
  (assume a, principal_ne_bot_iff.2 nonempty_Ici)

@[simp, nolint ge_or_gt]
lemma mem_at_top_sets [nonempty Î±] [semilattice_sup Î±] {s : set Î±} :
  s âˆˆ (at_top : filter Î±) â†” âˆƒa:Î±, âˆ€bâ‰¥a, b âˆˆ s :=
let âŸ¨aâŸ© := â€¹nonempty Î±â€º in
iff.intro
  (assume h, infi_sets_induct h âŸ¨a, by simp only [forall_const, mem_univ, forall_true_iff]âŸ©
    (assume a sâ‚ sâ‚‚ ha âŸ¨b, hbâŸ©, âŸ¨a âŠ” b,
      assume c hc, âŸ¨ha $ le_trans le_sup_left hc, hb _ $ le_trans le_sup_right hcâŸ©âŸ©)
    (assume sâ‚ sâ‚‚ h âŸ¨a, haâŸ©, âŸ¨a, assume b hb, h $ ha _ hbâŸ©))
  (assume âŸ¨a, hâŸ©, mem_infi_sets a $ assume x, h x)

@[simp, nolint ge_or_gt]
lemma eventually_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆ€á¶  x in at_top, p x) â†” (âˆƒ a, âˆ€ b â‰¥ a, p b) :=
mem_at_top_sets

lemma eventually_ge_at_top [preorder Î±] (a : Î±) : âˆ€á¶  x in at_top, a â‰¤ x := mem_at_top a

lemma order_top.at_top_eq (Î±) [order_top Î±] : (at_top : filter Î±) = pure âŠ¤ :=
le_antisymm (le_pure_iff.2 $ (eventually_ge_at_top âŠ¤).mono $ Î» b, top_unique)
  (le_infi $ Î» b, le_principal_iff.2 le_top)

lemma tendsto_at_top_pure [order_top Î±] (f : Î± â†’ Î²) :
  tendsto f at_top (pure $ f âŠ¤) :=
(order_top.at_top_eq Î±).symm â–¸ tendsto_pure_pure _ _

@[nolint ge_or_gt]
lemma eventually.exists_forall_of_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆ€á¶  x in at_top, p x) : âˆƒ a, âˆ€ b â‰¥ a, p b :=
eventually_at_top.mp h

@[nolint ge_or_gt]
lemma frequently_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_top, p x) â†” (âˆ€ a, âˆƒ b â‰¥ a, p b) :=
by simp only [filter.frequently, eventually_at_top, not_exists, not_forall, not_not]

@[nolint ge_or_gt]
lemma frequently_at_top' [semilattice_sup Î±] [nonempty Î±] [no_top_order Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_top, p x) â†” (âˆ€ a, âˆƒ b > a, p b) :=
begin
  rw frequently_at_top,
  split ; intros h a,
  { cases no_top a with a' ha',
    rcases h a' with âŸ¨b, hb, hb'âŸ©,
    exact âŸ¨b, lt_of_lt_of_le ha' hb, hb'âŸ© },
  { rcases h a with âŸ¨b, hb, hb'âŸ©,
    exact âŸ¨b, le_of_lt hb, hb'âŸ© },
end

@[nolint ge_or_gt]
lemma frequently.forall_exists_of_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆƒá¶  x in at_top, p x) : âˆ€ a, âˆƒ b â‰¥ a, p b :=
frequently_at_top.mp h

lemma map_at_top_eq [nonempty Î±] [semilattice_sup Î±] {f : Î± â†’ Î²} :
  at_top.map f = (â¨…a, ð“Ÿ $ f '' {a' | a â‰¤ a'}) :=
calc map f (â¨…a, ð“Ÿ {a' | a â‰¤ a'}) = (â¨…a, map f $ ð“Ÿ {a' | a â‰¤ a'}) :
    map_infi_eq (assume a b, âŸ¨a âŠ” b, by simp only [ge, le_principal_iff, forall_const, set_of_subset_set_of,
      mem_principal_sets, and_self, sup_le_iff, forall_true_iff] {contextual := tt}âŸ©)
      (by apply_instance)
  ... = (â¨…a, ð“Ÿ $ f '' {a' | a â‰¤ a'}) : by simp only [map_principal, eq_self_iff_true]

lemma tendsto_at_top [preorder Î²] (m : Î± â†’ Î²) (f : filter Î±) :
  tendsto m f at_top â†” (âˆ€b, âˆ€á¶  a in f, b â‰¤ m a) :=
by simp only [at_top, tendsto_infi, tendsto_principal, mem_set_of_eq]

lemma tendsto_at_bot [preorder Î²] (m : Î± â†’ Î²) (f : filter Î±) :
  tendsto m f at_bot â†” (âˆ€b, âˆ€á¶  a in f, m a â‰¤ b) :=
@tendsto_at_top Î± (order_dual Î²) _ m f

lemma tendsto_at_top_mono' [preorder Î²] (l : filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
  tendsto fâ‚ l at_top â†’ tendsto fâ‚‚ l at_top :=
assume hâ‚, (tendsto_at_top _ _).2 $ Î» b, mp_sets ((tendsto_at_top _ _).1 hâ‚ b)
  (monotone_mem_sets (Î» a ha haâ‚, le_trans haâ‚ ha) h)

lemma tendsto_at_top_mono [preorder Î²] {l : filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
  tendsto f l at_top â†’ tendsto g l at_top :=
tendsto_at_top_mono' l $ eventually_of_forall h

/-!
### Sequences
-/

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma inf_map_at_top_ne_bot_iff [semilattice_sup Î±] [nonempty Î±] {F : filter Î²} {u : Î± â†’ Î²} :
  ne_bot (F âŠ“ (map u at_top)) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ U :=
by simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]; refl

lemma extraction_of_frequently_at_top' {P : â„• â†’ Prop} (h : âˆ€ N, âˆƒ n > N, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
begin
  choose u hu using h,
  cases forall_and_distrib.mp hu with hu hu',
  exact âŸ¨u âˆ˜ (nat.rec 0 (Î» n v, u v)), strict_mono.nat (Î» n, hu _), Î» n, hu' _âŸ©,
end

lemma extraction_of_frequently_at_top {P : â„• â†’ Prop} (h : âˆƒá¶  n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
begin
  rw frequently_at_top' at h,
  exact extraction_of_frequently_at_top' h,
end

lemma extraction_of_eventually_at_top {P : â„• â†’ Prop} (h : âˆ€á¶  n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
extraction_of_frequently_at_top h.frequently

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_le_of_tendsto_at_top [semilattice_sup Î±] [preorder Î²] {u : Î± â†’ Î²}
  (h : tendsto u at_top at_top) : âˆ€ a b, âˆƒ a' â‰¥ a, b â‰¤ u a' :=
begin
  intros a b,
  have : âˆ€á¶  x in at_top, a â‰¤ x âˆ§ b â‰¤ u x :=
    (eventually_ge_at_top a).and (h.eventually $ eventually_ge_at_top b),
  haveI : nonempty Î± := âŸ¨aâŸ©,
  rcases this.exists with âŸ¨a', ha, hbâŸ©,
  exact âŸ¨a', ha, hbâŸ©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_lt_of_tendsto_at_top [semilattice_sup Î±] [preorder Î²] [no_top_order Î²]
  {u : Î± â†’ Î²} (h : tendsto u at_top at_top) : âˆ€ a b, âˆƒ a' â‰¥ a, b < u a' :=
begin
  intros a b,
  cases no_top b with b' hb',
  rcases exists_le_of_tendsto_at_top h a b' with âŸ¨a', ha', ha''âŸ©,
  exact âŸ¨a', ha', lt_of_lt_of_le hb' ha''âŸ©
end

/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma high_scores [linear_order Î²] [no_top_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_top) : âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u k < u n :=
begin
  letI := classical.DLO Î²,
  intros N,
  let A := finset.image u (finset.range $ N+1), -- A = {u 0, ..., u N}
  have Ane : A.nonempty,
    from âŸ¨u 0, finset.mem_image_of_mem _ (finset.mem_range.mpr $ nat.zero_lt_succ _)âŸ©,
  let M := finset.max' A Ane,
  have ex : âˆƒ n â‰¥ N, M < u n,
    from exists_lt_of_tendsto_at_top hu _ _,
  obtain âŸ¨n, hnN, hnM, hn_minâŸ© : âˆƒ n, N â‰¤ n âˆ§ M < u n âˆ§ âˆ€ k, N â‰¤ k â†’ k < n â†’ u k â‰¤ M,
  { use nat.find ex,
    rw â† and_assoc,
    split,
    { simpa using nat.find_spec ex },
    { intros k hk hk',
      simpa [hk] using nat.find_min ex hk' } },
  use [n, hnN],
  intros k hk,
  by_cases H : k â‰¤ N,
  { have : u k âˆˆ A,
      from finset.mem_image_of_mem _ (finset.mem_range.mpr $ nat.lt_succ_of_le H),
    have : u k â‰¤ M,
      from finset.le_max' A Ane (u k) this,
    exact lt_of_le_of_lt this hnM },
  { push_neg at H,
    calc u k â‰¤ M   : hn_min k (le_of_lt H) hk
         ... < u n : hnM },
end

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
lemma frequently_high_scores [linear_order Î²] [no_top_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_top) : âˆƒá¶  n in at_top, âˆ€ k < n, u k < u n :=
by simpa [frequently_at_top] using high_scores hu

lemma strict_mono_subseq_of_tendsto_at_top
  {Î² : Type*} [linear_order Î²] [no_top_order Î²]
  {u : â„• â†’ Î²} (hu : tendsto u at_top at_top) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ strict_mono (u âˆ˜ Ï†) :=
let âŸ¨Ï†, h, h'âŸ© := extraction_of_frequently_at_top (frequently_high_scores hu) in
âŸ¨Ï†, h, Î» n m hnm, h' m _ (h hnm)âŸ©

lemma strict_mono_subseq_of_id_le {u : â„• â†’ â„•} (hu : âˆ€ n, n â‰¤ u n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ strict_mono (u âˆ˜ Ï†) :=
strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

lemma strict_mono_tendsto_at_top {Ï† : â„• â†’ â„•} (h : strict_mono Ï†) :
  tendsto Ï† at_top at_top :=
tendsto_at_top_mono h.id_le tendsto_id

section ordered_add_comm_monoid

variables [ordered_add_comm_monoid Î²] {l : filter Î±} {f g : Î± â†’ Î²}

lemma tendsto_at_top_add_nonneg_left' (hf : âˆ€á¶  x in l, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_mono' l (hf.mono (Î» x, le_add_of_nonneg_left)) hg

lemma tendsto_at_top_add_nonneg_left (hf : âˆ€ x, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

lemma tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top) (hg : âˆ€á¶  x in l, 0 â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_mono' l (monotone_mem_sets (Î» x, le_add_of_nonneg_right) hg) hf

lemma tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : âˆ€ x, 0 â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

end ordered_add_comm_monoid

section ordered_cancel_add_comm_monoid

variables [ordered_cancel_add_comm_monoid Î²] {l : filter Î±} {f g : Î± â†’ Î²}

lemma tendsto_at_top_of_add_const_left (C : Î²) (hf : tendsto (Î» x, C + f x) l at_top) :
  tendsto f l at_top :=
(tendsto_at_top _ l).2 $ assume b,
  ((tendsto_at_top _ _).1 hf (C + b)).mono (Î» x, le_of_add_le_add_left)

lemma tendsto_at_top_of_add_const_right (C : Î²) (hf : tendsto (Î» x, f x + C) l at_top) :
  tendsto f l at_top :=
(tendsto_at_top _ l).2 $ assume b,
  ((tendsto_at_top _ _).1 hf (b + C)).mono (Î» x, le_of_add_le_add_right)

lemma tendsto_at_top_of_add_bdd_above_left' (C) (hC : âˆ€á¶  x in l, f x â‰¤ C)
  (h : tendsto (Î» x, f x + g x) l at_top) :
  tendsto g l at_top :=
tendsto_at_top_of_add_const_left C
  (tendsto_at_top_mono' l (hC.mono (Î» x hx, add_le_add_right hx (g x))) h)

lemma tendsto_at_top_of_add_bdd_above_left (C) (hC : âˆ€ x, f x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_top â†’ tendsto g l at_top :=
tendsto_at_top_of_add_bdd_above_left' C (univ_mem_sets' hC)

lemma tendsto_at_top_of_add_bdd_above_right' (C) (hC : âˆ€á¶  x in l, g x â‰¤ C)
  (h : tendsto (Î» x, f x + g x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top_of_add_const_right C
  (tendsto_at_top_mono' l (hC.mono (Î» x hx, add_le_add_left hx (f x))) h)

lemma tendsto_at_top_of_add_bdd_above_right (C) (hC : âˆ€ x, g x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_top â†’ tendsto f l at_top :=
tendsto_at_top_of_add_bdd_above_right' C (univ_mem_sets' hC)

end ordered_cancel_add_comm_monoid

section ordered_group

variables [ordered_add_comm_group Î²] (l : filter Î±) {f g : Î± â†’ Î²}

lemma tendsto_at_top_add_left_of_le' (C : Î²) (hf : âˆ€á¶  x in l, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_left' _ _ _ l (Î» x, -(f x)) (Î» x, f x + g x) (-C)
  (by simpa) (by simpa)

lemma tendsto_at_top_add_left_of_le (C : Î²) (hf : âˆ€ x, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem_sets' hf) hg

lemma tendsto_at_top_add_right_of_le' (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€á¶  x in l, C â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_right' _ _ _ l (Î» x, f x + g x) (Î» x, -(g x)) (-C)
  (by simp [hg]) (by simp [hf])

lemma tendsto_at_top_add_right_of_le (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€ x, C â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem_sets' hg)

lemma tendsto_at_top_add_const_left (C : Î²) (hf : tendsto f l at_top) :
  tendsto (Î» x, C + f x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem_sets' $ Î» _, le_refl C) hf

lemma tendsto_at_top_add_const_right (C : Î²) (hf : tendsto f l at_top) :
  tendsto (Î» x, f x + C) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem_sets' $ Î» _, le_refl C)

end ordered_group

open_locale filter

@[nolint ge_or_gt]
lemma tendsto_at_top' [nonempty Î±] [semilattice_sup Î±] (f : Î± â†’ Î²) (l : filter Î²) :
  tendsto f at_top l â†” (âˆ€s âˆˆ l, âˆƒa, âˆ€bâ‰¥a, f b âˆˆ s) :=
by simp only [tendsto_def, mem_at_top_sets]; refl

lemma tendsto_at_bot' [nonempty Î±] [semilattice_inf Î±] (f : Î± â†’ Î²) (l : filter Î²) :
  tendsto f at_bot l â†” (âˆ€s âˆˆ l, âˆƒa, âˆ€bâ‰¤a, f b âˆˆ s) :=
@tendsto_at_top' (order_dual Î±) _ _ _ _ _

@[nolint ge_or_gt]
theorem tendsto_at_top_principal [nonempty Î²] [semilattice_sup Î²] {f : Î² â†’ Î±} {s : set Î±} :
  tendsto f at_top (ð“Ÿ s) â†” âˆƒN, âˆ€nâ‰¥N, f n âˆˆ s :=
by rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]; refl

/-- A function `f` grows to infinity independent of an order-preserving embedding `e`. -/
lemma tendsto_at_top_embedding [preorder Î²] [preorder Î³]
  {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : filter Î±}
  (hm : âˆ€bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€c, âˆƒb, c â‰¤ e b) :
  tendsto (e âˆ˜ f) l at_top â†” tendsto f l at_top :=
begin
  rw [tendsto_at_top, tendsto_at_top],
  split,
  { assume hc b,
    filter_upwards [hc (e b)] assume a, (hm b (f a)).1 },
  { assume hb c,
    rcases hu c with âŸ¨b, hcâŸ©,
    filter_upwards [hb b] assume a ha, le_trans hc ((hm b (f a)).2 ha) }
end

lemma tendsto_at_top_at_top [nonempty Î±] [semilattice_sup Î±] [preorder Î²] (f : Î± â†’ Î²) :
  tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ b â‰¤ f a :=
iff.trans tendsto_infi $ forall_congr $ assume b, tendsto_at_top_principal

lemma tendsto_at_top_at_bot [nonempty Î±] [semilattice_sup Î±] [preorder Î²] (f : Î± â†’ Î²) :
  tendsto f at_top at_bot â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), i â‰¤ a â†’ f a â‰¤ b :=
@tendsto_at_top_at_top Î± (order_dual Î²) _ _ _ f

lemma tendsto_at_bot_at_top [nonempty Î±] [semilattice_inf Î±] [preorder Î²] (f : Î± â†’ Î²) :
  tendsto f at_bot at_top â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), a â‰¤ i â†’ b â‰¤ f a :=
@tendsto_at_top_at_top (order_dual Î±) Î² _ _ _ f

lemma tendsto_at_bot_at_bot [nonempty Î±] [semilattice_inf Î±] [preorder Î²] (f : Î± â†’ Î²) :
  tendsto f at_bot at_bot â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), a â‰¤ i â†’ f a â‰¤ b :=
@tendsto_at_top_at_top (order_dual Î±) (order_dual Î²) _ _ _ f

lemma tendsto_at_top_at_top_of_monotone [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f)
  (h : âˆ€ b, âˆƒ a, b â‰¤ f a) :
  tendsto f at_top at_top :=
tendsto_infi.2 $ Î» b, tendsto_principal.2 $ let âŸ¨a, haâŸ© := h b in
mem_sets_of_superset (mem_at_top a) $ Î» a' ha', le_trans ha (hf ha')

lemma tendsto_at_top_at_top_iff_of_monotone [nonempty Î±] [semilattice_sup Î±] [preorder Î²]
  {f : Î± â†’ Î²} (hf : monotone f) :
  tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ a : Î±, b â‰¤ f a :=
(tendsto_at_top_at_top f).trans $ forall_congr $ Î» b, exists_congr $ Î» a,
  âŸ¨Î» h, h a (le_refl a), Î» h a' ha', le_trans h $ hf ha'âŸ©

alias tendsto_at_top_at_top_of_monotone â† monotone.tendsto_at_top_at_top
alias tendsto_at_top_at_top_iff_of_monotone â† monotone.tendsto_at_top_at_top_iff

lemma tendsto_finset_range : tendsto finset.range at_top at_top :=
finset.range_mono.tendsto_at_top_at_top finset.exists_nat_subset_range

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
lemma monotone.tendsto_at_top_finset [semilattice_sup Î²]
  {f : Î² â†’ finset Î±} (h : monotone f) (h' : âˆ€ x : Î±, âˆƒ n, x âˆˆ f n) :
  tendsto f at_top at_top :=
begin
  by_cases ne : nonempty Î²,
  { resetI,
    apply h.tendsto_at_top_at_top,
    choose N hN using h',
    assume b,
    rcases (b.image N).bdd_above with âŸ¨n, hnâŸ©,
    refine âŸ¨n, Î» i ib, _âŸ©,
    have : N i âˆˆ b.image N := finset.mem_image_of_mem _ ib,
    exact h (hn $ finset.mem_coe.2 this) (hN i) },
  { exact tendsto_of_not_nonempty ne }
end

lemma tendsto_finset_image_at_top_at_top {i : Î² â†’ Î³} {j : Î³ â†’ Î²} (h : function.left_inverse j i) :
  tendsto (finset.image j) at_top at_top :=
(finset.image_mono j).tendsto_at_top_at_top $ assume s,
  âŸ¨s.image i, by simp only [finset.image_image, h.comp_eq_id, finset.image_id, le_refl]âŸ©

lemma prod_at_top_at_top_eq {Î²â‚ Î²â‚‚ : Type*} [semilattice_sup Î²â‚] [semilattice_sup Î²â‚‚] :
  (at_top : filter Î²â‚) Ã—á¶  (at_top : filter Î²â‚‚) = (at_top : filter (Î²â‚ Ã— Î²â‚‚)) :=
begin
  by_cases ne : nonempty Î²â‚ âˆ§ nonempty Î²â‚‚,
  { cases ne,
    resetI,
    inhabit Î²â‚,
    inhabit Î²â‚‚,
    simp [at_top, prod_infi_left (default Î²â‚), prod_infi_right (default Î²â‚‚), infi_prod],
    exact infi_comm },
  { rw not_and_distrib at ne,
    cases ne;
    { have : Â¬ (nonempty (Î²â‚ Ã— Î²â‚‚)), by simp [ne],
      rw [at_top.filter_eq_bot_of_not_nonempty ne, at_top.filter_eq_bot_of_not_nonempty this],
      simp only [bot_prod, prod_bot] } }
end

lemma prod_map_at_top_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type*} [semilattice_sup Î²â‚] [semilattice_sup Î²â‚‚]
  (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) :
  (map uâ‚ at_top) Ã—á¶  (map uâ‚‚ at_top) = map (prod.map uâ‚ uâ‚‚) at_top :=
by rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
lemma map_at_top_eq_of_gc [semilattice_sup Î±] [semilattice_sup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
  (hf : monotone f) (gc : âˆ€a, âˆ€bâ‰¥b', f a â‰¤ b â†” a â‰¤ g b) (hgi : âˆ€bâ‰¥b', b â‰¤ f (g b)) :
  map f at_top = at_top :=
begin
  rw [@map_at_top_eq Î± _ âŸ¨g b'âŸ©],
  refine le_antisymm
    (le_infi $ assume b, infi_le_of_le (g (b âŠ” b')) $ principal_mono.2 $ image_subset_iff.2 _)
    (le_infi $ assume a, infi_le_of_le (f a âŠ” b') $ principal_mono.2 _),
  { assume a ha, exact (le_trans le_sup_left $ le_trans (hgi _ le_sup_right) $ hf ha) },
  { assume b hb,
    have hb' : b' â‰¤ b := le_trans le_sup_right hb,
    exact âŸ¨g b, (gc _ _ hb').1 (le_trans le_sup_left hb),
      le_antisymm ((gc _ _ hb').2 (le_refl _)) (hgi _ hb')âŸ© }
end

lemma map_add_at_top_eq_nat (k : â„•) : map (Î»a, a + k) at_top = at_top :=
map_at_top_eq_of_gc (Î»a, a - k) k
  (assume a b h, add_le_add_right h k)
  (assume a b h, (nat.le_sub_right_iff_add_le h).symm)
  (assume a h, by rw [nat.sub_add_cancel h])

lemma map_sub_at_top_eq_nat (k : â„•) : map (Î»a, a - k) at_top = at_top :=
map_at_top_eq_of_gc (Î»a, a + k) 0
  (assume a b h, nat.sub_le_sub_right h _)
  (assume a b _, nat.sub_le_right_iff_le_add)
  (assume b _, by rw [nat.add_sub_cancel])

lemma tendsto_add_at_top_nat (k : â„•) : tendsto (Î»a, a + k) at_top at_top :=
le_of_eq (map_add_at_top_eq_nat k)

lemma tendsto_sub_at_top_nat (k : â„•) : tendsto (Î»a, a - k) at_top at_top :=
le_of_eq (map_sub_at_top_eq_nat k)

lemma tendsto_add_at_top_iff_nat {f : â„• â†’ Î±} {l : filter Î±} (k : â„•) :
  tendsto (Î»n, f (n + k)) at_top l â†” tendsto f at_top l :=
show tendsto (f âˆ˜ (Î»n, n + k)) at_top l â†” tendsto f at_top l,
  by rw [â† tendsto_map'_iff, map_add_at_top_eq_nat]

lemma map_div_at_top_eq_nat (k : â„•) (hk : k > 0) : map (Î»a, a / k) at_top = at_top :=
map_at_top_eq_of_gc (Î»b, b * k + (k - 1)) 1
  (assume a b h, nat.div_le_div_right h)
  (assume a b _,
    calc a / k â‰¤ b â†” a / k < b + 1 : by rw [â† nat.succ_eq_add_one, nat.lt_succ_iff]
      ... â†” a < (b + 1) * k : nat.div_lt_iff_lt_mul _ _ hk
      ... â†” _ :
      begin
        cases k,
        exact (lt_irrefl _ hk).elim,
        simp [mul_add, add_mul, nat.succ_add, nat.lt_succ_iff]
      end)
  (assume b _,
    calc b = (b * k) / k : by rw [nat.mul_div_cancel b hk]
      ... â‰¤ (b * k + (k - 1)) / k : nat.div_le_div_right $ nat.le_add_right _ _)

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
lemma tendsto_at_top_at_top_of_monotone' [preorder Î¹] [linear_order Î±]
  {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (range u)) :
  tendsto u at_top at_top :=
begin
  apply h.tendsto_at_top_at_top,
  intro b,
  rcases not_bdd_above_iff.1 H b with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©,
  exact âŸ¨N, le_of_lt hNâŸ©,
end

lemma unbounded_of_tendsto_at_top [nonempty Î±] [semilattice_sup Î±] [preorder Î²] [no_top_order Î²]
  {f : Î± â†’ Î²} (h : tendsto f at_top at_top) :
  Â¬ bdd_above (range f) :=
begin
  rintros âŸ¨M, hMâŸ©,
  cases mem_at_top_sets.mp (h $ Ioi_mem_at_top M) with a ha,
  apply lt_irrefl M,
  calc
  M < f a : ha a (le_refl _)
  ... â‰¤ M : hM (set.mem_range_self a)
end

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
lemma tendsto_at_top_of_monotone_of_filter [preorder Î¹] [preorder Î±] {l : filter Î¹}
  {u : Î¹ â†’ Î±} (h : monotone u) [ne_bot l] (hu : tendsto u l at_top) :
  tendsto u at_top at_top :=
h.tendsto_at_top_at_top $ Î» b, (hu.eventually (mem_at_top b)).exists

lemma tendsto_at_top_of_monotone_of_subseq [preorder Î¹] [preorder Î±] {u : Î¹ â†’ Î±}
  {Ï† : Î¹' â†’ Î¹} (h : monotone u) {l : filter Î¹'} [ne_bot l]
  (H : tendsto (u âˆ˜ Ï†) l at_top) :
  tendsto u at_top at_top :=
tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

lemma tendsto_neg_at_top_at_bot [ordered_add_comm_group Î±] :
  tendsto (has_neg.neg : Î± â†’ Î±) at_top at_bot :=
begin
  simp only [tendsto_at_bot, neg_le],
  exact Î» b, eventually_ge_at_top _
end

lemma tendsto_neg_at_bot_at_top [ordered_add_comm_group Î±] :
  tendsto (has_neg.neg : Î± â†’ Î±) at_bot at_top :=
@tendsto_neg_at_top_at_bot (order_dual Î±) _

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Î» s, âˆ b in s, f b)` with
`at_top.map (Î» s, âˆ b in s, g b)`. This is useful to compare the set of limit points of
`Î  b in s, f b` as `s â†’ at_top` with the similar set for `g`. -/
@[to_additive]
lemma map_at_top_finset_prod_le_of_prod_eq [comm_monoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±}
  (h_eq : âˆ€u:finset Î³, âˆƒv:finset Î², âˆ€v', v âŠ† v' â†’ âˆƒu', u âŠ† u' âˆ§ âˆ x in u', g x = âˆ b in v', f b) :
  at_top.map (Î»s:finset Î², âˆ b in s, f b) â‰¤ at_top.map (Î»s:finset Î³, âˆ x in s, g x) :=
by rw [map_at_top_eq, map_at_top_eq];
from (le_infi $ assume b, let âŸ¨v, hvâŸ© := h_eq b in infi_le_of_le v $
  by simp [set.image_subset_iff]; exact hv)

end filter

open filter finset

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Î» s, âˆ i in s, f (g i))` and `at_top.map (Î» s, âˆ i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
@[to_additive]
lemma function.injective.map_at_top_finset_prod_eq [comm_monoid Î±] {g : Î³ â†’ Î²}
  (hg : function.injective g) {f : Î² â†’ Î±} (hf : âˆ€ x âˆ‰ set.range g, f x = 1) :
  map (Î» s, âˆ i in s, f (g i)) at_top = map (Î» s, âˆ i in s, f i) at_top :=
begin
  apply le_antisymm; refine map_at_top_finset_prod_le_of_prod_eq (Î» s, _),
  { refine âŸ¨s.preimage (hg.inj_on _), Î» t ht, _âŸ©,
    refine âŸ¨t.image g âˆª s, finset.subset_union_right _ _, _âŸ©,
    rw [â† finset.prod_image (hg.inj_on _)],
    refine (prod_subset (subset_union_left _ _) _).symm,
    simp only [finset.mem_union, finset.mem_image],
    refine Î» y hy hyt, hf y (mt _ hyt),
    rintros âŸ¨x, rflâŸ©,
    exact âŸ¨x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rflâŸ© },
  { refine âŸ¨s.image g, Î» t ht, _âŸ©,
    simp only [â† prod_preimage _ _ (hg.inj_on _) _ (Î» x _, hf x)],
    exact âŸ¨_, (image_subset_iff_subset_preimage _).1 ht, rflâŸ© }
end

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Î» s, âˆ‘ i in s, f (g i))` and `at_top.map (Î» s, âˆ‘ i in s, f i)` coincide.

This lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
add_decl_doc function.injective.map_at_top_finset_sum_eq
