/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import order.filter.bases
import data.finset.preimage
import data.set.intervals.disjoint

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n ‚Üí +‚àû`;
* `at_bot`: corresponds to `n ‚Üí -‚àû`.

Then we prove many lemmas like ‚Äúif `f ‚Üí +‚àû`, then `f ¬± c ‚Üí +‚àû`‚Äù.
-/

variables {Œπ Œπ' Œ± Œ≤ Œ≥ : Type*}

open set
open_locale classical filter big_operators

namespace filter
/-- `at_top` is the filter representing the limit `‚Üí ‚àû` on an ordered set.
  It is generated by the collection of up-sets `{b | a ‚â§ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top [preorder Œ±] : filter Œ± := ‚®Ö a, ùìü (Ici a)

/-- `at_bot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.
  It is generated by the collection of down-sets `{b | b ‚â§ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot [preorder Œ±] : filter Œ± := ‚®Ö a, ùìü (Iic a)

lemma mem_at_top [preorder Œ±] (a : Œ±) : {b : Œ± | a ‚â§ b} ‚àà @at_top Œ± _ :=
mem_infi_of_mem a $ subset.refl _

lemma Ici_mem_at_top [preorder Œ±] (a : Œ±) : Ici a ‚àà (at_top : filter Œ±) := mem_at_top a

lemma Ioi_mem_at_top [preorder Œ±] [no_max_order Œ±] (x : Œ±) : Ioi x ‚àà (at_top : filter Œ±) :=
let ‚ü®z, hz‚ü© := exists_gt x in mem_of_superset (mem_at_top z) $ Œª y h,  lt_of_lt_of_le hz h

lemma mem_at_bot [preorder Œ±] (a : Œ±) : {b : Œ± | b ‚â§ a} ‚àà @at_bot Œ± _ :=
mem_infi_of_mem a $ subset.refl _

lemma Iic_mem_at_bot [preorder Œ±] (a : Œ±) : Iic a ‚àà (at_bot : filter Œ±) := mem_at_bot a

lemma Iio_mem_at_bot [preorder Œ±] [no_min_order Œ±] (x : Œ±) : Iio x ‚àà (at_bot : filter Œ±) :=
let ‚ü®z, hz‚ü© := exists_lt x in mem_of_superset (mem_at_bot z) $ Œª y h, lt_of_le_of_lt h hz

lemma disjoint_at_bot_principal_Ioi [preorder Œ±] (x : Œ±) : disjoint at_bot (ùìü (Ioi x)) :=
disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl) (Iic_mem_at_bot x) (mem_principal_self _)

lemma disjoint_at_top_principal_Iio [preorder Œ±] (x : Œ±) : disjoint at_top (ùìü (Iio x)) :=
@disjoint_at_bot_principal_Ioi Œ±·µí·µà _ _

lemma disjoint_at_top_principal_Iic [preorder Œ±] [no_max_order Œ±] (x : Œ±) :
  disjoint at_top (ùìü (Iic x)) :=
disjoint_of_disjoint_of_mem (Iic_disjoint_Ioi le_rfl).symm (Ioi_mem_at_top x) (mem_principal_self _)

lemma disjoint_at_bot_principal_Ici [preorder Œ±] [no_min_order Œ±] (x : Œ±) :
  disjoint at_bot (ùìü (Ici x)) :=
@disjoint_at_top_principal_Iic Œ±·µí·µà _ _ _

lemma disjoint_at_bot_at_top [partial_order Œ±] [nontrivial Œ±] :
  disjoint (at_bot : filter Œ±) at_top :=
begin
  rcases exists_pair_ne Œ± with ‚ü®x, y, hne‚ü©,
  by_cases hle : x ‚â§ y,
  { refine disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot x) (Ici_mem_at_top y),
    exact Iic_disjoint_Ici.2 (hle.lt_of_ne hne).not_le },
  { refine disjoint_of_disjoint_of_mem _ (Iic_mem_at_bot y) (Ici_mem_at_top x),
    exact Iic_disjoint_Ici.2 hle }
end

lemma disjoint_at_top_at_bot [partial_order Œ±] [nontrivial Œ±] :
  disjoint (at_top : filter Œ±) at_bot :=
disjoint_at_bot_at_top.symm

lemma at_top_basis [nonempty Œ±] [semilattice_sup Œ±] :
  (@at_top Œ± _).has_basis (Œª _, true) Ici :=
has_basis_infi_principal (directed_of_sup $ Œª a b, Ici_subset_Ici.2)

lemma at_top_basis' [semilattice_sup Œ±] (a : Œ±) :
  (@at_top Œ± _).has_basis (Œª x, a ‚â§ x) Ici :=
‚ü®Œª t, (@at_top_basis Œ± ‚ü®a‚ü© _).mem_iff.trans
  ‚ü®Œª ‚ü®x, _, hx‚ü©, ‚ü®x ‚äî a, le_sup_right, Œª y hy, hx (le_trans le_sup_left hy)‚ü©,
    Œª ‚ü®x, _, hx‚ü©, ‚ü®x, trivial, hx‚ü©‚ü©‚ü©

lemma at_bot_basis [nonempty Œ±] [semilattice_inf Œ±] : (@at_bot Œ± _).has_basis (Œª _, true) Iic :=
@at_top_basis Œ±·µí·µà _ _

lemma at_bot_basis' [semilattice_inf Œ±] (a : Œ±) : (@at_bot Œ± _).has_basis (Œª x, x ‚â§ a) Iic :=
@at_top_basis' Œ±·µí·µà _ _

@[instance]
lemma at_top_ne_bot [nonempty Œ±] [semilattice_sup Œ±] : ne_bot (at_top : filter Œ±) :=
at_top_basis.ne_bot_iff.2 $ Œª a _, nonempty_Ici

@[instance]
lemma at_bot_ne_bot [nonempty Œ±] [semilattice_inf Œ±] : ne_bot (at_bot : filter Œ±) :=
@at_top_ne_bot Œ±·µí·µà _ _

@[simp]
lemma mem_at_top_sets [nonempty Œ±] [semilattice_sup Œ±] {s : set Œ±} :
  s ‚àà (at_top : filter Œ±) ‚Üî ‚àÉa:Œ±, ‚àÄb‚â•a, b ‚àà s :=
at_top_basis.mem_iff.trans $ exists_congr $ Œª _, exists_const _

@[simp]
lemma mem_at_bot_sets [nonempty Œ±] [semilattice_inf Œ±] {s : set Œ±} :
  s ‚àà (at_bot : filter Œ±) ‚Üî ‚àÉa:Œ±, ‚àÄb‚â§a, b ‚àà s :=
@mem_at_top_sets Œ±·µí·µà _ _ _

@[simp]
lemma eventually_at_top [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_top, p x) ‚Üî (‚àÉ a, ‚àÄ b ‚â• a, p b) :=
mem_at_top_sets

@[simp]
lemma eventually_at_bot [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_bot, p x) ‚Üî (‚àÉ a, ‚àÄ b ‚â§ a, p b) :=
mem_at_bot_sets

lemma eventually_ge_at_top [preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_top, a ‚â§ x := mem_at_top a

lemma eventually_le_at_bot [preorder Œ±] (a : Œ±) : ‚àÄ·∂† x in at_bot, x ‚â§ a := mem_at_bot a

lemma eventually_gt_at_top [preorder Œ±] [no_max_order Œ±] (a : Œ±) :
  ‚àÄ·∂† x in at_top, a < x :=
Ioi_mem_at_top a

lemma eventually_ne_at_top [preorder Œ±] [no_max_order Œ±] (a : Œ±) :
  ‚àÄ·∂† x in at_top, x ‚â† a :=
(eventually_gt_at_top a).mono $ Œª x, ne_of_gt

lemma tendsto.eventually_gt_at_top [preorder Œ≤] [no_max_order Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_top) (c : Œ≤) : ‚àÄ·∂† x in l, c < f x :=
hf.eventually (eventually_gt_at_top c)

lemma tendsto.eventually_ge_at_top [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_top) (c : Œ≤) : ‚àÄ·∂† x in l, c ‚â§ f x :=
hf.eventually (eventually_ge_at_top c)

lemma tendsto.eventually_ne_at_top [preorder Œ≤] [no_max_order Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_top) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â† c :=
hf.eventually (eventually_ne_at_top c)

lemma eventually_lt_at_bot [preorder Œ±] [no_min_order Œ±] (a : Œ±) :
  ‚àÄ·∂† x in at_bot, x < a :=
Iio_mem_at_bot a

lemma eventually_ne_at_bot [preorder Œ±] [no_min_order Œ±] (a : Œ±) :
  ‚àÄ·∂† x in at_bot, x ‚â† a :=
(eventually_lt_at_bot a).mono $ Œª x, ne_of_lt

lemma tendsto.eventually_lt_at_bot [preorder Œ≤] [no_min_order Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_bot) (c : Œ≤) : ‚àÄ·∂† x in l, f x < c :=
hf.eventually (eventually_lt_at_bot c)

lemma tendsto.eventually_le_at_bot [preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_bot) (c : Œ≤) : ‚àÄ·∂† x in l, f x ‚â§ c :=
hf.eventually (eventually_le_at_bot c)

lemma tendsto.eventually_ne_at_bot [preorder Œ≤] [no_min_order Œ≤] {f : Œ± ‚Üí Œ≤} {l : filter Œ±}
  (hf : tendsto f l at_bot) (c : Œ≤) :  ‚àÄ·∂† x in l, f x ‚â† c :=
hf.eventually (eventually_ne_at_bot c)

lemma at_top_basis_Ioi [nonempty Œ±] [semilattice_sup Œ±] [no_max_order Œ±] :
  (@at_top Œ± _).has_basis (Œª _, true) Ioi :=
at_top_basis.to_has_basis (Œª a ha, ‚ü®a, ha, Ioi_subset_Ici_self‚ü©) $
  Œª a ha, (exists_gt a).imp $ Œª b hb, ‚ü®ha, Ici_subset_Ioi.2 hb‚ü©

lemma at_top_countable_basis [nonempty Œ±] [semilattice_sup Œ±] [encodable Œ±] :
  has_countable_basis (at_top : filter Œ±) (Œª _, true) Ici :=
{ countable := countable_encodable _,
  .. at_top_basis }

lemma at_bot_countable_basis [nonempty Œ±] [semilattice_inf Œ±] [encodable Œ±] :
  has_countable_basis (at_bot : filter Œ±) (Œª _, true) Iic :=
{ countable := countable_encodable _,
  .. at_bot_basis }

@[priority 200]
instance at_top.is_countably_generated [preorder Œ±] [encodable Œ±] :
  (at_top : filter $ Œ±).is_countably_generated :=
is_countably_generated_seq _

@[priority 200]
instance at_bot.is_countably_generated [preorder Œ±] [encodable Œ±] :
  (at_bot : filter $ Œ±).is_countably_generated :=
is_countably_generated_seq _

lemma order_top.at_top_eq (Œ±) [partial_order Œ±] [order_top Œ±] : (at_top : filter Œ±) = pure ‚ä§ :=
le_antisymm (le_pure_iff.2 $ (eventually_ge_at_top ‚ä§).mono $ Œª b, top_unique)
  (le_infi $ Œª b, le_principal_iff.2 le_top)

lemma order_bot.at_bot_eq (Œ±) [partial_order Œ±] [order_bot Œ±] : (at_bot : filter Œ±) = pure ‚ä• :=
@order_top.at_top_eq Œ±·µí·µà _ _

@[nontriviality]
lemma subsingleton.at_top_eq (Œ±) [subsingleton Œ±] [preorder Œ±] : (at_top : filter Œ±) = ‚ä§ :=
begin
  refine top_unique (Œª s hs x, _),
  letI : unique Œ± := ‚ü®‚ü®x‚ü©, Œª y, subsingleton.elim y x‚ü©,
  rw [at_top, infi_unique, unique.default_eq x, mem_principal] at hs,
  exact hs left_mem_Ici
end

@[nontriviality]
lemma subsingleton.at_bot_eq (Œ±) [subsingleton Œ±] [preorder Œ±] : (at_bot : filter Œ±) = ‚ä§ :=
@subsingleton.at_top_eq Œ±·µí·µà _ _

lemma tendsto_at_top_pure [partial_order Œ±] [order_top Œ±] (f : Œ± ‚Üí Œ≤) :
  tendsto f at_top (pure $ f ‚ä§) :=
(order_top.at_top_eq Œ±).symm ‚ñ∏ tendsto_pure_pure _ _

lemma tendsto_at_bot_pure [partial_order Œ±] [order_bot Œ±] (f : Œ± ‚Üí Œ≤) :
  tendsto f at_bot (pure $ f ‚ä•) :=
@tendsto_at_top_pure Œ±·µí·µà _ _ _ _

lemma eventually.exists_forall_of_at_top [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop}
  (h : ‚àÄ·∂† x in at_top, p x) : ‚àÉ a, ‚àÄ b ‚â• a, p b :=
eventually_at_top.mp h

lemma eventually.exists_forall_of_at_bot [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop}
  (h : ‚àÄ·∂† x in at_bot, p x) : ‚àÉ a, ‚àÄ b ‚â§ a, p b :=
eventually_at_bot.mp h

lemma frequently_at_top [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂† x in at_top, p x) ‚Üî (‚àÄ a, ‚àÉ b ‚â• a, p b) :=
by simp [at_top_basis.frequently_iff]

lemma frequently_at_bot [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂† x in at_bot, p x) ‚Üî (‚àÄ a, ‚àÉ b ‚â§ a, p b) :=
@frequently_at_top Œ±·µí·µà _ _ _

lemma frequently_at_top' [semilattice_sup Œ±] [nonempty Œ±] [no_max_order Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂† x in at_top, p x) ‚Üî (‚àÄ a, ‚àÉ b > a, p b) :=
by simp [at_top_basis_Ioi.frequently_iff]

lemma frequently_at_bot' [semilattice_inf Œ±] [nonempty Œ±] [no_min_order Œ±] {p : Œ± ‚Üí Prop} :
  (‚àÉ·∂† x in at_bot, p x) ‚Üî (‚àÄ a, ‚àÉ b < a, p b) :=
@frequently_at_top' Œ±·µí·µà _ _ _ _

lemma frequently.forall_exists_of_at_top [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop}
  (h : ‚àÉ·∂† x in at_top, p x) : ‚àÄ a, ‚àÉ b ‚â• a, p b :=
frequently_at_top.mp h

lemma frequently.forall_exists_of_at_bot [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± ‚Üí Prop}
  (h : ‚àÉ·∂† x in at_bot, p x) : ‚àÄ a, ‚àÉ b ‚â§ a, p b :=
frequently_at_bot.mp h

lemma map_at_top_eq [nonempty Œ±] [semilattice_sup Œ±] {f : Œ± ‚Üí Œ≤} :
  at_top.map f = (‚®Öa, ùìü $ f '' {a' | a ‚â§ a'}) :=
(at_top_basis.map _).eq_infi

lemma map_at_bot_eq [nonempty Œ±] [semilattice_inf Œ±] {f : Œ± ‚Üí Œ≤} :
  at_bot.map f = (‚®Öa, ùìü $ f '' {a' | a' ‚â§ a}) :=
@map_at_top_eq Œ±·µí·µà _ _ _ _

lemma tendsto_at_top [preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : filter Œ±} :
  tendsto m f at_top ‚Üî (‚àÄb, ‚àÄ·∂† a in f, b ‚â§ m a) :=
by simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]

lemma tendsto_at_bot [preorder Œ≤] {m : Œ± ‚Üí Œ≤} {f : filter Œ±} :
  tendsto m f at_bot ‚Üî (‚àÄb, ‚àÄ·∂† a in f, m a ‚â§ b) :=
@tendsto_at_top Œ± Œ≤·µí·µà _ m f

lemma tendsto_at_top_mono' [preorder Œ≤] (l : filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
  tendsto f‚ÇÅ l at_top ‚Üí tendsto f‚ÇÇ l at_top :=
assume h‚ÇÅ, tendsto_at_top.2 $ Œª b, mp_mem (tendsto_at_top.1 h‚ÇÅ b)
  (monotone_mem (Œª a ha ha‚ÇÅ, le_trans ha‚ÇÅ ha) h)

lemma tendsto_at_bot_mono' [preorder Œ≤] (l : filter Œ±) ‚¶Éf‚ÇÅ f‚ÇÇ : Œ± ‚Üí Œ≤‚¶Ñ (h : f‚ÇÅ ‚â§·∂†[l] f‚ÇÇ) :
  tendsto f‚ÇÇ l at_bot ‚Üí tendsto f‚ÇÅ l at_bot :=
@tendsto_at_top_mono' _ Œ≤·µí·µà _ _ _ _ h

lemma tendsto_at_top_mono [preorder Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
  tendsto f l at_top ‚Üí tendsto g l at_top :=
tendsto_at_top_mono' l $ eventually_of_forall h

lemma tendsto_at_bot_mono [preorder Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (h : ‚àÄ n, f n ‚â§ g n) :
  tendsto g l at_bot ‚Üí tendsto f l at_bot :=
@tendsto_at_top_mono _ Œ≤·µí·µà _ _ _ _ h

/-!
### Sequences
-/

lemma inf_map_at_top_ne_bot_iff [semilattice_sup Œ±] [nonempty Œ±] {F : filter Œ≤} {u : Œ± ‚Üí Œ≤} :
  ne_bot (F ‚äì (map u at_top)) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà U :=
by simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]; refl

lemma inf_map_at_bot_ne_bot_iff [semilattice_inf Œ±] [nonempty Œ±] {F : filter Œ≤} {u : Œ± ‚Üí Œ≤} :
  ne_bot (F ‚äì (map u at_bot)) ‚Üî ‚àÄ U ‚àà F, ‚àÄ N, ‚àÉ n ‚â§ N, u n ‚àà U :=
@inf_map_at_top_ne_bot_iff Œ±·µí·µà _ _ _ _ _

lemma extraction_of_frequently_at_top' {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ N, ‚àÉ n > N, P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
begin
  choose u hu using h,
  cases forall_and_distrib.mp hu with hu hu',
  exact ‚ü®u ‚àò (nat.rec 0 (Œª n v, u v)), strict_mono_nat_of_lt_succ (Œª n, hu _), Œª n, hu' _‚ü©,
end

lemma extraction_of_frequently_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÉ·∂† n in at_top, P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
begin
  rw frequently_at_top' at h,
  exact extraction_of_frequently_at_top' h,
end

lemma extraction_of_eventually_at_top {P : ‚Ñï ‚Üí Prop} (h : ‚àÄ·∂† n in at_top, P n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P (œÜ n) :=
extraction_of_frequently_at_top h.frequently

lemma extraction_forall_of_frequently {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ·∂† k in at_top, P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
begin
  simp only [frequently_at_top'] at h,
  choose u hu hu' using h,
  use (Œª n, nat.rec_on n (u 0 0) (Œª n v, u (n+1) v) : ‚Ñï ‚Üí ‚Ñï),
  split,
  { apply strict_mono_nat_of_lt_succ,
    intro n,
    apply hu },
  { intros n,
    cases n ; simp [hu'] },
end

lemma extraction_forall_of_eventually  {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÄ·∂† k in at_top, P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
extraction_forall_of_frequently (Œª n, (h n).frequently)

lemma extraction_forall_of_eventually' {P : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (h : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, P n k) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, P n (œÜ n) :=
extraction_forall_of_eventually (by simp [eventually_at_top, h])

lemma exists_le_of_tendsto_at_top [semilattice_sup Œ±] [preorder Œ≤] {u : Œ± ‚Üí Œ≤}
  (h : tendsto u at_top at_top) (a : Œ±) (b : Œ≤) : ‚àÉ a' ‚â• a, b ‚â§ u a' :=
begin
  have : ‚àÄ·∂† x in at_top, a ‚â§ x ‚àß b ‚â§ u x :=
    (eventually_ge_at_top a).and (h.eventually $ eventually_ge_at_top b),
  haveI : nonempty Œ± := ‚ü®a‚ü©,
  rcases this.exists with ‚ü®a', ha, hb‚ü©,
  exact ‚ü®a', ha, hb‚ü©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_le_of_tendsto_at_bot [semilattice_sup Œ±] [preorder Œ≤] {u : Œ± ‚Üí Œ≤}
  (h : tendsto u at_top at_bot) : ‚àÄ a b, ‚àÉ a' ‚â• a, u a' ‚â§ b :=
@exists_le_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ h

lemma exists_lt_of_tendsto_at_top [semilattice_sup Œ±] [preorder Œ≤] [no_max_order Œ≤]
  {u : Œ± ‚Üí Œ≤} (h : tendsto u at_top at_top) (a : Œ±) (b : Œ≤) : ‚àÉ a' ‚â• a, b < u a' :=
begin
  cases exists_gt b with b' hb',
  rcases exists_le_of_tendsto_at_top h a b' with ‚ü®a', ha', ha''‚ü©,
  exact ‚ü®a', ha', lt_of_lt_of_le hb' ha''‚ü©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_lt_of_tendsto_at_bot [semilattice_sup Œ±] [preorder Œ≤] [no_min_order Œ≤]
  {u : Œ± ‚Üí Œ≤} (h : tendsto u at_top at_bot) : ‚àÄ a b, ‚àÉ a' ‚â• a, u a' < b :=
@exists_lt_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ _ h

/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
lemma high_scores [linear_order Œ≤] [no_max_order Œ≤] {u : ‚Ñï ‚Üí Œ≤}
  (hu : tendsto u at_top at_top) : ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u k < u n :=
begin
  intros N,
  obtain ‚ü®k : ‚Ñï, hkn : k ‚â§ N, hku : ‚àÄ l ‚â§ N, u l ‚â§ u k‚ü© : ‚àÉ k ‚â§ N, ‚àÄ l ‚â§ N, u l ‚â§ u k,
    from exists_max_image _ u (finite_le_nat N) ‚ü®N, le_refl N‚ü©,
  have ex : ‚àÉ n ‚â• N, u k < u n,
    from exists_lt_of_tendsto_at_top hu _ _,
  obtain ‚ü®n : ‚Ñï, hnN : n ‚â• N, hnk : u k < u n, hn_min : ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k‚ü© :
    ‚àÉ n ‚â• N, u k < u n ‚àß ‚àÄ m, m < n ‚Üí N ‚â§ m ‚Üí u m ‚â§ u k,
  { rcases nat.find_x ex with ‚ü®n, ‚ü®hnN, hnk‚ü©, hn_min‚ü©,
    push_neg at hn_min,
    exact ‚ü®n, hnN, hnk, hn_min‚ü© },
  use [n, hnN],
  rintros (l : ‚Ñï) (hl : l < n),
  have hlk : u l ‚â§ u k,
  { cases (le_total l N : l ‚â§ N ‚à® N ‚â§ l) with H H,
    { exact hku l H },
    { exact hn_min l hl H } },
  calc u l ‚â§ u k : hlk
       ... < u n : hnk
end

/--
If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma low_scores [linear_order Œ≤] [no_min_order Œ≤] {u : ‚Ñï ‚Üí Œ≤}
  (hu : tendsto u at_top at_bot) : ‚àÄ N, ‚àÉ n ‚â• N, ‚àÄ k < n, u n < u k :=
@high_scores Œ≤·µí·µà _ _ _ hu

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
lemma frequently_high_scores [linear_order Œ≤] [no_max_order Œ≤] {u : ‚Ñï ‚Üí Œ≤}
  (hu : tendsto u at_top at_top) : ‚àÉ·∂† n in at_top, ‚àÄ k < n, u k < u n :=
by simpa [frequently_at_top] using high_scores hu

/--
If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
lemma frequently_low_scores [linear_order Œ≤] [no_min_order Œ≤] {u : ‚Ñï ‚Üí Œ≤}
  (hu : tendsto u at_top at_bot) : ‚àÉ·∂† n in at_top, ‚àÄ k < n, u n < u k :=
@frequently_high_scores Œ≤·µí·µà _ _ _ hu

lemma strict_mono_subseq_of_tendsto_at_top
  {Œ≤ : Type*} [linear_order Œ≤] [no_max_order Œ≤]
  {u : ‚Ñï ‚Üí Œ≤} (hu : tendsto u at_top at_top) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß strict_mono (u ‚àò œÜ) :=
let ‚ü®œÜ, h, h'‚ü© := extraction_of_frequently_at_top (frequently_high_scores hu) in
‚ü®œÜ, h, Œª n m hnm, h' m _ (h hnm)‚ü©

lemma strict_mono_subseq_of_id_le {u : ‚Ñï ‚Üí ‚Ñï} (hu : ‚àÄ n, n ‚â§ u n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß strict_mono (u ‚àò œÜ) :=
strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

lemma _root_.strict_mono.tendsto_at_top {œÜ : ‚Ñï ‚Üí ‚Ñï} (h : strict_mono œÜ) :
  tendsto œÜ at_top at_top :=
tendsto_at_top_mono h.id_le tendsto_id

section ordered_add_comm_monoid

variables [ordered_add_comm_monoid Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤}

lemma tendsto_at_top_add_nonneg_left' (hf : ‚àÄ·∂† x in l, 0 ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_mono' l (hf.mono (Œª x, le_add_of_nonneg_left)) hg

lemma tendsto_at_bot_add_nonpos_left' (hf : ‚àÄ·∂† x in l, f x ‚â§ 0) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_left' _ Œ≤·µí·µà _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_left (hf : ‚àÄ x, 0 ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

lemma tendsto_at_bot_add_nonpos_left (hf : ‚àÄ x, f x ‚â§ 0) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_left _ Œ≤·µí·µà _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top) (hg : ‚àÄ·∂† x in l, 0 ‚â§ g x) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_mono' l (monotone_mem (Œª x, le_add_of_nonneg_right) hg) hf

lemma tendsto_at_bot_add_nonpos_right' (hf : tendsto f l at_bot) (hg : ‚àÄ·∂† x in l, g x ‚â§ 0) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_right' _ Œ≤·µí·µà _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : ‚àÄ x, 0 ‚â§ g x) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

lemma tendsto_at_bot_add_nonpos_right (hf : tendsto f l at_bot) (hg : ‚àÄ x, g x ‚â§ 0) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_right _ Œ≤·µí·µà _ _ _ _ hf hg

lemma tendsto_at_top_add (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg

lemma tendsto_at_bot_add (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add _ Œ≤·µí·µà _ _ _ _ hf hg

lemma tendsto.nsmul_at_top (hf : tendsto f l at_top) {n : ‚Ñï} (hn : 0 < n) :
  tendsto (Œª x, n ‚Ä¢ f x) l at_top :=
tendsto_at_top.2 $ Œª y, (tendsto_at_top.1 hf y).mp $ (tendsto_at_top.1 hf 0).mono $ Œª x h‚ÇÄ hy,
calc y ‚â§ f x : hy
... = 1 ‚Ä¢ f x : (one_nsmul _).symm
... ‚â§  n ‚Ä¢ f x : nsmul_le_nsmul h‚ÇÄ hn

lemma tendsto.nsmul_at_bot (hf : tendsto f l at_bot) {n : ‚Ñï} (hn : 0 < n) :
  tendsto (Œª x, n ‚Ä¢ f x) l at_bot :=
@tendsto.nsmul_at_top Œ± Œ≤·µí·µà _ l f hf n hn

lemma tendsto_bit0_at_top : tendsto bit0 (at_top : filter Œ≤) at_top :=
tendsto_at_top_add tendsto_id tendsto_id

lemma tendsto_bit0_at_bot : tendsto bit0 (at_bot : filter Œ≤) at_bot :=
tendsto_at_bot_add tendsto_id tendsto_id

end ordered_add_comm_monoid

section ordered_cancel_add_comm_monoid

variables [ordered_cancel_add_comm_monoid Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤}

lemma tendsto_at_top_of_add_const_left (C : Œ≤) (hf : tendsto (Œª x, C + f x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ assume b, (tendsto_at_top.1 hf (C + b)).mono (Œª x, le_of_add_le_add_left)

lemma tendsto_at_bot_of_add_const_left (C : Œ≤) (hf : tendsto (Œª x, C + f x) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_const_left _ Œ≤·µí·µà _ _ _ C hf

lemma tendsto_at_top_of_add_const_right (C : Œ≤) (hf : tendsto (Œª x, f x + C) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ assume b, (tendsto_at_top.1 hf (b + C)).mono (Œª x, le_of_add_le_add_right)

lemma tendsto_at_bot_of_add_const_right (C : Œ≤) (hf : tendsto (Œª x, f x + C) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_const_right _ Œ≤·µí·µà _ _ _ C hf

lemma tendsto_at_top_of_add_bdd_above_left' (C) (hC : ‚àÄ·∂† x in l, f x ‚â§ C)
  (h : tendsto (Œª x, f x + g x) l at_top) :
  tendsto g l at_top :=
tendsto_at_top_of_add_const_left C
  (tendsto_at_top_mono' l (hC.mono (Œª x hx, add_le_add_right hx (g x))) h)

lemma tendsto_at_bot_of_add_bdd_below_left' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ f x)
  (h : tendsto (Œª x, f x + g x) l at_bot) :
  tendsto g l at_bot :=
@tendsto_at_top_of_add_bdd_above_left' _ Œ≤·µí·µà _ _ _ _ C hC h

lemma tendsto_at_top_of_add_bdd_above_left (C) (hC : ‚àÄ x, f x ‚â§ C) :
  tendsto (Œª x, f x + g x) l at_top ‚Üí tendsto g l at_top :=
tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)

lemma tendsto_at_bot_of_add_bdd_below_left (C) (hC : ‚àÄ x, C ‚â§ f x) :
  tendsto (Œª x, f x + g x) l at_bot ‚Üí tendsto g l at_bot :=
@tendsto_at_top_of_add_bdd_above_left _ Œ≤·µí·µà _ _ _ _ C hC

lemma tendsto_at_top_of_add_bdd_above_right' (C) (hC : ‚àÄ·∂† x in l, g x ‚â§ C)
  (h : tendsto (Œª x, f x + g x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top_of_add_const_right C
  (tendsto_at_top_mono' l (hC.mono (Œª x hx, add_le_add_left hx (f x))) h)

lemma tendsto_at_bot_of_add_bdd_below_right' (C) (hC : ‚àÄ·∂† x in l, C ‚â§ g x)
  (h : tendsto (Œª x, f x + g x) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_bdd_above_right' _ Œ≤·µí·µà _ _ _ _ C hC h

lemma tendsto_at_top_of_add_bdd_above_right (C) (hC : ‚àÄ x, g x ‚â§ C) :
  tendsto (Œª x, f x + g x) l at_top ‚Üí tendsto f l at_top :=
tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)

lemma tendsto_at_bot_of_add_bdd_below_right (C) (hC : ‚àÄ x, C ‚â§ g x) :
  tendsto (Œª x, f x + g x) l at_bot ‚Üí tendsto f l at_bot :=
@tendsto_at_top_of_add_bdd_above_right _ Œ≤·µí·µà _ _ _ _ C hC

end ordered_cancel_add_comm_monoid

section ordered_group

variables [ordered_add_comm_group Œ≤] (l : filter Œ±) {f g : Œ± ‚Üí Œ≤}

lemma tendsto_at_top_add_left_of_le' (C : Œ≤) (hf : ‚àÄ·∂† x in l, C ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_left' _ _ _ l (Œª x, -(f x)) (Œª x, f x + g x) (-C)
  (by simpa) (by simpa)

lemma tendsto_at_bot_add_left_of_ge' (C : Œ≤) (hf : ‚àÄ·∂† x in l, f x ‚â§ C) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_left_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg

lemma tendsto_at_top_add_left_of_le (C : Œ≤) (hf : ‚àÄ x, C ‚â§ f x) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg

lemma tendsto_at_bot_add_left_of_ge (C : Œ≤) (hf : ‚àÄ x, f x ‚â§ C) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_left_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg

lemma tendsto_at_top_add_right_of_le' (C : Œ≤) (hf : tendsto f l at_top) (hg : ‚àÄ·∂† x in l, C ‚â§ g x) :
  tendsto (Œª x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_right' _ _ _ l (Œª x, f x + g x) (Œª x, -(g x)) (-C)
  (by simp [hg]) (by simp [hf])

lemma tendsto_at_bot_add_right_of_ge' (C : Œ≤) (hf : tendsto f l at_bot) (hg : ‚àÄ·∂† x in l, g x ‚â§ C) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_right_of_le' _ Œ≤·µí·µà _ _ _ _ C hf hg

lemma tendsto_at_top_add_right_of_le (C : Œ≤) (hf : tendsto f l at_top) (hg : ‚àÄ x, C ‚â§ g x) :
  tendsto (Œª x, f x + g x) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)

lemma tendsto_at_bot_add_right_of_ge (C : Œ≤) (hf : tendsto f l at_bot) (hg : ‚àÄ x, g x ‚â§ C) :
  tendsto (Œª x, f x + g x) l at_bot :=
@tendsto_at_top_add_right_of_le _ Œ≤·µí·µà _ _ _ _ C hf hg

lemma tendsto_at_top_add_const_left (C : Œ≤) (hf : tendsto f l at_top) :
  tendsto (Œª x, C + f x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem' $ Œª _, le_refl C) hf

lemma tendsto_at_bot_add_const_left (C : Œ≤) (hf : tendsto f l at_bot) :
  tendsto (Œª x, C + f x) l at_bot :=
@tendsto_at_top_add_const_left _ Œ≤·µí·µà _ _ _ C hf

lemma tendsto_at_top_add_const_right (C : Œ≤) (hf : tendsto f l at_top) :
  tendsto (Œª x, f x + C) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem' $ Œª _, le_refl C)

lemma tendsto_at_bot_add_const_right (C : Œ≤) (hf : tendsto f l at_bot) :
  tendsto (Œª x, f x + C) l at_bot :=
@tendsto_at_top_add_const_right _ Œ≤·µí·µà _ _ _ C hf

lemma tendsto_neg_at_top_at_bot : tendsto (has_neg.neg : Œ≤ ‚Üí Œ≤) at_top at_bot :=
begin
  simp only [tendsto_at_bot, neg_le],
  exact Œª b, eventually_ge_at_top _
end

lemma tendsto_neg_at_bot_at_top : tendsto (has_neg.neg : Œ≤ ‚Üí Œ≤) at_bot at_top :=
@tendsto_neg_at_top_at_bot Œ≤·µí·µà _

lemma tendsto_at_top_iff_tends_to_neg_at_bot : tendsto f l at_top ‚Üî tendsto (-f) l at_bot :=
have hf : f = has_neg.neg ‚àò -f, { ext, simp, },
‚ü®tendsto_neg_at_top_at_bot.comp, Œª h, hf.symm ‚ñ∏ tendsto_neg_at_bot_at_top.comp h‚ü©

lemma tendsto_at_bot_iff_tends_to_neg_at_top : tendsto f l at_bot ‚Üî tendsto (-f) l at_top :=
@tendsto_at_top_iff_tends_to_neg_at_bot Œ± Œ≤·µí·µà _ l f

end ordered_group

section ordered_semiring

variables [ordered_semiring Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

lemma tendsto_bit1_at_top : tendsto bit1 (at_top : filter Œ±) at_top :=
tendsto_at_top_add_nonneg_right tendsto_bit0_at_top (Œª _, zero_le_one)

lemma tendsto.at_top_mul_at_top (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x * g x) l at_top :=
begin
  refine tendsto_at_top_mono' _ _ hg,
  filter_upwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)]
    with _ using le_mul_of_one_le_left,
end

lemma tendsto_mul_self_at_top : tendsto (Œª x : Œ±, x * x) at_top at_top :=
tendsto_id.at_top_mul_at_top tendsto_id

/-- The monomial function `x^n` tends to `+‚àû` at `+‚àû` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
lemma tendsto_pow_at_top {n : ‚Ñï} (hn : 1 ‚â§ n) : tendsto (Œª x : Œ±, x ^ n) at_top at_top :=
begin
  refine tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono $ Œª x hx, _) tendsto_id,
  simpa only [pow_one] using pow_le_pow hx hn
end

end ordered_semiring

lemma zero_pow_eventually_eq [monoid_with_zero Œ±] :
  (Œª n : ‚Ñï, (0 : Œ±) ^ n) =·∂†[at_top] (Œª n, 0) :=
eventually_at_top.2 ‚ü®1, Œª n hn, zero_pow (zero_lt_one.trans_le hn)‚ü©

section ordered_ring

variables [ordered_ring Œ±] {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

lemma tendsto.at_top_mul_at_bot (hf : tendsto f l at_top) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x * g x) l at_bot :=
have _ := (hf.at_top_mul_at_top $ tendsto_neg_at_bot_at_top.comp hg),
by simpa only [(‚àò), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp this

lemma tendsto.at_bot_mul_at_top (hf : tendsto f l at_bot) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x * g x) l at_bot :=
have tendsto (Œª x, (-f x) * g x) l at_top :=
  ( (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg),
by simpa only [(‚àò), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp this

lemma tendsto.at_bot_mul_at_bot (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x * g x) l at_top :=
have tendsto (Œª x, (-f x) * (-g x)) l at_top :=
  (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg),
by simpa only [neg_mul_neg] using this

end ordered_ring

section linear_ordered_add_comm_group

variables [linear_ordered_add_comm_group Œ±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_top_at_top : tendsto (abs : Œ± ‚Üí Œ±) at_top at_top :=
tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_bot_at_top : tendsto (abs : Œ± ‚Üí Œ±) at_bot at_top :=
tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

@[simp] lemma comap_abs_at_top : comap (abs : Œ± ‚Üí Œ±) at_top = at_bot ‚äî at_top :=
begin
  refine le_antisymm (((at_top_basis.comap _).le_basis_iff (at_bot_basis.sup at_top_basis)).2 _)
    (sup_le tendsto_abs_at_bot_at_top.le_comap tendsto_abs_at_top_at_top.le_comap),
  rintro ‚ü®a, b‚ü© -,
  refine ‚ü®max (-a) b, trivial, Œª x hx, _‚ü©,
  rw [mem_preimage, mem_Ici, le_abs', max_le_iff, ‚Üê min_neg_neg, le_min_iff, neg_neg] at hx,
  exact hx.imp and.left and.right
end

end linear_ordered_add_comm_group

section linear_ordered_semiring

variables [linear_ordered_semiring Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±}

lemma tendsto.at_top_of_const_mul {c : Œ±} (hc : 0 < c) (hf : tendsto (Œª x, c * f x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ Œª b, (tendsto_at_top.1 hf (c * b)).mono $ Œª x hx, le_of_mul_le_mul_left hx hc

lemma tendsto.at_top_of_mul_const {c : Œ±} (hc : 0 < c) (hf : tendsto (Œª x, f x * c) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ Œª b, (tendsto_at_top.1 hf (b * c)).mono $ Œª x hx, le_of_mul_le_mul_right hx hc

end linear_ordered_semiring

lemma nonneg_of_eventually_pow_nonneg [linear_ordered_ring Œ±] {a : Œ±}
  (h : ‚àÄ·∂† n in at_top, 0 ‚â§ a ^ (n : ‚Ñï)) : 0 ‚â§ a :=
let ‚ü®n, hn‚ü© := (tendsto_bit1_at_top.eventually h).exists in pow_bit1_nonneg_iff.1 hn

section linear_ordered_field

variables [linear_ordered_field Œ±] {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {r : Œ±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.const_mul_at_top'` instead. -/
lemma tendsto.const_mul_at_top (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, r * f x) l at_top :=
tendsto.at_top_of_const_mul (inv_pos.2 hr) $ by simpa only [inv_mul_cancel_left‚ÇÄ hr.ne']

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`filter.tendsto.at_top_mul_const'` instead. -/
lemma tendsto.at_top_mul_const (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, f x * r) l at_top :=
by simpa only [mul_comm] using hf.const_mul_at_top hr

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
lemma tendsto.at_top_div_const (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, f x / r) l at_top :=
by simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
lemma tendsto.neg_const_mul_at_top (hr : r < 0) (hf : tendsto f l at_top) :
  tendsto (Œª x, r * f x) l at_bot :=
by simpa only [(‚àò), neg_mul_eq_neg_mul, neg_neg]
  using tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
lemma tendsto.at_top_mul_neg_const (hr : r < 0) (hf : tendsto f l at_top) :
  tendsto (Œª x, f x * r) l at_bot :=
by simpa only [mul_comm] using hf.neg_const_mul_at_top hr

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
lemma tendsto.const_mul_at_bot (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Œªx, r * f x) l at_bot :=
by simpa only [(‚àò), neg_mul_eq_mul_neg, neg_neg]
  using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
lemma tendsto.at_bot_mul_const (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Œªx, f x * r) l at_bot :=
by simpa only [mul_comm] using hf.const_mul_at_bot hr

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
lemma tendsto.at_bot_div_const (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Œªx, f x / r) l at_bot :=
by simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
lemma tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : tendsto f l at_bot) :
  tendsto (Œª x, r * f x) l at_top :=
by simpa only [(‚àò), neg_mul_eq_neg_mul, neg_neg]
  using tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
lemma tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : tendsto f l at_bot) :
  tendsto (Œª x, f x * r) l at_top :=
by simpa only [mul_comm] using hf.neg_const_mul_at_bot hr

lemma tendsto_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï}
  (hn : 1 ‚â§ n) (hc : 0 < c) : tendsto (Œª x, c * x^n) at_top at_top :=
tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)

lemma tendsto_const_mul_pow_at_top_iff (c : Œ±) (n : ‚Ñï) :
  tendsto (Œª x, c * x^n) at_top at_top ‚Üî 1 ‚â§ n ‚àß 0 < c :=
begin
  refine ‚ü®Œª h, _, Œª h, tendsto_const_mul_pow_at_top h.1 h.2‚ü©,
  simp only [tendsto_at_top, eventually_at_top] at h,
  have : 0 < c := let ‚ü®x, hx‚ü© := h 1 in
    pos_of_mul_pos_right (lt_of_lt_of_le zero_lt_one (hx (max x 1) (le_max_left x 1)))
    (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n),
  refine ‚ü®nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Œª hn, _))), this‚ü©,
  obtain ‚ü®x, hx‚ü© := h (c + 1),
  specialize hx x le_rfl,
  rw [hn, pow_zero, mul_one, add_le_iff_nonpos_right] at hx,
  exact absurd hx (not_le.mpr zero_lt_one),
end

lemma tendsto_neg_const_mul_pow_at_top {c : Œ±} {n : ‚Ñï}
  (hn : 1 ‚â§ n) (hc : c < 0) : tendsto (Œª x, c * x^n) at_top at_bot :=
tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)

lemma tendsto_neg_const_mul_pow_at_top_iff (c : Œ±) (n : ‚Ñï) :
  tendsto (Œª x, c * x^n) at_top at_bot ‚Üî 1 ‚â§ n ‚àß c < 0 :=
begin
  refine ‚ü®Œª h, _, Œª h, tendsto_neg_const_mul_pow_at_top h.1 h.2‚ü©,
  simp only [tendsto_at_bot, eventually_at_top] at h,
  have : c < 0 := let ‚ü®x, hx‚ü© := h (-1) in
    neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [zero_lt_one]))
    (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n),
  refine ‚ü®nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Œª hn, _))), this‚ü©,
  obtain ‚ü®x, hx‚ü© := h (c - 1),
  specialize hx x le_rfl,
  rw [hn, pow_zero, mul_one, le_sub, sub_self] at hx,
  exact absurd hx (not_le.mpr zero_lt_one),
end

end linear_ordered_field

open_locale filter

lemma tendsto_at_top' [nonempty Œ±] [semilattice_sup Œ±] {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto f at_top l ‚Üî (‚àÄs ‚àà l, ‚àÉa, ‚àÄb‚â•a, f b ‚àà s) :=
by simp only [tendsto_def, mem_at_top_sets]; refl

lemma tendsto_at_bot' [nonempty Œ±] [semilattice_inf Œ±] {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto f at_bot l ‚Üî (‚àÄs ‚àà l, ‚àÉa, ‚àÄb‚â§a, f b ‚àà s) :=
@tendsto_at_top' Œ±·µí·µà _ _ _ _ _

theorem tendsto_at_top_principal [nonempty Œ≤] [semilattice_sup Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ±} :
  tendsto f at_top (ùìü s) ‚Üî ‚àÉN, ‚àÄn‚â•N, f n ‚àà s :=
by rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]; refl

theorem tendsto_at_bot_principal [nonempty Œ≤] [semilattice_inf Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ±} :
  tendsto f at_bot (ùìü s) ‚Üî ‚àÉN, ‚àÄn‚â§N, f n ‚àà s :=
@tendsto_at_top_principal _ Œ≤·µí·µà _ _ _ _

/-- A function `f` grows to `+‚àû` independent of an order-preserving embedding `e`. -/
lemma tendsto_at_top_at_top [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_top at_top ‚Üî ‚àÄ b : Œ≤, ‚àÉ i : Œ±, ‚àÄ a : Œ±, i ‚â§ a ‚Üí b ‚â§ f a :=
iff.trans tendsto_infi $ forall_congr $ assume b, tendsto_at_top_principal

lemma tendsto_at_top_at_bot [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_top at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (i : Œ±), ‚àÄ (a : Œ±), i ‚â§ a ‚Üí f a ‚â§ b :=
@tendsto_at_top_at_top Œ± Œ≤·µí·µà _ _ _ f

lemma tendsto_at_bot_at_top [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_bot at_top ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (i : Œ±), ‚àÄ (a : Œ±), a ‚â§ i ‚Üí b ‚â§ f a :=
@tendsto_at_top_at_top Œ±·µí·µà Œ≤ _ _ _ f

lemma tendsto_at_bot_at_bot [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} :
  tendsto f at_bot at_bot ‚Üî ‚àÄ (b : Œ≤), ‚àÉ (i : Œ±), ‚àÄ (a : Œ±), a ‚â§ i ‚Üí f a ‚â§ b :=
@tendsto_at_top_at_top Œ±·µí·µà Œ≤·µí·µà _ _ _ f

lemma tendsto_at_top_at_top_of_monotone [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f)
  (h : ‚àÄ b, ‚àÉ a, b ‚â§ f a) :
  tendsto f at_top at_top :=
tendsto_infi.2 $ Œª b, tendsto_principal.2 $ let ‚ü®a, ha‚ü© := h b in
mem_of_superset (mem_at_top a) $ Œª a' ha', le_trans ha (hf ha')

lemma tendsto_at_bot_at_bot_of_monotone [preorder Œ±] [preorder Œ≤] {f : Œ± ‚Üí Œ≤} (hf : monotone f)
  (h : ‚àÄ b, ‚àÉ a, f a ‚â§ b) :
  tendsto f at_bot at_bot :=
tendsto_infi.2 $ Œª b, tendsto_principal.2 $ let ‚ü®a, ha‚ü© := h b in
mem_of_superset (mem_at_bot a) $ Œª a' ha', le_trans (hf ha') ha

lemma tendsto_at_top_at_top_iff_of_monotone [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤]
  {f : Œ± ‚Üí Œ≤} (hf : monotone f) :
  tendsto f at_top at_top ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, b ‚â§ f a :=
tendsto_at_top_at_top.trans $ forall_congr $ Œª b, exists_congr $ Œª a,
  ‚ü®Œª h, h a (le_refl a), Œª h a' ha', le_trans h $ hf ha'‚ü©

lemma tendsto_at_bot_at_bot_iff_of_monotone [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤]
  {f : Œ± ‚Üí Œ≤} (hf : monotone f) :
  tendsto f at_bot at_bot ‚Üî ‚àÄ b : Œ≤, ‚àÉ a : Œ±, f a ‚â§ b :=
tendsto_at_bot_at_bot.trans $ forall_congr $ Œª b, exists_congr $ Œª a,
  ‚ü®Œª h, h a (le_refl a), Œª h a' ha', le_trans (hf ha') h‚ü©

alias tendsto_at_top_at_top_of_monotone ‚Üê monotone.tendsto_at_top_at_top
alias tendsto_at_bot_at_bot_of_monotone ‚Üê monotone.tendsto_at_bot_at_bot
alias tendsto_at_top_at_top_iff_of_monotone ‚Üê monotone.tendsto_at_top_at_top_iff
alias tendsto_at_bot_at_bot_iff_of_monotone ‚Üê monotone.tendsto_at_bot_at_bot_iff

lemma comap_embedding_at_top [preorder Œ≤] [preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}
  (hm : ‚àÄb‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄc, ‚àÉb, c ‚â§ e b) :
  comap e at_top = at_top :=
le_antisymm
  (le_infi $ Œª b, le_principal_iff.2 $ mem_comap.2 ‚ü®Ici (e b), mem_at_top _, Œª x, (hm _ _).1‚ü©)
  (tendsto_at_top_at_top_of_monotone (Œª _ _, (hm _ _).2) hu).le_comap

lemma comap_embedding_at_bot [preorder Œ≤] [preorder Œ≥] {e : Œ≤ ‚Üí Œ≥}
  (hm : ‚àÄ b‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄc, ‚àÉb, e b ‚â§ c) :
  comap e at_bot = at_bot :=
@comap_embedding_at_top Œ≤·µí·µà Œ≥·µí·µà _ _ e (function.swap hm) hu

lemma tendsto_at_top_embedding [preorder Œ≤] [preorder Œ≥]
  {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : filter Œ±}
  (hm : ‚àÄb‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄc, ‚àÉb, c ‚â§ e b) :
  tendsto (e ‚àò f) l at_top ‚Üî tendsto f l at_top :=
by rw [‚Üê comap_embedding_at_top hm hu, tendsto_comap_iff]

/-- A function `f` goes to `-‚àû` independent of an order-preserving embedding `e`. -/
lemma tendsto_at_bot_embedding [preorder Œ≤] [preorder Œ≥]
  {f : Œ± ‚Üí Œ≤} {e : Œ≤ ‚Üí Œ≥} {l : filter Œ±}
  (hm : ‚àÄb‚ÇÅ b‚ÇÇ, e b‚ÇÅ ‚â§ e b‚ÇÇ ‚Üî b‚ÇÅ ‚â§ b‚ÇÇ) (hu : ‚àÄc, ‚àÉb, e b ‚â§ c) :
  tendsto (e ‚àò f) l at_bot ‚Üî tendsto f l at_bot :=
@tendsto_at_top_embedding Œ± Œ≤·µí·µà Œ≥·µí·µà _ _ f e l (function.swap hm) hu

lemma tendsto_finset_range : tendsto finset.range at_top at_top :=
finset.range_mono.tendsto_at_top_at_top finset.exists_nat_subset_range

lemma at_top_finset_eq_infi : (at_top : filter $ finset Œ±) = ‚®Ö x : Œ±, ùìü (Ici {x}) :=
begin
  refine le_antisymm (le_infi (Œª i, le_principal_iff.2 $ mem_at_top {i})) _,
  refine le_infi (Œª s, le_principal_iff.2 $ mem_infi_of_Inter s.finite_to_set
                  (Œª i, mem_principal_self _) _),
  simp only [subset_def, mem_Inter, set_coe.forall, mem_Ici, finset.le_iff_subset,
    finset.mem_singleton, finset.subset_iff, forall_eq], dsimp,
  exact Œª t, id
end

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
lemma tendsto_at_top_finset_of_monotone [preorder Œ≤]
  {f : Œ≤ ‚Üí finset Œ±} (h : monotone f) (h' : ‚àÄ x : Œ±, ‚àÉ n, x ‚àà f n) :
  tendsto f at_top at_top :=
begin
  simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal],
  intro a,
  rcases h' a with ‚ü®b, hb‚ü©,
  exact eventually.mono (mem_at_top b)
    (Œª b' hb', le_trans (finset.singleton_subset_iff.2 hb) (h hb')),
end

alias tendsto_at_top_finset_of_monotone ‚Üê monotone.tendsto_at_top_finset

lemma tendsto_finset_image_at_top_at_top {i : Œ≤ ‚Üí Œ≥} {j : Œ≥ ‚Üí Œ≤} (h : function.left_inverse j i) :
  tendsto (finset.image j) at_top at_top :=
(finset.image_mono j).tendsto_at_top_finset $ assume a,
  ‚ü®{i a}, by simp only [finset.image_singleton, h a, finset.mem_singleton]‚ü©

lemma tendsto_finset_preimage_at_top_at_top {f : Œ± ‚Üí Œ≤} (hf : function.injective f) :
  tendsto (Œª s : finset Œ≤, s.preimage f (hf.inj_on _)) at_top at_top :=
(finset.monotone_preimage hf).tendsto_at_top_finset $
  Œª x, ‚ü®{f x}, finset.mem_preimage.2 $ finset.mem_singleton_self _‚ü©

lemma prod_at_top_at_top_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [semilattice_sup Œ≤‚ÇÅ] [semilattice_sup Œ≤‚ÇÇ] :
  (at_top : filter Œ≤‚ÇÅ) √ó·∂† (at_top : filter Œ≤‚ÇÇ) = (at_top : filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
begin
  casesI (is_empty_or_nonempty Œ≤‚ÇÅ).symm,
  casesI (is_empty_or_nonempty Œ≤‚ÇÇ).symm,
  { simp [at_top, prod_infi_left, prod_infi_right, infi_prod],
    exact infi_comm, },
  { simp only [at_top.filter_eq_bot_of_is_empty, prod_bot] },
  { simp only [at_top.filter_eq_bot_of_is_empty, bot_prod] },
end

lemma prod_at_bot_at_bot_eq {Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [semilattice_inf Œ≤‚ÇÅ] [semilattice_inf Œ≤‚ÇÇ] :
  (at_bot : filter Œ≤‚ÇÅ) √ó·∂† (at_bot : filter Œ≤‚ÇÇ) = (at_bot : filter (Œ≤‚ÇÅ √ó Œ≤‚ÇÇ)) :=
@prod_at_top_at_top_eq Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _

lemma prod_map_at_top_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [semilattice_sup Œ≤‚ÇÅ] [semilattice_sup Œ≤‚ÇÇ]
  (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) :
  (map u‚ÇÅ at_top) √ó·∂† (map u‚ÇÇ at_top) = map (prod.map u‚ÇÅ u‚ÇÇ) at_top :=
by rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]

lemma prod_map_at_bot_eq {Œ±‚ÇÅ Œ±‚ÇÇ Œ≤‚ÇÅ Œ≤‚ÇÇ : Type*} [semilattice_inf Œ≤‚ÇÅ] [semilattice_inf Œ≤‚ÇÇ]
  (u‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ) (u‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ) :
  (map u‚ÇÅ at_bot) √ó·∂† (map u‚ÇÇ at_bot) = map (prod.map u‚ÇÅ u‚ÇÇ) at_bot :=
@prod_map_at_top_eq _ _ Œ≤‚ÇÅ·µí·µà Œ≤‚ÇÇ·µí·µà _ _ _ _

lemma tendsto.subseq_mem {F : filter Œ±} {V : ‚Ñï ‚Üí set Œ±} (h : ‚àÄ n, V n ‚àà F) {u : ‚Ñï ‚Üí Œ±}
  (hu : tendsto u at_top F) : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ n, u (œÜ n) ‚àà V n :=
extraction_forall_of_eventually' (Œª n, tendsto_at_top'.mp hu _ (h n) : ‚àÄ n, ‚àÉ N, ‚àÄ k ‚â• N, u k ‚àà V n)

lemma tendsto_at_bot_diagonal [semilattice_inf Œ±] : tendsto (Œª a : Œ±, (a, a)) at_bot at_bot :=
by { rw ‚Üê prod_at_bot_at_bot_eq, exact tendsto_id.prod_mk tendsto_id }

lemma tendsto_at_top_diagonal [semilattice_sup Œ±] : tendsto (Œª a : Œ±, (a, a)) at_top at_top :=
by { rw ‚Üê prod_at_top_at_top_eq, exact tendsto_id.prod_mk tendsto_id }

lemma tendsto.prod_map_prod_at_bot [semilattice_inf Œ≥] {F : filter Œ±} {G : filter Œ≤}
  {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (hf : tendsto f F at_bot) (hg : tendsto g G at_bot) :
  tendsto (prod.map f g) (F √ó·∂† G) at_bot :=
by { rw ‚Üê prod_at_bot_at_bot_eq, exact hf.prod_map hg, }

lemma tendsto.prod_map_prod_at_top [semilattice_sup Œ≥] {F : filter Œ±} {G : filter Œ≤}
  {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (hf : tendsto f F at_top) (hg : tendsto g G at_top) :
  tendsto (prod.map f g) (F √ó·∂† G) at_top :=
by { rw ‚Üê prod_at_top_at_top_eq, exact hf.prod_map hg, }

lemma tendsto.prod_at_bot [semilattice_inf Œ±] [semilattice_inf Œ≥]
  {f g : Œ± ‚Üí Œ≥} (hf : tendsto f at_bot at_bot) (hg : tendsto g at_bot at_bot) :
  tendsto (prod.map f g) at_bot at_bot :=
by { rw ‚Üê prod_at_bot_at_bot_eq, exact hf.prod_map_prod_at_bot hg, }

lemma tendsto.prod_at_top [semilattice_sup Œ±] [semilattice_sup Œ≥]
  {f g : Œ± ‚Üí Œ≥} (hf : tendsto f at_top at_top) (hg : tendsto g at_top at_top) :
  tendsto (prod.map f g) at_top at_top :=
by { rw ‚Üê prod_at_top_at_top_eq, exact hf.prod_map_prod_at_top hg, }

lemma eventually_at_bot_prod_self [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_bot, p x) ‚Üî (‚àÉ a, ‚àÄ k l, k ‚â§ a ‚Üí l ‚â§ a ‚Üí p (k, l)) :=
by simp [‚Üê prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]

lemma eventually_at_top_prod_self [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_top, p x) ‚Üî (‚àÉ a, ‚àÄ k l, a ‚â§ k ‚Üí a ‚â§ l ‚Üí p (k, l)) :=
by simp [‚Üê prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]

lemma eventually_at_bot_prod_self' [semilattice_inf Œ±] [nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_bot, p x) ‚Üî (‚àÉ a, ‚àÄ k ‚â§ a, ‚àÄ l ‚â§ a, p (k, l)) :=
begin
  rw filter.eventually_at_bot_prod_self,
  apply exists_congr,
  tauto,
end

lemma eventually_at_top_prod_self' [semilattice_sup Œ±] [nonempty Œ±] {p : Œ± √ó Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in at_top, p x) ‚Üî (‚àÉ a, ‚àÄ k ‚â• a, ‚àÄ l ‚â• a, p (k, l)) :=
begin
  rw filter.eventually_at_top_prod_self,
  apply exists_congr,
  tauto,
end

lemma eventually_at_top_curry [semilattice_sup Œ±] [semilattice_sup Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
  (hp : ‚àÄ·∂† (x : Œ± √ó Œ≤) in filter.at_top, p x) :
  ‚àÄ·∂† k in at_top, ‚àÄ·∂† l in at_top, p (k, l) :=
begin
  rw ‚Üê prod_at_top_at_top_eq at hp,
  exact hp.curry,
end

lemma eventually_at_bot_curry [semilattice_inf Œ±] [semilattice_inf Œ≤] {p : Œ± √ó Œ≤ ‚Üí Prop}
  (hp : ‚àÄ·∂† (x : Œ± √ó Œ≤) in filter.at_bot, p x) :
  ‚àÄ·∂† k in at_bot, ‚àÄ·∂† l in at_bot, p (k, l) :=
@eventually_at_top_curry Œ±·µí·µà Œ≤·µí·µà _ _ _ hp

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
lemma map_at_top_eq_of_gc [semilattice_sup Œ±] [semilattice_sup Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤)
  (hf : monotone f) (gc : ‚àÄa, ‚àÄb‚â•b', f a ‚â§ b ‚Üî a ‚â§ g b) (hgi : ‚àÄb‚â•b', b ‚â§ f (g b)) :
  map f at_top = at_top :=
begin
  refine le_antisymm
    (hf.tendsto_at_top_at_top $ Œª b, ‚ü®g (b ‚äî b'), le_sup_left.trans $ hgi _ le_sup_right‚ü©) _,
  rw [@map_at_top_eq _ _ ‚ü®g b'‚ü©],
  refine le_infi (Œª a, infi_le_of_le (f a ‚äî b') $ principal_mono.2 $ Œª b hb, _),
  rw [mem_Ici, sup_le_iff] at hb,
  exact ‚ü®g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 le_rfl) (hgi _ hb.2)‚ü©
end

lemma map_at_bot_eq_of_gc [semilattice_inf Œ±] [semilattice_inf Œ≤] {f : Œ± ‚Üí Œ≤} (g : Œ≤ ‚Üí Œ±) (b' : Œ≤)
  (hf : monotone f) (gc : ‚àÄa, ‚àÄb‚â§b', b ‚â§ f a ‚Üî g b ‚â§ a) (hgi : ‚àÄb‚â§b', f (g b) ‚â§ b) :
  map f at_bot = at_bot :=
@map_at_top_eq_of_gc Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ hf.dual gc hgi

lemma map_coe_at_top_of_Ici_subset [semilattice_sup Œ±] {a : Œ±} {s : set Œ±} (h : Ici a ‚äÜ s) :
  map (coe : s ‚Üí Œ±) at_top = at_top :=
begin
  have : directed (‚â•) (Œª x : s, ùìü (Ici x)),
  { intros x y,
    use ‚ü®x ‚äî y ‚äî a, h le_sup_right‚ü©,
    simp only [ge_iff_le, principal_mono, Ici_subset_Ici, ‚Üê subtype.coe_le_coe, subtype.coe_mk],
    exact ‚ü®le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_left‚ü© },
  haveI : nonempty s := ‚ü®‚ü®a, h le_rfl‚ü©‚ü©,
  simp only [le_antisymm_iff, at_top, le_infi_iff, le_principal_iff, mem_map, mem_set_of_eq,
    map_infi_eq this, map_principal],
  split,
  { intro x,
    refine mem_of_superset (mem_infi_of_mem ‚ü®x ‚äî a, h le_sup_right‚ü© (mem_principal_self _)) _,
    rintro _ ‚ü®y, hy, rfl‚ü©,
    exact le_trans le_sup_left (subtype.coe_le_coe.2 hy) },
  { intro x,
    filter_upwards [mem_at_top (‚Üëx ‚äî a)] with b hb,
    exact ‚ü®‚ü®b, h $ le_sup_right.trans hb‚ü©, subtype.coe_le_coe.1 (le_sup_left.trans hb), rfl‚ü©, },
end

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp] lemma map_coe_Ici_at_top [semilattice_sup Œ±] (a : Œ±) :
  map (coe : Ici a ‚Üí Œ±) at_top = at_top :=
map_coe_at_top_of_Ici_subset (subset.refl _)

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp] lemma map_coe_Ioi_at_top [semilattice_sup Œ±] [no_max_order Œ±] (a : Œ±) :
  map (coe : Ioi a ‚Üí Œ±) at_top = at_top :=
let ‚ü®b, hb‚ü© := exists_gt a in map_coe_at_top_of_Ici_subset $ Ici_subset_Ioi.2 hb

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
lemma at_top_Ioi_eq [semilattice_sup Œ±] (a : Œ±) :
  at_top = comap (coe : Ioi a ‚Üí Œ±) at_top :=
begin
  nontriviality,
  rcases nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫ with ‚ü®b, hb‚ü©,
  rw [‚Üê map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map subtype.coe_injective]
end

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
lemma at_top_Ici_eq [semilattice_sup Œ±] (a : Œ±) :
  at_top = comap (coe : Ici a ‚Üí Œ±) at_top :=
by rw [‚Üê map_coe_Ici_at_top a, comap_map subtype.coe_injective]

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] lemma map_coe_Iio_at_bot [semilattice_inf Œ±] [no_min_order Œ±] (a : Œ±) :
  map (coe : Iio a ‚Üí Œ±) at_bot = at_bot :=
@map_coe_Ioi_at_top Œ±·µí·µà _ _ _

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
lemma at_bot_Iio_eq [semilattice_inf Œ±] (a : Œ±) : at_bot = comap (coe : Iio a ‚Üí Œ±) at_bot :=
@at_top_Ioi_eq Œ±·µí·µà _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] lemma map_coe_Iic_at_bot [semilattice_inf Œ±] (a : Œ±) :
  map (coe : Iic a ‚Üí Œ±) at_bot = at_bot :=
@map_coe_Ici_at_top Œ±·µí·µà _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
lemma at_bot_Iic_eq [semilattice_inf Œ±] (a : Œ±) :
  at_bot = comap (coe : Iic a ‚Üí Œ±) at_bot :=
@at_top_Ici_eq Œ±·µí·µà _ _

lemma tendsto_Ioi_at_top [semilattice_sup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ioi a}
  {l : filter Œ≤} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l at_top :=
by rw [at_top_Ioi_eq, tendsto_comap_iff]

lemma tendsto_Iio_at_bot [semilattice_inf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iio a}
  {l : filter Œ≤} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l at_bot :=
by rw [at_bot_Iio_eq, tendsto_comap_iff]

lemma tendsto_Ici_at_top [semilattice_sup Œ±] {a : Œ±} {f : Œ≤ ‚Üí Ici a} {l : filter Œ≤} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l at_top :=
by rw [at_top_Ici_eq, tendsto_comap_iff]

lemma tendsto_Iic_at_bot [semilattice_inf Œ±] {a : Œ±} {f : Œ≤ ‚Üí Iic a} {l : filter Œ≤} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l at_bot :=
by rw [at_bot_Iic_eq, tendsto_comap_iff]

@[simp] lemma tendsto_comp_coe_Ioi_at_top [semilattice_sup Œ±] [no_max_order Œ±] {a : Œ±}
  {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto (Œª x : Ioi a, f x) at_top l ‚Üî tendsto f at_top l :=
by rw [‚Üê map_coe_Ioi_at_top a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ici_at_top [semilattice_sup Œ±] {a : Œ±}
  {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto (Œª x : Ici a, f x) at_top l ‚Üî tendsto f at_top l :=
by rw [‚Üê map_coe_Ici_at_top a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iio_at_bot [semilattice_inf Œ±] [no_min_order Œ±] {a : Œ±}
  {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto (Œª x : Iio a, f x) at_bot l ‚Üî tendsto f at_bot l :=
by rw [‚Üê map_coe_Iio_at_bot a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iic_at_bot [semilattice_inf Œ±] {a : Œ±}
  {f : Œ± ‚Üí Œ≤} {l : filter Œ≤} :
  tendsto (Œª x : Iic a, f x) at_bot l ‚Üî tendsto f at_bot l :=
by rw [‚Üê map_coe_Iic_at_bot a, tendsto_map'_iff]

lemma map_add_at_top_eq_nat (k : ‚Ñï) : map (Œªa, a + k) at_top = at_top :=
map_at_top_eq_of_gc (Œªa, a - k) k
  (assume a b h, add_le_add_right h k)
  (assume a b h, (le_tsub_iff_right h).symm)
  (assume a h, by rw [tsub_add_cancel_of_le h])

lemma map_sub_at_top_eq_nat (k : ‚Ñï) : map (Œªa, a - k) at_top = at_top :=
map_at_top_eq_of_gc (Œªa, a + k) 0
  (assume a b h, tsub_le_tsub_right h _)
  (assume a b _, tsub_le_iff_right)
  (assume b _, by rw [add_tsub_cancel_right])

lemma tendsto_add_at_top_nat (k : ‚Ñï) : tendsto (Œªa, a + k) at_top at_top :=
le_of_eq (map_add_at_top_eq_nat k)

lemma tendsto_sub_at_top_nat (k : ‚Ñï) : tendsto (Œªa, a - k) at_top at_top :=
le_of_eq (map_sub_at_top_eq_nat k)

lemma tendsto_add_at_top_iff_nat {f : ‚Ñï ‚Üí Œ±} {l : filter Œ±} (k : ‚Ñï) :
  tendsto (Œªn, f (n + k)) at_top l ‚Üî tendsto f at_top l :=
show tendsto (f ‚àò (Œªn, n + k)) at_top l ‚Üî tendsto f at_top l,
  by rw [‚Üê tendsto_map'_iff, map_add_at_top_eq_nat]

lemma map_div_at_top_eq_nat (k : ‚Ñï) (hk : 0 < k) : map (Œªa, a / k) at_top = at_top :=
map_at_top_eq_of_gc (Œªb, b * k + (k - 1)) 1
  (assume a b h, nat.div_le_div_right h)
  (assume a b _,
    calc a / k ‚â§ b ‚Üî a / k < b + 1 : by rw [‚Üê nat.succ_eq_add_one, nat.lt_succ_iff]
      ... ‚Üî a < (b + 1) * k : nat.div_lt_iff_lt_mul _ _ hk
      ... ‚Üî _ :
      begin
        cases k,
        exact (lt_irrefl _ hk).elim,
        rw [add_mul, one_mul, nat.succ_sub_succ_eq_sub,
          tsub_zero, nat.add_succ, nat.lt_succ_iff],
      end)
  (assume b _,
    calc b = (b * k) / k : by rw [nat.mul_div_cancel b hk]
      ... ‚â§ (b * k + (k - 1)) / k : nat.div_le_div_right $ nat.le_add_right _ _)

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
lemma tendsto_at_top_at_top_of_monotone' [preorder Œπ] [linear_order Œ±]
  {u : Œπ ‚Üí Œ±} (h : monotone u) (H : ¬¨bdd_above (range u)) :
  tendsto u at_top at_top :=
begin
  apply h.tendsto_at_top_at_top,
  intro b,
  rcases not_bdd_above_iff.1 H b with ‚ü®_, ‚ü®N, rfl‚ü©, hN‚ü©,
  exact ‚ü®N, le_of_lt hN‚ü©,
end

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
lemma tendsto_at_bot_at_bot_of_monotone' [preorder Œπ] [linear_order Œ±]
  {u : Œπ ‚Üí Œ±} (h : monotone u) (H : ¬¨bdd_below (range u)) :
  tendsto u at_bot at_bot :=
@tendsto_at_top_at_top_of_monotone' Œπ·µí·µà Œ±·µí·µà _ _ _ h.dual H

lemma unbounded_of_tendsto_at_top [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] [no_max_order Œ≤]
  {f : Œ± ‚Üí Œ≤} (h : tendsto f at_top at_top) :
  ¬¨ bdd_above (range f) :=
begin
  rintros ‚ü®M, hM‚ü©,
  cases mem_at_top_sets.mp (h $ Ioi_mem_at_top M) with a ha,
  apply lt_irrefl M,
  calc
  M < f a : ha a le_rfl
  ... ‚â§ M : hM (set.mem_range_self a)
end

lemma unbounded_of_tendsto_at_bot [nonempty Œ±] [semilattice_sup Œ±] [preorder Œ≤] [no_min_order Œ≤]
  {f : Œ± ‚Üí Œ≤} (h : tendsto f at_top at_bot) :
  ¬¨ bdd_below (range f) :=
@unbounded_of_tendsto_at_top _ Œ≤·µí·µà _ _ _ _ _ h

lemma unbounded_of_tendsto_at_top' [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤] [no_max_order Œ≤]
  {f : Œ± ‚Üí Œ≤} (h : tendsto f at_bot at_top) :
  ¬¨ bdd_above (range f) :=
@unbounded_of_tendsto_at_top Œ±·µí·µà _ _ _ _ _ _ h

lemma unbounded_of_tendsto_at_bot' [nonempty Œ±] [semilattice_inf Œ±] [preorder Œ≤] [no_min_order Œ≤]
  {f : Œ± ‚Üí Œ≤} (h : tendsto f at_bot at_bot) :
  ¬¨ bdd_below (range f) :=
@unbounded_of_tendsto_at_top Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ h

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
lemma tendsto_at_top_of_monotone_of_filter [preorder Œπ] [preorder Œ±] {l : filter Œπ}
  {u : Œπ ‚Üí Œ±} (h : monotone u) [ne_bot l] (hu : tendsto u l at_top) :
  tendsto u at_top at_top :=
h.tendsto_at_top_at_top $ Œª b, (hu.eventually (mem_at_top b)).exists

/-- If a monotone function `u : Œπ ‚Üí Œ±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
lemma tendsto_at_bot_of_monotone_of_filter [preorder Œπ] [preorder Œ±] {l : filter Œπ}
  {u : Œπ ‚Üí Œ±} (h : monotone u) [ne_bot l] (hu : tendsto u l at_bot) :
  tendsto u at_bot at_bot :=
@tendsto_at_top_of_monotone_of_filter Œπ·µí·µà Œ±·µí·µà _ _ _ _ h.dual _ hu

lemma tendsto_at_top_of_monotone_of_subseq [preorder Œπ] [preorder Œ±] {u : Œπ ‚Üí Œ±}
  {œÜ : Œπ' ‚Üí Œπ} (h : monotone u) {l : filter Œπ'} [ne_bot l]
  (H : tendsto (u ‚àò œÜ) l at_top) :
  tendsto u at_top at_top :=
tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

lemma tendsto_at_bot_of_monotone_of_subseq [preorder Œπ] [preorder Œ±] {u : Œπ ‚Üí Œ±}
  {œÜ : Œπ' ‚Üí Œπ} (h : monotone u) {l : filter Œπ'} [ne_bot l]
  (H : tendsto (u ‚àò œÜ) l at_bot) :
  tendsto u at_bot at_bot :=
tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Œª s, ‚àè b in s, f b)` with
`at_top.map (Œª s, ‚àè b in s, g b)`. This is useful to compare the set of limit points of
`Œ† b in s, f b` as `s ‚Üí at_top` with the similar set for `g`. -/
@[to_additive "Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives
a sufficient condition for comparison of the filter `at_top.map (Œª s, ‚àë b in s, f b)` with
`at_top.map (Œª s, ‚àë b in s, g b)`. This is useful to compare the set of limit points of
`‚àë b in s, f b` as `s ‚Üí at_top` with the similar set for `g`."]
lemma map_at_top_finset_prod_le_of_prod_eq [comm_monoid Œ±] {f : Œ≤ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ±}
  (h_eq : ‚àÄu:finset Œ≥, ‚àÉv:finset Œ≤, ‚àÄv', v ‚äÜ v' ‚Üí ‚àÉu', u ‚äÜ u' ‚àß ‚àè x in u', g x = ‚àè b in v', f b) :
  at_top.map (Œªs:finset Œ≤, ‚àè b in s, f b) ‚â§ at_top.map (Œªs:finset Œ≥, ‚àè x in s, g x) :=
by rw [map_at_top_eq, map_at_top_eq];
from (le_infi $ assume b, let ‚ü®v, hv‚ü© := h_eq b in infi_le_of_le v $
  by simp [set.image_subset_iff]; exact hv)

lemma has_antitone_basis.eventually_subset [preorder Œπ] {l : filter Œ±}
  {s : Œπ ‚Üí set Œ±} (hl : l.has_antitone_basis s) {t : set Œ±} (ht : t ‚àà l) :
  ‚àÄ·∂† i in at_top, s i ‚äÜ t :=
let ‚ü®i, _, hi‚ü© := hl.to_has_basis.mem_iff.1 ht
in (eventually_ge_at_top i).mono $ Œª j hj, (hl.antitone hj).trans hi

protected lemma has_antitone_basis.tendsto [preorder Œπ] {l : filter Œ±}
  {s : Œπ ‚Üí set Œ±} (hl : l.has_antitone_basis s) {œÜ : Œπ ‚Üí Œ±}
  (h : ‚àÄ i : Œπ, œÜ i ‚àà s i) : tendsto œÜ at_top l  :=
Œª t ht, mem_map.2 $ (hl.eventually_subset ht).mono $ Œª i hi, hi (h i)

lemma has_antitone_basis.comp_mono [semilattice_sup Œπ] [nonempty Œπ] [preorder Œπ'] {l : filter Œ±}
  {s : Œπ' ‚Üí set Œ±} (hs : l.has_antitone_basis s)
  {œÜ : Œπ ‚Üí Œπ'} (œÜ_mono : monotone œÜ) (hœÜ : tendsto œÜ at_top at_top) :
  l.has_antitone_basis (s ‚àò œÜ) :=
‚ü®hs.to_has_basis.to_has_basis
  (Œª n hn, (hœÜ.eventually (eventually_ge_at_top n)).exists.imp $ Œª m hm, ‚ü®trivial, hs.antitone hm‚ü©)
  (Œª n hn, ‚ü®œÜ n, trivial, subset.rfl‚ü©), hs.antitone.comp_monotone œÜ_mono‚ü©

lemma has_antitone_basis.comp_strict_mono {l : filter Œ±} {s : ‚Ñï ‚Üí set Œ±}
  (hs : l.has_antitone_basis s) {œÜ : ‚Ñï ‚Üí ‚Ñï} (hœÜ : strict_mono œÜ) :
  l.has_antitone_basis (s ‚àò œÜ) :=
hs.comp_mono hœÜ.monotone hœÜ.tendsto_at_top

/-- Given an antitone basis `s : ‚Ñï ‚Üí set Œ±` of a filter, extract an antitone subbasis `s ‚àò œÜ`,
`œÜ : ‚Ñï ‚Üí ‚Ñï`, such that `m < n` implies `r (œÜ m) (œÜ n)`. This lemma can be used to extract an
antitone basis with basis sets decreasing "sufficiently fast". -/
lemma has_antitone_basis.subbasis_with_rel {f : filter Œ±} {s : ‚Ñï ‚Üí set Œ±}
  (hs : f.has_antitone_basis s) {r : ‚Ñï ‚Üí ‚Ñï ‚Üí Prop} (hr : ‚àÄ m, ‚àÄ·∂† n in at_top, r m n) :
  ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí r (œÜ m) (œÜ n)) ‚àß f.has_antitone_basis (s ‚àò œÜ) :=
begin
  suffices : ‚àÉ œÜ : ‚Ñï ‚Üí ‚Ñï, strict_mono œÜ ‚àß ‚àÄ m n, m < n ‚Üí r (œÜ m) (œÜ n),
  { rcases this with ‚ü®œÜ, hœÜ, hrœÜ‚ü©,
    exact ‚ü®œÜ, hœÜ, hrœÜ, hs.comp_strict_mono hœÜ‚ü© },
  have : ‚àÄ t : set ‚Ñï, t.finite ‚Üí ‚àÄ·∂† n in at_top, ‚àÄ m ‚àà t, m < n ‚àß r m n,
    from Œª t ht, (eventually_all_finite ht).2 (Œª m hm, (eventually_gt_at_top m).and (hr _)),
  rcases seq_of_forall_finite_exists (Œª t ht, (this t ht).exists) with ‚ü®œÜ, hœÜ‚ü©,
  simp only [ball_image_iff, forall_and_distrib, mem_Iio] at hœÜ,
  exact ‚ü®œÜ, forall_swap.2 hœÜ.1, forall_swap.2 hœÜ.2‚ü©
end

/-- If `f` is a nontrivial countably generated filter, then there exists a sequence that converges
to `f`. -/
lemma exists_seq_tendsto (f : filter Œ±) [is_countably_generated f] [ne_bot f] :
  ‚àÉ x : ‚Ñï ‚Üí Œ±, tendsto x at_top f :=
begin
  obtain ‚ü®B, h‚ü© := f.exists_antitone_basis,
  choose x hx using Œª n, filter.nonempty_of_mem (h.mem n),
  exact ‚ü®x, h.tendsto hx‚ü©
end

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f ‚àò u` tends to `l`. -/
lemma tendsto_iff_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : filter Œ±} {l : filter Œ≤} [k.is_countably_generated] :
  tendsto f k l ‚Üî (‚àÄ x : ‚Ñï ‚Üí Œ±, tendsto x at_top k ‚Üí tendsto (f ‚àò x) at_top l) :=
begin
  refine ‚ü®Œª h x hx, h.comp hx, Œª H s hs, _‚ü©,
  contrapose! H,
  haveI : ne_bot (k ‚äì ùìü (f ‚Åª¬π' s·∂ú)), by simpa [ne_bot_iff,  inf_principal_eq_bot],
  rcases (k ‚äì ùìü (f ‚Åª¬π' s·∂ú)).exists_seq_tendsto with ‚ü®x, hx‚ü©,
  rw [tendsto_inf, tendsto_principal] at hx,
  refine ‚ü®x, hx.1, Œª h, _‚ü©,
  rcases (hx.2.and (h hs)).exists with ‚ü®N, hnmem, hmem‚ü©,
  exact hnmem hmem
end

lemma tendsto_of_seq_tendsto {f : Œ± ‚Üí Œ≤} {k : filter Œ±} {l : filter Œ≤} [k.is_countably_generated] :
  (‚àÄ x : ‚Ñï ‚Üí Œ±, tendsto x at_top k ‚Üí tendsto (f ‚àò x) at_top l) ‚Üí tendsto f k l :=
tendsto_iff_seq_tendsto.2

lemma tendsto_iff_forall_eventually_mem {Œ± Œπ : Type*} {x : Œπ ‚Üí Œ±} {f : filter Œ±} {l : filter Œπ} :
  tendsto x l f ‚Üî ‚àÄ s ‚àà f, ‚àÄ·∂† n in l, x n ‚àà s :=
by { rw tendsto_def, refine forall_congr (Œª s, imp_congr_right (Œª hsf, _)), refl, }

lemma not_tendsto_iff_exists_frequently_nmem {Œ± Œπ : Type*} {x : Œπ ‚Üí Œ±} {f : filter Œ±}
  {l : filter Œπ} :
  ¬¨ tendsto x l f ‚Üî ‚àÉ s ‚àà f, ‚àÉ·∂† n in l, x n ‚àâ s :=
begin
  rw tendsto_iff_forall_eventually_mem,
  push_neg,
  refine exists_congr (Œª s, _),
  rw [not_eventually, exists_prop],
end

lemma frequently_iff_seq_frequently {Œπ : Type*} {l : filter Œπ} {p : Œπ ‚Üí Prop}
  [hl : l.is_countably_generated] :
  (‚àÉ·∂† n in l, p n) ‚Üî ‚àÉ (x : ‚Ñï ‚Üí Œπ), tendsto x at_top l ‚àß ‚àÉ·∂† (n : ‚Ñï) in at_top, p (x n) :=
begin
  refine ‚ü®Œª h_freq, _, Œª h_exists_freq, _‚ü©,
  { haveI : ne_bot (l ‚äì ùìü {x : Œπ | p x}), by simpa [ne_bot_iff, inf_principal_eq_bot],
    obtain ‚ü®x, hx‚ü© := exists_seq_tendsto (l ‚äì (ùìü {x : Œπ | p x})),
    rw tendsto_inf at hx,
    cases hx with hx_l hx_p,
    refine ‚ü®x, hx_l, _‚ü©,
    rw tendsto_principal at hx_p,
    exact hx_p.frequently, },
  { obtain ‚ü®x, hx_tendsto, hx_freq‚ü© := h_exists_freq,
    simp_rw [filter.frequently, filter.eventually] at hx_freq ‚ä¢,
    have : {n : ‚Ñï | ¬¨p (x n)} = {n | x n ‚àà {y | ¬¨ p y}} := rfl,
    rw [this, ‚Üê mem_map'] at hx_freq,
    contrapose! hx_freq,
    exact hx_tendsto hx_freq, },
end

lemma eventually_iff_seq_eventually {Œπ : Type*} {l : filter Œπ} {p : Œπ ‚Üí Prop}
  [hl : l.is_countably_generated] :
  (‚àÄ·∂† n in l, p n) ‚Üî ‚àÄ (x : ‚Ñï ‚Üí Œπ), tendsto x at_top l ‚Üí ‚àÄ·∂† (n : ‚Ñï) in at_top, p (x n) :=
begin
  have : (‚àÄ·∂† n in l, p n) ‚Üî ¬¨ ‚àÉ·∂† n in l, ¬¨(p n),
  { rw not_frequently, simp_rw not_not, },
  rw [this, frequently_iff_seq_frequently],
  push_neg,
  simp_rw [not_frequently, not_not],
end

lemma subseq_forall_of_frequently {Œπ : Type*} {x : ‚Ñï ‚Üí Œπ} {p : Œπ ‚Üí Prop} {l : filter Œπ}
  (h_tendsto : tendsto x at_top l) (h : ‚àÉ·∂† n in at_top, p (x n)) :
  ‚àÉ ns : ‚Ñï ‚Üí ‚Ñï, tendsto (Œª n, x (ns n)) at_top l ‚àß ‚àÄ n, p (x (ns n)) :=
begin
  rw tendsto_iff_seq_tendsto at h_tendsto,
  choose ns hge hns using frequently_at_top.1 h,
  exact ‚ü®ns, h_tendsto ns (tendsto_at_top_mono hge tendsto_id), hns‚ü©,
end

lemma exists_seq_forall_of_frequently {Œπ : Type*} {l : filter Œπ} {p : Œπ ‚Üí Prop}
  [hl : l.is_countably_generated] (h : ‚àÉ·∂† n in l, p n) :
  ‚àÉ ns : ‚Ñï ‚Üí Œπ, tendsto ns at_top l ‚àß ‚àÄ n, p (ns n) :=
begin
  rw frequently_iff_seq_frequently at h,
  obtain ‚ü®x, hx_tendsto, hx_freq‚ü© := h,
  obtain ‚ü®n_to_n, h_tendsto, h_freq‚ü© := subseq_forall_of_frequently hx_tendsto hx_freq,
  exact ‚ü®x ‚àò n_to_n, h_tendsto, h_freq‚ü©,
end

/-- A sequence converges if every subsequence has a convergent subsequence. -/
lemma tendsto_of_subseq_tendsto {Œ± Œπ : Type*}
  {x : Œπ ‚Üí Œ±} {f : filter Œ±} {l : filter Œπ} [l.is_countably_generated]
  (hxy : ‚àÄ ns : ‚Ñï ‚Üí Œπ, tendsto ns at_top l ‚Üí
    ‚àÉ ms : ‚Ñï ‚Üí ‚Ñï, tendsto (Œª n, x (ns $ ms n)) at_top f) :
  tendsto x l f :=
begin
  by_contra h,
  obtain ‚ü®s, hs, hfreq‚ü© : ‚àÉ s ‚àà f, ‚àÉ·∂† n in l, x n ‚àâ s,
    by rwa not_tendsto_iff_exists_frequently_nmem at h,
  obtain ‚ü®y, hy_tendsto, hy_freq‚ü© := exists_seq_forall_of_frequently hfreq,
  specialize hxy y hy_tendsto,
  obtain ‚ü®ms, hms_tendsto‚ü© := hxy,
  specialize hms_tendsto hs,
  rw mem_map at hms_tendsto,
  have hms_freq : ‚àÄ (n : ‚Ñï), x (y (ms n)) ‚àâ s, from Œª n, hy_freq (ms n),
  have h_empty : (Œª (n : ‚Ñï), x (y (ms n))) ‚Åª¬π' s = ‚àÖ,
  { ext1 n,
    simp only [set.mem_preimage, set.mem_empty_eq, iff_false],
    exact hms_freq n, },
  rw h_empty at hms_tendsto,
  exact empty_not_mem at_top hms_tendsto,
end

lemma subseq_tendsto_of_ne_bot {f : filter Œ±} [is_countably_generated f] {u : ‚Ñï ‚Üí Œ±}
  (hx : ne_bot (f ‚äì map u at_top)) :
  ‚àÉ (Œ∏ : ‚Ñï ‚Üí ‚Ñï), (strict_mono Œ∏) ‚àß (tendsto (u ‚àò Œ∏) at_top f) :=
begin
  obtain ‚ü®B, h‚ü© := f.exists_antitone_basis,
  have : ‚àÄ N, ‚àÉ n ‚â• N, u n ‚àà B N,
    from Œª N, filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N,
  choose œÜ hœÜ using this,
  cases forall_and_distrib.mp hœÜ with œÜ_ge œÜ_in,
  have lim_uœÜ : tendsto (u ‚àò œÜ) at_top f,
    from h.tendsto œÜ_in,
  have lim_œÜ : tendsto œÜ at_top at_top,
    from (tendsto_at_top_mono œÜ_ge tendsto_id),
  obtain ‚ü®œà, hœà, hœàœÜ‚ü© : ‚àÉ œà : ‚Ñï ‚Üí ‚Ñï, strict_mono œà ‚àß strict_mono (œÜ ‚àò œà),
    from strict_mono_subseq_of_tendsto_at_top lim_œÜ,
  exact ‚ü®œÜ ‚àò œà, hœàœÜ, lim_uœÜ.comp hœà.tendsto_at_top‚ü©,
end

end filter

open filter finset

section

variables {R : Type*} [linear_ordered_semiring R]

lemma exists_lt_mul_self (a : R) : ‚àÉ x ‚â• 0, a < x * x :=
let ‚ü®x, hxa, hx0‚ü© :=((tendsto_mul_self_at_top.eventually (eventually_gt_at_top a)).and
  (eventually_ge_at_top 0)).exists
in ‚ü®x, hx0, hxa‚ü©

lemma exists_le_mul_self (a : R) : ‚àÉ x ‚â• 0, a ‚â§ x * x :=
let ‚ü®x, hx0, hxa‚ü© := exists_lt_mul_self a in ‚ü®x, hx0, hxa.le‚ü©

end

namespace order_iso

variables [preorder Œ±] [preorder Œ≤]

@[simp] lemma comap_at_top (e : Œ± ‚âÉo Œ≤) : comap e at_top = at_top :=
by simp [at_top, ‚Üê e.surjective.infi_comp]

@[simp] lemma comap_at_bot (e : Œ± ‚âÉo Œ≤) : comap e at_bot = at_bot :=
e.dual.comap_at_top

@[simp] lemma map_at_top (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) at_top = at_top :=
by rw [‚Üê e.comap_at_top, map_comap_of_surjective e.surjective]

@[simp] lemma map_at_bot (e : Œ± ‚âÉo Œ≤) : map (e : Œ± ‚Üí Œ≤) at_bot = at_bot :=
e.dual.map_at_top

lemma tendsto_at_top (e : Œ± ‚âÉo Œ≤) : tendsto e at_top at_top :=
e.map_at_top.le

lemma tendsto_at_bot (e : Œ± ‚âÉo Œ≤) : tendsto e at_bot at_bot :=
e.map_at_bot.le

@[simp] lemma tendsto_at_top_iff {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
  tendsto (Œª x, e (f x)) l at_top ‚Üî tendsto f l at_top :=
by rw [‚Üê e.comap_at_top, tendsto_comap_iff]

@[simp] lemma tendsto_at_bot_iff {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} (e : Œ± ‚âÉo Œ≤) :
  tendsto (Œª x, e (f x)) l at_bot ‚Üî tendsto f l at_bot :=
e.dual.tendsto_at_top_iff

end order_iso

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Œª s, ‚àè i in s, f (g i))` and `at_top.map (Œª s, ‚àè i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
@[to_additive]
lemma function.injective.map_at_top_finset_prod_eq [comm_monoid Œ±] {g : Œ≥ ‚Üí Œ≤}
  (hg : function.injective g) {f : Œ≤ ‚Üí Œ±} (hf : ‚àÄ x ‚àâ set.range g, f x = 1) :
  map (Œª s, ‚àè i in s, f (g i)) at_top = map (Œª s, ‚àè i in s, f i) at_top :=
begin
  apply le_antisymm; refine map_at_top_finset_prod_le_of_prod_eq (Œª s, _),
  { refine ‚ü®s.preimage g (hg.inj_on _), Œª t ht, _‚ü©,
    refine ‚ü®t.image g ‚à™ s, finset.subset_union_right _ _, _‚ü©,
    rw [‚Üê finset.prod_image (hg.inj_on _)],
    refine (prod_subset (subset_union_left _ _) _).symm,
    simp only [finset.mem_union, finset.mem_image],
    refine Œª y hy hyt, hf y (mt _ hyt),
    rintros ‚ü®x, rfl‚ü©,
    exact ‚ü®x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rfl‚ü© },
  { refine ‚ü®s.image g, Œª t ht, _‚ü©,
    simp only [‚Üê prod_preimage _ _ (hg.inj_on _) _ (Œª x _, hf x)],
    exact ‚ü®_, (image_subset_iff_subset_preimage _).1 ht, rfl‚ü© }
end

/-- Let `g : Œ≥ ‚Üí Œ≤` be an injective function and `f : Œ≤ ‚Üí Œ±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Œª s, ‚àë i in s, f (g i))` and `at_top.map (Œª s, ‚àë i in s, f i)` coincide.

This lemma is used to prove the equality `‚àë' x, f (g x) = ‚àë' y, f y` under
the same assumptions.-/
add_decl_doc function.injective.map_at_top_finset_sum_eq
