/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Jeremy Avigad, Yury Kudryashov, Patrick Massot
-/
import order.filter.bases
import data.finset.preimage

/-!
# `at_top` and `at_bot` filters on preorded sets, monoids and groups.

In this file we define the filters

* `at_top`: corresponds to `n â†’ +âˆ`;
* `at_bot`: corresponds to `n â†’ -âˆ`.

Then we prove many lemmas like â€œif `f â†’ +âˆ`, then `f Â± c â†’ +âˆ`â€.
-/

variables {Î¹ Î¹' Î± Î² Î³ : Type*}

open set
open_locale classical filter big_operators

namespace filter
/-- `at_top` is the filter representing the limit `â†’ âˆ` on an ordered set.
  It is generated by the collection of up-sets `{b | a â‰¤ b}`.
  (The preorder need not have a top element for this to be well defined,
  and indeed is trivial when a top element exists.) -/
def at_top [preorder Î±] : filter Î± := â¨… a, ğ“Ÿ (Ici a)

/-- `at_bot` is the filter representing the limit `â†’ -âˆ` on an ordered set.
  It is generated by the collection of down-sets `{b | b â‰¤ a}`.
  (The preorder need not have a bottom element for this to be well defined,
  and indeed is trivial when a bottom element exists.) -/
def at_bot [preorder Î±] : filter Î± := â¨… a, ğ“Ÿ (Iic a)

lemma mem_at_top [preorder Î±] (a : Î±) : {b : Î± | a â‰¤ b} âˆˆ @at_top Î± _ :=
mem_infi_of_mem a $ subset.refl _

lemma Ioi_mem_at_top [preorder Î±] [no_top_order Î±] (x : Î±) : Ioi x âˆˆ (at_top : filter Î±) :=
let âŸ¨z, hzâŸ© := no_top x in mem_of_superset (mem_at_top z) $ Î» y h,  lt_of_lt_of_le hz h

lemma mem_at_bot [preorder Î±] (a : Î±) : {b : Î± | b â‰¤ a} âˆˆ @at_bot Î± _ :=
mem_infi_of_mem a $ subset.refl _

lemma Iio_mem_at_bot [preorder Î±] [no_bot_order Î±] (x : Î±) : Iio x âˆˆ (at_bot : filter Î±) :=
let âŸ¨z, hzâŸ© := no_bot x in mem_of_superset (mem_at_bot z) $ Î» y h, lt_of_le_of_lt h hz

lemma at_top_basis [nonempty Î±] [semilattice_sup Î±] :
  (@at_top Î± _).has_basis (Î» _, true) Ici :=
has_basis_infi_principal (directed_of_sup $ Î» a b, Ici_subset_Ici.2)

lemma at_top_basis' [semilattice_sup Î±] (a : Î±) :
  (@at_top Î± _).has_basis (Î» x, a â‰¤ x) Ici :=
âŸ¨Î» t, (@at_top_basis Î± âŸ¨aâŸ© _).mem_iff.trans
  âŸ¨Î» âŸ¨x, _, hxâŸ©, âŸ¨x âŠ” a, le_sup_right, Î» y hy, hx (le_trans le_sup_left hy)âŸ©,
    Î» âŸ¨x, _, hxâŸ©, âŸ¨x, trivial, hxâŸ©âŸ©âŸ©

lemma at_bot_basis [nonempty Î±] [semilattice_inf Î±] :
  (@at_bot Î± _).has_basis (Î» _, true) Iic :=
@at_top_basis (order_dual Î±) _ _

lemma at_bot_basis' [semilattice_inf Î±] (a : Î±) :
  (@at_bot Î± _).has_basis (Î» x, x â‰¤ a) Iic :=
@at_top_basis' (order_dual Î±) _ _

@[instance]
lemma at_top_ne_bot [nonempty Î±] [semilattice_sup Î±] : ne_bot (at_top : filter Î±) :=
at_top_basis.ne_bot_iff.2 $ Î» a _, nonempty_Ici

@[instance]
lemma at_bot_ne_bot [nonempty Î±] [semilattice_inf Î±] : ne_bot (at_bot : filter Î±) :=
@at_top_ne_bot (order_dual Î±) _ _

@[simp]
lemma mem_at_top_sets [nonempty Î±] [semilattice_sup Î±] {s : set Î±} :
  s âˆˆ (at_top : filter Î±) â†” âˆƒa:Î±, âˆ€bâ‰¥a, b âˆˆ s :=
at_top_basis.mem_iff.trans $ exists_congr $ Î» _, exists_const _

@[simp]
lemma mem_at_bot_sets [nonempty Î±] [semilattice_inf Î±] {s : set Î±} :
  s âˆˆ (at_bot : filter Î±) â†” âˆƒa:Î±, âˆ€bâ‰¤a, b âˆˆ s :=
@mem_at_top_sets (order_dual Î±) _ _ _

@[simp]
lemma eventually_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆ€á¶  x in at_top, p x) â†” (âˆƒ a, âˆ€ b â‰¥ a, p b) :=
mem_at_top_sets

@[simp]
lemma eventually_at_bot [semilattice_inf Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆ€á¶  x in at_bot, p x) â†” (âˆƒ a, âˆ€ b â‰¤ a, p b) :=
mem_at_bot_sets

lemma eventually_ge_at_top [preorder Î±] (a : Î±) : âˆ€á¶  x in at_top, a â‰¤ x := mem_at_top a

lemma eventually_le_at_bot [preorder Î±] (a : Î±) : âˆ€á¶  x in at_bot, x â‰¤ a := mem_at_bot a

lemma eventually_gt_at_top [preorder Î±] [no_top_order Î±] (a : Î±) :
  âˆ€á¶  x in at_top, a < x :=
Ioi_mem_at_top a

lemma eventually_lt_at_bot [preorder Î±] [no_bot_order Î±] (a : Î±) :
  âˆ€á¶  x in at_bot, x < a :=
Iio_mem_at_bot a

lemma at_top_basis_Ioi [nonempty Î±] [semilattice_sup Î±] [no_top_order Î±] :
  (@at_top Î± _).has_basis (Î» _, true) Ioi :=
at_top_basis.to_has_basis (Î» a ha, âŸ¨a, ha, Ioi_subset_Ici_selfâŸ©) $
  Î» a ha, (no_top a).imp $ Î» b hb, âŸ¨ha, Ici_subset_Ioi.2 hbâŸ©

lemma at_top_countable_basis [nonempty Î±] [semilattice_sup Î±] [encodable Î±] :
  has_countable_basis (at_top : filter Î±) (Î» _, true) Ici :=
{ countable := countable_encodable _,
  .. at_top_basis }

lemma at_bot_countable_basis [nonempty Î±] [semilattice_inf Î±] [encodable Î±] :
  has_countable_basis (at_bot : filter Î±) (Î» _, true) Iic :=
{ countable := countable_encodable _,
  .. at_bot_basis }

lemma is_countably_generated_at_top [nonempty Î±] [semilattice_sup Î±] [encodable Î±] :
  (at_top : filter $ Î±).is_countably_generated :=
at_top_countable_basis.is_countably_generated

lemma is_countably_generated_at_bot [nonempty Î±] [semilattice_inf Î±] [encodable Î±] :
  (at_bot : filter $ Î±).is_countably_generated :=
at_bot_countable_basis.is_countably_generated

lemma order_top.at_top_eq (Î±) [order_top Î±] : (at_top : filter Î±) = pure âŠ¤ :=
le_antisymm (le_pure_iff.2 $ (eventually_ge_at_top âŠ¤).mono $ Î» b, top_unique)
  (le_infi $ Î» b, le_principal_iff.2 le_top)

lemma order_bot.at_bot_eq (Î±) [order_bot Î±] : (at_bot : filter Î±) = pure âŠ¥ :=
@order_top.at_top_eq (order_dual Î±) _

@[nontriviality]
lemma subsingleton.at_top_eq (Î±) [subsingleton Î±] [preorder Î±] : (at_top : filter Î±) = âŠ¤ :=
begin
  refine top_unique (Î» s hs x, _),
  letI : unique Î± := âŸ¨âŸ¨xâŸ©, Î» y, subsingleton.elim y xâŸ©,
  rw [at_top, infi_unique, unique.default_eq x, mem_principal] at hs,
  exact hs left_mem_Ici
end

@[nontriviality]
lemma subsingleton.at_bot_eq (Î±) [subsingleton Î±] [preorder Î±] : (at_bot : filter Î±) = âŠ¤ :=
@subsingleton.at_top_eq (order_dual Î±) _ _

lemma tendsto_at_top_pure [order_top Î±] (f : Î± â†’ Î²) :
  tendsto f at_top (pure $ f âŠ¤) :=
(order_top.at_top_eq Î±).symm â–¸ tendsto_pure_pure _ _

lemma tendsto_at_bot_pure [order_bot Î±] (f : Î± â†’ Î²) :
  tendsto f at_bot (pure $ f âŠ¥) :=
@tendsto_at_top_pure (order_dual Î±) _ _ _

lemma eventually.exists_forall_of_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆ€á¶  x in at_top, p x) : âˆƒ a, âˆ€ b â‰¥ a, p b :=
eventually_at_top.mp h

lemma eventually.exists_forall_of_at_bot [semilattice_inf Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆ€á¶  x in at_bot, p x) : âˆƒ a, âˆ€ b â‰¤ a, p b :=
eventually_at_bot.mp h

lemma frequently_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_top, p x) â†” (âˆ€ a, âˆƒ b â‰¥ a, p b) :=
by simp [at_top_basis.frequently_iff]

lemma frequently_at_bot [semilattice_inf Î±] [nonempty Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_bot, p x) â†” (âˆ€ a, âˆƒ b â‰¤ a, p b) :=
@frequently_at_top (order_dual Î±) _ _ _

lemma frequently_at_top' [semilattice_sup Î±] [nonempty Î±] [no_top_order Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_top, p x) â†” (âˆ€ a, âˆƒ b > a, p b) :=
by simp [at_top_basis_Ioi.frequently_iff]

lemma frequently_at_bot' [semilattice_inf Î±] [nonempty Î±] [no_bot_order Î±] {p : Î± â†’ Prop} :
  (âˆƒá¶  x in at_bot, p x) â†” (âˆ€ a, âˆƒ b < a, p b) :=
@frequently_at_top' (order_dual Î±) _ _ _ _

lemma frequently.forall_exists_of_at_top [semilattice_sup Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆƒá¶  x in at_top, p x) : âˆ€ a, âˆƒ b â‰¥ a, p b :=
frequently_at_top.mp h

lemma frequently.forall_exists_of_at_bot [semilattice_inf Î±] [nonempty Î±] {p : Î± â†’ Prop}
  (h : âˆƒá¶  x in at_bot, p x) : âˆ€ a, âˆƒ b â‰¤ a, p b :=
frequently_at_bot.mp h

lemma map_at_top_eq [nonempty Î±] [semilattice_sup Î±] {f : Î± â†’ Î²} :
  at_top.map f = (â¨…a, ğ“Ÿ $ f '' {a' | a â‰¤ a'}) :=
(at_top_basis.map _).eq_infi

lemma map_at_bot_eq [nonempty Î±] [semilattice_inf Î±] {f : Î± â†’ Î²} :
  at_bot.map f = (â¨…a, ğ“Ÿ $ f '' {a' | a' â‰¤ a}) :=
@map_at_top_eq (order_dual Î±) _ _ _ _

lemma tendsto_at_top [preorder Î²] {m : Î± â†’ Î²} {f : filter Î±} :
  tendsto m f at_top â†” (âˆ€b, âˆ€á¶  a in f, b â‰¤ m a) :=
by simp only [at_top, tendsto_infi, tendsto_principal, mem_Ici]

lemma tendsto_at_bot [preorder Î²] {m : Î± â†’ Î²} {f : filter Î±} :
  tendsto m f at_bot â†” (âˆ€b, âˆ€á¶  a in f, m a â‰¤ b) :=
@tendsto_at_top Î± (order_dual Î²) _ m f

lemma tendsto_at_top_mono' [preorder Î²] (l : filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
  tendsto fâ‚ l at_top â†’ tendsto fâ‚‚ l at_top :=
assume hâ‚, tendsto_at_top.2 $ Î» b, mp_mem (tendsto_at_top.1 hâ‚ b)
  (monotone_mem (Î» a ha haâ‚, le_trans haâ‚ ha) h)

lemma tendsto_at_bot_mono' [preorder Î²] (l : filter Î±) â¦ƒfâ‚ fâ‚‚ : Î± â†’ Î²â¦„ (h : fâ‚ â‰¤á¶ [l] fâ‚‚) :
  tendsto fâ‚‚ l at_bot â†’ tendsto fâ‚ l at_bot :=
@tendsto_at_top_mono' _ (order_dual Î²) _ _ _ _ h

lemma tendsto_at_top_mono [preorder Î²] {l : filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
  tendsto f l at_top â†’ tendsto g l at_top :=
tendsto_at_top_mono' l $ eventually_of_forall h

lemma tendsto_at_bot_mono [preorder Î²] {l : filter Î±} {f g : Î± â†’ Î²} (h : âˆ€ n, f n â‰¤ g n) :
  tendsto g l at_bot â†’ tendsto f l at_bot :=
@tendsto_at_top_mono _ (order_dual Î²) _ _ _ _ h

/-!
### Sequences
-/

lemma inf_map_at_top_ne_bot_iff [semilattice_sup Î±] [nonempty Î±] {F : filter Î²} {u : Î± â†’ Î²} :
  ne_bot (F âŠ“ (map u at_top)) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ U :=
by simp_rw [inf_ne_bot_iff_frequently_left, frequently_map, frequently_at_top]; refl

lemma inf_map_at_bot_ne_bot_iff [semilattice_inf Î±] [nonempty Î±] {F : filter Î²} {u : Î± â†’ Î²} :
  ne_bot (F âŠ“ (map u at_bot)) â†” âˆ€ U âˆˆ F, âˆ€ N, âˆƒ n â‰¤ N, u n âˆˆ U :=
@inf_map_at_top_ne_bot_iff (order_dual Î±) _ _ _ _ _

lemma extraction_of_frequently_at_top' {P : â„• â†’ Prop} (h : âˆ€ N, âˆƒ n > N, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
begin
  choose u hu using h,
  cases forall_and_distrib.mp hu with hu hu',
  exact âŸ¨u âˆ˜ (nat.rec 0 (Î» n v, u v)), strict_mono_nat_of_lt_succ (Î» n, hu _), Î» n, hu' _âŸ©,
end

lemma extraction_of_frequently_at_top {P : â„• â†’ Prop} (h : âˆƒá¶  n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
begin
  rw frequently_at_top' at h,
  exact extraction_of_frequently_at_top' h,
end

lemma extraction_of_eventually_at_top {P : â„• â†’ Prop} (h : âˆ€á¶  n in at_top, P n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P (Ï† n) :=
extraction_of_frequently_at_top h.frequently

lemma extraction_forall_of_frequently {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒá¶  k in at_top, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
begin
  simp only [frequently_at_top'] at h,
  choose u hu hu' using h,
  use (Î» n, nat.rec_on n (u 0 0) (Î» n v, u (n+1) v) : â„• â†’ â„•),
  split,
  { apply strict_mono_nat_of_lt_succ,
    intro n,
    apply hu },
  { intros n,
    cases n ; simp [hu'] },
end

lemma extraction_forall_of_eventually  {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆ€á¶  k in at_top, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
extraction_forall_of_frequently (Î» n, (h n).frequently)

lemma extraction_forall_of_eventually' {P : â„• â†’ â„• â†’ Prop} (h : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, P n k) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, P n (Ï† n) :=
extraction_forall_of_eventually (by simp [eventually_at_top, h])

lemma exists_le_of_tendsto_at_top [semilattice_sup Î±] [preorder Î²] {u : Î± â†’ Î²}
  (h : tendsto u at_top at_top) (a : Î±) (b : Î²) : âˆƒ a' â‰¥ a, b â‰¤ u a' :=
begin
  have : âˆ€á¶  x in at_top, a â‰¤ x âˆ§ b â‰¤ u x :=
    (eventually_ge_at_top a).and (h.eventually $ eventually_ge_at_top b),
  haveI : nonempty Î± := âŸ¨aâŸ©,
  rcases this.exists with âŸ¨a', ha, hbâŸ©,
  exact âŸ¨a', ha, hbâŸ©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_le_of_tendsto_at_bot [semilattice_sup Î±] [preorder Î²] {u : Î± â†’ Î²}
  (h : tendsto u at_top at_bot) : âˆ€ a b, âˆƒ a' â‰¥ a, u a' â‰¤ b :=
@exists_le_of_tendsto_at_top _ (order_dual Î²) _ _ _ h

lemma exists_lt_of_tendsto_at_top [semilattice_sup Î±] [preorder Î²] [no_top_order Î²]
  {u : Î± â†’ Î²} (h : tendsto u at_top at_top) (a : Î±) (b : Î²) : âˆƒ a' â‰¥ a, b < u a' :=
begin
  cases no_top b with b' hb',
  rcases exists_le_of_tendsto_at_top h a b' with âŸ¨a', ha', ha''âŸ©,
  exact âŸ¨a', ha', lt_of_lt_of_le hb' ha''âŸ©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma exists_lt_of_tendsto_at_bot [semilattice_sup Î±] [preorder Î²] [no_bot_order Î²]
  {u : Î± â†’ Î²} (h : tendsto u at_top at_bot) : âˆ€ a b, âˆƒ a' â‰¥ a, u a' < b :=
@exists_lt_of_tendsto_at_top _ (order_dual Î²) _ _ _ _ h

/--
If `u` is a sequence which is unbounded above,
then after any point, it reaches a value strictly greater than all previous values.
-/
lemma high_scores [linear_order Î²] [no_top_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_top) : âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u k < u n :=
begin
  intros N,
  obtain âŸ¨k : â„•, hkn : k â‰¤ N, hku : âˆ€ l â‰¤ N, u l â‰¤ u kâŸ© : âˆƒ k â‰¤ N, âˆ€ l â‰¤ N, u l â‰¤ u k,
    from exists_max_image _ u (finite_le_nat N) âŸ¨N, le_refl NâŸ©,
  have ex : âˆƒ n â‰¥ N, u k < u n,
    from exists_lt_of_tendsto_at_top hu _ _,
  obtain âŸ¨n : â„•, hnN : n â‰¥ N, hnk : u k < u n, hn_min : âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u kâŸ© :
    âˆƒ n â‰¥ N, u k < u n âˆ§ âˆ€ m, m < n â†’ N â‰¤ m â†’ u m â‰¤ u k,
  { rcases nat.find_x ex with âŸ¨n, âŸ¨hnN, hnkâŸ©, hn_minâŸ©,
    push_neg at hn_min,
    exact âŸ¨n, hnN, hnk, hn_minâŸ© },
  use [n, hnN],
  rintros (l : â„•) (hl : l < n),
  have hlk : u l â‰¤ u k,
  { cases (le_total l N : l â‰¤ N âˆ¨ N â‰¤ l) with H H,
    { exact hku l H },
    { exact hn_min l hl H } },
  calc u l â‰¤ u k : hlk
       ... < u n : hnk
end

/--
If `u` is a sequence which is unbounded below,
then after any point, it reaches a value strictly smaller than all previous values.
-/
@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma low_scores [linear_order Î²] [no_bot_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_bot) : âˆ€ N, âˆƒ n â‰¥ N, âˆ€ k < n, u n < u k :=
@high_scores (order_dual Î²) _ _ _ hu

/--
If `u` is a sequence which is unbounded above,
then it `frequently` reaches a value strictly greater than all previous values.
-/
lemma frequently_high_scores [linear_order Î²] [no_top_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_top) : âˆƒá¶  n in at_top, âˆ€ k < n, u k < u n :=
by simpa [frequently_at_top] using high_scores hu

/--
If `u` is a sequence which is unbounded below,
then it `frequently` reaches a value strictly smaller than all previous values.
-/
lemma frequently_low_scores [linear_order Î²] [no_bot_order Î²] {u : â„• â†’ Î²}
  (hu : tendsto u at_top at_bot) : âˆƒá¶  n in at_top, âˆ€ k < n, u n < u k :=
@frequently_high_scores (order_dual Î²) _ _ _ hu

lemma strict_mono_subseq_of_tendsto_at_top
  {Î² : Type*} [linear_order Î²] [no_top_order Î²]
  {u : â„• â†’ Î²} (hu : tendsto u at_top at_top) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ strict_mono (u âˆ˜ Ï†) :=
let âŸ¨Ï†, h, h'âŸ© := extraction_of_frequently_at_top (frequently_high_scores hu) in
âŸ¨Ï†, h, Î» n m hnm, h' m _ (h hnm)âŸ©

lemma strict_mono_subseq_of_id_le {u : â„• â†’ â„•} (hu : âˆ€ n, n â‰¤ u n) :
  âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ strict_mono (u âˆ˜ Ï†) :=
strict_mono_subseq_of_tendsto_at_top (tendsto_at_top_mono hu tendsto_id)

lemma _root_.strict_mono.tendsto_at_top {Ï† : â„• â†’ â„•} (h : strict_mono Ï†) :
  tendsto Ï† at_top at_top :=
tendsto_at_top_mono h.id_le tendsto_id

section ordered_add_comm_monoid

variables [ordered_add_comm_monoid Î²] {l : filter Î±} {f g : Î± â†’ Î²}

lemma tendsto_at_top_add_nonneg_left' (hf : âˆ€á¶  x in l, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_mono' l (hf.mono (Î» x, le_add_of_nonneg_left)) hg

lemma tendsto_at_bot_add_nonpos_left' (hf : âˆ€á¶  x in l, f x â‰¤ 0) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_left' _ (order_dual Î²) _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_left (hf : âˆ€ x, 0 â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_left' (eventually_of_forall hf) hg

lemma tendsto_at_bot_add_nonpos_left (hf : âˆ€ x, f x â‰¤ 0) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_left _ (order_dual Î²) _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_right' (hf : tendsto f l at_top) (hg : âˆ€á¶  x in l, 0 â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_mono' l (monotone_mem (Î» x, le_add_of_nonneg_right) hg) hf

lemma tendsto_at_bot_add_nonpos_right' (hf : tendsto f l at_bot) (hg : âˆ€á¶  x in l, g x â‰¤ 0) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_right' _ (order_dual Î²) _ _ _ _ hf hg

lemma tendsto_at_top_add_nonneg_right (hf : tendsto f l at_top) (hg : âˆ€ x, 0 â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_right' hf (eventually_of_forall hg)

lemma tendsto_at_bot_add_nonpos_right (hf : tendsto f l at_bot) (hg : âˆ€ x, g x â‰¤ 0) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_nonneg_right _ (order_dual Î²) _ _ _ _ hf hg

lemma tendsto_at_top_add (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_nonneg_left' (tendsto_at_top.mp hf 0) hg

lemma tendsto_at_bot_add (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add _ (order_dual Î²) _ _ _ _ hf hg

lemma tendsto.nsmul_at_top (hf : tendsto f l at_top) {n : â„•} (hn : 0 < n) :
  tendsto (Î» x, n â€¢ f x) l at_top :=
tendsto_at_top.2 $ Î» y, (tendsto_at_top.1 hf y).mp $ (tendsto_at_top.1 hf 0).mono $ Î» x hâ‚€ hy,
calc y â‰¤ f x : hy
... = 1 â€¢ f x : (one_nsmul _).symm
... â‰¤  n â€¢ f x : nsmul_le_nsmul hâ‚€ hn

lemma tendsto.nsmul_at_bot (hf : tendsto f l at_bot) {n : â„•} (hn : 0 < n) :
  tendsto (Î» x, n â€¢ f x) l at_bot :=
@tendsto.nsmul_at_top Î± (order_dual Î²) _ l f hf n hn

lemma tendsto_bit0_at_top : tendsto bit0 (at_top : filter Î²) at_top :=
tendsto_at_top_add tendsto_id tendsto_id

lemma tendsto_bit0_at_bot : tendsto bit0 (at_bot : filter Î²) at_bot :=
tendsto_at_bot_add tendsto_id tendsto_id

end ordered_add_comm_monoid

section ordered_cancel_add_comm_monoid

variables [ordered_cancel_add_comm_monoid Î²] {l : filter Î±} {f g : Î± â†’ Î²}

lemma tendsto_at_top_of_add_const_left (C : Î²) (hf : tendsto (Î» x, C + f x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ assume b, (tendsto_at_top.1 hf (C + b)).mono (Î» x, le_of_add_le_add_left)

lemma tendsto_at_bot_of_add_const_left (C : Î²) (hf : tendsto (Î» x, C + f x) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_const_left _ (order_dual Î²) _ _ _ C hf

lemma tendsto_at_top_of_add_const_right (C : Î²) (hf : tendsto (Î» x, f x + C) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ assume b, (tendsto_at_top.1 hf (b + C)).mono (Î» x, le_of_add_le_add_right)

lemma tendsto_at_bot_of_add_const_right (C : Î²) (hf : tendsto (Î» x, f x + C) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_const_right _ (order_dual Î²) _ _ _ C hf

lemma tendsto_at_top_of_add_bdd_above_left' (C) (hC : âˆ€á¶  x in l, f x â‰¤ C)
  (h : tendsto (Î» x, f x + g x) l at_top) :
  tendsto g l at_top :=
tendsto_at_top_of_add_const_left C
  (tendsto_at_top_mono' l (hC.mono (Î» x hx, add_le_add_right hx (g x))) h)

lemma tendsto_at_bot_of_add_bdd_below_left' (C) (hC : âˆ€á¶  x in l, C â‰¤ f x)
  (h : tendsto (Î» x, f x + g x) l at_bot) :
  tendsto g l at_bot :=
@tendsto_at_top_of_add_bdd_above_left' _ (order_dual Î²) _ _ _ _ C hC h

lemma tendsto_at_top_of_add_bdd_above_left (C) (hC : âˆ€ x, f x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_top â†’ tendsto g l at_top :=
tendsto_at_top_of_add_bdd_above_left' C (univ_mem' hC)

lemma tendsto_at_bot_of_add_bdd_below_left (C) (hC : âˆ€ x, C â‰¤ f x) :
  tendsto (Î» x, f x + g x) l at_bot â†’ tendsto g l at_bot :=
@tendsto_at_top_of_add_bdd_above_left _ (order_dual Î²) _ _ _ _ C hC

lemma tendsto_at_top_of_add_bdd_above_right' (C) (hC : âˆ€á¶  x in l, g x â‰¤ C)
  (h : tendsto (Î» x, f x + g x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top_of_add_const_right C
  (tendsto_at_top_mono' l (hC.mono (Î» x hx, add_le_add_left hx (f x))) h)

lemma tendsto_at_bot_of_add_bdd_below_right' (C) (hC : âˆ€á¶  x in l, C â‰¤ g x)
  (h : tendsto (Î» x, f x + g x) l at_bot) :
  tendsto f l at_bot :=
@tendsto_at_top_of_add_bdd_above_right' _ (order_dual Î²) _ _ _ _ C hC h

lemma tendsto_at_top_of_add_bdd_above_right (C) (hC : âˆ€ x, g x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_top â†’ tendsto f l at_top :=
tendsto_at_top_of_add_bdd_above_right' C (univ_mem' hC)

lemma tendsto_at_bot_of_add_bdd_below_right (C) (hC : âˆ€ x, C â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_bot â†’ tendsto f l at_bot :=
@tendsto_at_top_of_add_bdd_above_right _ (order_dual Î²) _ _ _ _ C hC

end ordered_cancel_add_comm_monoid

section ordered_group

variables [ordered_add_comm_group Î²] (l : filter Î±) {f g : Î± â†’ Î²}

lemma tendsto_at_top_add_left_of_le' (C : Î²) (hf : âˆ€á¶  x in l, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_left' _ _ _ l (Î» x, -(f x)) (Î» x, f x + g x) (-C)
  (by simpa) (by simpa)

lemma tendsto_at_bot_add_left_of_ge' (C : Î²) (hf : âˆ€á¶  x in l, f x â‰¤ C) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_left_of_le' _ (order_dual Î²) _ _ _ _ C hf hg

lemma tendsto_at_top_add_left_of_le (C : Î²) (hf : âˆ€ x, C â‰¤ f x) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem' hf) hg

lemma tendsto_at_bot_add_left_of_ge (C : Î²) (hf : âˆ€ x, f x â‰¤ C) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_left_of_le _ (order_dual Î²) _ _ _ _ C hf hg

lemma tendsto_at_top_add_right_of_le' (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€á¶  x in l, C â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
@tendsto_at_top_of_add_bdd_above_right' _ _ _ l (Î» x, f x + g x) (Î» x, -(g x)) (-C)
  (by simp [hg]) (by simp [hf])

lemma tendsto_at_bot_add_right_of_ge' (C : Î²) (hf : tendsto f l at_bot) (hg : âˆ€á¶  x in l, g x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_right_of_le' _ (order_dual Î²) _ _ _ _ C hf hg

lemma tendsto_at_top_add_right_of_le (C : Î²) (hf : tendsto f l at_top) (hg : âˆ€ x, C â‰¤ g x) :
  tendsto (Î» x, f x + g x) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem' hg)

lemma tendsto_at_bot_add_right_of_ge (C : Î²) (hf : tendsto f l at_bot) (hg : âˆ€ x, g x â‰¤ C) :
  tendsto (Î» x, f x + g x) l at_bot :=
@tendsto_at_top_add_right_of_le _ (order_dual Î²) _ _ _ _ C hf hg

lemma tendsto_at_top_add_const_left (C : Î²) (hf : tendsto f l at_top) :
  tendsto (Î» x, C + f x) l at_top :=
tendsto_at_top_add_left_of_le' l C (univ_mem' $ Î» _, le_refl C) hf

lemma tendsto_at_bot_add_const_left (C : Î²) (hf : tendsto f l at_bot) :
  tendsto (Î» x, C + f x) l at_bot :=
@tendsto_at_top_add_const_left _ (order_dual Î²) _ _ _ C hf

lemma tendsto_at_top_add_const_right (C : Î²) (hf : tendsto f l at_top) :
  tendsto (Î» x, f x + C) l at_top :=
tendsto_at_top_add_right_of_le' l C hf (univ_mem' $ Î» _, le_refl C)

lemma tendsto_at_bot_add_const_right (C : Î²) (hf : tendsto f l at_bot) :
  tendsto (Î» x, f x + C) l at_bot :=
@tendsto_at_top_add_const_right _ (order_dual Î²) _ _ _ C hf

lemma tendsto_neg_at_top_at_bot : tendsto (has_neg.neg : Î² â†’ Î²) at_top at_bot :=
begin
  simp only [tendsto_at_bot, neg_le],
  exact Î» b, eventually_ge_at_top _
end

lemma tendsto_neg_at_bot_at_top : tendsto (has_neg.neg : Î² â†’ Î²) at_bot at_top :=
@tendsto_neg_at_top_at_bot (order_dual Î²) _

end ordered_group

section ordered_semiring

variables [ordered_semiring Î±] {l : filter Î²} {f g : Î² â†’ Î±}

lemma tendsto_bit1_at_top : tendsto bit1 (at_top : filter Î±) at_top :=
tendsto_at_top_add_nonneg_right tendsto_bit0_at_top (Î» _, zero_le_one)

lemma tendsto.at_top_mul_at_top (hf : tendsto f l at_top) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x * g x) l at_top :=
begin
  refine tendsto_at_top_mono' _ _ hg,
  filter_upwards [hg.eventually (eventually_ge_at_top 0), hf.eventually (eventually_ge_at_top 1)],
  exact Î» x, le_mul_of_one_le_left
end

lemma tendsto_mul_self_at_top : tendsto (Î» x : Î±, x * x) at_top at_top :=
tendsto_id.at_top_mul_at_top tendsto_id

/-- The monomial function `x^n` tends to `+âˆ` at `+âˆ` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_at_top`. -/
lemma tendsto_pow_at_top {n : â„•} (hn : 1 â‰¤ n) : tendsto (Î» x : Î±, x ^ n) at_top at_top :=
begin
  refine tendsto_at_top_mono' _ ((eventually_ge_at_top 1).mono $ Î» x hx, _) tendsto_id,
  simpa only [pow_one] using pow_le_pow hx hn
end

end ordered_semiring

lemma zero_pow_eventually_eq [monoid_with_zero Î±] :
  (Î» n : â„•, (0 : Î±) ^ n) =á¶ [at_top] (Î» n, 0) :=
eventually_at_top.2 âŸ¨1, Î» n hn, zero_pow (zero_lt_one.trans_le hn)âŸ©

section ordered_ring

variables [ordered_ring Î±] {l : filter Î²} {f g : Î² â†’ Î±}

lemma tendsto.at_top_mul_at_bot (hf : tendsto f l at_top) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x * g x) l at_bot :=
have _ := (hf.at_top_mul_at_top $ tendsto_neg_at_bot_at_top.comp hg),
by simpa only [(âˆ˜), neg_mul_eq_mul_neg, neg_neg] using tendsto_neg_at_top_at_bot.comp this

lemma tendsto.at_bot_mul_at_top (hf : tendsto f l at_bot) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x * g x) l at_bot :=
have tendsto (Î» x, (-f x) * g x) l at_top :=
  ( (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top hg),
by simpa only [(âˆ˜), neg_mul_eq_neg_mul, neg_neg] using tendsto_neg_at_top_at_bot.comp this

lemma tendsto.at_bot_mul_at_bot (hf : tendsto f l at_bot) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x * g x) l at_top :=
have tendsto (Î» x, (-f x) * (-g x)) l at_top :=
  (tendsto_neg_at_bot_at_top.comp hf).at_top_mul_at_top (tendsto_neg_at_bot_at_top.comp hg),
by simpa only [neg_mul_neg] using this

end ordered_ring

section linear_ordered_add_comm_group

variables [linear_ordered_add_comm_group Î±]

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_top_at_top : tendsto (abs : Î± â†’ Î±) at_top at_top :=
tendsto_at_top_mono le_abs_self tendsto_id

/-- $\lim_{x\to-\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_bot_at_top : tendsto (abs : Î± â†’ Î±) at_bot at_top :=
tendsto_at_top_mono neg_le_abs_self tendsto_neg_at_bot_at_top

end linear_ordered_add_comm_group

section linear_ordered_semiring

variables [linear_ordered_semiring Î±] {l : filter Î²} {f : Î² â†’ Î±}

lemma tendsto.at_top_of_const_mul {c : Î±} (hc : 0 < c) (hf : tendsto (Î» x, c * f x) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ Î» b, (tendsto_at_top.1 hf (c * b)).mono $ Î» x hx, le_of_mul_le_mul_left hx hc

lemma tendsto.at_top_of_mul_const {c : Î±} (hc : 0 < c) (hf : tendsto (Î» x, f x * c) l at_top) :
  tendsto f l at_top :=
tendsto_at_top.2 $ Î» b, (tendsto_at_top.1 hf (b * c)).mono $ Î» x hx, le_of_mul_le_mul_right hx hc

end linear_ordered_semiring

lemma nonneg_of_eventually_pow_nonneg [linear_ordered_ring Î±] {a : Î±}
  (h : âˆ€á¶  n in at_top, 0 â‰¤ a ^ (n : â„•)) : 0 â‰¤ a :=
let âŸ¨n, hnâŸ© := (tendsto_bit1_at_top.eventually h).exists in pow_bit1_nonneg_iff.1 hn

section linear_ordered_field

variables [linear_ordered_field Î±] {l : filter Î²} {f : Î² â†’ Î±} {r : Î±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.const_mul_at_top'` instead. -/
lemma tendsto.const_mul_at_top (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Î»x, r * f x) l at_top :=
tendsto.at_top_of_const_mul (inv_pos.2 hr) $ by simpa only [inv_mul_cancel_leftâ‚€ hr.ne']

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `â„•` or `â„¤`, use
`filter.tendsto.at_top_mul_const'` instead. -/
lemma tendsto.at_top_mul_const (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Î»x, f x * r) l at_top :=
by simpa only [mul_comm] using hf.const_mul_at_top hr

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
lemma tendsto.at_top_div_const (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Î»x, f x / r) l at_top :=
by simpa only [div_eq_mul_inv] using hf.at_top_mul_const (inv_pos.2 hr)

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the left) tends to negative infinity. -/
lemma tendsto.neg_const_mul_at_top (hr : r < 0) (hf : tendsto f l at_top) :
  tendsto (Î» x, r * f x) l at_bot :=
by simpa only [(âˆ˜), neg_mul_eq_neg_mul, neg_neg]
  using tendsto_neg_at_top_at_bot.comp (hf.const_mul_at_top (neg_pos.2 hr))

/-- If a function tends to infinity along a filter, then this function multiplied by a negative
constant (on the right) tends to negative infinity. -/
lemma tendsto.at_top_mul_neg_const (hr : r < 0) (hf : tendsto f l at_top) :
  tendsto (Î» x, f x * r) l at_bot :=
by simpa only [mul_comm] using hf.neg_const_mul_at_top hr

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the left) also tends to negative infinity. -/
lemma tendsto.const_mul_at_bot (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Î»x, r * f x) l at_bot :=
by simpa only [(âˆ˜), neg_mul_eq_mul_neg, neg_neg]
  using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).const_mul_at_top hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a positive constant (on the right) also tends to negative infinity. -/
lemma tendsto.at_bot_mul_const (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Î»x, f x * r) l at_bot :=
by simpa only [mul_comm] using hf.const_mul_at_bot hr

/-- If a function tends to negative infinity along a filter, then this function divided by
a positive constant also tends to negative infinity. -/
lemma tendsto.at_bot_div_const (hr : 0 < r) (hf : tendsto f l at_bot) :
  tendsto (Î»x, f x / r) l at_bot :=
by simpa only [div_eq_mul_inv] using hf.at_bot_mul_const (inv_pos.2 hr)

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the left) tends to positive infinity. -/
lemma tendsto.neg_const_mul_at_bot (hr : r < 0) (hf : tendsto f l at_bot) :
  tendsto (Î» x, r * f x) l at_top :=
by simpa only [(âˆ˜), neg_mul_eq_neg_mul, neg_neg]
  using tendsto_neg_at_bot_at_top.comp (hf.const_mul_at_bot (neg_pos.2 hr))

/-- If a function tends to negative infinity along a filter, then this function multiplied by
a negative constant (on the right) tends to positive infinity. -/
lemma tendsto.at_bot_mul_neg_const (hr : r < 0) (hf : tendsto f l at_bot) :
  tendsto (Î» x, f x * r) l at_top :=
by simpa only [mul_comm] using hf.neg_const_mul_at_bot hr

lemma tendsto_const_mul_pow_at_top {c : Î±} {n : â„•}
  (hn : 1 â‰¤ n) (hc : 0 < c) : tendsto (Î» x, c * x^n) at_top at_top :=
tendsto.const_mul_at_top hc (tendsto_pow_at_top hn)

lemma tendsto_const_mul_pow_at_top_iff (c : Î±) (n : â„•) :
  tendsto (Î» x, c * x^n) at_top at_top â†” 1 â‰¤ n âˆ§ 0 < c :=
begin
  refine âŸ¨Î» h, _, Î» h, tendsto_const_mul_pow_at_top h.1 h.2âŸ©,
  simp only [tendsto_at_top, eventually_at_top] at h,
  have : 0 < c := let âŸ¨x, hxâŸ© := h 1 in
    pos_of_mul_pos_right (lt_of_lt_of_le zero_lt_one (hx (max x 1) (le_max_left x 1)))
    (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n),
  refine âŸ¨nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Î» hn, _))), thisâŸ©,
  obtain âŸ¨x, hxâŸ© := h (c + 1),
  specialize hx x le_rfl,
  rw [hn, pow_zero, mul_one, add_le_iff_nonpos_right] at hx,
  exact absurd hx (not_le.mpr zero_lt_one),
end

lemma tendsto_neg_const_mul_pow_at_top {c : Î±} {n : â„•}
  (hn : 1 â‰¤ n) (hc : c < 0) : tendsto (Î» x, c * x^n) at_top at_bot :=
tendsto.neg_const_mul_at_top hc (tendsto_pow_at_top hn)

lemma tendsto_neg_const_mul_pow_at_top_iff (c : Î±) (n : â„•) :
  tendsto (Î» x, c * x^n) at_top at_bot â†” 1 â‰¤ n âˆ§ c < 0 :=
begin
  refine âŸ¨Î» h, _, Î» h, tendsto_neg_const_mul_pow_at_top h.1 h.2âŸ©,
  simp only [tendsto_at_bot, eventually_at_top] at h,
  have : c < 0 := let âŸ¨x, hxâŸ© := h (-1) in
    neg_of_mul_neg_right (lt_of_le_of_lt (hx (max x 1) (le_max_left x 1)) (by simp [zero_lt_one]))
    (pow_nonneg (le_trans zero_le_one (le_max_right x 1)) n),
  refine âŸ¨nat.succ_le_iff.mp (lt_of_le_of_ne (zero_le n) (ne.symm (Î» hn, _))), thisâŸ©,
  obtain âŸ¨x, hxâŸ© := h (c - 1),
  specialize hx x le_rfl,
  rw [hn, pow_zero, mul_one, le_sub, sub_self] at hx,
  exact absurd hx (not_le.mpr zero_lt_one),
end

end linear_ordered_field

open_locale filter

lemma tendsto_at_top' [nonempty Î±] [semilattice_sup Î±] {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto f at_top l â†” (âˆ€s âˆˆ l, âˆƒa, âˆ€bâ‰¥a, f b âˆˆ s) :=
by simp only [tendsto_def, mem_at_top_sets]; refl

lemma tendsto_at_bot' [nonempty Î±] [semilattice_inf Î±] {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto f at_bot l â†” (âˆ€s âˆˆ l, âˆƒa, âˆ€bâ‰¤a, f b âˆˆ s) :=
@tendsto_at_top' (order_dual Î±) _ _ _ _ _

theorem tendsto_at_top_principal [nonempty Î²] [semilattice_sup Î²] {f : Î² â†’ Î±} {s : set Î±} :
  tendsto f at_top (ğ“Ÿ s) â†” âˆƒN, âˆ€nâ‰¥N, f n âˆˆ s :=
by rw [tendsto_iff_comap, comap_principal, le_principal_iff, mem_at_top_sets]; refl

theorem tendsto_at_bot_principal [nonempty Î²] [semilattice_inf Î²] {f : Î² â†’ Î±} {s : set Î±} :
  tendsto f at_bot (ğ“Ÿ s) â†” âˆƒN, âˆ€nâ‰¤N, f n âˆˆ s :=
@tendsto_at_top_principal _ (order_dual Î²) _ _ _ _

/-- A function `f` grows to `+âˆ` independent of an order-preserving embedding `e`. -/
lemma tendsto_at_top_at_top [nonempty Î±] [semilattice_sup Î±] [preorder Î²] {f : Î± â†’ Î²} :
  tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ i : Î±, âˆ€ a : Î±, i â‰¤ a â†’ b â‰¤ f a :=
iff.trans tendsto_infi $ forall_congr $ assume b, tendsto_at_top_principal

lemma tendsto_at_top_at_bot [nonempty Î±] [semilattice_sup Î±] [preorder Î²] {f : Î± â†’ Î²} :
  tendsto f at_top at_bot â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), i â‰¤ a â†’ f a â‰¤ b :=
@tendsto_at_top_at_top Î± (order_dual Î²) _ _ _ f

lemma tendsto_at_bot_at_top [nonempty Î±] [semilattice_inf Î±] [preorder Î²] {f : Î± â†’ Î²} :
  tendsto f at_bot at_top â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), a â‰¤ i â†’ b â‰¤ f a :=
@tendsto_at_top_at_top (order_dual Î±) Î² _ _ _ f

lemma tendsto_at_bot_at_bot [nonempty Î±] [semilattice_inf Î±] [preorder Î²] {f : Î± â†’ Î²} :
  tendsto f at_bot at_bot â†” âˆ€ (b : Î²), âˆƒ (i : Î±), âˆ€ (a : Î±), a â‰¤ i â†’ f a â‰¤ b :=
@tendsto_at_top_at_top (order_dual Î±) (order_dual Î²) _ _ _ f

lemma tendsto_at_top_at_top_of_monotone [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f)
  (h : âˆ€ b, âˆƒ a, b â‰¤ f a) :
  tendsto f at_top at_top :=
tendsto_infi.2 $ Î» b, tendsto_principal.2 $ let âŸ¨a, haâŸ© := h b in
mem_of_superset (mem_at_top a) $ Î» a' ha', le_trans ha (hf ha')

lemma tendsto_at_bot_at_bot_of_monotone [preorder Î±] [preorder Î²] {f : Î± â†’ Î²} (hf : monotone f)
  (h : âˆ€ b, âˆƒ a, f a â‰¤ b) :
  tendsto f at_bot at_bot :=
tendsto_infi.2 $ Î» b, tendsto_principal.2 $ let âŸ¨a, haâŸ© := h b in
mem_of_superset (mem_at_bot a) $ Î» a' ha', le_trans (hf ha') ha

lemma tendsto_at_top_at_top_iff_of_monotone [nonempty Î±] [semilattice_sup Î±] [preorder Î²]
  {f : Î± â†’ Î²} (hf : monotone f) :
  tendsto f at_top at_top â†” âˆ€ b : Î², âˆƒ a : Î±, b â‰¤ f a :=
tendsto_at_top_at_top.trans $ forall_congr $ Î» b, exists_congr $ Î» a,
  âŸ¨Î» h, h a (le_refl a), Î» h a' ha', le_trans h $ hf ha'âŸ©

lemma tendsto_at_bot_at_bot_iff_of_monotone [nonempty Î±] [semilattice_inf Î±] [preorder Î²]
  {f : Î± â†’ Î²} (hf : monotone f) :
  tendsto f at_bot at_bot â†” âˆ€ b : Î², âˆƒ a : Î±, f a â‰¤ b :=
tendsto_at_bot_at_bot.trans $ forall_congr $ Î» b, exists_congr $ Î» a,
  âŸ¨Î» h, h a (le_refl a), Î» h a' ha', le_trans (hf ha') hâŸ©

alias tendsto_at_top_at_top_of_monotone â† monotone.tendsto_at_top_at_top
alias tendsto_at_bot_at_bot_of_monotone â† monotone.tendsto_at_bot_at_bot
alias tendsto_at_top_at_top_iff_of_monotone â† monotone.tendsto_at_top_at_top_iff
alias tendsto_at_bot_at_bot_iff_of_monotone â† monotone.tendsto_at_bot_at_bot_iff

lemma tendsto_at_top_embedding [preorder Î²] [preorder Î³]
  {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : filter Î±}
  (hm : âˆ€bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€c, âˆƒb, c â‰¤ e b) :
  tendsto (e âˆ˜ f) l at_top â†” tendsto f l at_top :=
begin
  refine âŸ¨_, (tendsto_at_top_at_top_of_monotone (Î» bâ‚ bâ‚‚, (hm bâ‚ bâ‚‚).2) hu).compâŸ©,
  rw [tendsto_at_top, tendsto_at_top],
  exact Î» hc b, (hc (e b)).mono (Î» a, (hm b (f a)).1)
end

/-- A function `f` goes to `-âˆ` independent of an order-preserving embedding `e`. -/
lemma tendsto_at_bot_embedding [preorder Î²] [preorder Î³]
  {f : Î± â†’ Î²} {e : Î² â†’ Î³} {l : filter Î±}
  (hm : âˆ€bâ‚ bâ‚‚, e bâ‚ â‰¤ e bâ‚‚ â†” bâ‚ â‰¤ bâ‚‚) (hu : âˆ€c, âˆƒb, e b â‰¤ c) :
  tendsto (e âˆ˜ f) l at_bot â†” tendsto f l at_bot :=
@tendsto_at_top_embedding Î± (order_dual Î²) (order_dual Î³) _ _ f e l (function.swap hm) hu

lemma tendsto_finset_range : tendsto finset.range at_top at_top :=
finset.range_mono.tendsto_at_top_at_top finset.exists_nat_subset_range

lemma at_top_finset_eq_infi : (at_top : filter $ finset Î±) = â¨… x : Î±, ğ“Ÿ (Ici {x}) :=
begin
  refine le_antisymm (le_infi (Î» i, le_principal_iff.2 $ mem_at_top {i})) _,
  refine le_infi (Î» s, le_principal_iff.2 $ mem_infi_of_Inter s.finite_to_set
                  (Î» i, mem_principal_self _) _),
  simp only [subset_def, mem_Inter, set_coe.forall, mem_Ici, finset.le_iff_subset,
    finset.mem_singleton, finset.subset_iff, forall_eq], dsimp,
  exact Î» t, id
end

/-- If `f` is a monotone sequence of `finset`s and each `x` belongs to one of `f n`, then
`tendsto f at_top at_top`. -/
lemma tendsto_at_top_finset_of_monotone [preorder Î²]
  {f : Î² â†’ finset Î±} (h : monotone f) (h' : âˆ€ x : Î±, âˆƒ n, x âˆˆ f n) :
  tendsto f at_top at_top :=
begin
  simp only [at_top_finset_eq_infi, tendsto_infi, tendsto_principal],
  intro a,
  rcases h' a with âŸ¨b, hbâŸ©,
  exact eventually.mono (mem_at_top b)
    (Î» b' hb', le_trans (finset.singleton_subset_iff.2 hb) (h hb')),
end

alias tendsto_at_top_finset_of_monotone â† monotone.tendsto_at_top_finset

lemma tendsto_finset_image_at_top_at_top {i : Î² â†’ Î³} {j : Î³ â†’ Î²} (h : function.left_inverse j i) :
  tendsto (finset.image j) at_top at_top :=
(finset.image_mono j).tendsto_at_top_finset $ assume a,
  âŸ¨{i a}, by simp only [finset.image_singleton, h a, finset.mem_singleton]âŸ©

lemma tendsto_finset_preimage_at_top_at_top {f : Î± â†’ Î²} (hf : function.injective f) :
  tendsto (Î» s : finset Î², s.preimage f (hf.inj_on _)) at_top at_top :=
(finset.monotone_preimage hf).tendsto_at_top_finset $
  Î» x, âŸ¨{f x}, finset.mem_preimage.2 $ finset.mem_singleton_self _âŸ©

lemma prod_at_top_at_top_eq {Î²â‚ Î²â‚‚ : Type*} [semilattice_sup Î²â‚] [semilattice_sup Î²â‚‚] :
  (at_top : filter Î²â‚) Ã—á¶  (at_top : filter Î²â‚‚) = (at_top : filter (Î²â‚ Ã— Î²â‚‚)) :=
begin
  casesI (is_empty_or_nonempty Î²â‚).symm,
  casesI (is_empty_or_nonempty Î²â‚‚).symm,
  { simp [at_top, prod_infi_left, prod_infi_right, infi_prod],
    exact infi_comm, },
  { simp only [at_top.filter_eq_bot_of_is_empty, prod_bot] },
  { simp only [at_top.filter_eq_bot_of_is_empty, bot_prod] },
end

lemma prod_at_bot_at_bot_eq {Î²â‚ Î²â‚‚ : Type*} [semilattice_inf Î²â‚] [semilattice_inf Î²â‚‚] :
  (at_bot : filter Î²â‚) Ã—á¶  (at_bot : filter Î²â‚‚) = (at_bot : filter (Î²â‚ Ã— Î²â‚‚)) :=
@prod_at_top_at_top_eq (order_dual Î²â‚) (order_dual Î²â‚‚) _ _

lemma prod_map_at_top_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type*} [semilattice_sup Î²â‚] [semilattice_sup Î²â‚‚]
  (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) :
  (map uâ‚ at_top) Ã—á¶  (map uâ‚‚ at_top) = map (prod.map uâ‚ uâ‚‚) at_top :=
by rw [prod_map_map_eq, prod_at_top_at_top_eq, prod.map_def]

lemma prod_map_at_bot_eq {Î±â‚ Î±â‚‚ Î²â‚ Î²â‚‚ : Type*} [semilattice_inf Î²â‚] [semilattice_inf Î²â‚‚]
  (uâ‚ : Î²â‚ â†’ Î±â‚) (uâ‚‚ : Î²â‚‚ â†’ Î±â‚‚) :
  (map uâ‚ at_bot) Ã—á¶  (map uâ‚‚ at_bot) = map (prod.map uâ‚ uâ‚‚) at_bot :=
@prod_map_at_top_eq _ _ (order_dual Î²â‚) (order_dual Î²â‚‚) _ _ _ _

lemma tendsto.subseq_mem {F : filter Î±} {V : â„• â†’ set Î±} (h : âˆ€ n, V n âˆˆ F) {u : â„• â†’ Î±}
  (hu : tendsto u at_top F) : âˆƒ Ï† : â„• â†’ â„•, strict_mono Ï† âˆ§ âˆ€ n, u (Ï† n) âˆˆ V n :=
extraction_forall_of_eventually' (Î» n, tendsto_at_top'.mp hu _ (h n) : âˆ€ n, âˆƒ N, âˆ€ k â‰¥ N, u k âˆˆ V n)

lemma tendsto_at_bot_diagonal [semilattice_inf Î±] : tendsto (Î» a : Î±, (a, a)) at_bot at_bot :=
by { rw â† prod_at_bot_at_bot_eq, exact tendsto_id.prod_mk tendsto_id }

lemma tendsto_at_top_diagonal [semilattice_sup Î±] : tendsto (Î» a : Î±, (a, a)) at_top at_top :=
by { rw â† prod_at_top_at_top_eq, exact tendsto_id.prod_mk tendsto_id }

lemma tendsto.prod_map_prod_at_bot [semilattice_inf Î³] {F : filter Î±} {G : filter Î²}
  {f : Î± â†’ Î³} {g : Î² â†’ Î³} (hf : tendsto f F at_bot) (hg : tendsto g G at_bot) :
  tendsto (prod.map f g) (F Ã—á¶  G) at_bot :=
by { rw â† prod_at_bot_at_bot_eq, exact hf.prod_map hg, }

lemma tendsto.prod_map_prod_at_top [semilattice_sup Î³] {F : filter Î±} {G : filter Î²}
  {f : Î± â†’ Î³} {g : Î² â†’ Î³} (hf : tendsto f F at_top) (hg : tendsto g G at_top) :
  tendsto (prod.map f g) (F Ã—á¶  G) at_top :=
by { rw â† prod_at_top_at_top_eq, exact hf.prod_map hg, }

lemma tendsto.prod_at_bot [semilattice_inf Î±] [semilattice_inf Î³]
  {f g : Î± â†’ Î³} (hf : tendsto f at_bot at_bot) (hg : tendsto g at_bot at_bot) :
  tendsto (prod.map f g) at_bot at_bot :=
by { rw â† prod_at_bot_at_bot_eq, exact hf.prod_map_prod_at_bot hg, }

lemma tendsto.prod_at_top [semilattice_sup Î±] [semilattice_sup Î³]
  {f g : Î± â†’ Î³} (hf : tendsto f at_top at_top) (hg : tendsto g at_top at_top) :
  tendsto (prod.map f g) at_top at_top :=
by { rw â† prod_at_top_at_top_eq, exact hf.prod_map_prod_at_top hg, }

lemma eventually_at_bot_prod_self [semilattice_inf Î±] [nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶  x in at_bot, p x) â†” (âˆƒ a, âˆ€ k l, k â‰¤ a â†’ l â‰¤ a â†’ p (k, l)) :=
by simp [â† prod_at_bot_at_bot_eq, at_bot_basis.prod_self.eventually_iff]

lemma eventually_at_top_prod_self [semilattice_sup Î±] [nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶  x in at_top, p x) â†” (âˆƒ a, âˆ€ k l, a â‰¤ k â†’ a â‰¤ l â†’ p (k, l)) :=
by simp [â† prod_at_top_at_top_eq, at_top_basis.prod_self.eventually_iff]

lemma eventually_at_bot_prod_self' [semilattice_inf Î±] [nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶  x in at_bot, p x) â†” (âˆƒ a, âˆ€ k â‰¤ a, âˆ€ l â‰¤ a, p (k, l)) :=
begin
  rw filter.eventually_at_bot_prod_self,
  apply exists_congr,
  tauto,
end

lemma eventually_at_top_prod_self' [semilattice_sup Î±] [nonempty Î±] {p : Î± Ã— Î± â†’ Prop} :
  (âˆ€á¶  x in at_top, p x) â†” (âˆƒ a, âˆ€ k â‰¥ a, âˆ€ l â‰¥ a, p (k, l)) :=
begin
  rw filter.eventually_at_top_prod_self,
  apply exists_congr,
  tauto,
end

/-- A function `f` maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois "insertion" and "connection" is weakened to only require it to be an
insertion and a connetion above `b'`. -/
lemma map_at_top_eq_of_gc [semilattice_sup Î±] [semilattice_sup Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
  (hf : monotone f) (gc : âˆ€a, âˆ€bâ‰¥b', f a â‰¤ b â†” a â‰¤ g b) (hgi : âˆ€bâ‰¥b', b â‰¤ f (g b)) :
  map f at_top = at_top :=
begin
  refine le_antisymm
    (hf.tendsto_at_top_at_top $ Î» b, âŸ¨g (b âŠ” b'), le_sup_left.trans $ hgi _ le_sup_rightâŸ©) _,
  rw [@map_at_top_eq _ _ âŸ¨g b'âŸ©],
  refine le_infi (Î» a, infi_le_of_le (f a âŠ” b') $ principal_mono.2 $ Î» b hb, _),
  rw [mem_Ici, sup_le_iff] at hb,
  exact âŸ¨g b, (gc _ _ hb.2).1 hb.1, le_antisymm ((gc _ _ hb.2).2 (le_refl _)) (hgi _ hb.2)âŸ©
end

lemma map_at_bot_eq_of_gc [semilattice_inf Î±] [semilattice_inf Î²] {f : Î± â†’ Î²} (g : Î² â†’ Î±) (b' : Î²)
  (hf : monotone f) (gc : âˆ€a, âˆ€bâ‰¤b', b â‰¤ f a â†” g b â‰¤ a) (hgi : âˆ€bâ‰¤b', f (g b) â‰¤ b) :
  map f at_bot = at_bot :=
@map_at_top_eq_of_gc (order_dual Î±) (order_dual Î²) _ _ _ _ _ hf.order_dual gc hgi

lemma map_coe_at_top_of_Ici_subset [semilattice_sup Î±] {a : Î±} {s : set Î±} (h : Ici a âŠ† s) :
  map (coe : s â†’ Î±) at_top = at_top :=
begin
  have : directed (â‰¥) (Î» x : s, ğ“Ÿ (Ici x)),
  { intros x y,
    use âŸ¨x âŠ” y âŠ” a, h le_sup_rightâŸ©,
    simp only [ge_iff_le, principal_mono, Ici_subset_Ici, â† subtype.coe_le_coe, subtype.coe_mk],
    exact âŸ¨le_sup_left.trans le_sup_left, le_sup_right.trans le_sup_leftâŸ© },
  haveI : nonempty s := âŸ¨âŸ¨a, h le_rflâŸ©âŸ©,
  simp only [le_antisymm_iff, at_top, le_infi_iff, le_principal_iff, mem_map, mem_set_of_eq,
    map_infi_eq this, map_principal],
  split,
  { intro x,
    refine mem_of_superset (mem_infi_of_mem âŸ¨x âŠ” a, h le_sup_rightâŸ© (mem_principal_self _)) _,
    rintro _ âŸ¨y, hy, rflâŸ©,
    exact le_trans le_sup_left (subtype.coe_le_coe.2 hy) },
  { intro x,
    filter_upwards [mem_at_top (â†‘x âŠ” a)],
    intros b hb,
    exact âŸ¨âŸ¨b, h $ le_sup_right.trans hbâŸ©, subtype.coe_le_coe.1 (le_sup_left.trans hb), rflâŸ© }
end

/-- The image of the filter `at_top` on `Ici a` under the coercion equals `at_top`. -/
@[simp] lemma map_coe_Ici_at_top [semilattice_sup Î±] (a : Î±) :
  map (coe : Ici a â†’ Î±) at_top = at_top :=
map_coe_at_top_of_Ici_subset (subset.refl _)

/-- The image of the filter `at_top` on `Ioi a` under the coercion equals `at_top`. -/
@[simp] lemma map_coe_Ioi_at_top [semilattice_sup Î±] [no_top_order Î±] (a : Î±) :
  map (coe : Ioi a â†’ Î±) at_top = at_top :=
begin
  rcases no_top a with âŸ¨b, hbâŸ©,
  exact map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb)
end

/-- The `at_top` filter for an open interval `Ioi a` comes from the `at_top` filter in the ambient
order. -/
lemma at_top_Ioi_eq [semilattice_sup Î±] (a : Î±) :
  at_top = comap (coe : Ioi a â†’ Î±) at_top :=
begin
  nontriviality,
  rcases nontrivial_iff_nonempty.1 â€¹_â€º with âŸ¨b, hbâŸ©,
  rw [â† map_coe_at_top_of_Ici_subset (Ici_subset_Ioi.2 hb), comap_map subtype.coe_injective]
end

/-- The `at_top` filter for an open interval `Ici a` comes from the `at_top` filter in the ambient
order. -/
lemma at_top_Ici_eq [semilattice_sup Î±] (a : Î±) :
  at_top = comap (coe : Ici a â†’ Î±) at_top :=
by rw [â† map_coe_Ici_at_top a, comap_map subtype.coe_injective]

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] lemma map_coe_Iio_at_bot [semilattice_inf Î±] [no_bot_order Î±] (a : Î±) :
  map (coe : Iio a â†’ Î±) at_bot = at_bot :=
@map_coe_Ioi_at_top (order_dual Î±) _ _ _

/-- The `at_bot` filter for an open interval `Iio a` comes from the `at_bot` filter in the ambient
order. -/
lemma at_bot_Iio_eq [semilattice_inf Î±] (a : Î±) :
  at_bot = comap (coe : Iio a â†’ Î±) at_bot :=
@at_top_Ioi_eq (order_dual Î±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
@[simp] lemma map_coe_Iic_at_bot [semilattice_inf Î±] (a : Î±) :
  map (coe : Iic a â†’ Î±) at_bot = at_bot :=
@map_coe_Ici_at_top (order_dual Î±) _ _

/-- The `at_bot` filter for an open interval `Iic a` comes from the `at_bot` filter in the ambient
order. -/
lemma at_bot_Iic_eq [semilattice_inf Î±] (a : Î±) :
  at_bot = comap (coe : Iic a â†’ Î±) at_bot :=
@at_top_Ici_eq (order_dual Î±) _ _

lemma tendsto_Ioi_at_top [semilattice_sup Î±] {a : Î±} {f : Î² â†’ Ioi a}
  {l : filter Î²} :
  tendsto f l at_top â†” tendsto (Î» x, (f x : Î±)) l at_top :=
by rw [at_top_Ioi_eq, tendsto_comap_iff]

lemma tendsto_Iio_at_bot [semilattice_inf Î±] {a : Î±} {f : Î² â†’ Iio a}
  {l : filter Î²} :
  tendsto f l at_bot â†” tendsto (Î» x, (f x : Î±)) l at_bot :=
by rw [at_bot_Iio_eq, tendsto_comap_iff]

lemma tendsto_Ici_at_top [semilattice_sup Î±] {a : Î±} {f : Î² â†’ Ici a} {l : filter Î²} :
  tendsto f l at_top â†” tendsto (Î» x, (f x : Î±)) l at_top :=
by rw [at_top_Ici_eq, tendsto_comap_iff]

lemma tendsto_Iic_at_bot [semilattice_inf Î±] {a : Î±} {f : Î² â†’ Iic a} {l : filter Î²} :
  tendsto f l at_bot â†” tendsto (Î» x, (f x : Î±)) l at_bot :=
by rw [at_bot_Iic_eq, tendsto_comap_iff]

@[simp] lemma tendsto_comp_coe_Ioi_at_top [semilattice_sup Î±] [no_top_order Î±] {a : Î±}
  {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto (Î» x : Ioi a, f x) at_top l â†” tendsto f at_top l :=
by rw [â† map_coe_Ioi_at_top a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ici_at_top [semilattice_sup Î±] {a : Î±}
  {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto (Î» x : Ici a, f x) at_top l â†” tendsto f at_top l :=
by rw [â† map_coe_Ici_at_top a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iio_at_bot [semilattice_inf Î±] [no_bot_order Î±] {a : Î±}
  {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto (Î» x : Iio a, f x) at_bot l â†” tendsto f at_bot l :=
by rw [â† map_coe_Iio_at_bot a, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iic_at_bot [semilattice_inf Î±] {a : Î±}
  {f : Î± â†’ Î²} {l : filter Î²} :
  tendsto (Î» x : Iic a, f x) at_bot l â†” tendsto f at_bot l :=
by rw [â† map_coe_Iic_at_bot a, tendsto_map'_iff]

lemma map_add_at_top_eq_nat (k : â„•) : map (Î»a, a + k) at_top = at_top :=
map_at_top_eq_of_gc (Î»a, a - k) k
  (assume a b h, add_le_add_right h k)
  (assume a b h, (nat.le_sub_right_iff_add_le h).symm)
  (assume a h, by rw [nat.sub_add_cancel h])

lemma map_sub_at_top_eq_nat (k : â„•) : map (Î»a, a - k) at_top = at_top :=
map_at_top_eq_of_gc (Î»a, a + k) 0
  (assume a b h, nat.sub_le_sub_right h _)
  (assume a b _, nat.sub_le_right_iff_le_add)
  (assume b _, by rw [nat.add_sub_cancel])

lemma tendsto_add_at_top_nat (k : â„•) : tendsto (Î»a, a + k) at_top at_top :=
le_of_eq (map_add_at_top_eq_nat k)

lemma tendsto_sub_at_top_nat (k : â„•) : tendsto (Î»a, a - k) at_top at_top :=
le_of_eq (map_sub_at_top_eq_nat k)

lemma tendsto_add_at_top_iff_nat {f : â„• â†’ Î±} {l : filter Î±} (k : â„•) :
  tendsto (Î»n, f (n + k)) at_top l â†” tendsto f at_top l :=
show tendsto (f âˆ˜ (Î»n, n + k)) at_top l â†” tendsto f at_top l,
  by rw [â† tendsto_map'_iff, map_add_at_top_eq_nat]

lemma map_div_at_top_eq_nat (k : â„•) (hk : 0 < k) : map (Î»a, a / k) at_top = at_top :=
map_at_top_eq_of_gc (Î»b, b * k + (k - 1)) 1
  (assume a b h, nat.div_le_div_right h)
  (assume a b _,
    calc a / k â‰¤ b â†” a / k < b + 1 : by rw [â† nat.succ_eq_add_one, nat.lt_succ_iff]
      ... â†” a < (b + 1) * k : nat.div_lt_iff_lt_mul _ _ hk
      ... â†” _ :
      begin
        cases k,
        exact (lt_irrefl _ hk).elim,
        rw [add_mul, one_mul, nat.succ_sub_succ_eq_sub,
          nat.sub_zero, nat.add_succ, nat.lt_succ_iff],
      end)
  (assume b _,
    calc b = (b * k) / k : by rw [nat.mul_div_cancel b hk]
      ... â‰¤ (b * k + (k - 1)) / k : nat.div_le_div_right $ nat.le_add_right _ _)

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
above, then `tendsto u at_top at_top`. -/
lemma tendsto_at_top_at_top_of_monotone' [preorder Î¹] [linear_order Î±]
  {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_above (range u)) :
  tendsto u at_top at_top :=
begin
  apply h.tendsto_at_top_at_top,
  intro b,
  rcases not_bdd_above_iff.1 H b with âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ©,
  exact âŸ¨N, le_of_lt hNâŸ©,
end

/-- If `u` is a monotone function with linear ordered codomain and the range of `u` is not bounded
below, then `tendsto u at_bot at_bot`. -/
lemma tendsto_at_bot_at_bot_of_monotone' [preorder Î¹] [linear_order Î±]
  {u : Î¹ â†’ Î±} (h : monotone u) (H : Â¬bdd_below (range u)) :
  tendsto u at_bot at_bot :=
@tendsto_at_top_at_top_of_monotone' (order_dual Î¹) (order_dual Î±) _ _ _ h.order_dual H

lemma unbounded_of_tendsto_at_top [nonempty Î±] [semilattice_sup Î±] [preorder Î²] [no_top_order Î²]
  {f : Î± â†’ Î²} (h : tendsto f at_top at_top) :
  Â¬ bdd_above (range f) :=
begin
  rintros âŸ¨M, hMâŸ©,
  cases mem_at_top_sets.mp (h $ Ioi_mem_at_top M) with a ha,
  apply lt_irrefl M,
  calc
  M < f a : ha a (le_refl _)
  ... â‰¤ M : hM (set.mem_range_self a)
end

lemma unbounded_of_tendsto_at_bot [nonempty Î±] [semilattice_sup Î±] [preorder Î²] [no_bot_order Î²]
  {f : Î± â†’ Î²} (h : tendsto f at_top at_bot) :
  Â¬ bdd_below (range f) :=
@unbounded_of_tendsto_at_top _ (order_dual Î²) _ _ _ _ _ h

lemma unbounded_of_tendsto_at_top' [nonempty Î±] [semilattice_inf Î±] [preorder Î²] [no_top_order Î²]
  {f : Î± â†’ Î²} (h : tendsto f at_bot at_top) :
  Â¬ bdd_above (range f) :=
@unbounded_of_tendsto_at_top (order_dual Î±) _ _ _ _ _ _ h

lemma unbounded_of_tendsto_at_bot' [nonempty Î±] [semilattice_inf Î±] [preorder Î²] [no_bot_order Î²]
  {f : Î± â†’ Î²} (h : tendsto f at_bot at_bot) :
  Â¬ bdd_below (range f) :=
@unbounded_of_tendsto_at_top (order_dual Î±) (order_dual Î²) _ _ _ _ _ h

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_top` along *some* non-trivial filter `l`, then
it tends to `at_top` along `at_top`. -/
lemma tendsto_at_top_of_monotone_of_filter [preorder Î¹] [preorder Î±] {l : filter Î¹}
  {u : Î¹ â†’ Î±} (h : monotone u) [ne_bot l] (hu : tendsto u l at_top) :
  tendsto u at_top at_top :=
h.tendsto_at_top_at_top $ Î» b, (hu.eventually (mem_at_top b)).exists

/-- If a monotone function `u : Î¹ â†’ Î±` tends to `at_bot` along *some* non-trivial filter `l`, then
it tends to `at_bot` along `at_bot`. -/
lemma tendsto_at_bot_of_monotone_of_filter [preorder Î¹] [preorder Î±] {l : filter Î¹}
  {u : Î¹ â†’ Î±} (h : monotone u) [ne_bot l] (hu : tendsto u l at_bot) :
  tendsto u at_bot at_bot :=
@tendsto_at_top_of_monotone_of_filter (order_dual Î¹) (order_dual Î±) _ _ _ _ h.order_dual _ hu

lemma tendsto_at_top_of_monotone_of_subseq [preorder Î¹] [preorder Î±] {u : Î¹ â†’ Î±}
  {Ï† : Î¹' â†’ Î¹} (h : monotone u) {l : filter Î¹'} [ne_bot l]
  (H : tendsto (u âˆ˜ Ï†) l at_top) :
  tendsto u at_top at_top :=
tendsto_at_top_of_monotone_of_filter h (tendsto_map' H)

lemma tendsto_at_bot_of_monotone_of_subseq [preorder Î¹] [preorder Î±] {u : Î¹ â†’ Î±}
  {Ï† : Î¹' â†’ Î¹} (h : monotone u) {l : filter Î¹'} [ne_bot l]
  (H : tendsto (u âˆ˜ Ï†) l at_bot) :
  tendsto u at_bot at_bot :=
tendsto_at_bot_of_monotone_of_filter h (tendsto_map' H)

/-- Let `f` and `g` be two maps to the same commutative monoid. This lemma gives a sufficient
condition for comparison of the filter `at_top.map (Î» s, âˆ b in s, f b)` with
`at_top.map (Î» s, âˆ b in s, g b)`. This is useful to compare the set of limit points of
`Î  b in s, f b` as `s â†’ at_top` with the similar set for `g`. -/
@[to_additive]
lemma map_at_top_finset_prod_le_of_prod_eq [comm_monoid Î±] {f : Î² â†’ Î±} {g : Î³ â†’ Î±}
  (h_eq : âˆ€u:finset Î³, âˆƒv:finset Î², âˆ€v', v âŠ† v' â†’ âˆƒu', u âŠ† u' âˆ§ âˆ x in u', g x = âˆ b in v', f b) :
  at_top.map (Î»s:finset Î², âˆ b in s, f b) â‰¤ at_top.map (Î»s:finset Î³, âˆ x in s, g x) :=
by rw [map_at_top_eq, map_at_top_eq];
from (le_infi $ assume b, let âŸ¨v, hvâŸ© := h_eq b in infi_le_of_le v $
  by simp [set.image_subset_iff]; exact hv)

lemma has_antitone_basis.tendsto [semilattice_sup Î¹] [nonempty Î¹] {l : filter Î±}
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (hl : l.has_antitone_basis p s) {Ï† : Î¹ â†’ Î±}
  (h : âˆ€ i : Î¹, Ï† i âˆˆ s i) : tendsto Ï† at_top l  :=
(at_top_basis.tendsto_iff hl.to_has_basis).2 $ assume i hi,
  âŸ¨i, trivial, Î» j hij, hl.decreasing hi (hl.mono hij hi) hij (h j)âŸ©

namespace is_countably_generated

/-- An abstract version of continuity of sequentially continuous functions on metric spaces:
if a filter `k` is countably generated then `tendsto f k l` iff for every sequence `u`
converging to `k`, `f âˆ˜ u` tends to `l`. -/
lemma tendsto_iff_seq_tendsto {f : Î± â†’ Î²} {k : filter Î±} {l : filter Î²}
  (hcb : k.is_countably_generated) :
  tendsto f k l â†” (âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l) :=
suffices (âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l) â†’ tendsto f k l,
  from âŸ¨by intros; apply tendsto.comp; assumption, by assumptionâŸ©,
begin
  obtain âŸ¨g, gbasis, gmon, -âŸ© := hcb.exists_antitone_basis,
  contrapose,
  simp only [not_forall, gbasis.tendsto_left_iff, exists_const, not_exists, not_imp],
  rintro âŸ¨B, hBl, hfBkâŸ©,
  choose x h using hfBk,
  use x, split,
  { exact (at_top_basis.tendsto_iff gbasis).2
      (Î» i _, âŸ¨i, trivial, Î» j hj, gmon trivial trivial hj (h j).1âŸ©) },
  { simp only [tendsto_at_top', (âˆ˜), not_forall, not_exists],
    use [B, hBl],
    intro i, use [i, (le_refl _)],
    apply (h i).right },
end

lemma tendsto_of_seq_tendsto {f : Î± â†’ Î²} {k : filter Î±} {l : filter Î²}
  (hcb : k.is_countably_generated) :
  (âˆ€ x : â„• â†’ Î±, tendsto x at_top k â†’ tendsto (f âˆ˜ x) at_top l) â†’ tendsto f k l :=
hcb.tendsto_iff_seq_tendsto.2

lemma subseq_tendsto {f : filter Î±} (hf : is_countably_generated f)
  {u : â„• â†’ Î±}
  (hx : ne_bot (f âŠ“ map u at_top)) :
  âˆƒ (Î¸ : â„• â†’ â„•), (strict_mono Î¸) âˆ§ (tendsto (u âˆ˜ Î¸) at_top f) :=
begin
  obtain âŸ¨B, hâŸ© := hf.exists_antitone_basis,
  have : âˆ€ N, âˆƒ n â‰¥ N, u n âˆˆ B N,
    from Î» N, filter.inf_map_at_top_ne_bot_iff.mp hx _ (h.to_has_basis.mem_of_mem trivial) N,
  choose Ï† hÏ† using this,
  cases forall_and_distrib.mp hÏ† with Ï†_ge Ï†_in,
  have lim_uÏ† : tendsto (u âˆ˜ Ï†) at_top f,
    from h.tendsto Ï†_in,
  have lim_Ï† : tendsto Ï† at_top at_top,
    from (tendsto_at_top_mono Ï†_ge tendsto_id),
  obtain âŸ¨Ïˆ, hÏˆ, hÏˆÏ†âŸ© : âˆƒ Ïˆ : â„• â†’ â„•, strict_mono Ïˆ âˆ§ strict_mono (Ï† âˆ˜ Ïˆ),
    from strict_mono_subseq_of_tendsto_at_top lim_Ï†,
  exact âŸ¨Ï† âˆ˜ Ïˆ, hÏˆÏ†, lim_uÏ†.comp hÏˆ.tendsto_at_topâŸ©,
end

end is_countably_generated

end filter

open filter finset

section

variables {R : Type*} [linear_ordered_semiring R]

lemma exists_lt_mul_self (a : R) : âˆƒ x â‰¥ 0, a < x * x :=
let âŸ¨x, hxa, hx0âŸ© :=((tendsto_mul_self_at_top.eventually (eventually_gt_at_top a)).and
  (eventually_ge_at_top 0)).exists
in âŸ¨x, hx0, hxaâŸ©

lemma exists_le_mul_self (a : R) : âˆƒ x â‰¥ 0, a â‰¤ x * x :=
let âŸ¨x, hx0, hxaâŸ© := exists_lt_mul_self a in âŸ¨x, hx0, hxa.leâŸ©

end

namespace order_iso

variables [preorder Î±] [preorder Î²]

@[simp] lemma comap_at_top (e : Î± â‰ƒo Î²) : comap e at_top = at_top :=
by simp [at_top, â† e.surjective.infi_comp]

@[simp] lemma comap_at_bot (e : Î± â‰ƒo Î²) : comap e at_bot = at_bot :=
e.dual.comap_at_top

@[simp] lemma map_at_top (e : Î± â‰ƒo Î²) : map â‡‘e at_top = at_top :=
by rw [â† e.comap_at_top, map_comap_of_surjective e.surjective]

@[simp] lemma map_at_bot (e : Î± â‰ƒo Î²) : map â‡‘e at_bot = at_bot :=
e.dual.map_at_top

lemma tendsto_at_top (e : Î± â‰ƒo Î²) : tendsto e at_top at_top :=
e.map_at_top.le

lemma tendsto_at_bot (e : Î± â‰ƒo Î²) : tendsto e at_bot at_bot :=
e.map_at_bot.le

@[simp] lemma tendsto_at_top_iff {l : filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
  tendsto (Î» x, e (f x)) l at_top â†” tendsto f l at_top :=
by rw [â† e.comap_at_top, tendsto_comap_iff]

@[simp] lemma tendsto_at_bot_iff {l : filter Î³} {f : Î³ â†’ Î±} (e : Î± â‰ƒo Î²) :
  tendsto (Î» x, e (f x)) l at_bot â†” tendsto f l at_bot :=
e.dual.tendsto_at_top_iff

end order_iso

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to a commutative monoid. Suppose that `f x = 1` outside of the range of `g`. Then the filters
`at_top.map (Î» s, âˆ i in s, f (g i))` and `at_top.map (Î» s, âˆ i in s, f i)` coincide.

The additive version of this lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
@[to_additive]
lemma function.injective.map_at_top_finset_prod_eq [comm_monoid Î±] {g : Î³ â†’ Î²}
  (hg : function.injective g) {f : Î² â†’ Î±} (hf : âˆ€ x âˆ‰ set.range g, f x = 1) :
  map (Î» s, âˆ i in s, f (g i)) at_top = map (Î» s, âˆ i in s, f i) at_top :=
begin
  apply le_antisymm; refine map_at_top_finset_prod_le_of_prod_eq (Î» s, _),
  { refine âŸ¨s.preimage g (hg.inj_on _), Î» t ht, _âŸ©,
    refine âŸ¨t.image g âˆª s, finset.subset_union_right _ _, _âŸ©,
    rw [â† finset.prod_image (hg.inj_on _)],
    refine (prod_subset (subset_union_left _ _) _).symm,
    simp only [finset.mem_union, finset.mem_image],
    refine Î» y hy hyt, hf y (mt _ hyt),
    rintros âŸ¨x, rflâŸ©,
    exact âŸ¨x, ht (finset.mem_preimage.2 $ hy.resolve_left hyt), rflâŸ© },
  { refine âŸ¨s.image g, Î» t ht, _âŸ©,
    simp only [â† prod_preimage _ _ (hg.inj_on _) _ (Î» x _, hf x)],
    exact âŸ¨_, (image_subset_iff_subset_preimage _).1 ht, rflâŸ© }
end

/-- Let `g : Î³ â†’ Î²` be an injective function and `f : Î² â†’ Î±` be a function from the codomain of `g`
to an additive commutative monoid. Suppose that `f x = 0` outside of the range of `g`. Then the
filters `at_top.map (Î» s, âˆ‘ i in s, f (g i))` and `at_top.map (Î» s, âˆ‘ i in s, f i)` coincide.

This lemma is used to prove the equality `âˆ‘' x, f (g x) = âˆ‘' y, f y` under
the same assumptions.-/
add_decl_doc function.injective.map_at_top_finset_sum_eq
