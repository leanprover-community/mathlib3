/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies
-/
import data.set.pointwise
import order.filter.n_ary
import order.filter.ultrafilter

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Pure filter at `0 : Œ±`, or alternatively principal filter at `0 : set Œ±`.
* `1` (`filter.has_one`): Pure filter at `1 : Œ±`, or alternatively principal filter at `1 : set Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`filter.has_inv`): Inversion, filter of all `s‚Åª¬π` where `s ‚àà f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `s - t` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `s / t` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`filter.has_vadd`): Scalar addition, filter generated by all `s +·µ• t` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `s -·µ• t` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`filter.has_scalar`): Scalar multiplication, filter generated by all `s ‚Ä¢ t` where
  `s ‚àà f` and `t ‚àà g`.
* `a +·µ• f` (`filter.has_vadd_filter`): Translation, filter of all `a +·µ• s` where `s ‚àà f`.
* `a ‚Ä¢ f` (`filter.has_scalar_filter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

## Implementation notes

We put all instances in the locale `pointwise`, so that these instances are not available by
default. Note that we do not mark them as reducible (as argued by note [reducible non-instances])
since we expect the locale to be open whenever the instances are actually used (and making the
instances reducible changes the behavior of `simp`.

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/

open function set
open_locale filter pointwise

variables {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}

namespace filter

/-! ### `0`/`1` as filters -/

section has_one
variables [has_one Œ±] {f : filter Œ±} {s : set Œ±}

/-- `1 : filter Œ±` is defined as the filter of sets containing `1 : Œ±` in locale `pointwise`. -/
@[to_additive "`0 : filter Œ±` is defined as the filter of sets containing `0 : Œ±` in locale
`pointwise`."]
protected def has_one : has_one (filter Œ±) := ‚ü®pure 1‚ü©

localized "attribute [instance] filter.has_one filter.has_zero" in pointwise

@[simp, to_additive] lemma mem_one : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := mem_pure
@[to_additive] lemma one_mem_one : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_pure.2 one_mem_one
@[simp, to_additive] lemma pure_one : pure 1 = (1 : filter Œ±) := rfl
@[simp, to_additive] lemma principal_one : ùìü 1 = (1 : filter Œ±) := principal_singleton _
@[to_additive] lemma one_ne_bot : (1 : filter Œ±).ne_bot := filter.pure_ne_bot
@[simp, to_additive] protected lemma map_one' (f : Œ± ‚Üí Œ≤) : (1 : filter Œ±).map f = pure (f 1) := rfl
@[simp, to_additive] lemma le_one_iff : f ‚â§ 1 ‚Üî (1 : set Œ±) ‚àà f := le_pure_iff
@[simp, to_additive] lemma eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 := eventually_pure
@[simp, to_additive] lemma tendsto_one {a : filter Œ≤} {f : Œ≤ ‚Üí Œ±} :
   tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
tendsto_pure

/-- `pure` as a `one_hom`. -/
@[to_additive "`pure` as a `zero_hom`."]
def pure_one_hom : one_hom Œ± (filter Œ±) := ‚ü®pure, pure_one‚ü©

@[simp, to_additive] lemma coe_pure_one_hom : (pure_one_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_one_hom_apply (a : Œ±) : pure_one_hom a = pure a := rfl

variables [has_one Œ≤]

@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
by rw [filter.map_one', map_one, pure_one]

end has_one

/-! ### Filter negation/inversion -/

section has_inv
variables [has_inv Œ±] {f g : filter Œ±} {s : set Œ±} {a : Œ±}

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : has_inv (filter Œ±) := ‚ü®map has_inv.inv‚ü©

@[simp, to_additive] protected lemma map_inv : f.map has_inv.inv = f‚Åª¬π := rfl
@[to_additive] lemma mem_inv : s ‚àà f‚Åª¬π ‚Üî has_inv.inv ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] protected lemma inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π := map_mono hf
@[simp, to_additive] lemma inv_pure : (pure a : filter Œ±)‚Åª¬π = pure a‚Åª¬π := rfl
@[simp, to_additive] lemma inv_eq_bot_iff : f‚Åª¬π = ‚ä• ‚Üî f = ‚ä•  := map_eq_bot_iff
@[simp, to_additive] lemma ne_bot_inv_iff : f‚Åª¬π.ne_bot ‚Üî ne_bot f := map_ne_bot_iff _
@[to_additive] lemma ne_bot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := Œª h, h.map _

end has_inv

section has_involutive_inv
variables [has_involutive_inv Œ±] {f : filter Œ±} {s : set Œ±}

@[to_additive] lemma inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]

/-- Inversion is involutive on `filter Œ±` if it is on `Œ±`. -/
@[to_additive "Negation is involutive on `filter Œ±` if it is on `Œ±`."]
def has_involutive_inv : has_involutive_inv (filter Œ±) :=
{ inv_inv := Œª f, map_map.trans $ by rw [inv_involutive.comp_self, map_id],
  ..filter.has_inv }

end has_involutive_inv

/-! ### Filter addition/multiplication -/

section has_mul
variables [has_mul Œ±] [has_mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}

/-- The filter `f * g` is generated by `{s * t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f + g` is generated by `{s + t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_mul : has_mul (filter Œ±) :=
/- This is defeq to `map‚ÇÇ (*) f g`, but the hypothesis unfolds to `t‚ÇÅ * t‚ÇÇ ‚äÜ s` rather than all the
way to `set.image2 (*) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (*) f g }‚ü©

localized "attribute [instance] filter.has_mul filter.has_add" in pointwise

@[simp, to_additive] lemma map‚ÇÇ_mul : map‚ÇÇ (*) f g = f * g := rfl
@[to_additive] lemma mem_mul_iff : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_mul : ‚ä• * g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma mul_bot : f * ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma mul_ne_bot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.mul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_mul_left : (f * g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_mul_right : (f * g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_mul : pure a * g = g.map ((*) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma mul_pure : f * pure b = f.map (* b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_mul_pure : (pure a : filter Œ±) * pure b = pure (a * b) := map‚ÇÇ_pure
@[simp, to_additive] lemma le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_mul : covariant_class (filter Œ±) (filter Œ±) (*) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_mul : covariant_class (filter Œ±) (filter Œ±) (swap (*)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
map_map‚ÇÇ_distrib $ map_mul m

/-- `pure` operation as a `mul_hom`. -/
@[to_additive "The singleton operation as an `add_hom`."]
def pure_mul_hom : Œ± ‚Üí‚Çô* filter Œ± := ‚ü®pure, Œª a b, pure_mul_pure.symm‚ü©

@[simp, to_additive] lemma coe_pure_mul_hom : (pure_mul_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_mul_hom_apply (a : Œ±) : pure_mul_hom a = pure a := rfl

end has_mul

/-! ### Filter subtraction/division -/

section div
variables [has_div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}

/-- The filter `f / g` is generated by `{s / t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f - g` is generated by `{s - t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_div : has_div (filter Œ±) :=
/- This is defeq to `map‚ÇÇ (/) f g`, but the hypothesis unfolds to `t‚ÇÅ / t‚ÇÇ ‚äÜ s` rather than all the
way to `set.image2 (/) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (/) f g }‚ü©

localized "attribute [instance] filter.has_div filter.has_sub" in pointwise

@[simp, to_additive] lemma map‚ÇÇ_div : map‚ÇÇ (/) f g = f / g := rfl
@[to_additive] lemma mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_div : ‚ä• / g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma div_bot : f / ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma div_ne_bot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.div : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f / g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_div_left : (f / g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_div_right : (f / g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_div : pure a / g = g.map ((/) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma div_pure : f / pure b = f.map (/ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_div_pure : (pure a : filter Œ±) / pure b = pure (a / b) := map‚ÇÇ_pure
@[to_additive] protected lemma div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] protected lemma div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] protected lemma div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g := map‚ÇÇ_mono_right
@[simp, to_additive] protected lemma le_div_iff :
  h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_div : covariant_class (filter Œ±) (filter Œ±) (/) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_div : covariant_class (filter Œ±) (filter Œ±) (swap (/)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

end div

open_locale pointwise

/-- `filter Œ±` is a `semigroup` under pointwise operations if `Œ±` is.-/
@[to_additive "`filter Œ±` is an `add_semigroup` under pointwise operations if `Œ±` is."]
protected def semigroup [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, map‚ÇÇ_assoc mul_assoc }

/-- `filter Œ±` is a `comm_semigroup` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_semigroup` under pointwise operations if `Œ±` is."]
protected def comm_semigroup [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, map‚ÇÇ_comm mul_comm,
  ..filter.semigroup }

section mul_one_class
variables [mul_one_class Œ±] [mul_one_class Œ≤]

/-- `filter Œ±` is a `mul_one_class` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_zero_class` under pointwise operations if `Œ±` is."]
protected def mul_one_class : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_left, one_mul, map_id'],
  mul_one := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_right, mul_one, map_id'] }

localized "attribute [instance] filter.semigroup filter.add_semigroup filter.comm_semigroup
  filter.add_comm_semigroup filter.mul_one_class filter.add_zero_class" in pointwise

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }

-- The other direction does not hold in general
@[to_additive]
lemma comap_mul_comap_le [mul_hom_class F Œ± Œ≤] (m : F) {f g : filter Œ≤} :
  f.comap m * g.comap m ‚â§ (f * g).comap m  :=
Œª s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©,
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans $ (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
lemma tendsto.mul_mul [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) :=
Œª hf hg, (filter.map_mul m).trans_le $ mul_le_mul' hf hg

/-- `pure` as a `monoid_hom`. -/
@[to_additive "`pure` as an `add_monoid_hom`."]
def pure_monoid_hom : Œ± ‚Üí* filter Œ± := { ..pure_mul_hom, ..pure_one_hom }

@[simp, to_additive] lemma coe_pure_monoid_hom : (pure_monoid_hom : Œ± ‚Üí filter Œ±) = pure := rfl
@[simp, to_additive] lemma pure_monoid_hom_apply (a : Œ±) : pure_monoid_hom a = pure a := rfl

end mul_one_class

section monoid
variables [monoid Œ±] {f g : filter Œ±} {s : set Œ±} {a : Œ±}

/-- `filter Œ±` is a `monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_monoid` under pointwise operations if `Œ±` is."]
protected def monoid : monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.semigroup }

localized "attribute [instance] filter.monoid filter.add_monoid" in pointwise

@[to_additive] lemma pow_mem_pow (hs : s ‚àà f) : ‚àÄ n : ‚Ñï, s ^ n ‚àà f ^ n
| 0 := by { rw pow_zero, exact one_mem_one }
| (n + 1) := by { rw pow_succ, exact mul_mem_mul hs (pow_mem_pow _) }

@[to_additive] protected lemma _root_.is_unit.filter : is_unit a ‚Üí is_unit (pure a : filter Œ±) :=
is_unit.map (pure_monoid_hom : Œ± ‚Üí* filter Œ±)

end monoid

/-- `filter Œ±` is a `comm_monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_monoid` under pointwise operations if `Œ±` is."]
protected def comm_monoid [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }

open_locale pointwise

section division_monoid
variables [division_monoid Œ±] {f g : filter Œ±}

@[to_additive]
protected lemma mul_eq_one_iff : f * g = 1 ‚Üî ‚àÉ a b, f = pure a ‚àß g = pure b ‚àß a * b = 1 :=
begin
  refine ‚ü®Œª hfg, _, _‚ü©,
  { obtain ‚ü®t‚ÇÅ, t‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ü© : (1 : set Œ±) ‚àà f * g := hfg.symm.subst one_mem_one,
    have hfg : (f * g).ne_bot := hfg.symm.subst one_ne_bot,
    rw [(hfg.nonempty_of_mem $ mul_mem_mul h‚ÇÅ h‚ÇÇ).subset_one_iff, set.mul_eq_one_iff] at h,
    obtain ‚ü®a, b, rfl, rfl, h‚ü© := h,
    refine ‚ü®a, b, _, _, h‚ü©,
    { rwa [‚Üêhfg.of_mul_left.le_pure_iff, le_pure_iff] },
    { rwa [‚Üêhfg.of_mul_right.le_pure_iff, le_pure_iff] } },
  { rintro ‚ü®a, b, rfl, rfl, h‚ü©,
    rw [pure_mul_pure, h, pure_one] }
end

/-- `filter Œ±` is a division monoid under pointwise operations if `Œ±` is. -/
@[to_additive subtraction_monoid "`filter Œ±` is a subtraction monoid under pointwise
operations if `Œ±` is."]
protected def division_monoid : division_monoid (filter Œ±) :=
{ mul_inv_rev := Œª s t, map_map‚ÇÇ_antidistrib mul_inv_rev,
  inv_eq_of_mul := Œª s t h, begin
    obtain ‚ü®a, b, rfl, rfl, hab‚ü© := filter.mul_eq_one_iff.1 h,
    rw [inv_pure, inv_eq_of_mul_eq_one_right hab],
  end,
  div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_involutive_inv, ..filter.has_div }

@[to_additive] lemma is_unit_iff : is_unit f ‚Üî ‚àÉ a, f = pure a ‚àß is_unit a :=
begin
  split,
  { rintro ‚ü®u, rfl‚ü©,
    obtain ‚ü®a, b, ha, hb, h‚ü© := filter.mul_eq_one_iff.1 u.mul_inv,
    refine ‚ü®a, ha, ‚ü®a, b, h, pure_injective _‚ü©, rfl‚ü©,
    rw [‚Üêpure_mul_pure, ‚Üêha, ‚Üêhb],
    exact u.inv_mul },
  { rintro ‚ü®a, rfl, ha‚ü©,
    exact ha.filter }
end

end division_monoid

/-- `filter Œ±` is a commutative division monoid under pointwise operations if `Œ±` is. -/
@[to_additive subtraction_comm_monoid "`filter Œ±` is a commutative subtraction monoid under
pointwise operations if `Œ±` is."]
protected def division_comm_monoid [division_comm_monoid Œ±] : division_comm_monoid (filter Œ±) :=
{ ..filter.division_monoid, ..filter.comm_semigroup }

localized "attribute [instance] filter.comm_monoid filter.add_comm_monoid filter.division_monoid
  filter.subtraction_monoid filter.division_comm_monoid filter.subtraction_comm_monoid" in pointwise

section group
variables [group Œ±] [group Œ≤] [monoid_hom_class F Œ± Œ≤] (m : F) {f g f‚ÇÅ g‚ÇÅ : filter Œ±}
  {f‚ÇÇ g‚ÇÇ : filter Œ≤}

/-! Note that `filter Œ±` is not a group because `f / f ‚â† 1` in general -/

@[to_additive] lemma is_unit_pure (a : Œ±) : is_unit (pure a : filter Œ±) := (group.is_unit a).filter

@[simp] lemma is_unit_iff_singleton : is_unit f ‚Üî ‚àÉ a, f = pure a :=
by simp only [is_unit_iff, group.is_unit, and_true]

include Œ≤

@[to_additive] lemma map_inv' : f‚Åª¬π.map m = (f.map m)‚Åª¬π := map_comm (funext $ map_inv m) _

@[to_additive] lemma tendsto.inv_inv : tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π :=
Œª hf, (filter.map_inv' m).trans_le $ filter.inv_le_inv hf

@[to_additive] protected lemma map_div : (f / g).map m = f.map m / g.map m :=
map_map‚ÇÇ_distrib $ map_div m

@[to_additive]
lemma tendsto.div_div : tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
Œª hf hg, (filter.map_div m).trans_le $ filter.div_le_div hf hg

end group

/-! ### Scalar addition/multiplication of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ h : filter Œ≤} {s : set Œ±} {t : set Œ≤}
  {a : Œ±} {b : Œ≤}

/-- The filter `f ‚Ä¢ g` is generated by `{s ‚Ä¢ t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive filter.has_vadd
"The filter `f +·µ• g` is generated by `{s +·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_scalar : has_scalar (filter Œ±) (filter Œ≤) :=
/- This is defeq to `map‚ÇÇ (‚Ä¢) f g`, but the hypothesis unfolds to `t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s` rather than all the
way to `set.image2 (‚Ä¢) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (‚Ä¢) f g }‚ü©

localized "attribute [instance] filter.has_scalar filter.has_vadd" in pointwise

@[simp, to_additive] lemma map‚ÇÇ_smul : map‚ÇÇ (‚Ä¢) f g = f ‚Ä¢ g := rfl
@[to_additive] lemma mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t := iff.rfl
@[to_additive] lemma smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=  image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_smul : (‚ä• : filter Œ±) ‚Ä¢ g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma smul_bot : f ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma smul_ne_bot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.smul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f ‚Ä¢ g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_smul_left : (f ‚Ä¢ g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_smul_right : (f ‚Ä¢ g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_smul : (pure a : filter Œ±) ‚Ä¢ g = g.map ((‚Ä¢) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma smul_pure : f ‚Ä¢ pure b = f.map (‚Ä¢ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_smul_pure :
  (pure a : filter Œ±) ‚Ä¢ (pure b : filter Œ≤) = pure (a ‚Ä¢ b) := map‚ÇÇ_pure
@[to_additive] lemma smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] lemma smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] lemma smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g := map‚ÇÇ_mono_right
@[simp, to_additive] lemma le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_smul : covariant_class (filter Œ±) (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

end smul

/-! ### Scalar subtraction of filters -/

section vsub
variables [has_vsub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h : filter Œ±} {s t : set Œ≤} {a b : Œ≤}
include Œ±

/-- The filter `f -·µ• g` is generated by `{s -·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
protected def has_vsub : has_vsub (filter Œ±) (filter Œ≤) :=
/- This is defeq to `map‚ÇÇ (-·µ•) f g`, but the hypothesis unfolds to `t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s` rather than all
the way to `set.image2 (-·µ•) t‚ÇÅ t‚ÇÇ ‚äÜ s`. -/
‚ü®Œª f g, { sets := {s | ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s}, ..map‚ÇÇ (-·µ•) f g }‚ü©

localized "attribute [instance] filter.has_vsub" in pointwise

@[simp] lemma map‚ÇÇ_vsub : map‚ÇÇ (-·µ•) f g = f -·µ• g := rfl
lemma mem_vsub {s : set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s := iff.rfl
lemma vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=  image2_mem_map‚ÇÇ
@[simp] lemma bot_vsub : (‚ä• : filter Œ≤) -·µ• g = ‚ä• := map‚ÇÇ_bot_left
@[simp] lemma vsub_bot : f -·µ• (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp] lemma vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp] lemma vsub_ne_bot_iff : (f -·µ• g : filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
lemma ne_bot.vsub : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f -·µ• g) := ne_bot.map‚ÇÇ
lemma ne_bot.of_vsub_left : (f -·µ• g : filter Œ±).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
lemma ne_bot.of_vsub_right : (f -·µ• g : filter Œ±).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp] lemma pure_vsub : (pure a : filter Œ≤) -·µ• g = g.map ((-·µ•) a)  := map‚ÇÇ_pure_left
@[simp] lemma vsub_pure : f -·µ• pure b = f.map (-·µ• b)  := map‚ÇÇ_pure_right
@[simp] lemma pure_vsub_pure : (pure a : filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : filter Œ±) :=
map‚ÇÇ_pure
lemma vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ := map‚ÇÇ_mono
lemma vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ := map‚ÇÇ_mono_left
lemma vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g := map‚ÇÇ_mono_right
@[simp] lemma le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h := le_map‚ÇÇ_iff

end vsub

/-! ### Translation/scaling of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ≤} {s : set Œ≤} {a : Œ±}

/-- `a ‚Ä¢ f` is the map of `f` under `a ‚Ä¢` in locale `pointwise`. -/
@[to_additive filter.has_vadd_filter
"`a +·µ• f` is the map of `f` under `a +·µ•` in locale `pointwise`."]
protected def has_scalar_filter : has_scalar Œ± (filter Œ≤) := ‚ü®Œª a, map ((‚Ä¢) a)‚ü©

localized "attribute [instance] filter.has_scalar_filter filter.has_vadd_filter" in pointwise

@[simp, to_additive] lemma map_smul : map (Œª b, a ‚Ä¢ b) f = a ‚Ä¢ f := rfl
@[to_additive] lemma mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (‚Ä¢) a ‚Åª¬π' s ‚àà f := iff.rfl

@[to_additive] lemma smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f := image_mem_map
@[simp, to_additive] lemma smul_filter_bot : a ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map_bot
@[simp, to_additive] lemma smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• := map_eq_bot_iff
@[simp, to_additive] lemma smul_filter_ne_bot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot := map_ne_bot_iff _
@[to_additive] lemma ne_bot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := Œª h, h.map _
@[to_additive] lemma smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
map_mono hf

@[to_additive] instance covariant_smul_filter : covariant_class Œ± (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f, map_mono‚ü©

end smul

open_locale pointwise

@[to_additive]
instance smul_comm_class_filter [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, map_map‚ÇÇ_distrib_right $ smul_comm a‚ü©

@[to_additive]
instance smul_comm_class_filter' [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) Œ≤ (filter Œ≥) :=
by haveI := smul_comm_class.symm Œ± Œ≤ Œ≥; exact smul_comm_class.symm _ _ _

@[to_additive]
instance smul_comm_class [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_left_comm smul_comm‚ü©

instance is_scalar_tower [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª a b f, by simp only [‚Üêmap_smul, map_map, smul_assoc]‚ü©

instance is_scalar_tower' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, by { refine (map_map‚ÇÇ_distrib_left $ Œª _ _, _).symm, exact (smul_assoc a _ _).symm }‚ü©

instance is_scalar_tower'' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_assoc smul_assoc‚ü©

instance is_central_scalar [has_scalar Œ± Œ≤] [has_scalar Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] :
  is_central_scalar Œ± (filter Œ≤) :=
‚ü®Œª a f, congr_arg (Œª m, map m f) $ by exact funext (Œª _, op_smul_eq_smul _ _)‚ü©

@[to_additive]
instance [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤) :=
{ one_smul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_smul, map‚ÇÇ_pure_left, one_smul, map_id'],
  mul_smul := Œª f g h, map‚ÇÇ_assoc mul_smul }

end filter
