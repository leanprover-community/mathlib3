/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies
-/
import data.set.pointwise
import order.filter.n_ary
import order.filter.ultrafilter

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Principal filter at `0 : Œ±`.
* `1` (`filter.has_one`): Principal filter at `1 : Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`filter.has_inv`): Inversion, filter of all `x‚Åª¬π` where `s ‚àà f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `x - y` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `x / y` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`filter.has_vadd`): Scalar addition, filter generated by all `x +·µ• y` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `x -·µ• y` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`filter.has_scalar`): Scalar multiplication, filter generated by all `x ‚Ä¢ y` where
  `s ‚àà f` and `t ‚àà g`.
* `a +·µ• f` (`filter.has_vadd_filter`): Translation, filter of all `a +·µ• x` where `s ‚àà f`.
* `a ‚Ä¢ f` (`filter.has_scalar_filter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

## Implementation notes

We put all instances in the locale `pointwise`, so that these instances are not available by
default. Note that we do not mark them as reducible (as argued by note [reducible non-instances])
since we expect the locale to be open whenever the instances are actually used (and making the
instances reducible changes the behavior of `simp`.

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/

open function set
open_locale filter pointwise

variables {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}

namespace filter

/-! ### `0`/`1` as filters -/

section one
variables [has_one Œ±] {f : filter Œ±} {s : set Œ±}

/-- `1 : filter Œ±` is defined as the filter of sets containing `1 : Œ±` in locale `pointwise`. -/
@[to_additive "`0 : filter Œ±` is defined as the filter of sets containing `0 : Œ±` in locale
`pointwise`."]
protected def has_one : has_one (filter Œ±) := ‚ü®principal 1‚ü©

localized "attribute [instance] filter.has_one filter.has_zero" in pointwise

@[simp, to_additive] lemma mem_one : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := one_subset

@[to_additive] lemma one_mem_one : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_principal_self _

@[simp, to_additive] lemma principal_one : ùìü 1 = (1 : filter Œ±) := rfl
@[simp, to_additive] lemma le_one_iff : f ‚â§ 1 ‚Üî (1 : set Œ±) ‚àà f := le_principal_iff
@[simp, to_additive] lemma pure_one : pure 1 = (1 : filter Œ±) := (principal_singleton _).symm
@[simp, to_additive] lemma eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 :=
by rw [‚Üêpure_one, eventually_pure]
@[simp, to_additive] lemma tendsto_one {a : filter Œ≤} {f : Œ≤ ‚Üí Œ±} :
   tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
by rw [‚Üêpure_one, tendsto_pure]

variables [has_one Œ≤]

@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
le_antisymm
  (le_principal_iff.2 $ mem_map_iff_exists_image.2 ‚ü®1, one_mem_one, Œª x, by simp [map_one œÜ]‚ü©)
  (le_map $ Œª s hs, mem_one.2 ‚ü®1, mem_one.1 hs, map_one œÜ‚ü©)

end one

/-! ### Filter addition/multiplication -/

section mul
variables [has_mul Œ±] [has_mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}

/-- The filter `f * g` is generated by `{s * t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f + g` is generated by `{s + t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_mul : has_mul (filter Œ±) := ‚ü®map‚ÇÇ (*)‚ü©

localized "attribute [instance] filter.has_mul filter.has_add" in pointwise

@[simp, to_additive] lemma map‚ÇÇ_mul : map‚ÇÇ (*) f g = f * g := rfl
@[to_additive] lemma mem_mul_iff : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_mul : ‚ä• * g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma mul_bot : f * ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma mul_ne_bot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.mul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_mul_left : (f * g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_mul_right : (f * g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_mul : pure a * g = g.map ((*) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma mul_pure : f * pure b = f.map (* b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_mul_pure : (pure a : filter Œ±) * pure b = pure (a * b) := map‚ÇÇ_pure
@[simp, to_additive] lemma le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_mul : covariant_class (filter Œ±) (filter Œ±) (*) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_mul : covariant_class (filter Œ±) (filter Œ±) (swap (*)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
map_map‚ÇÇ_distrib $ map_mul m

end mul

open_locale pointwise

/-- `filter Œ±` is a `semigroup` under pointwise operations if `Œ±` is.-/
@[to_additive "`filter Œ±` is an `add_semigroup` under pointwise operations if `Œ±` is."]
protected def semigroup [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, map‚ÇÇ_assoc mul_assoc }

/-- `filter Œ±` is a `comm_semigroup` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_semigroup` under pointwise operations if `Œ±` is."]
protected def comm_semigroup [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, map‚ÇÇ_comm mul_comm,
  ..filter.semigroup }

/-- `filter Œ±` is a `mul_one_class` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_zero_class` under pointwise operations if `Œ±` is."]
protected def mul_one_class [mul_one_class Œ±] : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_left, one_mul, map_id'],
  mul_one := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_right, mul_one, map_id'] }

/-- `filter Œ±` is a `monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_monoid` under pointwise operations if `Œ±` is."]
protected def monoid [monoid Œ±] : monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.semigroup }

/-- `filter Œ±` is a `comm_monoid` under pointwise operations if `Œ±` is. -/
@[to_additive "`filter Œ±` is an `add_comm_monoid` under pointwise operations if `Œ±` is."]
protected def comm_monoid [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }

localized "attribute [instance] filter.mul_one_class filter.add_zero_class filter.semigroup
  filter.add_semigroup filter.comm_semigroup filter.add_comm_semigroup filter.monoid
  filter.add_monoid filter.comm_monoid filter.add_comm_monoid" in pointwise

section map

variables [mul_one_class Œ±] [mul_one_class Œ≤]

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }

-- The other direction does not hold in general.
@[to_additive]
lemma comap_mul_comap_le [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ f‚ÇÇ : filter Œ≤} :
  f‚ÇÅ.comap m * f‚ÇÇ.comap m ‚â§ (f‚ÇÅ * f‚ÇÇ).comap m  :=
Œª s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©,
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans $ (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
lemma tendsto.mul_mul [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) :=
Œª hf hg, (filter.map_mul m).trans_le $ mul_le_mul' hf hg

end map

/-! ### Filter negation/inversion -/

section has_inv
variables [has_inv Œ±] {f g : filter Œ±} {s : set Œ±} {a : Œ±}

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : has_inv (filter Œ±) := ‚ü®map has_inv.inv‚ü©

@[simp, to_additive] protected lemma map_inv : f.map has_inv.inv = f‚Åª¬π := rfl
@[to_additive] lemma mem_inv : s ‚àà f‚Åª¬π ‚Üî has_inv.inv ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] protected lemma inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π := map_mono hf
@[simp, to_additive] lemma inv_pure : (pure a : filter Œ±)‚Åª¬π = pure a‚Åª¬π := rfl
@[simp, to_additive] lemma inv_eq_bot_iff : f‚Åª¬π = ‚ä• ‚Üî f = ‚ä•  := map_eq_bot_iff
@[simp, to_additive] lemma ne_bot_inv_iff : f‚Åª¬π.ne_bot ‚Üî ne_bot f := map_ne_bot_iff _
@[to_additive] lemma ne_bot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := Œª h, h.map _

end has_inv

section has_involutive_inv
variables [has_involutive_inv Œ±] {f : filter Œ±} {s : set Œ±}

@[to_additive] lemma inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]

/-- Inversion is involutive on `filter Œ±` if it is on `Œ±`. -/
@[to_additive "Negation is involutive on `filter Œ±` if it is on `Œ±`."]
def has_involutive_inv : has_involutive_inv (filter Œ±) :=
{ inv_inv := Œª f, map_map.trans $ by rw [inv_involutive.comp_self, map_id],
  ..filter.has_inv }

end has_involutive_inv

section group
variables [group Œ±] [group Œ≤]

@[to_additive]
lemma map_inv' [monoid_hom_class F Œ± Œ≤] (m : F) {f : filter Œ±} : f‚Åª¬π.map m = (f.map m)‚Åª¬π :=
map_comm (funext $ map_inv m) _

@[to_additive]
lemma tendsto.inv_inv [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ  : filter Œ±} {f‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π :=
Œª hf, (filter.map_inv' m).trans_le $ filter.inv_le_inv hf

end group

/-! ### Filter subtraction/division -/

section div
variables [has_div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±} {a b : Œ±}

/-- The filter `f / g` is generated by `{s / t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
@[to_additive "The filter `f - g` is generated by `{s - t | s ‚àà f, t ‚àà g}` in locale `pointwise`."]
protected def has_div : has_div (filter Œ±) := ‚ü®map‚ÇÇ (/)‚ü©

localized "attribute [instance] filter.has_div filter.has_sub" in pointwise

@[simp, to_additive] lemma map‚ÇÇ_div : map‚ÇÇ (/) f g = f / g := rfl
@[to_additive] lemma mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_div : ‚ä• / g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma div_bot : f / ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma div_ne_bot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.div : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f / g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_div_left : (f / g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_div_right : (f / g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_div : pure a / g = g.map ((/) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma div_pure : f / pure b = f.map (/ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_div_pure : (pure a : filter Œ±) / pure b = pure (a / b) := map‚ÇÇ_pure
@[to_additive] protected lemma div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] protected lemma div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] protected lemma div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g := map‚ÇÇ_mono_right
@[simp, to_additive] protected lemma le_div_iff :
  h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_div : covariant_class (filter Œ±) (filter Œ±) (/) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_div : covariant_class (filter Œ±) (filter Œ±) (swap (/)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

end div

open_locale pointwise

section group
variables [group Œ±] [group Œ≤] {f g  : filter Œ±} {f‚ÇÇ : filter Œ≤}

@[to_additive]
protected lemma map_div [monoid_hom_class F Œ± Œ≤] (m : F) : (f / g).map m = f.map m / g.map m :=
map_map‚ÇÇ_distrib $ map_div m

@[to_additive]
lemma tendsto.div_div [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
Œª hf hg, (filter.map_div m).trans_le $ filter.div_le_div hf hg

end group

/-TODO: The below instances are duplicate because there is no typeclass greater than
`div_inv_monoid` and `has_involutive_inv` but smaller than `group` and `group_with_zero`. -/

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
@[to_additive filter.sub_neg_monoid "`f - g = f + -g` for all `f g : filter Œ±` if `a - b = a + -b`
for all `a b : Œ±`."]
protected def div_inv_monoid [group Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
protected def div_inv_monoid' [group_with_zero Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

localized "attribute [instance] filter.div_inv_monoid filter.sub_neg_monoid filter.div_inv_monoid'"
  in pointwise

/-! ### Scalar addition/multiplication of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ h : filter Œ≤} {s : set Œ±} {t : set Œ≤}
  {a : Œ±} {b : Œ≤}

@[to_additive filter.has_vadd] instance : has_scalar (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (‚Ä¢)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_smul : map‚ÇÇ (‚Ä¢) f g = f ‚Ä¢ g := rfl
@[to_additive] lemma mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t := iff.rfl
@[to_additive] lemma smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=  image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_smul : (‚ä• : filter Œ±) ‚Ä¢ g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma smul_bot : f ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma smul_ne_bot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.smul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f ‚Ä¢ g) := ne_bot.map‚ÇÇ
@[to_additive] lemma ne_bot.of_smul_left : (f ‚Ä¢ g).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
@[to_additive] lemma ne_bot.of_smul_right : (f ‚Ä¢ g).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp, to_additive] lemma pure_smul : (pure a : filter Œ±) ‚Ä¢ g = g.map ((‚Ä¢) a)  := map‚ÇÇ_pure_left
@[simp, to_additive] lemma smul_pure : f ‚Ä¢ pure b = f.map (‚Ä¢ b)  := map‚ÇÇ_pure_right
@[simp, to_additive] lemma pure_smul_pure :
  (pure a : filter Œ±) ‚Ä¢ (pure b : filter Œ≤) = pure (a ‚Ä¢ b) := map‚ÇÇ_pure
@[to_additive] lemma smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] lemma smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] lemma smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g := map‚ÇÇ_mono_right
@[simp, to_additive] lemma le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_smul : covariant_class (filter Œ±) (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

end smul

@[to_additive]
instance [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤) :=
{ one_smul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_smul, map‚ÇÇ_pure_left, one_smul, map_id'],
  mul_smul := Œª f g h, map‚ÇÇ_assoc mul_smul }

/-! ### Scalar subtraction of filters -/

section vsub
variables [has_vsub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h : filter Œ±} {s t : set Œ≤} {a b : Œ≤}
include Œ±

/-- The filter `f -·µ• g` is generated by `{s -·µ• t | s ‚àà f, t ‚àà g}` in locale `pointwise`. -/
protected def has_vsub : has_vsub (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (-·µ•)‚ü©

localized "attribute [instance] filter.has_vsub" in pointwise

@[simp] lemma map‚ÇÇ_vsub : map‚ÇÇ (-·µ•) f g = f -·µ• g := rfl
lemma mem_vsub {s : set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s := iff.rfl
lemma vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=  image2_mem_map‚ÇÇ
@[simp] lemma bot_vsub : (‚ä• : filter Œ≤) -·µ• g = ‚ä• := map‚ÇÇ_bot_left
@[simp] lemma vsub_bot : f -·µ• (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp] lemma vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp] lemma vsub_ne_bot_iff : (f -·µ• g : filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
lemma ne_bot.vsub : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f -·µ• g) := ne_bot.map‚ÇÇ
lemma ne_bot.of_vsub_left : (f -·µ• g : filter Œ±).ne_bot ‚Üí f.ne_bot := ne_bot.of_map‚ÇÇ_left
lemma ne_bot.of_vsub_right : (f -·µ• g : filter Œ±).ne_bot ‚Üí g.ne_bot := ne_bot.of_map‚ÇÇ_right
@[simp] lemma pure_vsub : (pure a : filter Œ≤) -·µ• g = g.map ((-·µ•) a)  := map‚ÇÇ_pure_left
@[simp] lemma vsub_pure : f -·µ• pure b = f.map (-·µ• b)  := map‚ÇÇ_pure_right
@[simp] lemma pure_vsub_pure : (pure a : filter Œ≤) -·µ• pure b = (pure (a -·µ• b) : filter Œ±) :=
map‚ÇÇ_pure
lemma vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ := map‚ÇÇ_mono
lemma vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ := map‚ÇÇ_mono_left
lemma vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g := map‚ÇÇ_mono_right
@[simp] lemma le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h := le_map‚ÇÇ_iff

end vsub

/-! ### Translation/scaling of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ≤} {s : set Œ≤} {a : Œ±}

/-- `a ‚Ä¢ f` is the map of `f` under `a ‚Ä¢` in locale `pointwise`. -/
@[to_additive filter.has_vadd_filter
"`a +·µ• f` is the map of `f` under `a +·µ•` in locale `pointwise`."]
protected def has_scalar_filter : has_scalar Œ± (filter Œ≤) := ‚ü®Œª a, map ((‚Ä¢) a)‚ü©

localized "attribute [instance] filter.has_scalar_filter filter.has_vadd_filter" in pointwise

@[simp, to_additive] lemma map_smul : map (Œª b, a ‚Ä¢ b) f = a ‚Ä¢ f := rfl
@[to_additive] lemma mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (‚Ä¢) a ‚Åª¬π' s ‚àà f := iff.rfl

@[to_additive] lemma smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f := image_mem_map
@[simp, to_additive] lemma smul_filter_bot : a ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map_bot
@[simp, to_additive] lemma smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• := map_eq_bot_iff
@[simp, to_additive] lemma smul_filter_ne_bot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot := map_ne_bot_iff _
@[to_additive] lemma ne_bot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := Œª h, h.map _
@[to_additive] lemma smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
map_mono hf

@[to_additive] instance covariant_smul_filter : covariant_class Œ± (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f, map_mono‚ü©

end smul

open_locale pointwise

@[to_additive]
instance smul_comm_class_filter [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, map_map‚ÇÇ_distrib_right $ smul_comm a‚ü©

@[to_additive]
instance smul_comm_class_filter' [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) Œ≤ (filter Œ≥) :=
by haveI := smul_comm_class.symm Œ± Œ≤ Œ≥; exact smul_comm_class.symm _ _ _

@[to_additive]
instance smul_comm_class [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_left_comm smul_comm‚ü©

instance is_scalar_tower [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª a b f, by simp only [‚Üêmap_smul, map_map, smul_assoc]‚ü©

instance is_scalar_tower' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, by { refine (map_map‚ÇÇ_distrib_left $ Œª _ _, _).symm, exact (smul_assoc a _ _).symm }‚ü©

instance is_scalar_tower'' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_assoc smul_assoc‚ü©

instance is_central_scalar [has_scalar Œ± Œ≤] [has_scalar Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] :
  is_central_scalar Œ± (filter Œ≤) :=
‚ü®Œª a f, congr_arg (Œª m, map m f) $ by exact funext (Œª _, op_smul_eq_smul _ _)‚ü©

end filter
