/-
Copyright (c) 2019 Zhouhang Zhou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhouhang Zhou, Ya√´l Dillies
-/
import data.set.pointwise
import order.filter.n_ary

/-!
# Pointwise operations on filters

This file defines pointwise operations on filters. This is useful because usual algebraic operations
distribute over pointwise operations. For example,
* `(f‚ÇÅ * f‚ÇÇ).map m  = f‚ÇÅ.map m * f‚ÇÇ.map m`
* `ùìù (x * y) = ùìù x * ùìù y`

## Main declarations

* `0` (`filter.has_zero`): Principal filter at `0 : Œ±`.
* `1` (`filter.has_one`): Principal filter at `1 : Œ±`.
* `f + g` (`filter.has_add`): Addition, filter generated by all `s + t` where `s ‚àà f` and `t ‚àà g`.
* `f * g` (`filter.has_mul`): Multiplication, filter generated by all `s * t` where `s ‚àà f` and
  `t ‚àà g`.
* `-f` (`filter.has_neg`): Negation, filter of all `-s` where `s ‚àà f`.
* `f‚Åª¬π` (`filter.has_inv`): Inversion, filter of all `x‚Åª¬π` where `s ‚àà f`.
* `f - g` (`filter.has_sub`): Subtraction, filter generated by all `x - y` where `s ‚àà f` and
  `t ‚àà g`.
* `f / g` (`filter.has_div`): Division, filter generated by all `x / y` where `s ‚àà f` and `t ‚àà g`.
* `f +·µ• g` (`filter.has_vadd`): Scalar addition, filter generated by all `x +·µ• y` where `s ‚àà f` and
  `t ‚àà g`.
* `f -·µ• g` (`filter.has_vsub`): Scalar subtraction, filter generated by all `x -·µ• y` where `s ‚àà f`
  and `t ‚àà g`.
* `f ‚Ä¢ g` (`filter.has_smul`): Scalar multiplication, filter generated by all `x ‚Ä¢ y` where `s ‚àà f`
  and `t ‚àà g`.
* `a +·µ• f` (`filter.has_vadd_filter`): Translation, filter of all `a +·µ• x` where `s ‚àà f`.
* `a ‚Ä¢ f` (`filter.has_smul_filter`): Scaling, filter of all `a ‚Ä¢ s` where `s ‚àà f`.

## Tags

filter multiplication, filter addition, pointwise addition, pointwise multiplication,
-/

open function set
open_locale filter pointwise

variables {F Œ± Œ≤ Œ≥ Œ¥ Œµ : Type*}

namespace filter

/-! ### `0`/`1` as filters -/

section one
variables [has_one Œ±] {f : filter Œ±} {s : set Œ±}

/-- `1 : filter Œ±` is the set of sets containing `1 : Œ±`. -/
@[to_additive "`0 : filter Œ±` is the set of sets containing `0 : Œ±`."]
instance : has_one (filter Œ±) := ‚ü®principal 1‚ü©

@[simp, to_additive] lemma mem_one : s ‚àà (1 : filter Œ±) ‚Üî (1 : Œ±) ‚àà s := one_subset

@[to_additive] lemma one_mem_one : (1 : set Œ±) ‚àà (1 : filter Œ±) := mem_principal_self _

@[simp, to_additive] lemma principal_one : ùìü 1 = (1 : filter Œ±) := rfl
@[simp, to_additive] lemma pure_one : pure 1 = (1 : filter Œ±) := (principal_singleton _).symm
@[simp, to_additive] lemma le_one_iff : f ‚â§ 1 ‚Üî (1 : set Œ±) ‚àà f := le_principal_iff
@[simp, to_additive] lemma eventually_one {p : Œ± ‚Üí Prop} : (‚àÄ·∂† x in 1, p x) ‚Üî p 1 :=
by rw [‚Üêpure_one, eventually_pure]
@[simp, to_additive] lemma tendsto_one {a : filter Œ≤} {f : Œ≤ ‚Üí Œ±} :
   tendsto f a 1 ‚Üî ‚àÄ·∂† x in a, f x = 1 :=
by rw [‚Üêpure_one, tendsto_pure]

variables [has_one Œ≤]

@[simp, to_additive]
protected lemma map_one [one_hom_class F Œ± Œ≤] (œÜ : F) : map œÜ 1 = 1 :=
le_antisymm
  (le_principal_iff.2 $ mem_map_iff_exists_image.2 ‚ü®1, one_mem_one, Œª x, by simp [map_one œÜ]‚ü©)
  (le_map $ Œª s hs, mem_one.2 ‚ü®1, mem_one.1 hs, map_one œÜ‚ü©)

end one

/-! ### Filter addition/multiplication -/

section mul
variables [has_mul Œ±] [has_mul Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±}

@[to_additive] instance : has_mul (filter Œ±) := ‚ü®map‚ÇÇ (*)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_mul : map‚ÇÇ (*) f g = f * g := rfl
@[to_additive] lemma mem_mul_iff : s ‚àà f * g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ * t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma mul_mem_mul : s ‚àà f ‚Üí t ‚àà g ‚Üí s * t ‚àà f * g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_mul : ‚ä• * g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma mul_bot : f * ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma mul_eq_bot_iff : f * g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma mul_ne_bot_iff : (f * g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.mul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f * g) := ne_bot.map‚ÇÇ
@[simp, to_additive] lemma le_mul_iff : h ‚â§ f * g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s * t ‚àà h :=
le_map‚ÇÇ_iff

@[to_additive] instance covariant_mul : covariant_class (filter Œ±) (filter Œ±) (*) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_mul : covariant_class (filter Œ±) (filter Œ±) (swap (*)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

@[to_additive]
protected lemma map_mul [mul_hom_class F Œ± Œ≤] (m : F) : (f‚ÇÅ * f‚ÇÇ).map m = f‚ÇÅ.map m * f‚ÇÇ.map m :=
map_map‚ÇÇ_distrib $ map_mul m

end mul

@[to_additive]
instance [semigroup Œ±] : semigroup (filter Œ±) :=
{ mul := (*),
  mul_assoc := Œª f g h, map‚ÇÇ_assoc mul_assoc }

@[to_additive]
instance [comm_semigroup Œ±] : comm_semigroup (filter Œ±) :=
{ mul_comm := Œª f g, map‚ÇÇ_comm mul_comm,
  ..filter.semigroup }

@[to_additive]
instance [mul_one_class Œ±] : mul_one_class (filter Œ±) :=
{ one := 1,
  mul := (*),
  one_mul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_left, one_mul, map_id'],
  mul_one := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_mul, map‚ÇÇ_pure_right, mul_one, map_id'] }

@[to_additive]
instance [monoid Œ±] : monoid (filter Œ±) := { ..filter.mul_one_class, ..filter.semigroup }

@[to_additive]
instance [comm_monoid Œ±] : comm_monoid (filter Œ±) :=
{ ..filter.mul_one_class, ..filter.comm_semigroup }

section map

variables [mul_one_class Œ±] [mul_one_class Œ≤]

/-- If `œÜ : Œ± ‚Üí* Œ≤` then `map_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí* filter Œ≤` induced by `map œÜ`. -/
@[to_additive "If `œÜ : Œ± ‚Üí+ Œ≤` then `map_add_monoid_hom œÜ` is the monoid homomorphism
`filter Œ± ‚Üí+ filter Œ≤` induced by `map œÜ`."]
def map_monoid_hom [monoid_hom_class F Œ± Œ≤] (œÜ : F) : filter Œ± ‚Üí* filter Œ≤ :=
{ to_fun := map œÜ,
  map_one' := filter.map_one œÜ,
  map_mul' := Œª _ _, filter.map_mul œÜ }

-- The other direction does not hold in general.
@[to_additive]
lemma comap_mul_comap_le [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ f‚ÇÇ : filter Œ≤} :
  f‚ÇÅ.comap m * f‚ÇÇ.comap m ‚â§ (f‚ÇÅ * f‚ÇÇ).comap m  :=
Œª s ‚ü®t, ‚ü®t‚ÇÅ, t‚ÇÇ, ht‚ÇÅ, ht‚ÇÇ, t‚ÇÅt‚ÇÇ‚ü©, mt‚ü©,
  ‚ü®m ‚Åª¬π' t‚ÇÅ, m ‚Åª¬π' t‚ÇÇ, ‚ü®t‚ÇÅ, ht‚ÇÅ, subset.rfl‚ü©, ‚ü®t‚ÇÇ, ht‚ÇÇ, subset.rfl‚ü©,
    (preimage_mul_preimage_subset _).trans $ (preimage_mono t‚ÇÅt‚ÇÇ).trans mt‚ü©

@[to_additive]
lemma tendsto.mul_mul [mul_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ * g‚ÇÅ) (f‚ÇÇ * g‚ÇÇ) :=
Œª hf hg, (filter.map_mul m).trans_le $ mul_le_mul' hf hg

end map

/-! ### Filter negation/inversion -/

section has_inv
variables [has_inv Œ±] {f g : filter Œ±} {s : set Œ±}

/-- The inverse of a filter is the pointwise preimage under `‚Åª¬π` of its sets. -/
@[to_additive "The negation of a filter is the pointwise preimage under `-` of its sets."]
instance : has_inv (filter Œ±) := ‚ü®map has_inv.inv‚ü©

@[simp, to_additive] protected lemma map_inv : f.map has_inv.inv = f‚Åª¬π := rfl
@[to_additive] lemma mem_inv : s ‚àà f‚Åª¬π ‚Üî has_inv.inv ‚Åª¬π' s ‚àà f := iff.rfl
@[to_additive] protected lemma inv_le_inv (hf : f ‚â§ g) : f‚Åª¬π ‚â§ g‚Åª¬π := map_mono hf
@[simp, to_additive] lemma ne_bot_inv_iff : f‚Åª¬π.ne_bot ‚Üî ne_bot f := map_ne_bot_iff _
@[to_additive] lemma ne_bot.inv : f.ne_bot ‚Üí f‚Åª¬π.ne_bot := Œª h, h.map _

end has_inv

section has_involutive_inv
variables [has_involutive_inv Œ±] {f : filter Œ±} {s : set Œ±}

@[to_additive] lemma inv_mem_inv (hs : s ‚àà f) : s‚Åª¬π ‚àà f‚Åª¬π := by rwa [mem_inv, inv_preimage, inv_inv]

instance : has_involutive_inv (filter Œ±) :=
{ inv_inv := Œª f, map_map.trans $ by rw [inv_involutive.comp_self, map_id],
  ..filter.has_inv }

end has_involutive_inv

section group
variables [group Œ±] [group Œ≤]

@[to_additive]
lemma map_inv' [monoid_hom_class F Œ± Œ≤] (m : F) {f : filter Œ±} : f‚Åª¬π.map m = (f.map m)‚Åª¬π :=
map_comm (funext $ map_inv m) _

@[to_additive]
lemma tendsto.inv_inv [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ  : filter Œ±} {f‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m f‚ÇÅ‚Åª¬π f‚ÇÇ‚Åª¬π :=
Œª hf, (filter.map_inv' m).trans_le $ filter.inv_le_inv hf

end group

/-! ### Filter subtraction/division -/

section div
variables [has_div Œ±] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ h : filter Œ±} {s t : set Œ±}

@[to_additive] instance : has_div (filter Œ±) := ‚ü®map‚ÇÇ (/)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_div : map‚ÇÇ (/) f g = f / g := rfl
@[to_additive] lemma mem_div : s ‚àà f / g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ / t‚ÇÇ ‚äÜ s := iff.rfl
@[to_additive] lemma div_mem_div : s ‚àà f ‚Üí t ‚àà g ‚Üí s / t ‚àà f / g := image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_div : ‚ä• / g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma div_bot : f / ‚ä• = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma div_eq_bot_iff : f / g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma div_ne_bot_iff : (f / g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.div : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f / g) := ne_bot.map‚ÇÇ
@[simp, to_additive] protected lemma le_div_iff :
  h ‚â§ f / g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s / t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] protected lemma div_le_div : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ / g‚ÇÅ ‚â§ f‚ÇÇ / g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] protected lemma div_le_div_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f / g‚ÇÅ ‚â§ f / g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] protected lemma div_le_div_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ / g ‚â§ f‚ÇÇ / g := map‚ÇÇ_mono_right

@[to_additive] instance covariant_div : covariant_class (filter Œ±) (filter Œ±) (/) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

@[to_additive] instance covariant_swap_div : covariant_class (filter Œ±) (filter Œ±) (swap (/)) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_right‚ü©

end div

section group
variables [group Œ±] [group Œ≤] {f g  : filter Œ±} {f‚ÇÇ : filter Œ≤}

@[to_additive]
protected lemma map_div [monoid_hom_class F Œ± Œ≤] (m : F) : (f / g).map m = f.map m / g.map m :=
map_map‚ÇÇ_distrib $ map_div m

@[to_additive]
lemma tendsto.div_div [monoid_hom_class F Œ± Œ≤] (m : F) {f‚ÇÅ g‚ÇÅ : filter Œ±} {f‚ÇÇ g‚ÇÇ : filter Œ≤} :
  tendsto m f‚ÇÅ f‚ÇÇ ‚Üí tendsto m g‚ÇÅ g‚ÇÇ ‚Üí tendsto m (f‚ÇÅ / g‚ÇÅ) (f‚ÇÇ / g‚ÇÇ) :=
Œª hf hg, (filter.map_div m).trans_le $ filter.div_le_div hf hg

end group

/-TODO: The below instances are duplicate because there is no typeclass greater than
`div_inv_monoid` and `has_involutive_inv` but smaller than `group` and `group_with_zero`. -/

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
@[to_additive "`f - g = f + -g` for all `f g : filter Œ±` if `a - b = a + -b` for all `a b : Œ±`."]
instance div_inv_monoid [group Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

/-- `f / g = f * g‚Åª¬π` for all `f g : filter Œ±` if `a / b = a * b‚Åª¬π` for all `a b : Œ±`. -/
instance div_inv_monoid' [group_with_zero Œ±] : div_inv_monoid (filter Œ±) :=
{ div_eq_mul_inv := Œª f g, map_map‚ÇÇ_distrib_right div_eq_mul_inv,
  ..filter.monoid, ..filter.has_inv, ..filter.has_div }

/-! ### Scalar addition/multiplication of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ±} {g g‚ÇÅ g‚ÇÇ h : filter Œ≤} {s : set Œ±} {t : set Œ≤}

@[to_additive filter.has_vadd] instance : has_scalar (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (‚Ä¢)‚ü©

@[simp, to_additive] lemma map‚ÇÇ_smul : map‚ÇÇ (‚Ä¢) f g = f ‚Ä¢ g := rfl
@[to_additive] lemma mem_smul : t ‚àà f ‚Ä¢ g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ ‚Ä¢ t‚ÇÇ ‚äÜ t := iff.rfl
@[to_additive] lemma smul_mem_smul : s ‚àà f ‚Üí t ‚àà g ‚Üí s ‚Ä¢ t ‚àà f ‚Ä¢ g :=  image2_mem_map‚ÇÇ
@[simp, to_additive] lemma bot_smul : (‚ä• : filter Œ±) ‚Ä¢ g = ‚ä• := map‚ÇÇ_bot_left
@[simp, to_additive] lemma smul_bot : f ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp, to_additive] lemma smul_eq_bot_iff : f ‚Ä¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp, to_additive] lemma smul_ne_bot_iff : (f ‚Ä¢ g).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
@[to_additive] lemma ne_bot.smul : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f ‚Ä¢ g) := ne_bot.map‚ÇÇ
@[simp, to_additive] lemma le_smul_iff : h ‚â§ f ‚Ä¢ g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s ‚Ä¢ t ‚àà h :=
le_map‚ÇÇ_iff
@[to_additive] lemma smul_le_smul : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g‚ÇÅ ‚â§ f‚ÇÇ ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono
@[to_additive] lemma smul_le_smul_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f ‚Ä¢ g‚ÇÅ ‚â§ f ‚Ä¢ g‚ÇÇ := map‚ÇÇ_mono_left
@[to_additive] lemma smul_le_smul_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ ‚Ä¢ g ‚â§ f‚ÇÇ ‚Ä¢ g := map‚ÇÇ_mono_right

@[to_additive] instance covariant_smul : covariant_class (filter Œ±) (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f g h, map‚ÇÇ_mono_left‚ü©

end smul

@[to_additive]
instance [monoid Œ±] [mul_action Œ± Œ≤] : mul_action (filter Œ±) (filter Œ≤) :=
{ one_smul := Œª f, by simp only [‚Üêpure_one, ‚Üêmap‚ÇÇ_smul, map‚ÇÇ_pure_left, one_smul, map_id'],
  mul_smul := Œª f g h, map‚ÇÇ_assoc mul_smul }

/-! ### Scalar subtraction of filters -/

section vsub
variables [has_vsub Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ g g‚ÇÅ g‚ÇÇ : filter Œ≤} {h : filter Œ±} {s t : set Œ≤}
include Œ±

instance : has_vsub (filter Œ±) (filter Œ≤) := ‚ü®map‚ÇÇ (-·µ•)‚ü©

@[simp] lemma map‚ÇÇ_vsub : map‚ÇÇ (-·µ•) f g = f -·µ• g := rfl
lemma mem_vsub {s : set Œ±} : s ‚àà f -·µ• g ‚Üî ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ ‚àà f ‚àß t‚ÇÇ ‚àà g ‚àß t‚ÇÅ -·µ• t‚ÇÇ ‚äÜ s := iff.rfl
lemma vsub_mem_vsub : s ‚àà f ‚Üí t ‚àà g ‚Üí s -·µ• t ‚àà f -·µ• g :=  image2_mem_map‚ÇÇ
@[simp] lemma bot_vsub : (‚ä• : filter Œ≤) -·µ• g = ‚ä• := map‚ÇÇ_bot_left
@[simp] lemma vsub_bot : f -·µ• (‚ä• : filter Œ≤) = ‚ä• := map‚ÇÇ_bot_right
@[simp] lemma vsub_eq_bot_iff : f -·µ• g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := map‚ÇÇ_eq_bot_iff
@[simp] lemma vsub_ne_bot_iff : (f -·µ• g : filter Œ±).ne_bot ‚Üî f.ne_bot ‚àß g.ne_bot := map‚ÇÇ_ne_bot_iff
lemma ne_bot.vsub : ne_bot f ‚Üí ne_bot g ‚Üí ne_bot (f -·µ• g) := ne_bot.map‚ÇÇ
@[simp] lemma le_vsub_iff : h ‚â§ f -·µ• g ‚Üî ‚àÄ ‚¶És‚¶Ñ, s ‚àà f ‚Üí ‚àÄ ‚¶Ét‚¶Ñ, t ‚àà g ‚Üí s -·µ• t ‚àà h := le_map‚ÇÇ_iff
lemma vsub_le_vsub : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f‚ÇÅ -·µ• g‚ÇÅ ‚â§ f‚ÇÇ -·µ• g‚ÇÇ := map‚ÇÇ_mono
lemma vsub_le_vsub_left : g‚ÇÅ ‚â§ g‚ÇÇ ‚Üí f -·µ• g‚ÇÅ ‚â§ f -·µ• g‚ÇÇ := map‚ÇÇ_mono_left
lemma vsub_le_vsub_right : f‚ÇÅ ‚â§ f‚ÇÇ ‚Üí f‚ÇÅ -·µ• g ‚â§ f‚ÇÇ -·µ• g := map‚ÇÇ_mono_right

end vsub

/-! ### Translation/scaling of filters -/

section smul
variables [has_scalar Œ± Œ≤] {f f‚ÇÅ f‚ÇÇ : filter Œ≤} {s : set Œ≤} {a : Œ±}

@[to_additive filter.has_vadd_filter]
instance has_scalar_filter : has_scalar Œ± (filter Œ≤) := ‚ü®Œª a, map ((‚Ä¢) a)‚ü©

@[simp, to_additive] lemma map_smul : map (Œª b, a ‚Ä¢ b) f = a ‚Ä¢ f := rfl
@[to_additive] lemma mem_smul_filter : s ‚àà a ‚Ä¢ f ‚Üî (‚Ä¢) a ‚Åª¬π' s ‚àà f := iff.rfl

@[to_additive] lemma smul_set_mem_smul_filter : s ‚àà f ‚Üí a ‚Ä¢ s ‚àà a ‚Ä¢ f := image_mem_map
@[simp, to_additive] lemma smul_filter_bot : a ‚Ä¢ (‚ä• : filter Œ≤) = ‚ä• := map_bot
@[simp, to_additive] lemma smul_filter_eq_bot_iff : a ‚Ä¢ f = ‚ä• ‚Üî f = ‚ä• := map_eq_bot_iff
@[simp, to_additive] lemma smul_filter_ne_bot_iff : (a ‚Ä¢ f).ne_bot ‚Üî f.ne_bot := map_ne_bot_iff _
@[to_additive] lemma ne_bot.smul_filter : f.ne_bot ‚Üí (a ‚Ä¢ f).ne_bot := Œª h, h.map _
@[to_additive] lemma smul_filter_le_smul_filter (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : a ‚Ä¢ f‚ÇÅ ‚â§ a ‚Ä¢ f‚ÇÇ :=
map_mono hf

@[to_additive] instance covariant_smul_filter : covariant_class Œ± (filter Œ≤) (‚Ä¢) (‚â§) :=
‚ü®Œª f, map_mono‚ü©

end smul

@[to_additive]
instance smul_comm_class_filter [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, map_map‚ÇÇ_distrib_right $ smul_comm a‚ü©

@[to_additive]
instance smul_comm_class_filter' [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) Œ≤ (filter Œ≥) :=
by haveI := smul_comm_class.symm Œ± Œ≤ Œ≥; exact smul_comm_class.symm _ _ _

@[to_additive]
instance smul_comm_class [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥] [smul_comm_class Œ± Œ≤ Œ≥] :
  smul_comm_class (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_left_comm smul_comm‚ü©

instance is_scalar_tower [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± Œ≤ (filter Œ≥) :=
‚ü®Œª a b f, by simp only [‚Üêmap_smul, map_map, smul_assoc]‚ü©

instance is_scalar_tower' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower Œ± (filter Œ≤) (filter Œ≥) :=
‚ü®Œª a f g, by { refine (map_map‚ÇÇ_distrib_left $ Œª _ _, _).symm, exact (smul_assoc a _ _).symm }‚ü©

instance is_scalar_tower'' [has_scalar Œ± Œ≤] [has_scalar Œ± Œ≥] [has_scalar Œ≤ Œ≥]
  [is_scalar_tower Œ± Œ≤ Œ≥] :
  is_scalar_tower (filter Œ±) (filter Œ≤) (filter Œ≥) :=
‚ü®Œª f g h, map‚ÇÇ_assoc smul_assoc‚ü©

instance is_central_scalar [has_scalar Œ± Œ≤] [has_scalar Œ±·µê·µí·µñ Œ≤] [is_central_scalar Œ± Œ≤] :
  is_central_scalar Œ± (filter Œ≤) :=
‚ü®Œª a f, congr_arg (Œª m, map m f) $ by exact funext (Œª _, op_smul_eq_smul _ _)‚ü©

end filter
