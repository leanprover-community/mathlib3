/-
Copyright (c) 2020 David WÃ¤rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David WÃ¤rn
-/
import data.equiv.encodable.basic
import order.atoms

/-!
# Order ideals, cofinal sets, and the Rasiowaâ€“Sikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `order.ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `order.is_ideal P`: a predicate for when a `set P` is an ideal.
- `order.ideal.principal p`: the principal ideal generated by `p : P`.
- `order.ideal.is_proper P`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `order.ideal.is_maximal`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `ideal_inter_nonempty P`: a predicate for when the intersection of any two ideals of
  `P` is nonempty.
- `ideal_Inter_nonempty P`: a predicate for when the intersection of all ideals of
  `P` is nonempty.
- `order.cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `order.ideal_of_cofinals p ğ’Ÿ`, where `p : P`, and `ğ’Ÿ` is a countable family of cofinal
  subsets of P: an ideal in `P` which contains `p` and intersects every set in `ğ’Ÿ`. (This a form
  of the Rasiowaâ€“Sikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowaâ€“Sikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## Tags

ideal, cofinal, dense, countable, generic

-/

namespace order

variables {P : Type*}

/-- An ideal on a preorder `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure ideal (P) [preorder P] :=
(carrier   : set P)
(nonempty  : carrier.nonempty)
(directed  : directed_on (â‰¤) carrier)
(mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ carrier â†’ x âˆˆ carrier)

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mk_iff] structure is_ideal {P} [preorder P] (I : set P) : Prop :=
(nonempty : I.nonempty)
(directed : directed_on (â‰¤) I)
(mem_of_le : âˆ€ {x y : P}, x â‰¤ y â†’ y âˆˆ I â†’ x âˆˆ I)

/-- Create an element of type `order.ideal` from a set satisfying the predicate
`order.is_ideal`. -/
def is_ideal.to_ideal [preorder P] {I : set P} (h : is_ideal I) : ideal P :=
âŸ¨I, h.1, h.2, h.3âŸ©

namespace ideal

section preorder
variables [preorder P] {x y : P} {I J : ideal P}

/-- The smallest ideal containing a given element. -/
def principal (p : P) : ideal P :=
{ carrier   := { x | x â‰¤ p },
  nonempty  := âŸ¨p, le_refl _âŸ©,
  directed  := Î» x hx y hy, âŸ¨p, le_refl _, hx, hyâŸ©,
  mem_of_le := Î» x y hxy hy, le_trans hxy hy, }

instance [inhabited P] : inhabited (ideal P) :=
âŸ¨ideal.principal $ default PâŸ©

/-- An ideal of `P` can be viewed as a subset of `P`. -/
instance : has_coe (ideal P) (set P) := âŸ¨carrierâŸ©

/-- For the notation `x âˆˆ I`. -/
instance : has_mem P (ideal P) := âŸ¨Î» x I, x âˆˆ (I : set P)âŸ©

@[simp] lemma mem_coe : x âˆˆ (I : set P) â†” x âˆˆ I := iff_of_eq rfl

@[simp] lemma mem_principal : x âˆˆ principal y â†” x â‰¤ y := by refl

/-- Two ideals are equal when their underlying sets are equal. -/
@[ext] lemma ext : âˆ€ (I J : ideal P), (I : set P) = J â†’ I = J
| âŸ¨_, _, _, _âŸ© âŸ¨_, _, _, _âŸ© rfl := rfl

@[simp, norm_cast] lemma ext_set_eq {I J : ideal P} : (I : set P) = J â†” I = J :=
âŸ¨by ext, congr_arg _âŸ©

lemma ext'_iff {I J : ideal P} : I = J â†” (I : set P) = J := ext_set_eq.symm

lemma is_ideal (I : ideal P) : is_ideal (I : set P) := âŸ¨I.2, I.3, I.4âŸ©

/-- The partial ordering by subset inclusion, inherited from `set P`. -/
instance : partial_order (ideal P) := partial_order.lift coe ext

@[trans] lemma mem_of_mem_of_le : x âˆˆ I â†’ I â‰¤ J â†’ x âˆˆ J :=
@set.mem_of_mem_of_subset P x I J

@[simp] lemma principal_le_iff : principal x â‰¤ I â†” x âˆˆ I :=
âŸ¨Î» (h : âˆ€ {y}, y â‰¤ x â†’ y âˆˆ I), h (le_refl x),
 Î» h_mem y (h_le : y â‰¤ x), I.mem_of_le h_le h_memâŸ©

lemma mem_compl_of_ge {x y : P} : x â‰¤ y â†’ x âˆˆ (I : set P)á¶œ â†’ y âˆˆ (I : set P)á¶œ :=
Î» h, mt (I.mem_of_le h)

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mk_iff] class is_proper (I : ideal P) : Prop := (ne_univ : (I : set P) â‰  set.univ)

lemma is_proper_of_not_mem {I : ideal P} {p : P} (nmem : p âˆ‰ I) : is_proper I :=
âŸ¨Î» hp, begin
  change p âˆ‰ â†‘I at nmem,
  rw hp at nmem,
  exact nmem (set.mem_univ p),
endâŸ©

/-- An ideal is maximal if it is maximal in the collection of proper ideals.
  Note that we cannot use the `is_coatom` class because `P` might not have a `top` element.
-/
@[mk_iff] class is_maximal (I : ideal P) extends is_proper I : Prop :=
(maximal_proper : âˆ€ â¦ƒJ : ideal Pâ¦„, I < J â†’ (J : set P) = set.univ)

variable (P)

/-- A preorder `P` has the `ideal_inter_nonempty` property if the
    intersection of any two ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a lattice.
-/
class ideal_inter_nonempty : Prop :=
(inter_nonempty : âˆ€ (I J : ideal P), ((I : set P) âˆ© (J : set P)).nonempty)

/-- A preorder `P` has the `ideal_Inter_nonempty` property if the
    intersection of all ideals is nonempty.
    Most importantly, a `semilattice_sup` preorder with this property
    satisfies that its ideal poset is a complete lattice.
-/
class ideal_Inter_nonempty : Prop :=
(Inter_nonempty : (â‹‚ (I : ideal P), (I : set P)).nonempty)

variable {P}

lemma inter_nonempty [ideal_inter_nonempty P] :
  âˆ€ (I J : ideal P), ((I : set P) âˆ© (J : set P)).nonempty :=
ideal_inter_nonempty.inter_nonempty

lemma Inter_nonempty [ideal_Inter_nonempty P] :
  (â‹‚ (I : ideal P), (I : set P)).nonempty :=
ideal_Inter_nonempty.Inter_nonempty

lemma ideal_Inter_nonempty.exists_all_mem [ideal_Inter_nonempty P] :
  âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I :=
begin
  change âˆƒ (a : P), âˆ€ (I : ideal P), a âˆˆ (I : set P),
  rw â† set.nonempty_Inter,
  exact Inter_nonempty,
end

lemma ideal_Inter_nonempty_of_exists_all_mem (h : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I) :
  ideal_Inter_nonempty P :=
{ Inter_nonempty := by rwa set.nonempty_Inter }

lemma ideal_Inter_nonempty_iff :
  ideal_Inter_nonempty P â†” âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I :=
âŸ¨Î» _, by exactI ideal_Inter_nonempty.exists_all_mem, ideal_Inter_nonempty_of_exists_all_memâŸ©

end preorder

section order_bot
variables [order_bot P] {I : ideal P}

/-- A specific witness of `I.nonempty` when `P` has a bottom element. -/
@[simp] lemma bot_mem : âŠ¥ âˆˆ I :=
I.mem_of_le bot_le I.nonempty.some_mem

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : order_bot (ideal P) :=
{ bot := principal âŠ¥,
  bot_le := by simp,
  .. ideal.partial_order }

@[priority 100]
instance order_bot.ideal_Inter_nonempty : ideal_Inter_nonempty P :=
by { rw ideal_Inter_nonempty_iff, exact âŸ¨âŠ¥, Î» I, bot_memâŸ© }

end order_bot

section order_top

variables [order_top P]

/-- There is a top ideal when `P` has a top element. -/
instance : order_top (ideal P) :=
{ top := principal âŠ¤,
  le_top := Î» I x h, le_top,
  .. ideal.partial_order }

@[simp] lemma coe_top : ((âŠ¤ : ideal P) : set P) = set.univ :=
set.univ_subset_iff.1 (Î» p _, le_top)

lemma top_of_mem_top {I : ideal P} (mem_top : âŠ¤ âˆˆ I) : I = âŠ¤ :=
begin
  ext,
  change x âˆˆ I â†” x âˆˆ ((âŠ¤ : ideal P) : set P),
  split,
  { simp [coe_top] },
  { exact Î» _, I.mem_of_le le_top mem_top }
end

lemma is_proper_of_ne_top {I : ideal P} (ne_top : I â‰  âŠ¤) : is_proper I :=
is_proper_of_not_mem (Î» h, ne_top (top_of_mem_top h))

lemma is_proper.ne_top {I : ideal P} (hI : is_proper I) : I â‰  âŠ¤ :=
begin
  intro h,
  rw [ext'_iff, coe_top] at h,
  apply hI.ne_univ,
  assumption,
end

lemma is_proper.top_not_mem {I : ideal P} (hI : is_proper I) : âŠ¤ âˆ‰ I :=
by { by_contra, exact hI.ne_top (top_of_mem_top h) }

lemma _root_.is_coatom.is_proper {I : ideal P} (hI : is_coatom I) : is_proper I :=
is_proper_of_ne_top hI.1

lemma is_proper_iff_ne_top {I : ideal P} : is_proper I â†” I â‰  âŠ¤ :=
âŸ¨Î» h, h.ne_top, Î» h, is_proper_of_ne_top hâŸ©

lemma is_maximal.is_coatom {I : ideal P} (h : is_maximal I) : is_coatom I :=
âŸ¨is_maximal.to_is_proper.ne_top,
 Î» _ _, by { rw [ext'_iff, coe_top], exact is_maximal.maximal_proper â€¹_â€º }âŸ©

lemma is_maximal.is_coatom' {I : ideal P} [is_maximal I] : is_coatom I :=
is_maximal.is_coatom â€¹_â€º

lemma _root_.is_coatom.is_maximal {I : ideal P} (hI : is_coatom I) : is_maximal I :=
{ maximal_proper := Î» _ _, by simp [hI.2 _ â€¹_â€º],
  ..is_coatom.is_proper â€¹_â€º }

lemma is_maximal_iff_is_coatom {I : ideal P} : is_maximal I â†” is_coatom I :=
âŸ¨Î» h, h.is_coatom, Î» h, h.is_maximalâŸ©

end order_top

section semilattice_sup
variables [semilattice_sup P] {x y : P} {I : ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
lemma sup_mem (x y âˆˆ I) : x âŠ” y âˆˆ I :=
let âŸ¨z, h_mem, hx, hyâŸ© := I.directed x â€¹_â€º y â€¹_â€º in
I.mem_of_le (sup_le hx hy) h_mem

@[simp] lemma sup_mem_iff : x âŠ” y âˆˆ I â†” x âˆˆ I âˆ§ y âˆˆ I :=
âŸ¨Î» h, âŸ¨I.mem_of_le le_sup_left h, I.mem_of_le le_sup_right hâŸ©,
 Î» h, sup_mem x y h.left h.rightâŸ©

end semilattice_sup

section semilattice_sup_ideal_inter_nonempty

variables [semilattice_sup P] [ideal_inter_nonempty P] {x : P} {I J K : ideal P}

/-- The intersection of two ideals is an ideal, when it is nonempty and `P` has joins. -/
def inf (I J : ideal P) : ideal P :=
{ carrier   := I âˆ© J,
  nonempty  := inter_nonempty I J,
  directed  := Î» x âŸ¨_, _âŸ© y âŸ¨_, _âŸ©, âŸ¨x âŠ” y, âŸ¨sup_mem x y â€¹_â€º â€¹_â€º, sup_mem x y â€¹_â€º â€¹_â€ºâŸ©, by simpâŸ©,
  mem_of_le := Î» x y h âŸ¨_, _âŸ©, âŸ¨mem_of_le I h â€¹_â€º, mem_of_le J h â€¹_â€ºâŸ© }

/-- There is a smallest ideal containing two ideals, when their intersection is nonempty and
    `P` has joins. -/
def sup (I J : ideal P) : ideal P :=
{ carrier   := {x | âˆƒ (i âˆˆ I) (j âˆˆ J), x â‰¤ i âŠ” j},
  nonempty  := by { cases inter_nonempty I J, exact âŸ¨w, w, h.1, w, h.2, le_sup_leftâŸ© },
  directed  := Î» x âŸ¨xi, _, xj, _, _âŸ© y âŸ¨yi, _, yj, _, _âŸ©,
    âŸ¨x âŠ” y,
     âŸ¨xi âŠ” yi, sup_mem xi yi â€¹_â€º â€¹_â€º,
      xj âŠ” yj, sup_mem xj yj â€¹_â€º â€¹_â€º,
      sup_le
        (calc x â‰¤ xi âŠ” xj               : â€¹_â€º
         ...    â‰¤ (xi âŠ” yi) âŠ” (xj âŠ” yj) : sup_le_sup le_sup_left le_sup_left)
        (calc y â‰¤ yi âŠ” yj               : â€¹_â€º
         ...    â‰¤ (xi âŠ” yi) âŠ” (xj âŠ” yj) : sup_le_sup le_sup_right le_sup_right)âŸ©,
     le_sup_left, le_sup_rightâŸ©,
  mem_of_le := Î» x y _ âŸ¨yi, _, yj, _, _âŸ©, âŸ¨yi, â€¹_â€º, yj, â€¹_â€º, le_trans â€¹x â‰¤ yâ€º â€¹_â€ºâŸ© }

lemma sup_le : I â‰¤ K â†’ J â‰¤ K â†’ sup I J â‰¤ K :=
Î» hIK hJK x âŸ¨i, hiI, j, hjJ, hxijâŸ©,
K.mem_of_le hxij $ sup_mem i j (mem_of_mem_of_le hiI hIK) (mem_of_mem_of_le hjJ hJK)

instance : lattice (ideal P) :=
{ sup          := sup,
  le_sup_left  := Î» I J (i âˆˆ I), by { cases nonempty J, exact âŸ¨i, â€¹_â€º, w, â€¹_â€º, le_sup_leftâŸ© },
  le_sup_right := Î» I J (j âˆˆ J), by { cases nonempty I, exact âŸ¨w, â€¹_â€º, j, â€¹_â€º, le_sup_rightâŸ© },
  sup_le       := @sup_le _ _ _,
  inf          := inf,
  inf_le_left  := Î» I J, set.inter_subset_left I J,
  inf_le_right := Î» I J, set.inter_subset_right I J,
  le_inf       := Î» I J K, set.subset_inter,
  .. ideal.partial_order }

@[simp] lemma mem_inf : x âˆˆ I âŠ“ J â†” x âˆˆ I âˆ§ x âˆˆ J := iff_of_eq rfl

@[simp] lemma mem_sup : x âˆˆ I âŠ” J â†” âˆƒ (i âˆˆ I) (j âˆˆ J), x â‰¤ i âŠ” j := iff_of_eq rfl

lemma lt_sup_principal_of_not_mem (hx : x âˆ‰ I) : I < I âŠ” principal x :=
begin
  apply lt_of_le_of_ne le_sup_left,
  intro h,
  simp at h,
  exact hx h
end

end semilattice_sup_ideal_inter_nonempty

section ideal_Inter_nonempty

variables [preorder P] [ideal_Inter_nonempty P]

@[priority 100]
instance ideal_Inter_nonempty.ideal_inter_nonempty : ideal_inter_nonempty P :=
{ inter_nonempty := Î» _ _, begin
    obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem,
    exact âŸ¨a, ha _, ha _âŸ©
  end }

variables {Î± Î² Î³ : Type*} {Î¹ : Sort*}

lemma ideal_Inter_nonempty.all_Inter_nonempty {f : Î¹ â†’ ideal P} :
  (â‹‚ x, (f x : set P)).nonempty :=
begin
  obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem,
  exact âŸ¨a, by simp [ha]âŸ©
end

lemma ideal_Inter_nonempty.all_bInter_nonempty {f : Î± â†’ ideal P} {s : set Î±} :
  (â‹‚ x âˆˆ s, (f x : set P)).nonempty :=
begin
  obtain âŸ¨a, haâŸ© : âˆƒ a : P, âˆ€ I : ideal P, a âˆˆ I := ideal_Inter_nonempty.exists_all_mem,
  exact âŸ¨a, by simp [ha]âŸ©
end

end ideal_Inter_nonempty

section semilattice_sup_ideal_Inter_nonempty

variables [semilattice_sup P] [ideal_Inter_nonempty P] {x : P} {I J K : ideal P}

instance : has_Inf (ideal P) :=
{ Inf := Î» s, { carrier := â‹‚ (I âˆˆ s), (I : set P),
  nonempty := ideal_Inter_nonempty.all_bInter_nonempty,
  directed := Î» x hx y hy, âŸ¨x âŠ” y, âŸ¨Î» S âŸ¨I, hSâŸ©,
    begin
      simp only [â†hS, sup_mem_iff, mem_coe, set.mem_Inter],
      intro hI,
      rw set.mem_bInter_iff at *,
      exact âŸ¨hx _ hI, hy _ hIâŸ©
    end,
    le_sup_left, le_sup_rightâŸ©âŸ©,
  mem_of_le := Î» x y hxy hy,
    begin
      rw set.mem_bInter_iff at *,
      exact Î» I hI, mem_of_le I â€¹_â€º (hy I hI)
    end } }

variables {s : set (ideal P)}

@[simp] lemma mem_Inf : x âˆˆ Inf s â†” âˆ€ I âˆˆ s, x âˆˆ I :=
by { change x âˆˆ (â‹‚ (I âˆˆ s), (I : set P)) â†” âˆ€ I âˆˆ s, x âˆˆ I, simp }

@[simp] lemma coe_Inf : â†‘(Inf s) = â‹‚ (I âˆˆ s), (I : set P) := rfl

lemma Inf_le (hI : I âˆˆ s) : Inf s â‰¤ I :=
Î» _ hx, hx I âŸ¨I, by simp [hI]âŸ©

lemma le_Inf (h : âˆ€ J âˆˆ s, I â‰¤ J) : I â‰¤ Inf s :=
Î» _ _, by { simp only [mem_coe, coe_Inf, set.mem_Inter], tauto }

lemma is_glb_Inf : is_glb s (Inf s) := âŸ¨Î» _, Inf_le, Î» _, le_InfâŸ©

instance : complete_lattice (ideal P) :=
{ ..ideal.lattice,
  ..complete_lattice_of_Inf (ideal P) (Î» _, @is_glb_Inf _ _ _ _) }

end semilattice_sup_ideal_Inter_nonempty

section semilattice_inf

variable [semilattice_inf P]

@[priority 100]
instance semilattice_inf.ideal_inter_nonempty : ideal_inter_nonempty P :=
{ inter_nonempty := Î» I J, begin
    cases I.nonempty with i _,
    cases J.nonempty with j _,
    exact âŸ¨i âŠ“ j, I.mem_of_le inf_le_left â€¹_â€º, J.mem_of_le inf_le_right â€¹_â€ºâŸ©
  end }

end semilattice_inf

section distrib_lattice

variables [distrib_lattice P]
variables {I J : ideal P}

lemma eq_sup_of_le_sup {x i j: P} (hi : i âˆˆ I) (hj : j âˆˆ J) (hx : x â‰¤ i âŠ” j):
âˆƒ (i' âˆˆ I) (j' âˆˆ J), x = i' âŠ” j' :=
begin
  refine âŸ¨x âŠ“ i, I.mem_of_le inf_le_right hi, x âŠ“ j, J.mem_of_le inf_le_right hj, _âŸ©,
  calc
  x    = x âŠ“ (i âŠ” j)       : left_eq_inf.mpr hx
  ...  = (x âŠ“ i) âŠ” (x âŠ“ j) : inf_sup_left,
end

lemma coe_sup_eq : â†‘(I âŠ” J) = {x | âˆƒ i âˆˆ I, âˆƒ j âˆˆ J, x = i âŠ” j} :=
begin
  ext,
  rw [mem_coe, mem_sup],
  exact âŸ¨Î» âŸ¨_, _, _, _, _âŸ©, eq_sup_of_le_sup â€¹_â€º â€¹_â€º â€¹_â€º,
  Î» âŸ¨i, _, j, _, _âŸ©, âŸ¨i, â€¹_â€º, j, â€¹_â€º, le_of_eq â€¹_â€ºâŸ©âŸ©
end

end distrib_lattice

section boolean_algebra

variables [boolean_algebra P] {x : P} {I : ideal P}

lemma is_proper.not_mem_of_compl_mem (hI : is_proper I) (hxc : xá¶œ âˆˆ I) : x âˆ‰ I :=
begin
  intro hx,
  apply hI.top_not_mem,
  have ht : x âŠ” xá¶œ âˆˆ I := sup_mem _ _ â€¹_â€º â€¹_â€º,
  rwa sup_compl_eq_top at ht,
end

lemma is_proper.not_mem_or_compl_not_mem (hI : is_proper I) : x âˆ‰ I âˆ¨ xá¶œ âˆ‰ I :=
have h : xá¶œ âˆˆ I â†’ x âˆ‰ I := hI.not_mem_of_compl_mem, by tauto

end boolean_algebra

end ideal

/-- For a preorder `P`, `cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure cofinal (P) [preorder P] :=
(carrier : set P)
(mem_gt  : âˆ€ x : P, âˆƒ y âˆˆ carrier, x â‰¤ y)

namespace cofinal

variables [preorder P]

instance : inhabited (cofinal P) :=
âŸ¨{ carrier := set.univ, mem_gt := Î» x, âŸ¨x, trivial, le_refl _âŸ© }âŸ©

instance : has_mem P (cofinal P) := âŸ¨Î» x D, x âˆˆ D.carrierâŸ©

variables (D : cofinal P) (x : P)
/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P := classical.some $ D.mem_gt x

lemma above_mem : D.above x âˆˆ D :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Î» a _, a

lemma le_above : x â‰¤ D.above x :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Î» _ b, b

end cofinal

section ideal_of_cofinals

variables [preorder P] (p : P) {Î¹ : Type*} [encodable Î¹] (ğ’Ÿ : Î¹ â†’ cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequence_of_cofinals : â„• â†’ P
| 0 := p
| (n+1) := match encodable.decode Î¹ n with
           | none   := sequence_of_cofinals n
           | some i := (ğ’Ÿ i).above (sequence_of_cofinals n)
           end

lemma sequence_of_cofinals.monotone : monotone (sequence_of_cofinals p ğ’Ÿ) :=
by { apply monotone_nat_of_le_succ, intros n, dunfold sequence_of_cofinals,
  cases encodable.decode Î¹ n, { refl }, { apply cofinal.le_above }, }

lemma sequence_of_cofinals.encode_mem (i : Î¹) :
  sequence_of_cofinals p ğ’Ÿ (encodable.encode i + 1) âˆˆ ğ’Ÿ i :=
by { dunfold sequence_of_cofinals, rw encodable.encodek, apply cofinal.above_mem, }

/-- Given an element `p : P` and a family `ğ’Ÿ` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `ideal_of_cofinals p ğ’Ÿ` is an ideal in `P` which
  - contains `p`, according to `mem_ideal_of_cofinals p ğ’Ÿ`, and
  - intersects every set in `ğ’Ÿ`, according to `cofinal_meets_ideal_of_cofinals p ğ’Ÿ`.

  This proves the Rasiowaâ€“Sikorski lemma. -/
def ideal_of_cofinals : ideal P :=
{ carrier   := { x : P | âˆƒ n, x â‰¤ sequence_of_cofinals p ğ’Ÿ n },
  nonempty  := âŸ¨p, 0, le_refl _âŸ©,
  directed  := Î» x âŸ¨n, hnâŸ© y âŸ¨m, hmâŸ©,
               âŸ¨_, âŸ¨max n m, le_refl _âŸ©,
               le_trans hn $ sequence_of_cofinals.monotone p ğ’Ÿ (le_max_left _ _),
               le_trans hm $ sequence_of_cofinals.monotone p ğ’Ÿ (le_max_right _ _) âŸ©,
  mem_of_le := Î» x y hxy âŸ¨n, hnâŸ©, âŸ¨n, le_trans hxy hnâŸ©, }

lemma mem_ideal_of_cofinals : p âˆˆ ideal_of_cofinals p ğ’Ÿ := âŸ¨0, le_refl _âŸ©

/-- `ideal_of_cofinals p ğ’Ÿ` is `ğ’Ÿ`-generic. -/
lemma cofinal_meets_ideal_of_cofinals (i : Î¹) : âˆƒ x : P, x âˆˆ ğ’Ÿ i âˆ§ x âˆˆ ideal_of_cofinals p ğ’Ÿ :=
âŸ¨_, sequence_of_cofinals.encode_mem p ğ’Ÿ i, _, le_refl _âŸ©

end ideal_of_cofinals

end order
