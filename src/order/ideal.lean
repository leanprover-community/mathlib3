/-
Copyright (c) 2020 David W√§rn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David W√§rn
-/
import logic.encodable.basic
import order.atoms

/-!
# Order ideals, cofinal sets, and the Rasiowa‚ÄìSikorski lemma

## Main definitions

Throughout this file, `P` is at least a preorder, but some sections require more
structure, such as a bottom element, a top element, or a join-semilattice structure.
- `order.ideal P`: the type of nonempty, upward directed, and downward closed subsets of `P`.
  Dual to the notion of a filter on a preorder.
- `order.is_ideal P`: a predicate for when a `set P` is an ideal.
- `order.ideal.principal p`: the principal ideal generated by `p : P`.
- `order.ideal.is_proper P`: a predicate for proper ideals.
  Dual to the notion of a proper filter.
- `order.ideal.is_maximal`: a predicate for maximal ideals.
  Dual to the notion of an ultrafilter.
- `ideal_Inter_nonempty P`: a predicate for when the intersection of all ideals of
  `P` is nonempty.
- `order.cofinal P`: the type of subsets of `P` containing arbitrarily large elements.
  Dual to the notion of 'dense set' used in forcing.
- `order.ideal_of_cofinals p ùíü`, where `p : P`, and `ùíü` is a countable family of cofinal
  subsets of P: an ideal in `P` which contains `p` and intersects every set in `ùíü`. (This a form
  of the Rasiowa‚ÄìSikorski lemma.)

## References

- <https://en.wikipedia.org/wiki/Ideal_(order_theory)>
- <https://en.wikipedia.org/wiki/Cofinal_(mathematics)>
- <https://en.wikipedia.org/wiki/Rasiowa%E2%80%93Sikorski_lemma>

Note that for the Rasiowa‚ÄìSikorski lemma, Wikipedia uses the opposite ordering on `P`,
in line with most presentations of forcing.

## TODO

`order.ideal.ideal_Inter_nonempty` is a complicated way to say that `P` has a bottom element. It
should be replaced by this clearer condition, which could be called strong directedness and which
is a Prop version of `order_bot`.

## Tags

ideal, cofinal, dense, countable, generic

-/

open function

namespace order

variables {P : Type*}

/-- An ideal on an order `P` is a subset of `P` that is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
structure ideal (P) [has_le P] :=
(carrier   : set P)
(nonempty  : carrier.nonempty)
(directed  : directed_on (‚â§) carrier)
(mem_of_le : ‚àÄ {x y : P}, x ‚â§ y ‚Üí y ‚àà carrier ‚Üí x ‚àà carrier)

/-- A subset of a preorder `P` is an ideal if it is
  - nonempty
  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)
  - downward closed (any element less than an element of the ideal is in the ideal). -/
@[mk_iff] structure is_ideal {P} [has_le P] (I : set P) : Prop :=
(nonempty : I.nonempty)
(directed : directed_on (‚â§) I)
(mem_of_le : ‚àÄ {x y : P}, x ‚â§ y ‚Üí y ‚àà I ‚Üí x ‚àà I)

attribute [protected] ideal.nonempty ideal.directed is_ideal.nonempty is_ideal.directed

/-- Create an element of type `order.ideal` from a set satisfying the predicate
`order.is_ideal`. -/
def is_ideal.to_ideal [has_le P] {I : set P} (h : is_ideal I) : ideal P :=
‚ü®I, h.1, h.2, h.3‚ü©

namespace ideal
section has_le
variables [has_le P] {I J : ideal P} {x y : P}

/-- An ideal of `P` can be viewed as a subset of `P`. -/
instance : has_coe (ideal P) (set P) := ‚ü®carrier‚ü©

/-- For the notation `x ‚àà I`. -/
instance : has_mem P (ideal P) := ‚ü®Œª x I, x ‚àà (I : set P)‚ü©

@[simp] lemma mem_coe : x ‚àà (I : set P) ‚Üî x ‚àà I := iff_of_eq rfl

/-- Two ideals are equal when their underlying sets are equal. -/
@[ext] lemma ext : ‚àÄ {I J : ideal P}, (I : set P) = J ‚Üí I = J
| ‚ü®_, _, _, _‚ü© ‚ü®_, _, _, _‚ü© rfl := rfl

lemma coe_injective : injective (coe : ideal P ‚Üí set P) := Œª _ _, ext

@[simp, norm_cast] lemma coe_inj : (I : set P) = J ‚Üî I = J := ‚ü®by ext, congr_arg _‚ü©

lemma ext_iff : I = J ‚Üî (I : set P) = J := coe_inj.symm

protected lemma is_ideal (I : ideal P) : is_ideal (I : set P) := ‚ü®I.2, I.3, I.4‚ü©

/-- The partial ordering by subset inclusion, inherited from `set P`. -/
instance : partial_order (ideal P) := partial_order.lift coe coe_injective

@[trans] lemma mem_of_mem_of_le : x ‚àà I ‚Üí I ‚â§ J ‚Üí x ‚àà J :=
@set.mem_of_mem_of_subset P x I J

/-- A proper ideal is one that is not the whole set.
    Note that the whole set might not be an ideal. -/
@[mk_iff] class is_proper (I : ideal P) : Prop := (ne_univ : (I : set P) ‚â† set.univ)

lemma is_proper_of_not_mem {I : ideal P} {p : P} (nmem : p ‚àâ I) : is_proper I :=
‚ü®Œª hp, begin
  change p ‚àâ ‚ÜëI at nmem,
  rw hp at nmem,
  exact nmem (set.mem_univ p),
end‚ü©

/-- An ideal is maximal if it is maximal in the collection of proper ideals.

Note that `is_coatom` is less general because ideals only have a top element when `P` is directed
and nonempty. -/
@[mk_iff] class is_maximal (I : ideal P) extends is_proper I : Prop :=
(maximal_proper : ‚àÄ ‚¶ÉJ : ideal P‚¶Ñ, I < J ‚Üí (J : set P) = set.univ)

variable (P)

/-- An order `P` has the `ideal_Inter_nonempty` property if the intersection of all ideals is
nonempty. Most importantly, the ideals of a `semilattice_sup` with this property form a complete
lattice.

TODO: This is equivalent to the existence of a bottom element and shouldn't be specialized to
ideals. -/
class ideal_Inter_nonempty : Prop :=
(Inter_nonempty : (‚ãÇ (I : ideal P), (I : set P)).nonempty)

variable {P}

lemma Inter_nonempty [ideal_Inter_nonempty P] :
  (‚ãÇ (I : ideal P), (I : set P)).nonempty :=
ideal_Inter_nonempty.Inter_nonempty

lemma ideal_Inter_nonempty.exists_all_mem [ideal_Inter_nonempty P] :
  ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I :=
begin
  change ‚àÉ (a : P), ‚àÄ (I : ideal P), a ‚àà (I : set P),
  rw ‚Üê set.nonempty_Inter,
  exact Inter_nonempty,
end

lemma ideal_Inter_nonempty_of_exists_all_mem (h : ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I) :
  ideal_Inter_nonempty P :=
{ Inter_nonempty := by rwa set.nonempty_Inter }

lemma ideal_Inter_nonempty_iff :
  ideal_Inter_nonempty P ‚Üî ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I :=
‚ü®Œª _, by exactI ideal_Inter_nonempty.exists_all_mem, ideal_Inter_nonempty_of_exists_all_mem‚ü©

lemma inter_nonempty [is_directed P (swap (‚â§))] (I J : ideal P) : (I ‚à© J : set P).nonempty :=
begin
  obtain ‚ü®a, ha‚ü© := I.nonempty,
  obtain ‚ü®b, hb‚ü© := J.nonempty,
  obtain ‚ü®c, hac, hbc‚ü© := directed_of (swap (‚â§)) a b,
  exact ‚ü®c, I.mem_of_le hac ha, J.mem_of_le hbc hb‚ü©,
end

end has_le

section preorder
variables [preorder P] {I J : ideal P} {x y : P}

/-- The smallest ideal containing a given element. -/
def principal (p : P) : ideal P :=
{ carrier   := { x | x ‚â§ p },
  nonempty  := ‚ü®p, le_rfl‚ü©,
  directed  := Œª x hx y hy, ‚ü®p, le_rfl, hx, hy‚ü©,
  mem_of_le := Œª x y hxy hy, le_trans hxy hy, }

instance [inhabited P] : inhabited (ideal P) := ‚ü®ideal.principal default‚ü©

@[simp] lemma principal_le_iff : principal x ‚â§ I ‚Üî x ‚àà I :=
‚ü®Œª (h : ‚àÄ {y}, y ‚â§ x ‚Üí y ‚àà I), h (le_refl x),
 Œª h_mem y (h_le : y ‚â§ x), I.mem_of_le h_le h_mem‚ü©

@[simp] lemma mem_principal : x ‚àà principal y ‚Üî x ‚â§ y := iff.rfl

lemma mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : set P)·∂ú ‚Üí y ‚àà (I : set P)·∂ú :=
Œª h, mt (I.mem_of_le h)

end preorder

section order_bot

/-- A specific witness of `I.nonempty` when `P` has a bottom element. -/
@[simp] lemma bot_mem [has_le P] [order_bot P] {I : ideal P} : ‚ä• ‚àà I :=
I.mem_of_le bot_le I.nonempty.some_mem

variables [preorder P] [order_bot P] {I : ideal P}

/-- There is a bottom ideal when `P` has a bottom element. -/
instance : order_bot (ideal P) :=
{ bot := principal ‚ä•,
  bot_le := by simp }

@[priority 100]
instance order_bot.ideal_Inter_nonempty : ideal_Inter_nonempty P :=
by { rw ideal_Inter_nonempty_iff, exact ‚ü®‚ä•, Œª I, bot_mem‚ü© }

end order_bot

section directed
variables [has_le P] [is_directed P (‚â§)] [nonempty P] {I : ideal P}

/-- In a directed and nonempty order, the top ideal of a is `set.univ`. -/
instance : order_top (ideal P) :=
{ top := { carrier := set.univ,
           nonempty := set.univ_nonempty,
           directed := directed_on_univ,
           mem_of_le := Œª _ _ _ _, trivial },
  le_top := Œª I, le_top }

@[simp] lemma coe_top : ((‚ä§ : ideal P) : set P) = set.univ := rfl

lemma is_proper_of_ne_top (ne_top : I ‚â† ‚ä§) : is_proper I := ‚ü®Œª h, ne_top $ ext h‚ü©

lemma is_proper.ne_top (hI : is_proper I) : I ‚â† ‚ä§ :=
begin
  intro h,
  rw [ext_iff, coe_top] at h,
  apply hI.ne_univ,
  assumption,
end

lemma _root_.is_coatom.is_proper (hI : is_coatom I) : is_proper I := is_proper_of_ne_top hI.1

lemma is_proper_iff_ne_top : is_proper I ‚Üî I ‚â† ‚ä§ := ‚ü®Œª h, h.ne_top, Œª h, is_proper_of_ne_top h‚ü©

lemma is_maximal.is_coatom (h : is_maximal I) : is_coatom I :=
‚ü®is_maximal.to_is_proper.ne_top,
  Œª _ _, by { rw [ext_iff, coe_top], exact is_maximal.maximal_proper ‚Äπ_‚Ä∫ }‚ü©

lemma is_maximal.is_coatom' [is_maximal I] : is_coatom I := is_maximal.is_coatom ‚Äπ_‚Ä∫

lemma _root_.is_coatom.is_maximal (hI : is_coatom I) : is_maximal I :=
{ maximal_proper := Œª _ _, by simp [hI.2 _ ‚Äπ_‚Ä∫],
  ..is_coatom.is_proper ‚Äπ_‚Ä∫ }

lemma is_maximal_iff_is_coatom : is_maximal I ‚Üî is_coatom I := ‚ü®Œª h, h.is_coatom, Œª h, h.is_maximal‚ü©

end directed

section order_top
variables [has_le P] [order_top P] {I : ideal P}

lemma top_of_top_mem (hI : ‚ä§ ‚àà I) : I = ‚ä§ :=
by { ext, exact iff_of_true (I.mem_of_le le_top hI) trivial }

lemma is_proper.top_not_mem (hI : is_proper I) : ‚ä§ ‚àâ I := Œª h, hI.ne_top $ top_of_top_mem h

end order_top

section semilattice_sup
variables [semilattice_sup P] {x y : P} {I : ideal P}

/-- A specific witness of `I.directed` when `P` has joins. -/
lemma sup_mem (x y ‚àà I) : x ‚äî y ‚àà I :=
let ‚ü®z, h_mem, hx, hy‚ü© := I.directed x ‚Äπ_‚Ä∫ y ‚Äπ_‚Ä∫ in
I.mem_of_le (sup_le hx hy) h_mem

@[simp] lemma sup_mem_iff : x ‚äî y ‚àà I ‚Üî x ‚àà I ‚àß y ‚àà I :=
‚ü®Œª h, ‚ü®I.mem_of_le le_sup_left h, I.mem_of_le le_sup_right h‚ü©,
 Œª h, sup_mem x h.left y h.right‚ü©

end semilattice_sup

section semilattice_sup_directed
variables [semilattice_sup P] [is_directed P (swap (‚â§))] {x : P} {I J K : ideal P}

/-- The infimum of two ideals of a co-directed order is their intersection. -/
instance : has_inf (ideal P) :=
‚ü®Œª I J, { carrier   := I ‚à© J,
  nonempty  := inter_nonempty I J,
  directed  := Œª x ‚ü®_, _‚ü© y ‚ü®_, _‚ü©, ‚ü®x ‚äî y, ‚ü®sup_mem x ‚Äπ_‚Ä∫ y ‚Äπ_‚Ä∫, sup_mem x ‚Äπ_‚Ä∫ y ‚Äπ_‚Ä∫‚ü©, by simp‚ü©,
  mem_of_le := Œª x y h ‚ü®_, _‚ü©, ‚ü®mem_of_le I h ‚Äπ_‚Ä∫, mem_of_le J h ‚Äπ_‚Ä∫‚ü© }‚ü©

/-- The supremum of two ideals of a co-directed order is the union of the down sets of the pointwise
supremum of `I` and `J`. -/
instance : has_sup (ideal P) :=
‚ü®Œª I J, { carrier   := {x | ‚àÉ (i ‚àà I) (j ‚àà J), x ‚â§ i ‚äî j},
  nonempty  := by { cases inter_nonempty I J, exact ‚ü®w, w, h.1, w, h.2, le_sup_left‚ü© },
  directed  := Œª x ‚ü®xi, _, xj, _, _‚ü© y ‚ü®yi, _, yj, _, _‚ü©,
    ‚ü®x ‚äî y,
     ‚ü®xi ‚äî yi, sup_mem xi ‚Äπ_‚Ä∫ yi ‚Äπ_‚Ä∫,
      xj ‚äî yj, sup_mem xj ‚Äπ_‚Ä∫ yj ‚Äπ_‚Ä∫,
      sup_le
        (calc x ‚â§ xi ‚äî xj               : ‚Äπ_‚Ä∫
         ...    ‚â§ (xi ‚äî yi) ‚äî (xj ‚äî yj) : sup_le_sup le_sup_left le_sup_left)
        (calc y ‚â§ yi ‚äî yj               : ‚Äπ_‚Ä∫
         ...    ‚â§ (xi ‚äî yi) ‚äî (xj ‚äî yj) : sup_le_sup le_sup_right le_sup_right)‚ü©,
     le_sup_left, le_sup_right‚ü©,
  mem_of_le := Œª x y _ ‚ü®yi, _, yj, _, _‚ü©, ‚ü®yi, ‚Äπ_‚Ä∫, yj, ‚Äπ_‚Ä∫, le_trans ‚Äπx ‚â§ y‚Ä∫ ‚Äπ_‚Ä∫‚ü© }‚ü©

instance : lattice (ideal P) :=
{ sup          := (‚äî),
  le_sup_left  := Œª I J (i ‚àà I), by { cases J.nonempty, exact ‚ü®i, ‚Äπ_‚Ä∫, w, ‚Äπ_‚Ä∫, le_sup_left‚ü© },
  le_sup_right := Œª I J (j ‚àà J), by { cases I.nonempty, exact ‚ü®w, ‚Äπ_‚Ä∫, j, ‚Äπ_‚Ä∫, le_sup_right‚ü© },
  sup_le       := Œª I J K hIK hJK a ‚ü®i, hi, j, hj, ha‚ü©,
    K.mem_of_le ha $ sup_mem i (mem_of_mem_of_le hi hIK) j (mem_of_mem_of_le hj hJK),
  inf          := (‚äì),
  inf_le_left  := Œª I J, set.inter_subset_left I J,
  inf_le_right := Œª I J, set.inter_subset_right I J,
  le_inf       := Œª I J K, set.subset_inter,
  .. ideal.partial_order }

@[simp] lemma mem_inf : x ‚àà I ‚äì J ‚Üî x ‚àà I ‚àß x ‚àà J := iff.rfl
@[simp] lemma mem_sup : x ‚àà I ‚äî J ‚Üî ‚àÉ (i ‚àà I) (j ‚àà J), x ‚â§ i ‚äî j := iff.rfl

lemma lt_sup_principal_of_not_mem (hx : x ‚àâ I) : I < I ‚äî principal x :=
le_sup_left.lt_of_ne $ Œª h, hx $ by simpa only [left_eq_sup, principal_le_iff] using h

end semilattice_sup_directed

section ideal_Inter_nonempty

variables [preorder P] [ideal_Inter_nonempty P]

@[priority 100]
instance ideal_Inter_nonempty.to_directed_ge : is_directed P (swap (‚â§)) :=
‚ü®Œª a b, begin
    obtain ‚ü®c, hc‚ü© : ‚àÉ a, ‚àÄ I : ideal P, a ‚àà I := ideal_Inter_nonempty.exists_all_mem,
    exact ‚ü®c, hc (principal a), hc (principal b)‚ü©,
  end‚ü©

variables {Œ± Œ≤ Œ≥ : Type*} {Œπ : Sort*}

lemma ideal_Inter_nonempty.all_Inter_nonempty {f : Œπ ‚Üí ideal P} :
  (‚ãÇ x, (f x : set P)).nonempty :=
begin
  obtain ‚ü®a, ha‚ü© : ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I := ideal_Inter_nonempty.exists_all_mem,
  exact ‚ü®a, by simp [ha]‚ü©
end

lemma ideal_Inter_nonempty.all_bInter_nonempty {f : Œ± ‚Üí ideal P} {s : set Œ±} :
  (‚ãÇ x ‚àà s, (f x : set P)).nonempty :=
begin
  obtain ‚ü®a, ha‚ü© : ‚àÉ a : P, ‚àÄ I : ideal P, a ‚àà I := ideal_Inter_nonempty.exists_all_mem,
  exact ‚ü®a, by simp [ha]‚ü©
end

end ideal_Inter_nonempty

section semilattice_sup_ideal_Inter_nonempty

variables [semilattice_sup P] [ideal_Inter_nonempty P] {x : P} {I J K : ideal P}

instance : has_Inf (ideal P) :=
{ Inf := Œª s, { carrier := ‚ãÇ (I ‚àà s), (I : set P),
  nonempty := ideal_Inter_nonempty.all_bInter_nonempty,
  directed := Œª x hx y hy, ‚ü®x ‚äî y, ‚ü®Œª S ‚ü®I, hS‚ü©,
    begin
      simp only [‚ÜêhS, sup_mem_iff, mem_coe, set.mem_Inter],
      intro hI,
      rw set.mem_Inter‚ÇÇ at *,
      exact ‚ü®hx _ hI, hy _ hI‚ü©
    end,
    le_sup_left, le_sup_right‚ü©‚ü©,
  mem_of_le := Œª x y hxy hy,
    begin
      rw set.mem_Inter‚ÇÇ at *,
      exact Œª I hI, mem_of_le I ‚Äπ_‚Ä∫ (hy I hI)
    end } }

variables {s : set (ideal P)}

@[simp] lemma mem_Inf : x ‚àà Inf s ‚Üî ‚àÄ I ‚àà s, x ‚àà I :=
by { change x ‚àà (‚ãÇ (I ‚àà s), (I : set P)) ‚Üî ‚àÄ I ‚àà s, x ‚àà I, simp }

@[simp] lemma coe_Inf : ‚Üë(Inf s) = ‚ãÇ (I ‚àà s), (I : set P) := rfl

lemma Inf_le (hI : I ‚àà s) : Inf s ‚â§ I :=
Œª _ hx, hx I ‚ü®I, by simp [hI]‚ü©

lemma le_Inf (h : ‚àÄ J ‚àà s, I ‚â§ J) : I ‚â§ Inf s :=
Œª _ _, by { simp only [mem_coe, coe_Inf, set.mem_Inter], tauto }

lemma is_glb_Inf : is_glb s (Inf s) := ‚ü®Œª _, Inf_le, Œª _, le_Inf‚ü©

instance : complete_lattice (ideal P) :=
{ ..ideal.lattice,
  ..complete_lattice_of_Inf (ideal P) (Œª _, @is_glb_Inf _ _ _ _) }

end semilattice_sup_ideal_Inter_nonempty

section distrib_lattice

variables [distrib_lattice P]
variables {I J : ideal P}

lemma eq_sup_of_le_sup {x i j: P} (hi : i ‚àà I) (hj : j ‚àà J) (hx : x ‚â§ i ‚äî j) :
  ‚àÉ (i' ‚àà I) (j' ‚àà J), x = i' ‚äî j' :=
begin
  refine ‚ü®x ‚äì i, I.mem_of_le inf_le_right hi, x ‚äì j, J.mem_of_le inf_le_right hj, _‚ü©,
  calc
  x    = x ‚äì (i ‚äî j)       : left_eq_inf.mpr hx
  ...  = (x ‚äì i) ‚äî (x ‚äì j) : inf_sup_left,
end

lemma coe_sup_eq : ‚Üë(I ‚äî J) = {x | ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x = i ‚äî j} :=
begin
  ext,
  rw [mem_coe, mem_sup],
  exact ‚ü®Œª ‚ü®_, _, _, _, _‚ü©, eq_sup_of_le_sup ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫,
  Œª ‚ü®i, _, j, _, _‚ü©, ‚ü®i, ‚Äπ_‚Ä∫, j, ‚Äπ_‚Ä∫, le_of_eq ‚Äπ_‚Ä∫‚ü©‚ü©
end

end distrib_lattice

section boolean_algebra

variables [boolean_algebra P] {x : P} {I : ideal P}

lemma is_proper.not_mem_of_compl_mem (hI : is_proper I) (hxc : x·∂ú ‚àà I) : x ‚àâ I :=
begin
  intro hx,
  apply hI.top_not_mem,
  have ht : x ‚äî x·∂ú ‚àà I := sup_mem _ ‚Äπ_‚Ä∫ _ ‚Äπ_‚Ä∫,
  rwa sup_compl_eq_top at ht,
end

lemma is_proper.not_mem_or_compl_not_mem (hI : is_proper I) : x ‚àâ I ‚à® x·∂ú ‚àâ I :=
have h : x·∂ú ‚àà I ‚Üí x ‚àâ I := hI.not_mem_of_compl_mem, by tauto

end boolean_algebra

end ideal

/-- For a preorder `P`, `cofinal P` is the type of subsets of `P`
  containing arbitrarily large elements. They are the dense sets in
  the topology whose open sets are terminal segments. -/
structure cofinal (P) [preorder P] :=
(carrier : set P)
(mem_gt  : ‚àÄ x : P, ‚àÉ y ‚àà carrier, x ‚â§ y)

namespace cofinal

variables [preorder P]

instance : inhabited (cofinal P) :=
‚ü®{ carrier := set.univ, mem_gt := Œª x, ‚ü®x, trivial, le_rfl‚ü© }‚ü©

instance : has_mem P (cofinal P) := ‚ü®Œª x D, x ‚àà D.carrier‚ü©

variables (D : cofinal P) (x : P)
/-- A (noncomputable) element of a cofinal set lying above a given element. -/
noncomputable def above : P := classical.some $ D.mem_gt x

lemma above_mem : D.above x ‚àà D :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Œª a _, a

lemma le_above : x ‚â§ D.above x :=
exists.elim (classical.some_spec $ D.mem_gt x) $ Œª _ b, b

end cofinal

section ideal_of_cofinals

variables [preorder P] (p : P) {Œπ : Type*} [encodable Œπ] (ùíü : Œπ ‚Üí cofinal P)

/-- Given a starting point, and a countable family of cofinal sets,
  this is an increasing sequence that intersects each cofinal set. -/
noncomputable def sequence_of_cofinals : ‚Ñï ‚Üí P
| 0 := p
| (n+1) := match encodable.decode Œπ n with
           | none   := sequence_of_cofinals n
           | some i := (ùíü i).above (sequence_of_cofinals n)
           end

lemma sequence_of_cofinals.monotone : monotone (sequence_of_cofinals p ùíü) :=
by { apply monotone_nat_of_le_succ, intros n, dunfold sequence_of_cofinals,
  cases encodable.decode Œπ n, { refl }, { apply cofinal.le_above }, }

lemma sequence_of_cofinals.encode_mem (i : Œπ) :
  sequence_of_cofinals p ùíü (encodable.encode i + 1) ‚àà ùíü i :=
by { dunfold sequence_of_cofinals, rw encodable.encodek, apply cofinal.above_mem, }

/-- Given an element `p : P` and a family `ùíü` of cofinal subsets of a preorder `P`,
  indexed by a countable type, `ideal_of_cofinals p ùíü` is an ideal in `P` which
  - contains `p`, according to `mem_ideal_of_cofinals p ùíü`, and
  - intersects every set in `ùíü`, according to `cofinal_meets_ideal_of_cofinals p ùíü`.

  This proves the Rasiowa‚ÄìSikorski lemma. -/
def ideal_of_cofinals : ideal P :=
{ carrier   := { x : P | ‚àÉ n, x ‚â§ sequence_of_cofinals p ùíü n },
  nonempty  := ‚ü®p, 0, le_rfl‚ü©,
  directed  := Œª x ‚ü®n, hn‚ü© y ‚ü®m, hm‚ü©,
               ‚ü®_, ‚ü®max n m, le_rfl‚ü©,
               le_trans hn $ sequence_of_cofinals.monotone p ùíü (le_max_left _ _),
               le_trans hm $ sequence_of_cofinals.monotone p ùíü (le_max_right _ _) ‚ü©,
  mem_of_le := Œª x y hxy ‚ü®n, hn‚ü©, ‚ü®n, le_trans hxy hn‚ü©, }

lemma mem_ideal_of_cofinals : p ‚àà ideal_of_cofinals p ùíü := ‚ü®0, le_rfl‚ü©

/-- `ideal_of_cofinals p ùíü` is `ùíü`-generic. -/
lemma cofinal_meets_ideal_of_cofinals (i : Œπ) : ‚àÉ x : P, x ‚àà ùíü i ‚àß x ‚àà ideal_of_cofinals p ùíü :=
‚ü®_, sequence_of_cofinals.encode_mem p ùíü i, _, le_rfl‚ü©

end ideal_of_cofinals

end order
