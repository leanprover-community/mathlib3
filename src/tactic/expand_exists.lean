/-
Copyright (c) 2022 Ian Wood. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ian Wood
-/
import meta.expr
import tactic.core

/-!
# `expand_exists`

`expand_exists` is an attribute which takes a proof that something exists with some property, and
outputs a value using `classical.some`, and a proof that it has that property using
`classical.some_spec`. For example:

```lean
@[expand_exists it it_spec]
lemma it_exists (n : ℕ) : ∃ m : ℕ, n < m := sorry
```

produces

```
def it (n : ℕ) : ℕ := classical.some (it_exists n)

lemma it_spec (n : ℕ) : n < it n := classical.some_spec (it_exists n)
```
-/

namespace tactic
setup_tactic_parser

open expr

namespace expand_exists

@[derive has_reflect]
meta structure arg :=
(is_root : bool)
(name : name)
(docstring : option string)

meta def parse_docstring : parser $ (option string) :=
do
  pe <- parser.pexpr,
  e <- to_expr pe,
  val <- some <$> eval_expr string e,
  return val

meta def parse_arg : parser arg :=
do
  is_root <- option.is_some <$> (tk "@")?,
  name <- ident,
  is_docstring <- option.is_some <$> (tk "=")?,
  doc <- if is_docstring then parse_docstring else pure none,
  return ⟨is_root, name, doc⟩

/--
Data known when parsing pi expressions.

`decl`'s arguments are: is_theorem, arg, type, value.
-/
meta structure parse_ctx :=
(original_decl : declaration)
(decl : bool → arg → expr → pexpr → tactic name)
(args : list arg)
(pis_depth : ℕ := 0)

/--
Data known when parsing exists expressions (after parsing pi expressions).

* `with_args` applies pi arguments to a term (eg `id` -> `id #2 #1 #0`).
* `spec_chain` takes the form of `classical.some_spec^n (it_exists ...)`,
with `n` the depth of `∃` parsed.
* `exists_decls` is a list of declarations containing the value(s) of witnesses.
-/
meta structure parse_ctx_exists extends parse_ctx :=
(with_args : expr → expr)
(spec_chain : pexpr)
(exists_decls : list name := [])

/--
Data known when parsing the proposition (after parsing exists and pi expressions).

`project_proof` projects a proof of the full proposition (eg `A ∧ B ∧ C`) to a specific proof (eg
`B`).
-/
meta structure parse_ctx_props extends parse_ctx_exists :=
(project_proof : pexpr → pexpr := id)

/--
Replaces free variables with their exists declaration. For example, if:

```lean
def n_value : ℕ := ... -- generated by `expand_exists`
```

then this function converts `#0` in `#0 = #0` from `∃ n : ℕ, n = n` to `n_value = n_value`.
-/
meta def instantiate_exists_decls (ctx : parse_ctx_exists) (p : expr) : expr :=
p.instantiate_vars $ ctx.exists_decls.reverse.map (λname,
  ctx.with_args (const name ctx.original_decl.univ_levels))

/--
Parses a proposition and creates the associated specification proof. Does not break down the
proposition further.
-/
meta def parse_one_prop (ctx : parse_ctx_props) (p : expr) : tactic unit :=
do
  let p : expr := instantiate_exists_decls { ..ctx } p,
  let val : pexpr := ctx.project_proof ctx.spec_chain,
  a <- match ctx.args with
  | [a] := return a
  | [] := fail "missing name for proposition"
  | _ := fail "too many names for propositions (are you missing an and?)"
  end,
  ctx.decl true a p val,
  skip

/--
Parses a proposition and decides if it should be broken down (eg `P ∧ Q` -> `P` and `Q`) depending
on how many `args` are left. Then creates the associated specification proof(s).
-/
meta def parse_props : parse_ctx_props → expr → tactic unit
| ctx (app (app (const "and" []) p) q) := do
  match ctx.args with
  | [a] := parse_one_prop ctx (app (app (const `and []) p) q)
  | (a :: tail) :=
    parse_one_prop { args := [a],
      project_proof := (λ p, (const `and.left []) p) ∘ ctx.project_proof,
      ..ctx } p
    >> parse_props { args := tail,
      project_proof := (λ p, (const `and.right []) p) ∘ ctx.project_proof,
      ..ctx } q
  | [] := fail "missing name for proposition"
  end
| ctx p := parse_one_prop ctx p

/--
Parses an `∃ a : α, p a`, and creates an associated definition with a value of `α`. When `p α` is
not an exists statement, it will call `parse_props`.
-/
meta def parse_exists : parse_ctx_exists → expr → tactic unit
| ctx (app (app (const "Exists" [lvl]) type) (lam var_name bi var_type body)) := do
  /- TODO: Is this needed, and/or does this create issues? -/
  (if type = var_type then tactic.skip else tactic.fail "exists types should be equal"),
  ⟨a, args⟩ <- match ctx.args with
  | (a :: tail) := return (a, tail)
  | [] := fail "missing name for exists"
  end,
  -- Type may be dependant on earlier arguments.
  let type := instantiate_exists_decls ctx type,
  let value : pexpr := (const `classical.some [lvl]) ctx.spec_chain,
  decl_name <- ctx.decl false a type value,

  let exists_decls := ctx.exists_decls.concat decl_name,
  let some_spec : pexpr := (const `classical.some_spec [lvl]) ctx.spec_chain,
  let ctx : parse_ctx_exists := { args := args,
    spec_chain := some_spec,
    exists_decls := exists_decls,
    ..ctx },
  parse_exists ctx body
| ctx e := parse_props { ..ctx } e

/--
Parses a `∀ (a : α), p a`. If `p` is not a pi expression, it will call `parse_exists`
-/
meta def parse_pis : parse_ctx → expr → tactic unit
| ctx (pi n bi ty body) :=
  -- When making a declaration, wrap in an equivalent pi expression.
  let decl := (λ is_theorem arg type val,
    ctx.decl is_theorem arg (pi n bi ty type) (lam n bi (to_pexpr ty) val)) in
  parse_pis { decl := decl, pis_depth := ctx.pis_depth + 1, ..ctx } body
| ctx (app (app (const "Exists" [lvl]) type) p) :=
  let with_args := (λ (e : expr),
    (list.range ctx.pis_depth).foldr (λ n (e : expr), e (var n)) e) in
  parse_exists { with_args := with_args,
    spec_chain := to_pexpr (
      with_args $ const ctx.original_decl.to_name ctx.original_decl.univ_levels),
    ..ctx } (app (app (const "Exists" [lvl]) type) p)
| ctx e := fail ("unexpected expression " ++ to_string e)

end expand_exists

/--
From a proof that (a) value(s) exist(s) with certain properties, constructs (an) instance(s)
satisfying those properties. For instance:

```lean
@[expand_exists nat_greater nat_greater_spec]
lemma nat_greater_exists (n : ℕ) : ∃ m : ℕ, n < m := ...

#check nat_greater      -- nat_greater : ℕ → ℕ
#check nat_greater_spec -- nat_greater_spec : ∀ (n : ℕ), n < nat_greater n
```

It supports multiple witnesses:

```lean
@[expand_exists nat_greater_m nat_greater_l nat_greater_spec]
lemma nat_greater_exists (n : ℕ) : ∃ (m l : ℕ), n < m ∧ m < l := ...

#check nat_greater_m      -- nat_greater : ℕ → ℕ
#check nat_greater_l      -- nat_greater : ℕ → ℕ
#check nat_greater_spec-- nat_greater_spec : ∀ (n : ℕ),
  n < nat_greater_m n ∧ nat_greater_m n < nat_greater_l n
```

It also supports logical conjunctions:
```lean
@[expand_exists nat_greater nat_greater_lt nat_greater_nonzero]
lemma nat_greater_exists (n : ℕ) : ∃ m : ℕ, n < m ∧ m ≠ 0 := ...

#check nat_greater         -- nat_greater : ℕ → ℕ
#check nat_greater_lt      -- nat_greater_lt : ∀ (n : ℕ), n < nat_greater n
#check nat_greater_nonzero -- nat_greater_nonzero : ∀ (n : ℕ), nat_greater n ≠ 0
```
Note that without the last argument `nat_greater_nonzero`, `nat_greater_lt` would be:
```lean
#check nat_greater_lt -- nat_greater_lt : ∀ (n : ℕ), n < nat_greater n ∧ nat_greater n ≠ 0
```

All definitions will be created in the same namespace as the `exists` lemma. You can prepend the
name with `@` to create it in the root namespace:

```lean
namespace foo
@[expand_exists @a b]
lemma a_exists : ∃ (a : α), a = a := ...
end foo

#check a     -- α
#check foo.b -- a = a
```

A docstring can be added either using `add_decl_doc` after the lemma, or by appending `="..."` to
the name:

```lean
@[expand_exists foo="a foo with property bar" bar]
lemma foo_exists : ∃ (f : foo), bar f := ...

/--
the property satisfied by foo
-/
add_decl_doc bar
```
-/
@[user_attribute]
meta def expand_exists_attr : user_attribute unit (list expand_exists.arg) :=
{ name := "expand_exists",
  descr := "From a proof that (a) value(s) exist(s) with certain properties, "
  ++ "constructs (an) instance(s) satisfying those properties.",
  parser := expand_exists.parse_arg*,
  after_set := some $ λ decl prio persistent, do
    d <- get_decl decl,
    args <- expand_exists_attr.get_param decl,
    expand_exists.parse_pis
    { original_decl := d,
      decl := (λ is_t a ty val, do
        let name := if a.is_root then a.name else d.to_name.get_prefix ++ a.name,
        val <- tactic.to_expr val,
        decl <- tactic.add_decl $ if is_t then declaration.thm name d.univ_params ty (pure val)
          else declaration.defn name d.univ_params ty val default tt,
        a.docstring.mmap $ tactic.add_doc_string name,
        return name),
      args := args } d.type }

add_tactic_doc
{ name := "expand_exists",
  category := doc_category.attr,
  decl_names := [`tactic.expand_exists_attr],
  tags := ["lemma derivation", "environment"] }

end tactic
