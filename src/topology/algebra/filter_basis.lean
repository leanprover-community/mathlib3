/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot
-/

import order.filter.bases
import topology.algebra.module
/-!
# Group and ring filter bases

A `group_filter_basis` is a `filter_basis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `group_filter_basis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `group_filter_basis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `group_filter_basis.topology`: the associated topology
* `group_filter_basis.is_topological_group`: the compatibility between the above topology
  and the group structure
* `ring_filter_basis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `ring_filter_basis.topology`: the associated topology
* `ring_filter_basis.is_topological_ring`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/

open filter set topological_space function
open_locale topological_space filter pointwise

universe u

/-- A `group_filter_basis` on a group is a `filter_basis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `group_filter_basis`. Conversely given a `group_filter_basis` one can define a topology
  compatible with the group structure on `G`.  -/
class group_filter_basis (G : Type u) [group G] extends filter_basis G :=
(one' : âˆ€ {U}, U âˆˆ sets â†’ (1 : G) âˆˆ U)
(mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U)
(inv' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ»Â¹) â»Â¹' U)
(conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ‚€*x*xâ‚€â»Â¹) â»Â¹' U)

/-- A `add_group_filter_basis` on an additive group is a `filter_basis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `add_group_filter_basis`. Conversely given a `add_group_filter_basis` one can define a topology
  compatible with the group structure on `G`. -/
class add_group_filter_basis (A : Type u) [add_group A] extends filter_basis A :=
(zero' : âˆ€ {U}, U âˆˆ sets â†’ (0 : A) âˆˆ U)
(add' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V + V âŠ† U)
(neg' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, -x) â»Â¹' U)
(conj' : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ‚€+x+-xâ‚€) â»Â¹' U)

attribute [to_additive] group_filter_basis
attribute [to_additive] group_filter_basis.one'
attribute [to_additive] group_filter_basis.mul'
attribute [to_additive] group_filter_basis.inv'
attribute [to_additive] group_filter_basis.conj'
attribute [to_additive] group_filter_basis.to_filter_basis

/-- `group_filter_basis` constructor in the commutative group case. -/
@[to_additive "`add_group_filter_basis` constructor in the commutative group case."]
def group_filter_basis_of_comm {G : Type*} [comm_group G]
  (sets                   : set (set G))
  (nonempty               : sets.nonempty)
  (inter_sets  : âˆ€ (x y), x âˆˆ sets â†’ y âˆˆ sets â†’ âˆƒ z âˆˆ sets, z âŠ† x âˆ© y)
  (one : âˆ€ U âˆˆ sets, (1 : G) âˆˆ U)
  (mul : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V * V âŠ† U)
  (inv : âˆ€ U âˆˆ sets, âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ»Â¹) â»Â¹' U) : group_filter_basis G :=
{ sets := sets,
  nonempty := nonempty,
  inter_sets := inter_sets,
  one' := one,
  mul' := mul,
  inv' := inv,
  conj' := Î» x U U_in, âŸ¨U, U_in, by simpâŸ© }


namespace group_filter_basis
variables {G : Type u} [group G] {B : group_filter_basis G}

@[to_additive]
instance : has_mem (set G) (group_filter_basis G) :=
âŸ¨Î» s f, s âˆˆ f.setsâŸ©

@[to_additive] lemma one {U : set G} : U âˆˆ B â†’ (1 : G) âˆˆ U := group_filter_basis.one'

@[to_additive] lemma mul {U : set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V*V âŠ† U := group_filter_basis.mul'

@[to_additive] lemma inv {U : set G} : U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (Î» x, xâ»Â¹) â»Â¹' U :=
group_filter_basis.inv'

@[to_additive]
lemma conj : âˆ€ xâ‚€, âˆ€ {U}, U âˆˆ B â†’ âˆƒ V âˆˆ B, V âŠ† (Î» x, xâ‚€*x*xâ‚€â»Â¹) â»Â¹' U :=
group_filter_basis.conj'

/-- The trivial group filter basis consists of `{1}` only. The associated topology
is discrete. -/
@[to_additive "The trivial additive group filter basis consists of `{0}` only. The associated
topology is discrete."]
instance : inhabited (group_filter_basis G) :=
âŸ¨begin
  refine { sets := {{1}}, nonempty := singleton_nonempty _, .. },
  all_goals { simp only [exists_prop, mem_singleton_iff] },
  { rintros - - rfl rfl,
    use {1},
    simp },
  { simp },
  { rintro - rfl,
    use {1},
    simp },
  { rintro - rfl,
    use {1},
    simp },
  { rintro xâ‚€ - rfl,
    use {1},
    simp }
endâŸ©

@[to_additive]
lemma prod_subset_self (B : group_filter_basis G) {U : set G} (h : U âˆˆ B) : U âŠ† U * U :=
Î» x x_in, âŸ¨1, x, one h, x_in, one_mul xâŸ©

/-- The neighborhood function of a `group_filter_basis` -/
@[to_additive "The neighborhood function of a `add_group_filter_basis`"]
def N (B : group_filter_basis G) : G â†’ filter G :=
Î» x, map (Î» y, x*y) B.to_filter_basis.filter

@[simp, to_additive]
lemma N_one (B : group_filter_basis G) : B.N 1 = B.to_filter_basis.filter :=
by simp only [N, one_mul, map_id']

@[to_additive]
protected lemma has_basis (B : group_filter_basis G) (x : G) :
  has_basis (B.N x) (Î» V : set G, V âˆˆ B) (Î» V, (Î» y, x*y) '' V) :=
has_basis.map (Î» y, x * y) to_filter_basis.has_basis

/-- The topological space structure coming from a group filter basis. -/
@[to_additive "The topological space structure coming from an additive group filter basis."]
def topology (B : group_filter_basis G) : topological_space G :=
topological_space.mk_of_nhds B.N

@[to_additive]
lemma nhds_eq (B : group_filter_basis G) {xâ‚€ : G} :
  @nhds G (B.topology) xâ‚€ = B.N xâ‚€ :=
begin
  rw [topological_space.nhds_mk_of_nhds],
  { intros x U U_in,
    rw (B.has_basis x).mem_iff at U_in,
    rcases U_in with âŸ¨V, V_in, HâŸ©,
    simpa [mem_pure] using H (mem_image_of_mem _ (group_filter_basis.one V_in)), },
  { intros x U U_in,
    rw (B.has_basis x).mem_iff at U_in,
    rcases U_in with âŸ¨V, V_in, HâŸ©,
    rcases group_filter_basis.mul V_in with âŸ¨W, W_in, hWâŸ©,
    use [(Î» y, x*y) '' W, image_mem_map (filter_basis.mem_filter_of_mem _ W_in)],
    split,
    { rw image_subset_iff at H âŠ¢,
      exact ((B.prod_subset_self W_in).trans hW).trans H },
    { rintros y âŸ¨t, tW, rflâŸ©,
      rw (B.has_basis _).mem_iff,
      use [W, W_in],
      apply subset.trans _ H, clear H,
      rintros z âŸ¨w, wW, rflâŸ©,
      exact âŸ¨t*w, hW (mul_mem_mul tW wW), by simp [mul_assoc]âŸ© } }
end

@[to_additive]
lemma nhds_one_eq (B : group_filter_basis G) :
  @nhds G (B.topology) (1 : G) = B.to_filter_basis.filter :=
by { rw B.nhds_eq, simp only [N, one_mul], exact map_id }

@[to_additive]
lemma nhds_has_basis (B : group_filter_basis G) (xâ‚€ : G) :
has_basis (@nhds G B.topology xâ‚€) (Î» V : set G, V âˆˆ B) (Î» V, (Î» y, xâ‚€ * y) '' V)  :=
by { rw B.nhds_eq, apply B.has_basis }

@[to_additive]
lemma nhds_one_has_basis (B : group_filter_basis G) :
has_basis (@nhds G B.topology 1) (Î» V : set G, V âˆˆ B) id  :=
by { rw B.nhds_one_eq, exact B.to_filter_basis.has_basis }

@[to_additive]
lemma mem_nhds_one (B : group_filter_basis G) {U : set G} (hU : U âˆˆ B) : U âˆˆ @nhds G B.topology 1 :=
begin
  rw B.nhds_one_has_basis.mem_iff,
  exact âŸ¨U, hU, rfl.subsetâŸ©
end

/-- If a group is endowed with a topological structure coming from
a group filter basis then it's a topological group. -/
@[to_additive, priority 100]
instance is_topological_group (B : group_filter_basis G) :
  @topological_group G B.topology _ :=
begin
  letI := B.topology,
  have basis := B.nhds_one_has_basis,
  have basis' := basis.prod basis,
  refine topological_group.of_nhds_one _ _ _ _,
  { rw basis'.tendsto_iff basis,
    suffices : âˆ€ U âˆˆ B, âˆƒ V W, (V âˆˆ B âˆ§ W âˆˆ B) âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U, by simpa,
    intros U U_in,
    rcases mul U_in with âŸ¨V, V_in, hVâŸ©,
    use [V, V, V_in, V_in],
    intros a b a_in b_in,
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ© },
  { rw basis.tendsto_iff basis,
    intros U U_in,
    simpa using inv U_in },
  { intro xâ‚€,
    rw [nhds_eq, nhds_one_eq],
    refl },
  { intro xâ‚€,
    rw basis.tendsto_iff basis,
    intros U U_in,
    exact conj xâ‚€ U_in }
end

end group_filter_basis

/-- A `ring_filter_basis` on a ring is a `filter_basis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `ring_filter_basis`. Conversely given a `ring_filter_basis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure.  -/
class ring_filter_basis (R : Type u) [ring R] extends add_group_filter_basis R :=
(mul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V * V âŠ† U)
(mul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ‚€*x) â»Â¹' U)
(mul_right' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, x*xâ‚€) â»Â¹' U)

namespace ring_filter_basis

variables {R : Type u} [ring R] (B : ring_filter_basis R)

instance : has_mem (set R) (ring_filter_basis R) :=
âŸ¨Î» s B, s âˆˆ B.setsâŸ©

lemma mul {U : set R} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V * V âŠ† U :=
mul' hU

lemma mul_left (xâ‚€ : R) {U : set R} (hU : U âˆˆ B) :
  âˆƒ V âˆˆ B, V âŠ† (Î» x, xâ‚€*x) â»Â¹' U :=
mul_left' xâ‚€ hU

lemma mul_right (xâ‚€ : R) {U : set R} (hU : U âˆˆ B) :
  âˆƒ V âˆˆ B, V âŠ† (Î» x, x*xâ‚€) â»Â¹' U :=
mul_right' xâ‚€ hU

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : topological_space R := B.to_add_group_filter_basis.topology

/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
@[priority 100]
instance is_topological_ring {R : Type u} [ring R] (B : ring_filter_basis R) :
  @topological_ring R B.topology _ :=
begin
  let B' := B.to_add_group_filter_basis,
  letI := B'.topology,
  have basis := B'.nhds_zero_has_basis,
  have basis' := basis.prod basis,
  haveI := B'.is_topological_add_group,
  apply topological_ring.of_add_group_of_nhds_zero,
  { rw basis'.tendsto_iff basis,
    suffices : âˆ€ U âˆˆ B', âˆƒ V W, (V âˆˆ B' âˆ§ W âˆˆ B') âˆ§ âˆ€ a b, a âˆˆ V â†’ b âˆˆ W â†’ a * b âˆˆ U, by simpa,
    intros U U_in,
    rcases B.mul U_in with âŸ¨V, V_in, hVâŸ©,
    use [V, V, V_in, V_in],
    intros a b a_in b_in,
    exact hV âŸ¨a, b, a_in, b_in, rflâŸ© },
  { intro xâ‚€,
    rw basis.tendsto_iff basis,
    intros U,
    simpa using B.mul_left xâ‚€ },
  { intro xâ‚€,
    rw basis.tendsto_iff basis,
    intros U,
    simpa using B.mul_right xâ‚€ },
end

end ring_filter_basis

/-- A `module_filter_basis` on a module is a `filter_basis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `module_filter_basis`. Conversely given a `module_filter_basis` one can define a topology
  compatible with the module structure on `M`.  -/
structure module_filter_basis (R M : Type*) [comm_ring R] [topological_space R]
  [add_comm_group M] [module R M] extends add_group_filter_basis M :=
(smul' : âˆ€ {U}, U âˆˆ sets â†’ âˆƒ (V âˆˆ ğ“ (0 : R)) (W âˆˆ sets), V â€¢ W âŠ† U)
(smul_left' : âˆ€ (xâ‚€ : R) {U}, U âˆˆ sets â†’ âˆƒ V âˆˆ sets, V âŠ† (Î» x, xâ‚€ â€¢ x) â»Â¹' U)
(smul_right' : âˆ€ (mâ‚€ : M) {U}, U âˆˆ sets â†’ âˆ€á¶  x in ğ“ (0 : R), x â€¢ mâ‚€ âˆˆ U)

namespace module_filter_basis
variables {R M : Type*} [comm_ring R] [topological_space R]
  [add_comm_group M] [module R M] (B : module_filter_basis R M)

instance group_filter_basis.has_mem : has_mem (set M) (module_filter_basis R M) :=
âŸ¨Î» s B, s âˆˆ B.setsâŸ©

lemma smul  {U : set M} (hU : U âˆˆ B) : âˆƒ (V âˆˆ ğ“ (0 : R)) (W âˆˆ B), V â€¢ W âŠ† U :=
B.smul' hU

lemma smul_left (xâ‚€ : R) {U : set M} (hU : U âˆˆ B) : âˆƒ V âˆˆ B, V âŠ† (Î» x, xâ‚€ â€¢ x) â»Â¹' U :=
B.smul_left' xâ‚€ hU

lemma smul_right (mâ‚€ : M) {U : set M} (hU : U âˆˆ B) : âˆ€á¶  x in ğ“ (0 : R), x â€¢ mâ‚€ âˆˆ U :=
B.smul_right' mâ‚€ hU

/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [discrete_topology R] : inhabited (module_filter_basis R M) :=
âŸ¨{ smul' := begin
     rintro U (h : U âˆˆ {{(0 : M)}}),
     rw mem_singleton_iff at h,
     use [univ, univ_mem, {0}, rfl],
     rintros a âŸ¨x, m, -, hm, rflâŸ©,
     simp [mem_singleton_iff.1 hm, h]
   end,
   smul_left' := begin
     rintro xâ‚€ U (h : U âˆˆ {{(0 : M)}}),
     rw mem_singleton_iff at h,
     use [{0}, rfl],
     simp [h]
   end,
   smul_right' := begin
     rintro mâ‚€ U (h : U âˆˆ {{(0 : M)}}),
     rw mem_singleton_iff at h,
     simp [h, nhds_discrete]
   end,
   ..(default $ add_group_filter_basis M) }âŸ©

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
def topology : topological_space M := B.to_add_group_filter_basis.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type*} [comm_ring R] {tR : topological_space R}
  [add_comm_group M] [module R M] (B : module_filter_basis R M) : topological_space M :=
  B.to_add_group_filter_basis.topology

/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
@[priority 100]
instance has_continuous_smul [topological_ring R] :
  @has_continuous_smul R M _ _ B.topology  :=
begin
  let B' := B.to_add_group_filter_basis,
  letI := B'.topology,
  have basis := B'.nhds_zero_has_basis,
  haveI := B'.is_topological_add_group,
  apply has_continuous_smul.of_nhds_zero,
  { rw basis.tendsto_right_iff,
    intros U U_in,
    rcases B.smul U_in with âŸ¨V, V_in, W, W_in, HâŸ©,
    apply mem_of_superset (prod_mem_prod V_in $ B'.mem_nhds_zero W_in),
    rintros âŸ¨v, wâŸ© âŸ¨v_in : v âˆˆ V, w_in : w âˆˆ WâŸ©,
    exact H (set.mem_smul_of_mem v_in w_in) },
  { intro mâ‚€,
    rw basis.tendsto_right_iff,
    intros U U_in,
    exact B.smul_right mâ‚€ U_in },
  { intro xâ‚€,
    rw basis.tendsto_right_iff,
    intros U U_in,
    rcases B.smul_left xâ‚€ U_in with âŸ¨V, V_in, hVâŸ©,
    exact mem_of_superset (B'.mem_nhds_zero V_in) hV },
end

/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def of_bases {R M : Type*} [comm_ring R]
  [add_comm_group M] [module R M] (BR : ring_filter_basis R) (BM : add_group_filter_basis M)
  (smul : âˆ€ {U}, U âˆˆ BM â†’ âˆƒ (V âˆˆ BR) (W âˆˆ BM), V â€¢ W âŠ† U)
  (smul_left : âˆ€ (xâ‚€ : R) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BM, V âŠ† (Î» x, xâ‚€ â€¢ x) â»Â¹' U)
  (smul_right : âˆ€ (mâ‚€ : M) {U}, U âˆˆ BM â†’ âˆƒ V âˆˆ BR, V âŠ† (Î» x, x â€¢ mâ‚€) â»Â¹' U) :
  @module_filter_basis R M _ BR.topology _ _ :=
{ smul' := begin
    intros U U_in,
    rcases smul U_in with âŸ¨V, V_in, W, W_in, HâŸ©,
    exact âŸ¨V, BR.to_add_group_filter_basis.mem_nhds_zero V_in, W, W_in, HâŸ©
  end,
  smul_left' := smul_left,
  smul_right' := begin
    intros mâ‚€ U U_in,
    rcases smul_right mâ‚€ U_in with âŸ¨V, V_in, HâŸ©,
    exact mem_of_superset (BR.to_add_group_filter_basis.mem_nhds_zero V_in) H
  end,
  ..BM }

end module_filter_basis
