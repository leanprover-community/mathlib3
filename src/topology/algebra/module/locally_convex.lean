/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import analysis.convex.topology
/-!
# Locally convex topological modules

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

A `locally_convex_space` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locally_convex_space_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `seminorm.locally_convex_space` : a topology generated by a family of seminorms is locally convex
- `normed_space.locally_convex_space` : a normed space is locally convex

## TODO

- define a structure `locally_convex_filter_basis`, extending `module_filter_basis`, for filter
  bases generating a locally convex topology

-/

open topological_space filter set

open_locale topology pointwise

section semimodule

/-- A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class locally_convex_space (ğ•œ E : Type*) [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E]
  [topological_space E] : Prop :=
(convex_basis : âˆ€ x : E, (ğ“ x).has_basis (Î» (s : set E), s âˆˆ ğ“ x âˆ§ convex ğ•œ s) id)

variables (ğ•œ E : Type*) [ordered_semiring ğ•œ] [add_comm_monoid E] [module ğ•œ E] [topological_space E]

lemma locally_convex_space_iff :
  locally_convex_space ğ•œ E â†”
  âˆ€ x : E, (ğ“ x).has_basis (Î» (s : set E), s âˆˆ ğ“ x âˆ§ convex ğ•œ s) id :=
âŸ¨@locally_convex_space.convex_basis _ _ _ _ _ _, locally_convex_space.mkâŸ©

lemma locally_convex_space.of_bases {Î¹ : Type*} (b : E â†’ Î¹ â†’ set E) (p : E â†’ Î¹ â†’ Prop)
  (hbasis : âˆ€ x : E, (ğ“ x).has_basis (p x) (b x)) (hconvex : âˆ€ x i, p x i â†’ convex ğ•œ (b x i)) :
  locally_convex_space ğ•œ E :=
âŸ¨Î» x, (hbasis x).to_has_basis
  (Î» i hi, âŸ¨b x i, âŸ¨âŸ¨(hbasis x).mem_of_mem hi, hconvex x i hiâŸ©, le_refl (b x i)âŸ©âŸ©)
  (Î» s hs, âŸ¨(hbasis x).index s hs.1,
    âŸ¨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1âŸ©âŸ©)âŸ©

lemma locally_convex_space.convex_basis_zero [locally_convex_space ğ•œ E] :
  (ğ“ 0 : filter E).has_basis (Î» s, s âˆˆ (ğ“ 0 : filter E) âˆ§ convex ğ•œ s) id :=
locally_convex_space.convex_basis 0

lemma locally_convex_space_iff_exists_convex_subset :
  locally_convex_space ğ•œ E â†” âˆ€ x : E, âˆ€ U âˆˆ ğ“ x, âˆƒ S âˆˆ ğ“ x, convex ğ•œ S âˆ§ S âŠ† U :=
(locally_convex_space_iff ğ•œ E).trans (forall_congr $ Î» x, has_basis_self)

end semimodule

section module

variables (ğ•œ E : Type*) [ordered_semiring ğ•œ] [add_comm_group E] [module ğ•œ E] [topological_space E]
  [topological_add_group E]

lemma locally_convex_space.of_basis_zero {Î¹ : Type*} (b : Î¹ â†’ set E) (p : Î¹ â†’ Prop)
  (hbasis : (ğ“ 0).has_basis p b) (hconvex : âˆ€ i, p i â†’ convex ğ•œ (b i)) :
  locally_convex_space ğ•œ E :=
begin
  refine locally_convex_space.of_bases ğ•œ E (Î» (x : E) (i : Î¹), ((+) x) '' b i) (Î» _, p) (Î» x, _)
    (Î» x i hi, (hconvex i hi).translate x),
  rw â† map_add_left_nhds_zero,
  exact hbasis.map _
end

lemma locally_convex_space_iff_zero :
  locally_convex_space ğ•œ E â†”
  (ğ“ 0 : filter E).has_basis (Î» (s : set E), s âˆˆ (ğ“ 0 : filter E) âˆ§ convex ğ•œ s) id :=
âŸ¨Î» h, @locally_convex_space.convex_basis _ _ _ _ _ _ h 0,
 Î» h, locally_convex_space.of_basis_zero ğ•œ E _ _ h (Î» s, and.right)âŸ©

lemma locally_convex_space_iff_exists_convex_subset_zero :
  locally_convex_space ğ•œ E â†”
  âˆ€ U âˆˆ (ğ“ 0 : filter E), âˆƒ S âˆˆ (ğ“ 0 : filter E), convex ğ•œ S âˆ§ S âŠ† U :=
(locally_convex_space_iff_zero ğ•œ E).trans has_basis_self

-- see Note [lower instance priority]
@[priority 100] instance locally_convex_space.to_locally_connected_space [module â„ E]
  [has_continuous_smul â„ E] [locally_convex_space â„ E] :
  locally_connected_space E :=
locally_connected_space_of_connected_bases _ _
  (Î» x, @locally_convex_space.convex_basis â„ _ _ _ _ _ _ x)
  (Î» x s hs, hs.2.is_preconnected)

end module

section linear_ordered_field

variables (ğ•œ E : Type*) [linear_ordered_field ğ•œ] [add_comm_group E] [module ğ•œ E]
  [topological_space E] [topological_add_group E] [has_continuous_const_smul ğ•œ E]

lemma locally_convex_space.convex_open_basis_zero [locally_convex_space ğ•œ E] :
  (ğ“ 0 : filter E).has_basis (Î» s, (0 : E) âˆˆ s âˆ§ is_open s âˆ§ convex ğ•œ s) id :=
(locally_convex_space.convex_basis_zero ğ•œ E).to_has_basis
  (Î» s hs, âŸ¨interior s, âŸ¨mem_interior_iff_mem_nhds.mpr hs.1, is_open_interior,
    hs.2.interiorâŸ©, interior_subsetâŸ©)
  (Î» s hs, âŸ¨s, âŸ¨hs.2.1.mem_nhds hs.1, hs.2.2âŸ©, subset_rflâŸ©)

variables {ğ•œ E}

/-- In a locally convex space, if `s`, `t` are disjoint convex sets, `s` is compact and `t` is
closed, then we can find open disjoint convex sets containing them. -/
lemma disjoint.exists_open_convexes [locally_convex_space ğ•œ E] {s t : set E} (disj : disjoint s t)
  (hsâ‚ : convex ğ•œ s) (hsâ‚‚ : is_compact s) (htâ‚ : convex ğ•œ t) (htâ‚‚ : is_closed t) :
  âˆƒ u v, is_open u âˆ§ is_open v âˆ§ convex ğ•œ u âˆ§ convex ğ•œ v âˆ§ s âŠ† u âˆ§ t âŠ† v âˆ§ disjoint u v :=
begin
  letI : uniform_space E := topological_add_group.to_uniform_space E,
  haveI : uniform_add_group E := topological_add_comm_group_is_uniform,
  have := (locally_convex_space.convex_open_basis_zero ğ•œ E).comap (Î» x : E Ã— E, x.2 - x.1),
  rw â† uniformity_eq_comap_nhds_zero at this,
  rcases disj.exists_uniform_thickening_of_basis this hsâ‚‚ htâ‚‚
    with âŸ¨V, âŸ¨hV0, hVopen, hVconvexâŸ©, hVâŸ©,
  refine âŸ¨s + V, t + V, hVopen.add_left, hVopen.add_left, hsâ‚.add hVconvex, htâ‚.add hVconvex,
    subset_add_left _ hV0, subset_add_left _ hV0, _âŸ©,
  simp_rw [â†Union_add_left_image, image_add_left],
  simp_rw [uniform_space.ball, â†preimage_comp, sub_eq_neg_add] at hV,
  exact hV
end

end linear_ordered_field

section lattice_ops

variables {Î¹ : Sort*} {ğ•œ E F : Type*} [ordered_semiring ğ•œ] [add_comm_monoid E]
  [module ğ•œ E] [add_comm_monoid F] [module ğ•œ F]

lemma locally_convex_space_Inf {ts : set (topological_space E)}
  (h : âˆ€ t âˆˆ ts, @locally_convex_space ğ•œ E  _ _ _ t) :
  @locally_convex_space ğ•œ E _ _ _ (Inf ts) :=
begin
  letI : topological_space E := Inf ts,
  refine locally_convex_space.of_bases ğ•œ E
    (Î» x, Î» If : set ts Ã— (ts â†’ set E), â‹‚ i âˆˆ If.1, If.2 i)
    (Î» x, Î» If : set ts Ã— (ts â†’ set E), If.1.finite âˆ§ âˆ€ i âˆˆ If.1,
      ((If.2 i) âˆˆ @nhds _ â†‘i x âˆ§ convex ğ•œ (If.2 i)))
    (Î» x, _) (Î» x If hif, convex_Inter $ Î» i, convex_Inter $ Î» hi, (hif.2 i hi).2),
  rw [nhds_Inf, â† infi_subtype''],
  exact has_basis_infi' (Î» i : ts, (@locally_convex_space_iff ğ•œ E _ _ _ â†‘i).mp (h â†‘i i.2) x),
end

lemma locally_convex_space_infi {ts' : Î¹ â†’ topological_space E}
  (h' : âˆ€ i, @locally_convex_space ğ•œ E  _ _ _ (ts' i)) :
  @locally_convex_space ğ•œ E _ _ _ (â¨… i, ts' i) :=
begin
  refine locally_convex_space_Inf _,
  rwa forall_range_iff
end

lemma locally_convex_space_inf {tâ‚ tâ‚‚ : topological_space E}
  (hâ‚ : @locally_convex_space ğ•œ E _ _ _ tâ‚) (hâ‚‚ : @locally_convex_space ğ•œ E _ _ _ tâ‚‚) :
  @locally_convex_space ğ•œ E _ _ _ (tâ‚ âŠ“ tâ‚‚) :=
by {rw inf_eq_infi, refine locally_convex_space_infi (Î» b, _), cases b; assumption}

lemma locally_convex_space_induced {t : topological_space F} [locally_convex_space ğ•œ F]
  (f : E â†’â‚—[ğ•œ] F) :
  @locally_convex_space ğ•œ E _ _ _ (t.induced f) :=
begin
  letI : topological_space E := t.induced f,
  refine locally_convex_space.of_bases ğ•œ E (Î» x, preimage f)
    (Î» x, Î» (s : set F), s âˆˆ ğ“ (f x) âˆ§ convex ğ•œ s) (Î» x, _)
    (Î» x s âŸ¨_, hsâŸ©, hs.linear_preimage f),
  rw nhds_induced,
  exact (locally_convex_space.convex_basis $ f x).comap f
end

instance {Î¹ : Type*} {X : Î¹ â†’ Type*} [Î  i, add_comm_monoid (X i)] [Î  i, topological_space (X i)]
  [Î  i, module ğ•œ (X i)] [Î  i, locally_convex_space ğ•œ (X i)] :
  locally_convex_space ğ•œ (Î  i, X i) :=
locally_convex_space_infi (Î» i, locally_convex_space_induced (linear_map.proj i))

instance [topological_space E] [topological_space F] [locally_convex_space ğ•œ E]
  [locally_convex_space ğ•œ F] :
  locally_convex_space ğ•œ (E Ã— F) :=
locally_convex_space_inf
  (locally_convex_space_induced (linear_map.fst _ _ _))
  (locally_convex_space_induced (linear_map.snd _ _ _))

end lattice_ops
