/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import tactic.linarith
import tactic.tfae
import algebra.archimedean
import algebra.group.pi
import algebra.ordered_ring
import order.liminf_limsup
import data.set.intervals.image_preimage
import data.set.intervals.ord_connected
import data.set.intervals.surj_on
import topology.algebra.group
import topology.extend_from_subset
import order.filter.interval

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±`(which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements (`order_closed_topology`
vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc) see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

### Connected sets and Intermediate Value Theorem

* `is_preconnected_I??` : all intervals `I??` are preconnected,
* `is_preconnected.intermediate_value`, `intermediate_value_univ` : Intermediate Value Theorem for
  connected sets and connected spaces, respectively;
* `intermediate_value_Icc`, `intermediate_value_Icc'`: Intermediate Value Theorem for functions
  on closed intervals.

### Miscellaneous facts

* `is_compact.exists_forall_le`, `is_compact.exists_forall_ge` : extreme value theorem, a continuous
  function on a compact set takes its minimum and maximum values.
* `is_closed.Icc_subset_of_forall_mem_nhds_within` : ‚ÄúContinuous induction‚Äù principle;
  if `s ‚à© [a, b]` is closed, `a ‚àà s`, and for each `x ‚àà [a, b) ‚à© s` some of its right neighborhoods
  is included `s`, then `[a, b] ‚äÜ s`.
* `is_closed.Icc_subset_of_forall_exists_gt`, `is_closed.mem_of_ge_of_forall_exists_gt` : two
  other versions of the ‚Äúcontinuous induction‚Äù principle.

## Implementation

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/

open classical set filter topological_space
open function (curry uncurry)
open_locale topological_space classical filter

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ‚â§ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class order_closed_topology (Œ± : Type*) [topological_space Œ±] [preorder Œ±] : Prop :=
(is_closed_le' : is_closed {p:Œ±√óŒ± | p.1 ‚â§ p.2})

instance : Œ† [topological_space Œ±], topological_space (order_dual Œ±) := id

section order_closed_topology

section preorder
variables [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±]
include t

lemma is_closed_le_prod : is_closed {p : Œ± √ó Œ± | p.1 ‚â§ p.2} :=
t.is_closed_le'

lemma is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b ‚â§ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod

lemma is_closed_le' (a : Œ±) : is_closed {b | b ‚â§ a} :=
is_closed_le continuous_id continuous_const

lemma is_closed_Iic {a : Œ±} : is_closed (Iic a) :=
is_closed_le' a

lemma is_closed_ge' (a : Œ±) : is_closed {b | a ‚â§ b} :=
is_closed_le continuous_const continuous_id

lemma is_closed_Ici {a : Œ±} : is_closed (Ici a) :=
is_closed_ge' a

instance : order_closed_topology (order_dual Œ±) :=
‚ü®continuous_swap _ (@order_closed_topology.is_closed_le' Œ± _ _ _)‚ü©

lemma is_closed_Icc {a b : Œ±} : is_closed (Icc a b) :=
is_closed_inter is_closed_Ici is_closed_Iic

@[simp] lemma closure_Icc (a b : Œ±) : closure (Icc a b) = Icc a b :=
is_closed_Icc.closure_eq

@[simp] lemma closure_Iic (a : Œ±) : closure (Iic a) = Iic a :=
is_closed_Iic.closure_eq

@[simp] lemma closure_Ici (a : Œ±) : closure (Ici a) = Ici a :=
is_closed_Ici.closure_eq

lemma le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : f ‚â§·∂†[b] g) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
have tendsto (Œªb, (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (a‚ÇÅ, a‚ÇÇ) ‚àà {p:Œ±√óŒ± | p.1 ‚â§ p.2},
  from t.is_closed_le'.mem_of_tendsto this h

lemma le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

lemma le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto_of_tendsto lim tendsto_const_nhds h

lemma le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto lim (eventually_of_forall h)

lemma ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, b ‚â§ f c) : b ‚â§ a :=
le_of_tendsto_of_tendsto tendsto_const_nhds lim h

lemma ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, b ‚â§ f c) : b ‚â§ a :=
ge_of_tendsto lim (eventually_of_forall h)

@[simp]
lemma closure_le_eq [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b ‚â§ g b} = {b | f b ‚â§ g b} :=
(is_closed_le hf hg).closure_eq

lemma closure_lt_subset_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f)
  (hg : continuous g) :
  closure {b | f b < g b} ‚äÜ {b | f b ‚â§ g b} :=
by { rw [‚Üêclosure_le_eq hf hg], exact closure_mono (Œª b, le_of_lt) }

lemma continuous_within_at.closure_le [topological_space Œ≤]
 {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} {x : Œ≤} (hx : x ‚àà closure s)
 (hf : continuous_within_at f s x)
 (hg : continuous_within_at g s x)
 (h : ‚àÄ y ‚àà s, f y ‚â§ g y) : f x ‚â§ g x :=
show (f x, g x) ‚àà {p : Œ± √ó Œ± | p.1 ‚â§ p.2},
from order_closed_topology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. -/
lemma is_closed.is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (hs : is_closed s)
  (hf : continuous_on f s) (hg : continuous_on g s) :
  is_closed {x ‚àà s | f x ‚â§ g x} :=
(hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'

omit t

lemma nhds_within_Ici_ne_bot {a b : Œ±} (H‚ÇÇ : a ‚â§ b) :
  ùìù[Ici a] b ‚â† ‚ä• :=
nhds_within_ne_bot_of_mem H‚ÇÇ

lemma nhds_within_Ici_self_ne_bot (a : Œ±) :
  ùìù[Ici a] a ‚â† ‚ä• :=
nhds_within_Ici_ne_bot (le_refl a)

lemma nhds_within_Iic_ne_bot {a b : Œ±} (H : a ‚â§ b) :
  ùìù[Iic b] a ‚â† ‚ä• :=
nhds_within_ne_bot_of_mem H

lemma nhds_within_Iic_self_ne_bot (a : Œ±) :
  ùìù[Iic a] a ‚â† ‚ä• :=
nhds_within_Iic_ne_bot (le_refl a)

end preorder

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_closed_topology Œ±]
include t

private lemma is_closed_eq : is_closed {p : Œ± √ó Œ± | p.1 = p.2} :=
by simp only [le_antisymm_iff];
   exact is_closed_inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

@[priority 90] -- see Note [lower instance priority]
instance order_closed_topology.to_t2_space : t2_space Œ± :=
{ t2 :=
  have is_open {p : Œ± √ó Œ± | p.1 ‚â† p.2}, from is_closed_eq,
  assume a b h,
  let ‚ü®u, v, hu, hv, ha, hb, h‚ü© := is_open_prod_iff.mp this a b h in
  ‚ü®u, v, hu, hv, ha, hb,
    set.eq_empty_iff_forall_not_mem.2 $ assume a ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    have a ‚â† a, from @h (a, a) ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    this rfl‚ü© }

end partial_order

section linear_order
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±]

lemma is_open_lt_prod : is_open {p : Œ± √ó Œ± | p.1 < p.2} :=
by { simp_rw [‚Üê is_closed_compl_iff, compl_set_of, not_lt],
     exact is_closed_le continuous_snd continuous_fst }

lemma is_open_lt [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_open {b | f b < g b} :=
by simp [lt_iff_not_ge, -not_le]; exact is_closed_le hg hf

variables {a b : Œ±}

lemma is_open_Iio : is_open (Iio a) :=
is_open_lt continuous_id continuous_const

lemma is_open_Ioi : is_open (Ioi a) :=
is_open_lt continuous_const continuous_id

lemma is_open_Ioo : is_open (Ioo a b) :=
is_open_inter is_open_Ioi is_open_Iio

@[simp] lemma interior_Ioi : interior (Ioi a) = Ioi a :=
is_open_Ioi.interior_eq

@[simp] lemma interior_Iio : interior (Iio a) = Iio a :=
is_open_Iio.interior_eq

@[simp] lemma interior_Ioo : interior (Ioo a b) = Ioo a b :=
is_open_Ioo.interior_eq

/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions
on a preconnected space and `f a ‚â§ g a` and `g b ‚â§ f b`, then for some `x` we have `f x = g x`. -/
lemma intermediate_value_univ‚ÇÇ {Œ≥ : Type*} [topological_space Œ≥] [preconnected_space Œ≥] {a b : Œ≥}
  {f g : Œ≥ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (ha : f a ‚â§ g a) (hb : g b ‚â§ f b) :
  ‚àÉ x, f x = g x :=
begin
  obtain ‚ü®x, h, hfg, hgf‚ü© : (univ ‚à© {x | f x ‚â§ g x ‚àß g x ‚â§ f x}).nonempty,
    from is_preconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _
      (is_closed_le hf hg) (is_closed_le hg hf) (Œª x hx, le_total _ _) ‚ü®a, trivial, ha‚ü©
      ‚ü®b, trivial, hb‚ü©,
  exact ‚ü®x, le_antisymm hfg hgf‚ü©
end

/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous
on a preconnected set `s` and for some `a b ‚àà s` we have `f a ‚â§ g a` and `g b ‚â§ f b`,
then for some `x ‚àà s` we have `f x = g x`. -/
lemma is_preconnected.intermediate_value‚ÇÇ {Œ≥ : Type*} [topological_space Œ≥] {s : set Œ≥}
  (hs : is_preconnected s) {a b : Œ≥} (ha : a ‚àà s) (hb : b ‚àà s) {f g : Œ≥ ‚Üí Œ±}
  (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a ‚â§ g a) (hb' : g b ‚â§ f b) :
  ‚àÉ x ‚àà s, f x = g x :=
let ‚ü®x, hx‚ü© := @intermediate_value_univ‚ÇÇ Œ± _ _ _ s _ (subtype.preconnected_space hs) ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©
  _ _ (continuous_on_iff_continuous_restrict.1 hf) (continuous_on_iff_continuous_restrict.1 hg)
  ha' hb'
in ‚ü®x, x.2, hx‚ü©

/-- Intermediate Value Theorem for continuous functions on connected sets. -/
lemma is_preconnected.intermediate_value {Œ≥ : Type*} [topological_space Œ≥] {s : set Œ≥}
  (hs : is_preconnected s) {a b : Œ≥} (ha : a ‚àà s) (hb : b ‚àà s) {f : Œ≥ ‚Üí Œ±}
  (hf : continuous_on f s) :
  Icc (f a) (f b) ‚äÜ f '' s :=
Œª x hx, mem_image_iff_bex.2 $ hs.intermediate_value‚ÇÇ ha hb hf continuous_on_const hx.1 hx.2

/-- Intermediate Value Theorem for continuous functions on connected spaces. -/
lemma intermediate_value_univ {Œ≥ : Type*} [topological_space Œ≥] [preconnected_space Œ≥]
  (a b : Œ≥) {f : Œ≥ ‚Üí Œ±} (hf : continuous f) :
  Icc (f a) (f b) ‚äÜ range f :=
Œª x hx, intermediate_value_univ‚ÇÇ hf continuous_const hx.1 hx.2

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
lemma is_preconnected.Icc_subset {s : set Œ±} (hs : is_preconnected s)
  {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) :
  Icc a b ‚äÜ s :=
by simpa only [image_id] using hs.intermediate_value ha hb continuous_on_id

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
lemma is_connected.Icc_subset {s : set Œ±} (hs : is_connected s)
  {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) :
  Icc a b ‚äÜ s :=
hs.2.Icc_subset ha hb

/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole
space. -/
lemma is_preconnected.eq_univ_of_unbounded {s : set Œ±} (hs : is_preconnected s) (hb : ¬¨bdd_below s)
  (ha : ¬¨bdd_above s) :
  s = univ :=
begin
  refine eq_univ_of_forall (Œª x, _),
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := not_bdd_below_iff.1 hb x,
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
end

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ùìù[Ioi a] a` and
`ùìù[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Œ±` -/

/-!
#### Right neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioo a c ‚àà ùìù[Ioi b] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by rw [inter_comm, Ioi_inter_Iio]; exact Ioo_subset_Ioo_left H.1‚ü©

lemma Ioc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioc a c ‚àà ùìù[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

lemma Icc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] a = ùìù[Ioi a] a :=
le_antisymm (nhds_within_mono _ Ioc_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioc_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] a = ùìù[Ioi a] a :=
le_antisymm (nhds_within_mono _ Ioo_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioo_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Ioc_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
lemma continuous_within_at_Ioo_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioo a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioo a c ‚àà ùìù[Iio b] b :=
by simpa only [dual_Ioo] using @Ioo_mem_nhds_within_Ioi (order_dual Œ±) _ _ _ _ _ _ ‚ü®H.2, H.1‚ü©

lemma Ico_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ico a c ‚àà ùìù[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

lemma Icc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ico_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] b = ùìù[Iio b] b :=
by simpa only [dual_Ioc] using @nhds_within_Ioc_eq_nhds_within_Ioi (order_dual Œ±) _ _ _ _ _ h

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] b = ùìù[Iio b] b :=
by simpa only [dual_Ioo] using @nhds_within_Ioo_eq_nhds_within_Ioi (order_dual Œ±) _ _ _ _ _ h

@[simp] lemma continuous_within_at_Ico_iff_Iio [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ico a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp] lemma continuous_within_at_Ioo_iff_Iio [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioo a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[Ici b] b :=
mem_nhds_within_of_mem_nhds $ mem_nhds_sets is_open_Ioo H

lemma Ioc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioc a c ‚àà ùìù[Ici b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[Ici b] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]‚ü©

lemma Icc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[Ici b] b :=
mem_sets_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] a = ùìù[Ici a] a :=
le_antisymm (nhds_within_mono _ Icc_subset_Ici_self) $
  nhds_within_le_of_mem $ Icc_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ico_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] a = ùìù[Ici a] a :=
le_antisymm (nhds_within_mono _ (Œª x, and.left)) $
  nhds_within_le_of_mem $ Ico_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Icc_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
lemma continuous_within_at_Ico_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ico a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[Iic b] b :=
mem_nhds_within_of_mem_nhds $ mem_nhds_sets is_open_Ioo H

lemma Ico_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ico a c ‚àà ùìù[Iic b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[Iic b] b :=
by simpa only [dual_Ico] using @Ico_mem_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ _ ‚ü®H.2, H.1‚ü©

lemma Icc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[Iic b] b :=
mem_sets_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] b = ùìù[Iic b] b :=
by simpa only [dual_Icc] using @nhds_within_Icc_eq_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ h

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] b = ùìù[Iic b] b :=
by simpa only [dual_Ico] using @nhds_within_Ico_eq_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ h

@[simp]
lemma continuous_within_at_Icc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
lemma continuous_within_at_Ioc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]

end linear_order

section decidable_linear_order
variables [topological_space Œ±] [decidable_linear_order Œ±] [order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±}

section
variables [topological_space Œ≤] (hf : continuous f) (hg : continuous g)
include hf hg

lemma frontier_le_subset_eq : frontier {b | f b ‚â§ g b} ‚äÜ {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _),
  convert hb‚ÇÇ using 2, simp only [not_le.symm], refl
end

lemma frontier_lt_subset_eq : frontier {b | f b < g b} ‚äÜ {b | f b = g b} :=
by rw ‚Üê frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]

@[continuity] lemma continuous.min : continuous (Œªb, min (f b) (g b)) :=
have ‚àÄb‚ààfrontier {b | f b ‚â§ g b}, f b = g b, from assume b hb, frontier_le_subset_eq hf hg hb,
continuous_if this hf hg

@[continuity] lemma continuous.max : continuous (Œªb, max (f b) (g b)) :=
@continuous.min (order_dual Œ±) _ _ _ _ _ _ _ hf hg

end

lemma tendsto.max {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, max p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (max a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.max continuous_snd) _
    end
    (hf.prod_mk hg)

lemma tendsto.min {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, min p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (min a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.min continuous_snd) _
    end
    (hf.prod_mk hg)

end decidable_linear_order

end order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class order_topology (Œ± : Type*) [t : topological_space Œ±] [preorder Œ±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | ‚àÉa, s = Ioi a ‚à® s = Iio a})

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def preorder.topology (Œ± : Type*) [preorder Œ±] : topological_space Œ± :=
generate_from {s : set Œ± | ‚àÉ (a : Œ±), s = {b : Œ± | a < b} ‚à® s = {b : Œ± | b < a}}

section order_topology

instance {Œ± : Type*} [topological_space Œ±] [partial_order Œ±] [order_topology Œ±] :
  order_topology (order_dual Œ±) :=
‚ü®by convert @order_topology.topology_eq_generate_intervals Œ± _ _ _;
  conv in (_ ‚à® _) { rw or.comm }; refl‚ü©

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_topology Œ±]
include t

lemma is_open_iff_generate_intervals {s : set Œ±} :
  is_open s ‚Üî generate_open {s | ‚àÉa, s = Ioi a ‚à® s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl

lemma is_open_lt' (a : Œ±) : is_open {b:Œ± | a < b} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©

lemma is_open_gt' (a : Œ±) : is_open {b:Œ± | b < a} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©

lemma lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
mem_nhds_sets (is_open_lt' _) h

lemma le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
(ùìù b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
mem_nhds_sets (is_open_gt' _) h

lemma ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
(ùìù a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma nhds_eq_order (a : Œ±) :
  ùìù a = (‚®Öb ‚àà Iio a, ùìü (Ioi b)) ‚äì (‚®Öb ‚àà Ioi a, ùìü (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | b < c} $ infi_le _ ‚ü®hb, b, or.inl rfl‚ü©)
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | c < b} $ infi_le _ ‚ü®hb, b, or.inr rfl‚ü©))
  (le_infi $ assume s, le_infi $ assume ‚ü®ha, b, hs‚ü©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_left_of_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_right_of_le $ infi_le_of_le b $ infi_le _ h
    end)

lemma tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß (‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a') :=
by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Œ±) : tendsto_Ixx_class Icc (ùìù a) (ùìù a) :=
begin
  simp only [nhds_eq_order, infi_subtype'],
  refine ((has_basis_infi_principal_finite _).inf
    (has_basis_infi_principal_finite _)).tendsto_Ixx_class (Œª s hs, _),
  refine (ord_connected_bInter _).inter (ord_connected_bInter _); intros _ _,
  exacts [ord_connected_Ioi, ord_connected_Iio]
end

instance tendsto_Ico_class_nhds (a : Œ±) : tendsto_Ixx_class Ico (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ico_subset_Icc_self)

instance tendsto_Ioc_class_nhds (a : Œ±) : tendsto_Ixx_class Ioc (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioc_subset_Icc_self)

instance tendsto_Ioo_class_nhds (a : Œ±) : tendsto_Ixx_class Ioo (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioo_subset_Icc_self)

instance tendsto_Ixx_nhds_within (a : Œ±) {s t : set Œ±} {Ixx}
  [tendsto_Ixx_class Ixx (ùìù a) (ùìù a)] [tendsto_Ixx_class Ixx (ùìü s) (ùìü t)]:
  tendsto_Ixx_class Ixx (ùìù[s] a) (ùìù[t] a) :=
filter.tendsto_Ixx_class_inf

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a))
  (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b) (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) :
  tendsto f b (ùìù a) :=
tendsto_order.2
  ‚ü®assume a' h',
    have ‚àÄ·∂† b in b, a' < g b, from (tendsto_order.1 hg).left a' h',
    by filter_upwards [this, hgf] assume a, lt_of_lt_of_le,
    assume a' h',
    have ‚àÄ·∂† b in b, h b < a', from (tendsto_order.1 hh).right a' h',
    by filter_upwards [this, hfh] assume a h‚ÇÅ h‚ÇÇ, lt_of_le_of_lt h‚ÇÇ h‚ÇÅ‚ü©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
  tendsto f b (ùìù a) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh
  (eventually_of_forall hgf) (eventually_of_forall hfh)

lemma nhds_order_unbounded {a : Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  ùìù a = (‚®Öl (h‚ÇÇ : l < a) u (h‚ÇÇ : a < u), ùìü (Ioo l u)) :=
calc ùìù a = (‚®Öb<a, ùìü {c | b < c}) ‚äì (‚®Öb>a, ùìü {c | c < b}) : nhds_eq_order a
  ... = (‚®Öb<a, ùìü {c | b < c} ‚äì (‚®Öb>a, ùìü {c | c < b})) : binfi_inf hl
  ... = (‚®Öl<a, (‚®Öu>a, ùìü {c | c < u} ‚äì ùìü {c | l < c})) :
    begin
      congr, funext x,
      congr, funext hx,
      rw [inf_comm],
      apply binfi_inf hu
    end
  ... = _ : by simp [inter_comm]; refl

lemma tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤}
  (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) (h : ‚àÄl u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
  tendsto f x (ùìù a) :=
by rw [nhds_order_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)

end partial_order

theorem induced_order_topology' {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b)
  (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
  @order_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { exact mem_comap_sets.2 ‚ü®{x | f b < x},
        mem_inf_sets_of_left $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© },
    { exact mem_comap_sets.2 ‚ü®{x | x < f b},
        mem_inf_sets_of_right $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _); simp,
    { rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inl rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inr rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end

theorem induced_order_topology {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @order_topology _ (induced f ta) _ :=
induced_order_topology' f @hf
  (Œª a x xa, let ‚ü®b, xb, ba‚ü© := H xa in ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
  (Œª a x ax, let ‚ü®b, ab, bx‚ü© := H ax in ‚ü®b, hf.1 ab, le_of_lt bx‚ü©)

/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected {Œ± : Type u}
  [ta : topological_space Œ±] [decidable_linear_order Œ±] [order_topology Œ±]
  {t : set Œ±} [ht : ord_connected t] :
  order_topology t :=
begin
  letI := induced (coe : t ‚Üí Œ±) ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Œ±)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { refine ‚ü®Ioi b, _, Œª _, id‚ü©,
      refine mem_inf_sets_of_left (mem_infi_sets b _),
      exact mem_infi_sets ab (mem_principal_self (Ioi ‚Üëb)) },
    { refine ‚ü®Iio b, _, Œª _, id‚ü©,
      refine mem_inf_sets_of_right (mem_infi_sets b _),
      exact mem_infi_sets ab (mem_principal_self (Iio b)) } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _,
    { refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _),
      by_cases hx : x ‚àà t,
      { refine mem_infi_sets (Ioi ‚ü®x, hx‚ü©) (mem_infi_sets ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inl rfl‚ü©‚ü© _),
        exact Œª _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map],
      convert univ_sets _,
      suffices hx' : ‚àÄ (y : t), ‚Üëy ‚àà Ioi x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Œª hx, ht y.2 a.2 ‚ü®le_of_not_gt hx, le_of_lt h‚ü© },
    { refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _),
      by_cases hx : x ‚àà t,
      { refine mem_infi_sets (Iio ‚ü®x, hx‚ü©) (mem_infi_sets ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inr rfl‚ü©‚ü© _),
        exact Œª _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map],
      convert univ_sets _,
      suffices hx' : ‚àÄ (y : t), ‚Üëy ‚àà Iio x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Œª hx, ht a.2 y.2 ‚ü®le_of_lt h, le_of_not_gt hx‚ü© } }
end

lemma nhds_top_order [topological_space Œ±] [order_top Œ±] [order_topology Œ±] :
  ùìù (‚ä§:Œ±) = (‚®Öl (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l)) :=
by simp [nhds_eq_order (‚ä§:Œ±)]

lemma nhds_bot_order [topological_space Œ±] [order_bot Œ±] [order_topology Œ±] :
  ùìù (‚ä•:Œ±) = (‚®Öl (h‚ÇÇ : ‚ä• < l), ùìü (Iio l)) :=
by simp [nhds_eq_order (‚ä•:Œ±)]

section linear_order

variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]

lemma exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
  ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
begin
  rw [nhds_eq_order a] at hs,
  rcases hs with ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hts‚ü©,
  -- First we show that `t‚ÇÇ` includes `(-‚àû, a]`, so it suffices to show `(l', ‚àû) ‚äÜ t‚ÇÅ`
  suffices : ‚àÉ l' ‚àà Ico l a, Ioi l' ‚äÜ t‚ÇÅ,
  { have A : ùìü (Iic a) ‚â§ ‚®Ö b ‚àà Ioi a, ùìü (Iio b),
      from (le_infi $ Œª b, le_infi $ Œª hb, principal_mono.2 $ Iic_subset_Iio.2 hb),
    have B : t‚ÇÅ ‚à© Iic a ‚äÜ s,
      from subset.trans (inter_subset_inter_right _ (A ht‚ÇÇ)) hts,
    from this.imp (Œª l', Exists.imp $ Œª hl' hl x hx, B ‚ü®hl hx.1, hx.2‚ü©) },
  clear hts ht‚ÇÇ t‚ÇÇ,
  -- Now we find `l` such that `(l', ‚àû) ‚äÜ t‚ÇÅ`
  letI := classical.DLO Œ±,
  rw [mem_binfi] at ht‚ÇÅ,
  { rcases ht‚ÇÅ with ‚ü®b, hb, hb'‚ü©,
    exact ‚ü®max b l, ‚ü®le_max_right _ _, max_lt hb hl‚ü©,
      Œª x hx, hb' $ Ioi_subset_Ioi (le_max_left _ _) hx‚ü© },
  { intros b hb b' hb', simp only [mem_Iio] at hb hb',
    use [max b b', max_lt hb hb'],
    simp [le_refl] },
  exact ‚ü®l, hl‚ü©
end

lemma exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
  ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s :=
begin
  convert @exists_Ioc_subset_of_mem_nhds' (order_dual Œ±) _ _ _ _ _ hs _ hu,
  ext, rw [dual_Ico, dual_Ioc]
end

lemma exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
  ‚àÉ l < a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.2, hl.snd‚ü©

lemma exists_Ico_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
  ‚àÉ u (_ : a < u), Ico a u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.1, hl.snd‚ü©

lemma mem_nhds_unbounded {a : Œ±} {s : set Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  s ‚àà ùìù a ‚Üî (‚àÉl u, l < a ‚àß a < u ‚àß ‚àÄb, l < b ‚Üí b < u ‚Üí b ‚àà s) :=
let ‚ü®l, hl'‚ü© := hl, ‚ü®u, hu'‚ü© := hu in
have ùìù a = (‚®Öp : {l // l < a} √ó {u // a < u}, ùìü (Ioo p.1.val p.2.val)),
  by simp [nhds_order_unbounded hu hl, infi_subtype, infi_prod],
iff.intro
  (assume hs, by rw [this] at hs; from infi_sets_induct hs
    ‚ü®l, u, hl', hu', by simp‚ü©
    begin
      intro p, rcases p with ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü©,
      simp [set.subset_def],
      intros s‚ÇÅ s‚ÇÇ hs‚ÇÅ l' hl' u' hu' hs‚ÇÇ,
      letI := classical.DLO Œ±,
      refine ‚ü®max l l', _, min u u', _‚ü©;
      simp [*, lt_min_iff, max_lt_iff] {contextual := tt}
    end
    (assume s‚ÇÅ s‚ÇÇ h ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©, ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, assume b hu hl, h $ h‚ÇÉ _ hu hl‚ü©))
  (assume ‚ü®l, u, hl, hu, h‚ü©,
    by rw [this]; exact mem_infi_sets ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü© (assume b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h b h‚ÇÅ h‚ÇÇ))

lemma order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
  ‚àÉu v : set Œ±, is_open u ‚àß is_open v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß (‚àÄb‚ÇÅ‚ààu, ‚àÄb‚ÇÇ‚ààv, b‚ÇÅ < b‚ÇÇ) :=
match dense_or_discrete a‚ÇÅ a‚ÇÇ with
| or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, {a' | a < a'}, is_open_gt' a, is_open_lt' a, ha‚ÇÅ, ha‚ÇÇ,
    assume b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ, lt_trans h‚ÇÅ h‚ÇÇ‚ü©
| or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a | a < a‚ÇÇ}, {a | a‚ÇÅ < a}, is_open_gt' a‚ÇÇ, is_open_lt' a‚ÇÅ, h, h,
    assume b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ,
    calc b‚ÇÅ ‚â§ a‚ÇÅ : h‚ÇÇ _ hb‚ÇÅ
      ... < a‚ÇÇ : h
      ... ‚â§ b‚ÇÇ : h‚ÇÅ _ hb‚ÇÇ‚ü©
end

@[priority 100] -- see Note [lower instance priority]
instance order_topology.to_order_closed_topology : order_closed_topology Œ± :=
{ is_closed_le' :=
    is_open_prod_iff.mpr $ assume a‚ÇÅ a‚ÇÇ (h : ¬¨ a‚ÇÅ ‚â§ a‚ÇÇ),
      have h : a‚ÇÇ < a‚ÇÅ, from lt_of_not_ge h,
      let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h in
      ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, assume ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, not_le_of_gt $ h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü© }

lemma order_topology.t2_space : t2_space Œ± := by apply_instance

@[priority 100] -- see Note [lower instance priority]
instance order_topology.regular_space : regular_space Œ± :=
{ regular := assume s a hs ha,
    have hs' : s·∂ú ‚àà ùìù a, from mem_nhds_sets hs ha,
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄl‚àà s, l < a ‚Üí l ‚àà t) ‚àß ùìù[t] a = ‚ä•,
      from by_cases
        (assume h : ‚àÉl, l < a,
          let ‚ü®l, hl, h‚ü© := exists_Ioc_subset_of_mem_nhds hs' h in
          match dense_or_discrete l a with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | a < b}, is_open_gt' _,
              assume c hcs hca, show c < b,
                from lt_of_not_ge $ assume hbc, h ‚ü®lt_of_lt_of_le hb‚ÇÅ hbc, le_of_lt hca‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hb‚ÇÇ) $
                assume x (hx : b < x), show ¬¨ x < b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, is_open_gt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hl) $
                assume x (hx : l < x), show ¬¨ x < a, from not_lt.2 $ h‚ÇÅ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉl, l < a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          nhds_within_empty _‚ü©),
    let ‚ü®t‚ÇÅ, ht‚ÇÅo, ht‚ÇÅs, ht‚ÇÅa‚ü© := this in
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄu‚àà s, u>a ‚Üí u ‚àà t) ‚àß ùìù[t] a = ‚ä•,
      from by_cases
        (assume h : ‚àÉu, u > a,
          let ‚ü®u, hu, h‚ü© := exists_Ico_subset_of_mem_nhds hs' h in
          match dense_or_discrete a u with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | b < a}, is_open_lt' _,
              assume c hcs hca, show c > b,
                from lt_of_not_ge $ assume hbc, h ‚ü®le_of_lt hca, lt_of_le_of_lt hbc hb‚ÇÇ‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hb‚ÇÅ) $
                assume x (hx : b > x), show ¬¨ x > b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' > a}, is_open_lt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hu) $
                assume x (hx : u > x), show ¬¨ x > a, from not_lt.2 $ h‚ÇÇ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉu, u > a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          nhds_within_empty _‚ü©),
    let ‚ü®t‚ÇÇ, ht‚ÇÇo, ht‚ÇÇs, ht‚ÇÇa‚ü© := this in
    ‚ü®t‚ÇÅ ‚à™ t‚ÇÇ, is_open_union ht‚ÇÅo ht‚ÇÇo,
      assume x hx,
      have x ‚â† a, from assume eq, ha $ eq ‚ñ∏ hx,
      (ne_iff_lt_or_gt.mp this).imp (ht‚ÇÅs _ hx) (ht‚ÇÇs _ hx),
      by rw [nhds_within_union, ht‚ÇÅa, ht‚ÇÇa, bot_sup_eq]‚ü©,
  ..order_topology.t2_space }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
lemma mem_nhds_iff_exists_Ioo_subset' {a l' u' : Œ±} {s : set Œ±}
  (hl' : l' < a) (hu' : a < u') :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds' h hu' with ‚ü®u, au, hu‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds' h hl' with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, u, ‚ü®la.2, au.1‚ü©, Œªx hx, _‚ü©,
    cases le_total a x with hax hax,
    { exact hu ‚ü®hax, hx.2‚ü© },
    { exact hl ‚ü®hx.1, hax‚ü© } },
  { rintros ‚ü®l, u, ha, h‚ü©,
    apply mem_sets_of_superset (mem_nhds_sets is_open_Ioo ha) h }
end

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`. -/
lemma mem_nhds_iff_exists_Ioo_subset [no_top_order Œ±] [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_iff_exists_Ioo_subset' hl' hu'

lemma Iio_mem_nhds {a b : Œ±} (h : a < b) : Iio b ‚àà ùìù a :=
mem_nhds_sets is_open_Iio h

lemma Ioi_mem_nhds {a b : Œ±} (h : a < b) : Ioi a ‚àà ùìù b :=
mem_nhds_sets is_open_Ioi h

lemma Ioo_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioo a b ‚àà ùìù x :=
mem_nhds_sets is_open_Ioo ‚ü®ha, hb‚ü©

lemma disjoint_nhds_at_top [no_top_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_top :=
begin
  rw filter.disjoint_iff,
  cases no_top x with a ha,
  use [Iio a, Ici a, Iio_mem_nhds ha, mem_at_top a],
  rw [inter_comm, Ici_inter_Iio, Ico_self]
end

@[simp] lemma inf_nhds_at_top [no_top_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_top = ‚ä• :=
disjoint_iff.1 (disjoint_nhds_at_top x)

lemma disjoint_nhds_at_bot [no_bot_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_bot :=
@disjoint_nhds_at_top (order_dual Œ±) _ _ _ _ x

@[simp] lemma inf_nhds_at_bot [no_bot_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_bot = ‚ä• :=
@inf_nhds_at_top (order_dual Œ±) _ _ _ _ x

lemma not_tendsto_nhds_of_tendsto_at_top [no_top_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_top) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_top x).symm

lemma not_tendsto_at_top_of_tendsto_nhds [no_top_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_top :=
hf.not_tendsto (disjoint_nhds_at_top x)

lemma not_tendsto_nhds_of_tendsto_at_bot [no_bot_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_bot) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_bot x).symm

lemma not_tendsto_at_bot_of_tendsto_nhds [no_bot_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_bot :=
hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/

-- NB: If you extend the list, append to the end please to avoid breaking the API
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ioi {a b : Œ±} (hab : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[Ioi a] a, -- 0 : `s` is a neighborhood of `a` within `(a, +‚àû)`
    s ‚àà ùìù[Ioc a b] a,   -- 1 : `s` is a neighborhood of `a` within `(a, b]`
    s ‚àà ùìù[Ioo a b] a,   -- 2 : `s` is a neighborhood of `a` within `(a, b)`
    ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,    -- 3 : `s` includes `(a, u)` for some `u ‚àà (a, b]`
    ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] :=   -- 4 : `s` includes `(a, u)` for some `u > a`
begin
  tfae_have : 1 ‚Üî 2, by rw [nhds_within_Ioc_eq_nhds_within_Ioi hab],
  tfae_have : 1 ‚Üî 3, by rw [nhds_within_Ioo_eq_nhds_within_Ioi hab],
  tfae_have : 4 ‚Üí 5, from Œª ‚ü®u, umem, hu‚ü©, ‚ü®u, umem.1, hu‚ü©,
  tfae_have : 5 ‚Üí 1,
  { rintros ‚ü®u, hau, hu‚ü©,
    exact mem_sets_of_superset (Ioo_mem_nhds_within_Ioi ‚ü®le_refl a, hau‚ü©) hu },
  tfae_have : 1 ‚Üí 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, _‚ü©,
    exact hx.1 },
  tfae_finish
end

lemma mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉu ‚àà Ioc a u', Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Ioi a] a ‚Üî ‚àÉu ‚àà Ioi a, Ioc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
lemma tfae_mem_nhds_within_Iio {a b : Œ±} (h : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[Iio b] b, -- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`
    s ‚àà ùìù[Ico a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b)`
    s ‚àà ùìù[Ioo a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b)`
    ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,    -- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`
    ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] :=   -- 4 : `s` includes `(l, b)` for some `l < b`
begin
  have := @tfae_mem_nhds_within_Ioi (order_dual Œ±) _ _ _ _ _ h s,
  -- If we call `convert` here, it generates wrong equations, so we need to simplify first
  simp only [exists_prop] at this ‚ä¢,
  rw [dual_Ioi, dual_Ioc, dual_Ioo] at this,
  convert this; ext l; rw [dual_Ioo]
end

lemma mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉl ‚àà Ico l' a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[Iio a] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Iio a] a ‚Üî ‚àÉl ‚àà Iio a, Ico l a ‚äÜ s :=
begin
  convert @mem_nhds_within_Ioi_iff_exists_Ioc_subset (order_dual Œ±) _ _ _ _ _ _ _,
  simp only [dual_Ioc], refl
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +‚àû)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u ‚àà (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ici {a b : Œ±} (hab : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[Ici a] a, -- 0 : `s` is a neighborhood of `a` within `[a, +‚àû)`
    s ‚àà ùìù[Icc a b] a,   -- 1 : `s` is a neighborhood of `a` within `[a, b]`
    s ‚àà ùìù[Ico a b] a,   -- 2 : `s` is a neighborhood of `a` within `[a, b)`
    ‚àÉ u ‚àà Ioc a b, Ico a u ‚äÜ s,    -- 3 : `s` includes `[a, u)` for some `u ‚àà (a, b]`
    ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s] :=   -- 4 : `s` includes `[a, u)` for some `u > a`
begin
  tfae_have : 1 ‚Üî 2, by rw [nhds_within_Icc_eq_nhds_within_Ici hab],
  tfae_have : 1 ‚Üî 3, by rw [nhds_within_Ico_eq_nhds_within_Ici hab],
  tfae_have : 4 ‚Üí 5, from Œª ‚ü®u, umem, hu‚ü©, ‚ü®u, umem.1, hu‚ü©,
  tfae_have : 5 ‚Üí 1,
  { rintros ‚ü®u, hau, hu‚ü©,
    exact mem_sets_of_superset (Ico_mem_nhds_within_Ici ‚ü®le_refl a, hau‚ü©) hu },
  tfae_have : 1 ‚Üí 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®hu ‚ü®hx.1, hx.2‚ü©, _‚ü©,
    exact hx.1 },
  tfae_finish
end

lemma mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉu ‚àà Ioc a u', Ico a u ‚äÜ s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[Ici a] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset' [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Ici a] a ‚Üî ‚àÉu ‚àà Ioi a, Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ‚àà [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
lemma tfae_mem_nhds_within_Iic {a b : Œ±} (h : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[Iic b] b, -- 0 : `s` is a neighborhood of `b` within `(-‚àû, b]`
    s ‚àà ùìù[Icc a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b]`
    s ‚àà ùìù[Ioc a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b]`
    ‚àÉ l ‚àà Ico a b, Ioc l b ‚äÜ s,    -- 3 : `s` includes `(l, b]` for some `l ‚àà [a, b)`
    ‚àÉ l ‚àà Iio b, Ioc l b ‚äÜ s] :=   -- 4 : `s` includes `(l, b]` for some `l < b`
begin
  have := @tfae_mem_nhds_within_Ici (order_dual Œ±) _ _ _ _ _ h s,
  -- If we call `convert` here, it generates wrong equations, so we need to simplify first
  simp only [exists_prop] at this ‚ä¢,
  rw [dual_Icc, dual_Ioc, dual_Ioi] at this,
  convert this; ext l; rw [dual_Ico]
end

lemma mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉl ‚àà Ico l' a, Ioc l a ‚äÜ s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[Iic a] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset' [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Iic a] a ‚Üî ‚àÉl ‚àà Iio a, Icc l a ‚äÜ s :=
begin
  convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (order_dual Œ±) _ _ _ _ _ _ _,
  simp_rw (show ‚àÄ u : order_dual Œ±, @Icc (order_dual Œ±) _ a u = @Icc Œ± _ u a, from Œª u, dual_Icc),
  refl,
end

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Ici a] a ‚Üî ‚àÉu, a < u ‚àß Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[Iic a] a ‚Üî ‚àÉl, l < a ‚àß Icc l a ‚äÜ s :=
begin
  rw mem_nhds_within_Iic_iff_exists_Ioc_subset,
  split,
  { rintros ‚ü®l, la, as‚ü©,
    rcases dense la with ‚ü®v, hv‚ü©,
    refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, },
  { rintros ‚ü®l, la, as‚ü©,
    exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü© }
end

section functions
variables [topological_space Œ≤] [linear_order Œ≤] [order_topology Œ≤]

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and surjective, it is everywhere right-continuous. Superseded
later in this file by `continuous_of_strict_mono_surjective` (same assumptions). -/
lemma continuous_right_of_strict_mono_surjective
  {f : Œ± ‚Üí Œ≤} (h_mono : strict_mono f) (h_surj : function.surjective f) (a : Œ±) :
  continuous_within_at f (Ici a) a :=
begin
  have ha : a ‚àà Ici a := left_mem_Ici,
  intros s hs,
  by_cases hfa_top : ‚àÉ p, f a < p,
  { obtain ‚ü®q, hq, hqs‚ü© : ‚àÉ q ‚àà Ioi (f a), Ico (f a) q ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds hs hfa_top,
    refine mem_sets_of_superset (mem_map.2 _) hqs,
    have h_surj_on := surj_on_Ici_of_monotone_surjective h_mono.monotone h_surj a,
    rcases h_surj_on (Ioi_subset_Ici_self hq) with ‚ü®x, hx, rfl‚ü©,
    rcases eq_or_lt_of_le hx with rfl|hax, { exact (lt_irrefl _ hq).elim },
    refine mem_sets_of_superset (Ico_mem_nhds_within_Ici (left_mem_Ico.2 hax)) _,
    intros z hz,
    exact ‚ü®h_mono.monotone hz.1, h_mono hz.2‚ü© },
  { push_neg at hfa_top,
    have ha_top : ‚àÄ x : Œ±, x ‚â§ a := strict_mono.top_preimage_top h_mono hfa_top,
    rw [Ici_singleton_of_top ha_top, nhds_within_eq_map_subtype_coe (mem_singleton a),
      nhds_discrete {x : Œ± // x ‚àà {a}}],
    { exact mem_pure_sets.mpr (mem_of_nhds hs) },
    { apply_instance } }
end

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and surjective, it is everywhere left-continuous. Superseded
later in this file by `continuous_of_strict_mono_surjective` (same assumptions). -/
lemma continuous_left_of_strict_mono_surjective
  {f : Œ± ‚Üí Œ≤} (h_mono : strict_mono f) (h_surj : function.surjective f) (a : Œ±) :
  continuous_within_at f (Iic a) a :=
begin
  apply @continuous_right_of_strict_mono_surjective (order_dual Œ±) (order_dual Œ≤),
  { exact Œª x y hxy, h_mono hxy },
  { simpa only [dual_Icc] }
end

end functions

end linear_order

section linear_ordered_ring
variables [topological_space Œ±] [linear_ordered_ring Œ±] [order_topology Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

/- TODO The theorems in this section ought to be written in the context of linearly ordered
(additive) commutative groups rather than linearly ordered rings; however, the former concept does
not currently exist in mathlib. -/

/-- In a linearly ordered ring with the order topology, if `f` tends to `C` and `g` tends to
`at_top` then `f + g` tends to `at_top`. -/
lemma tendsto_at_top_add_tendsto_left
  {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
begin
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := no_bot C,
  refine tendsto_at_top_add_left_of_le' _ C' _ hg,
  rw tendsto_order at hf,
  exact (hf.1 C' hC').mp (eventually_of_forall (Œª x hx, le_of_lt hx))
end

/-- In a linearly ordered ring with the order topology, if `f` tends to `C` and `g` tends to
`at_bot` then `f + g` tends to `at_bot`. -/
lemma tendsto_at_bot_add_tendsto_left
  {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
begin
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C < C' := no_top C,
  refine tendsto_at_bot_add_left_of_ge' _ C' _ hg,
  rw tendsto_order at hf,
  exact (hf.2 C' hC').mp (eventually_of_forall (Œª x hx, le_of_lt hx))
end

/-- In a linearly ordered ring with the order topology, if `f` tends to `at_top` and `g` tends to
`C` then `f + g` tends to `at_top`. -/
lemma tendsto_at_top_add_tendsto_right
  {C : Œ±} (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_top :=
begin
  convert tendsto_at_top_add_tendsto_left hg hf,
  ext,
  exact add_comm _ _,
end

/-- In a linearly ordered ring with the order topology, if `f` tends to `at_bot` and `g` tends to
`C` then `f + g` tends to `at_bot`. -/
lemma tendsto_at_bot_add_tendsto_right
  {C : Œ±} (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_bot :=
begin
  convert tendsto_at_bot_add_tendsto_left hg hf,
  ext,
  exact add_comm _ _,
end

end linear_ordered_ring

section decidable_linear_ordered_semiring
variables [decidable_linear_ordered_semiring Œ±] [archimedean Œ±]
variables {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. The archimedean assumption is convenient to get a
statement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is
given in `tendsto_at_top_mul_left'`). -/
lemma tendsto_at_top_mul_left  {r : Œ±} (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, r * f x) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢‚Ñï r‚ü© := archimedean.arch 1 hr,
  have hn' : 1 ‚â§ r * n, by rwa nsmul_eq_mul' at hn,
  filter_upwards [(tendsto_at_top _ _).1 hf (n * max b 0)],
  assume x hx,
  calc b ‚â§ 1 * max b 0 : by { rw [one_mul], exact le_max_left _ _ }
  ... ‚â§ (r * n) * max b 0 : mul_le_mul_of_nonneg_right hn' (le_max_right _ _)
  ... = r * (n * max b 0) : by rw [mul_assoc]
  ... ‚â§ r * f x : mul_le_mul_of_nonneg_left hx (le_of_lt hr)
end

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. The archimedean assumption is convenient to get a
statement that works on `‚Ñï`, `‚Ñ§` and `‚Ñù`, although not necessary (a version in ordered fields is
given in `tendsto_at_top_mul_right'`). -/
lemma tendsto_at_top_mul_right {r : Œ±} (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, f x * r) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  obtain ‚ü®n : ‚Ñï, hn : 1 ‚â§ n ‚Ä¢‚Ñï r‚ü© := archimedean.arch 1 hr,
  have hn' : 1 ‚â§ (n : Œ±) * r, by rwa nsmul_eq_mul at hn,
  filter_upwards [(tendsto_at_top _ _).1 hf (max b 0 * n)],
  assume x hx,
  calc b ‚â§ max b 0 * 1 : by { rw [mul_one], exact le_max_left _ _ }
  ... ‚â§ max b 0 * (n * r) : mul_le_mul_of_nonneg_left hn' (le_max_right _ _)
  ... = (max b 0 * n) * r : by rw [mul_assoc]
  ... ‚â§ f x * r : mul_le_mul_of_nonneg_right hx (le_of_lt hr)
end

end decidable_linear_ordered_semiring

section linear_ordered_field
variables [linear_ordered_field Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the left) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`tendsto_at_top_mul_left` instead. -/
lemma tendsto_at_top_mul_left' {r : Œ±} (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, r * f x) l at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  filter_upwards [(tendsto_at_top _ _).1 hf (b/r)],
  assume x hx,
  simpa [div_le_iff' hr] using hx
end

/-- If a function tends to infinity along a filter, then this function multiplied by a positive
constant (on the right) also tends to infinity. For a version working in `‚Ñï` or `‚Ñ§`, use
`tendsto_at_top_mul_right` instead. -/
lemma tendsto_at_top_mul_right' {r : Œ±} (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, f x * r) l at_top :=
by simpa [mul_comm] using tendsto_at_top_mul_left' hr hf

/-- If a function tends to infinity along a filter, then this function divided by a positive
constant also tends to infinity. -/
lemma tendsto_at_top_div {r : Œ±} (hr : 0 < r) (hf : tendsto f l at_top) :
  tendsto (Œªx, f x / r) l at_top :=
tendsto_at_top_mul_right' (inv_pos.2 hr) hf

variables [topological_space Œ±] [order_topology Œ±]

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
lemma tendsto_mul_at_top {C : Œ±} (hC : 0 < C) (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_top :=
begin
  rw tendsto_at_top at hf ‚ä¢,
  rw tendsto_order at hg,
  intro b,
  refine (hf (b/(C/2))).mp ((hg.1 (C/2) (half_lt_self hC)).mp ((hf 1).mp (eventually_of_forall _))),
  intros x hx hltg hlef,
  nlinarith [(div_le_iff' (half_pos hC)).mp hlef],
end

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
lemma tendsto_mul_at_bot {C : Œ±} (hC : C < 0) (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, (f x * g x)) l at_bot :=
begin
  rw tendsto_at_bot,
  rw tendsto_at_top at hf,
  rw tendsto_order at hg,
  intro b,
  refine (hf (b/(C/2))).mp ((hg.2 (C/2) (by linarith)).mp ((hf 1).mp (eventually_of_forall _))),
  intros x hx hltg hlef,
  nlinarith [(div_le_iff_of_neg (div_neg_of_neg_of_pos hC zero_lt_two)).mp hlef],
end

end linear_ordered_field

section discrete_linear_ordered_field
variables [discrete_linear_ordered_field Œ±] [topological_space Œ±] [order_topology Œ±]

/-- The function `x ‚Ü¶ x‚Åª¬π` tends to `+‚àû` on the right of `0`. -/
lemma tendsto_inv_zero_at_top : tendsto (Œªx:Œ±, x‚Åª¬π) (ùìù[set.Ioi (0:Œ±)] 0) at_top :=
begin
  apply (tendsto_at_top _ _).2 (Œªb, _),
  refine mem_nhds_within_Ioi_iff_exists_Ioo_subset.2 ‚ü®(max b 1)‚Åª¬π, by simp [zero_lt_one], Œªx hx, _‚ü©,
  calc b ‚â§ max b 1 : le_max_left _ _
  ... ‚â§ x‚Åª¬π : begin
    apply (le_inv _ hx.1).2 (le_of_lt hx.2),
    exact lt_of_lt_of_le zero_lt_one (le_max_right _ _)
  end
end

/-- The function `r ‚Ü¶ r‚Åª¬π` tends to `0` on the right as `r ‚Üí +‚àû`. -/
lemma tendsto_inv_at_top_zero' : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (ùìù[set.Ioi (0:Œ±)] 0) :=
begin
  assume s hs,
  rw mem_nhds_within_Ioi_iff_exists_Ioc_subset at hs,
  rcases hs with ‚ü®C, C0, hC‚ü©,
  change 0 < C at C0,
  refine filter.mem_map.2 (mem_sets_of_superset (mem_at_top C‚Åª¬π) (Œª x hx, hC _)),
  have : 0 < x, from lt_of_lt_of_le (inv_pos.2 C0) hx,
  exact ‚ü®inv_pos.2 this, (inv_le C0 this).1 hx‚ü©
end

lemma tendsto_inv_at_top_zero : tendsto (Œªr:Œ±, r‚Åª¬π) at_top (ùìù 0) :=
tendsto_inv_at_top_zero'.mono_right inf_le_left

variables {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±}

lemma tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (f‚Åª¬π) l (ùìù 0) :=
tendsto_inv_at_top_zero.comp h

lemma tendsto.inv_tendsto_zero (h : tendsto f l (ùìù[set.Ioi 0] 0)) : tendsto (f‚Åª¬π) l at_top :=
tendsto_inv_zero_at_top.comp h

end discrete_linear_ordered_field

lemma preimage_neg [add_group Œ±] : preimage (has_neg.neg : Œ± ‚Üí Œ±) = image (has_neg.neg : Œ± ‚Üí Œ±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm

lemma filter.map_neg [add_group Œ±] : map (has_neg.neg : Œ± ‚Üí Œ±) = comap (has_neg.neg : Œ± ‚Üí Œ±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

section topological_add_group

variables [topological_space Œ±] [ordered_add_comm_group Œ±] [topological_add_group Œ±]

lemma neg_preimage_closure {s : set Œ±} : (Œªr:Œ±, -r) ‚Åª¬π' closure s = closure ((Œªr:Œ±, -r) '' s) :=
have (Œªr:Œ±, -r) ‚àò (Œªr:Œ±, -r) = id, from funext neg_neg,
by rw [preimage_neg]; exact
  (subset.antisymm (image_closure_subset_closure_image continuous_neg) $
    calc closure ((Œª (r : Œ±), -r) '' s) = (Œªr, -r) '' ((Œªr, -r) '' closure ((Œª (r : Œ±), -r) '' s)) :
        by rw [‚Üêimage_comp, this, image_id]
      ... ‚äÜ (Œªr, -r) '' closure ((Œªr, -r) '' ((Œª (r : Œ±), -r) '' s)) :
        monotone_image $ image_closure_subset_closure_image continuous_neg
      ... = _ : by rw [‚Üêimage_comp, this, image_id])

end topological_add_group

section order_topology

variables [topological_space Œ±] [topological_space Œ≤]
  [linear_order Œ±] [linear_order Œ≤] [order_topology Œ±] [order_topology Œ≤]

lemma is_lub.nhds_within_ne_bot {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ne_bot (ùìù[s] a) :=
let ‚ü®a', ha'‚ü© := hs in
forall_sets_nonempty_iff_ne_bot.mp $ assume t ht,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, ht‚ü© := mem_inf_sets.mp ht in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ, from mem_of_nhds ht‚ÇÅ,
      have a ‚àà t‚ÇÇ, from ht‚ÇÇ $ by rwa [h],
      ‚ü®a, ht ‚ü®‚Äπa ‚àà t‚ÇÅ‚Ä∫, ‚Äπa ‚àà t‚ÇÇ‚Ä∫‚ü©‚ü©)
    (assume : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ‚Äπa' ‚àà s‚Ä∫) this.symm,
      let ‚ü®l, hl, hlt‚ÇÅ‚ü© := exists_Ioc_subset_of_mem_nhds ht‚ÇÅ ‚ü®a', this‚ü© in
      have ‚àÉa'‚ààs, l < a',
        from classical.by_contradiction $ assume : ¬¨ ‚àÉa'‚ààs, l < a',
          have ‚àÄa'‚ààs, a' ‚â§ l, from assume a ha, not_lt.1 $ assume ha', this ‚ü®a, ha, ha'‚ü©,
          have ¬¨ l < a, from not_lt.2 $ ha.right this,
          this ‚Äπl < a‚Ä∫,
      let ‚ü®a', ha', ha'l‚ü© := this in
      have a' ‚àà t‚ÇÅ, from hlt‚ÇÅ ‚ü®‚Äπl < a'‚Ä∫, ha.left ha'‚ü©,
      ‚ü®a', ht ‚ü®‚Äπa' ‚àà t‚ÇÅ‚Ä∫, ht‚ÇÇ ‚Äπa' ‚àà s‚Ä∫‚ü©‚ü©)

lemma is_glb.nhds_within_ne_bot : ‚àÄ {a : Œ±} {s : set Œ±}, is_glb s a ‚Üí s.nonempty ‚Üí
  ne_bot (ùìù[s] a) :=
@is_lub.nhds_within_ne_bot (order_dual Œ±) _ _ _

lemma is_lub_of_mem_nhds {s : set Œ±} {a : Œ±} {f : filter Œ±}
  (hsa : a ‚àà upper_bounds s) (hsf : s ‚àà f) [ne_bot (f ‚äì ùìù a)] : is_lub s a :=
‚ü®hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s ‚à© {a | b < a} ‚àà f ‚äì ùìù a,
    from inter_mem_inf_sets hsf (mem_nhds_sets (is_open_lt' _) hba),
  let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := nonempty_of_mem_sets this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b this‚ü©

lemma is_glb_of_mem_nhds : ‚àÄ {s : set Œ±} {a : Œ±} {f : filter Œ±},
  a ‚àà lower_bounds s ‚Üí s ‚àà f ‚Üí ne_bot (f ‚äì ùìù a) ‚Üí is_glb s a :=
@is_lub_of_mem_nhds (order_dual Œ±) _ _ _

lemma is_lub_of_is_lub_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) (ha : is_lub s a) (hs : s.nonempty)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : is_lub (f '' s) b :=
have hnbot : ne_bot (ùìù[s] a), from ha.nhds_within_ne_bot hs,
have ‚àÄa'‚ààs, ¬¨ b < f a',
  from assume a' ha' h,
  have ‚àÄ·∂† x in ùìù b, x < f a', from mem_nhds_sets (is_open_gt' _) h,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hs‚ü© := mem_inf_sets.mp (hb this) in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ ‚à© t‚ÇÇ, from ‚ü®mem_of_nhds ht‚ÇÅ, ht‚ÇÇ $ by rwa [h]‚ü©,
      have f a < f a', from hs this,
      lt_irrefl (f a') $ by rwa [h] at this)
    (assume h : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ha') h.symm,
      have {x | a' < x} ‚àà ùìù a, from mem_nhds_sets (is_open_lt' _) this,
      have {x | a' < x} ‚à© t‚ÇÅ ‚àà ùìù a, from inter_mem_sets this ht‚ÇÅ,
      have ({x | a' < x} ‚à© t‚ÇÅ) ‚à© s ‚àà ùìù[s] a,
        from inter_mem_inf_sets this (subset.refl s),
      let ‚ü®x, ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©, hx‚ÇÉ‚ü© := hnbot.nonempty_of_mem this in
      have hxa' : f x < f a', from hs ‚ü®hx‚ÇÇ, ht‚ÇÇ hx‚ÇÉ‚ü©,
      have ha'x : f a' ‚â§ f x, from hf _ ha' _ hx‚ÇÉ $ le_of_lt hx‚ÇÅ,
      lt_irrefl _ (lt_of_le_of_lt ha'x hxa')),
and.intro
  (assume b' ‚ü®a', ha', h_eq‚ü©, h_eq ‚ñ∏ not_lt.1 $ this _ ha')
  (assume b' hb', by exactI (le_of_tendsto hb $
      mem_inf_sets_of_right $ assume x hx, hb' $ mem_image_of_mem _ hx))

lemma is_glb_of_is_glb_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) : is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s a b
  (Œª x hx y hy, hf y hy x hx)

lemma is_glb_of_is_lub_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_lub s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma is_lub_of_is_glb_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_lub (f '' s) b :=
@is_glb_of_is_glb_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma mem_closure_of_is_lub {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  a ‚àà closure s :=
by rw closure_eq_cluster_pts; exact ha.nhds_within_ne_bot hs

lemma mem_of_is_lub_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêsc.closure_eq; exact mem_closure_of_is_lub ha hs

lemma mem_closure_of_is_glb {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  a ‚àà closure s :=
by rw closure_eq_cluster_pts; exact ha.nhds_within_ne_bot hs

lemma mem_of_is_glb_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêsc.closure_eq; exact mem_closure_of_is_glb ha hs

/-- A compact set is bounded below -/
lemma is_compact.bdd_below {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : is_compact s) : bdd_below s :=
begin
  by_contra H,
  letI := classical.DLO Œ±,
  rcases hs.elim_finite_subcover_image (Œª x (_ : x ‚àà s), @is_open_Ioi _ _ _ _ x) _
    with ‚ü®t, st, ft, ht‚ü©,
  { refine H (ft.bdd_below.imp $ Œª C hC y hy, _),
    rcases mem_bUnion_iff.1 (ht hy) with ‚ü®x, hx, xy‚ü©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Œª x hx, mem_bUnion_iff.2 (not_imp_comm.1 _ H),
    exact Œª h, ‚ü®x, Œª y hy, le_of_not_lt (h.imp $ Œª ys, ‚ü®_, hy, ys‚ü©)‚ü© }
end

/-- A compact set is bounded above -/
lemma is_compact.bdd_above {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [order_topology Œ±] : Œ† [nonempty Œ±] {s : set Œ±}, is_compact s ‚Üí bdd_above s :=
@is_compact.bdd_below (order_dual Œ±) _ _ _

end order_topology

section linear_order

variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±]

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
lemma closure_Ioi' {a b : Œ±} (hab : a < b) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioi_subset_Ici_self is_closed_Ici },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb is_glb_Ioi ‚ü®_, hab‚ü© },
    { exact subset_closure (lt_of_le_of_ne hx (ne.symm h)) } }
end

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
@[simp] lemma closure_Ioi (a : Œ±) [no_top_order Œ±] :
  closure (Ioi a) = Ici a :=
let ‚ü®b, hb‚ü© := no_top a in closure_Ioi' hb

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
lemma closure_Iio' {a b : Œ±} (hab : b < a) :
  closure (Iio a) = Iic a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Iio_subset_Iic_self is_closed_Iic },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_lub is_lub_Iio ‚ü®_, hab‚ü© },
    { apply subset_closure, by simpa [h] using lt_or_eq_of_le hx } }
end

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
@[simp] lemma closure_Iio (a : Œ±) [no_bot_order Œ±] :
  closure (Iio a) = Iic a :=
let ‚ü®b, hb‚ü© := no_bot a in closure_Iio' hb

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioo {a b : Œ±} (hab : a < b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioo_subset_Icc_self is_closed_Icc },
  { have hab' : (Ioo a b).nonempty, from nonempty_Ioo.2 hab,
    assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb (is_glb_Ioo hab) hab' },
    by_cases h' : x = b,
    { rw h', refine mem_closure_of_is_lub (is_lub_Ioo hab) hab' },
    exact subset_closure ‚ü®lt_of_le_of_ne hx.1 (ne.symm h), by simpa [h'] using lt_or_eq_of_le hx.2‚ü© }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioc {a b : Œ±} (hab : a < b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioc_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ico {a b : Œ±} (hab : a < b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ico_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end

@[simp] lemma interior_Ici [no_bot_order Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
by rw [‚Üê compl_Iio, interior_compl, closure_Iio, compl_Iic]

@[simp] lemma interior_Iic [no_top_order Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
by rw [‚Üê compl_Ioi, interior_compl, closure_Ioi, compl_Ici]

@[simp] lemma interior_Icc [no_bot_order Œ±] [no_top_order Œ±] {a b : Œ±}:
  interior (Icc a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp] lemma interior_Ico [no_bot_order Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp] lemma interior_Ioc [no_top_order Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b :=
by rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

@[simp] lemma frontier_Ici [no_bot_order Œ±] {a : Œ±} : frontier (Ici a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Iic [no_top_order Œ±] {a : Œ±} : frontier (Iic a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Ioi [no_top_order Œ±] {a : Œ±} : frontier (Ioi a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Iio [no_bot_order Œ±] {a : Œ±} : frontier (Iio a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Icc [no_bot_order Œ±] [no_top_order Œ±] {a b : Œ±} (h : a < b) :
  frontier (Icc a b) = {a, b} :=
by simp [frontier, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ioo {a b : Œ±} (h : a < b) : frontier (Ioo a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ico [no_bot_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ico a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ioc [no_top_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ioc a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

lemma nhds_within_Ioi_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Ioi' H‚ÇÅ], exact H‚ÇÇ }

lemma nhds_within_Ioi_ne_bot [no_top_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
let ‚ü®c, hc‚ü© := no_top a in nhds_within_Ioi_ne_bot' hc H

lemma nhds_within_Ioi_self_ne_bot' {a b : Œ±} (H : a < b) :
  ne_bot (ùìù[Ioi a] a) :=
nhds_within_Ioi_ne_bot' H (le_refl a)

@[instance]
lemma nhds_within_Ioi_self_ne_bot [no_top_order Œ±] (a : Œ±) :
  ne_bot (ùìù[Ioi a] a) :=
nhds_within_Ioi_ne_bot (le_refl a)

lemma nhds_within_Iio_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : b ‚â§ c) :
  ne_bot (ùìù[Iio c] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Iio' H‚ÇÅ], exact H‚ÇÇ }

lemma nhds_within_Iio_ne_bot [no_bot_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Iio b] a) :=
let ‚ü®c, hc‚ü© := no_bot b in nhds_within_Iio_ne_bot' hc H

lemma nhds_within_Iio_self_ne_bot' {a b : Œ±} (H : a < b) :
  ne_bot (ùìù[Iio b] b) :=
nhds_within_Iio_ne_bot' H (le_refl b)

@[instance]
lemma nhds_within_Iio_self_ne_bot [no_bot_order Œ±] (a : Œ±) :
  ne_bot (ùìù[Iio a] a) :=
nhds_within_Iio_ne_bot (le_refl a)

end linear_order

section decidable_linear_order

variables [topological_space Œ±] [decidable_linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±]

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
lemma Ioo_at_top_eq_nhds_within {a b : Œ±} (h : a < b) :
  (at_top : filter (Ioo a b)) = comap (coe : Ioo a b ‚Üí Œ±) (ùìù[Iio b] b) :=
begin
  haveI : nonempty (Ioo a b) := nonempty_Ioo_subtype h,
  ext,
  split,
  { intros hs,
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : (Ioo a b), ‚àÄ z : (Ioo a b), z ‚â• x ‚Üí z ‚àà s := mem_at_top_sets.mp hs,
    refine ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.mpr x.2.2), _‚ü©,
    intros z hz,
    simpa using hx z (le_of_lt hz.1) },
  { rintros ‚ü®t, ht, hts‚ü©,
    obtain ‚ü®x, hx, hxt‚ü© : ‚àÉ x ‚àà Iio b, Ioo x b ‚äÜ t := (mem_nhds_within_Iio_iff_exists_Ioo_subset' h).mp ht,
    obtain ‚ü®y, hay, hyb‚ü© : ‚àÉ y, max a x < y ‚àß y < b := dense (max_lt_iff.mpr ‚ü®h, hx‚ü©),
    refine mem_at_top_sets.mpr ‚ü®‚ü®y, (max_lt_iff.mp hay).1, hyb‚ü©, _‚ü©,
    intros z hz,
    exact hts (hxt ‚ü®lt_of_lt_of_le (lt_of_le_of_lt (le_max_right a x) hay) hz, z.2.2‚ü©) }
end

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
lemma Ioo_at_bot_eq_nhds_within {a b : Œ±} (h : a < b) :
  (at_bot : filter (Ioo a b)) = comap (coe : Ioo a b ‚Üí Œ±) (ùìù[Ioi a] a) :=
begin
  haveI : nonempty (Ioo a b) := nonempty_Ioo_subtype h,
  ext,
  split,
  { intros hs,
    obtain ‚ü®x, hx‚ü© : ‚àÉ x : (Ioo a b), ‚àÄ z : (Ioo a b), z ‚â§ x ‚Üí z ‚àà s := mem_at_bot_sets.mp hs,
    refine ‚ü®Ioo a x, Ioo_mem_nhds_within_Ioi (left_mem_Ico.mpr x.2.1), _‚ü©,
    intros z hz,
    simpa using hx z (le_of_lt hz.2) },
  { rintros ‚ü®t, ht, hts‚ü©,
    obtain ‚ü®x, hx, hxt‚ü© : ‚àÉ x ‚àà Ioi a, Ioo a x ‚äÜ t := (mem_nhds_within_Ioi_iff_exists_Ioo_subset' h).mp ht,
    obtain ‚ü®y, hay, hyb‚ü© : ‚àÉ y, a < y ‚àß y < min b x := dense (lt_min_iff.mpr ‚ü®h, hx‚ü©),
    refine mem_at_bot_sets.mpr ‚ü®‚ü®y, hay, (lt_min_iff.mp hyb).1‚ü©, _‚ü©,
    intros z hz,
    exact hts (hxt ‚ü®z.2.1, lt_of_le_of_lt hz (lt_of_lt_of_le hyb (min_le_right b x))‚ü©) }
end

end decidable_linear_order

section complete_linear_order

variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]

lemma Sup_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Sup s ‚àà closure s :=
mem_closure_of_is_lub (is_lub_Sup _) hs

lemma Inf_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Inf s ‚àà closure s :=
mem_closure_of_is_glb (is_glb_Inf _) hs

lemma is_closed.Sup_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Sup s ‚àà s :=
mem_of_is_lub_of_is_closed (is_lub_Sup _) hs hc

lemma is_closed.Inf_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Inf s ‚àà s :=
mem_of_is_glb_of_is_closed (is_glb_Inf _) hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
lemma map_Sup_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Sup s) = Sup (f '' s) :=
--This is a particular case of the more general is_lub_of_is_lub_of_tendsto
(is_lub_of_is_lub_of_tendsto (Œª x hx y hy xy, Mf xy) (is_lub_Sup _) hs $
  Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
lemma map_Sup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (Sup s) = Sup (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simp [h, fbot] },
  { exact map_Sup_of_continuous_at_of_monotone' Cf Mf h }
end

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
lemma map_supr_of_continuous_at_of_monotone' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), ‚Üê range_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
lemma map_supr_of_continuous_at_of_monotone {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, ‚Üê range_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
lemma map_Inf_of_continuous_at_of_monotone' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone' (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s Cf
  Mf.order_dual hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
lemma map_Inf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s Cf
  Mf.order_dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
lemma map_infi_of_continuous_at_of_monotone' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@map_supr_of_continuous_at_of_monotone' (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ Œπ _ f g Cf
  Mf.order_dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
lemma map_infi_of_continuous_at_of_monotone {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (infi g) = infi (f ‚àò g) :=
@map_supr_of_continuous_at_of_monotone (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ Œπ f g Cf
  Mf.order_dual ftop

end complete_linear_order


section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]

lemma cSup_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_above s) : Sup s ‚àà closure s :=
mem_closure_of_is_lub (is_lub_cSup hs B) hs

lemma cInf_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_below s) : Inf s ‚àà closure s :=
mem_closure_of_is_glb (is_glb_cInf hs B) hs

lemma is_closed.cSup_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_above s) :
  Sup s ‚àà s :=
mem_of_is_lub_of_is_closed (is_lub_cSup hs B) hs hc

lemma is_closed.cInf_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_below s) :
  Inf s ‚àà s :=
mem_of_is_glb_of_is_closed (is_glb_cInf hs B) hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
lemma map_cSup_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) :
  f (Sup s) = Sup (f '' s) :=
begin
  refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm,
  refine is_lub_of_is_lub_of_tendsto (Œªx hx y hy xy, Mf xy) (is_lub_cSup ne H) ne _,
  exact Cf.mono_left inf_le_left
end

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
lemma map_csupr_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ü i, g i)) (Mf : monotone f) (H : bdd_above (range g)) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, ‚Üê range_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
lemma map_cInf_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) :
  f (Inf s) = Inf (f '' s) :=
@map_cSup_of_continuous_at_of_monotone (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s Cf
  Mf.order_dual ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
lemma map_cinfi_of_continuous_at_of_monotone {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ö i, g i)) (Mf : monotone f) (H : bdd_below (range g)) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@map_csupr_of_continuous_at_of_monotone (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ _ _ _ _
  Cf Mf.order_dual H

/-- A bounded connected subset of a conditionally complete linear order includes the open interval
`(Inf s, Sup s)`. -/
lemma is_connected.Ioo_cInf_cSup_subset {s : set Œ±} (hs : is_connected s) (hb : bdd_below s)
  (ha : bdd_above s) :
  Ioo (Inf s) (Sup s) ‚äÜ s :=
Œª x hx, let ‚ü®y, ys, hy‚ü© := (is_glb_lt_iff (is_glb_cInf hs.nonempty hb)).1 hx.1 in
let ‚ü®z, zs, hz‚ü© := (lt_is_lub_iff (is_lub_cSup hs.nonempty ha)).1 hx.2 in
hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©

lemma eq_Icc_cInf_cSup_of_connected_bdd_closed {s : set Œ±} (hc : is_connected s) (hb : bdd_below s)
  (ha : bdd_above s) (hcl : is_closed s) :
  s = Icc (Inf s) (Sup s) :=
subset.antisymm (subset_Icc_cInf_cSup hb ha) $
  hc.Icc_subset (hcl.cInf_mem hc.nonempty hb) (hcl.cSup_mem hc.nonempty ha)

lemma is_preconnected.Ioi_cInf_subset {s : set Œ±} (hs : is_preconnected s) (hb : bdd_below s)
  (ha : ¬¨bdd_above s) :
  Ioi (Inf s) ‚äÜ s :=
begin
  have sne : s.nonempty := @nonempty_of_not_bdd_above Œ± _ s ‚ü®Inf ‚àÖ‚ü© ha,
  intros x hx,
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := (is_glb_lt_iff (is_glb_cInf sne hb)).1 hx,
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
end

lemma is_preconnected.Iio_cSup_subset {s : set Œ±} (hs : is_preconnected s) (hb : ¬¨bdd_below s)
  (ha : bdd_above s) :
  Iio (Sup s) ‚äÜ s :=
@is_preconnected.Ioi_cInf_subset (order_dual Œ±) _ _ _ s hs ha hb

/-- A preconnected set in a conditionally complete linear order is either one of the intervals
`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +‚àû)`,
`(Inf s, +‚àû)`, `(-‚àû, Sup s]`, `(-‚àû, Sup s)`, `(-‚àû, +‚àû)`, or `‚àÖ`. The converse statement requires
`Œ±` to be densely ordererd. -/
lemma is_preconnected.mem_intervals {s : set Œ±} (hs : is_preconnected s) :
  s ‚àà ({Icc (Inf s) (Sup s), Ico (Inf s) (Sup s), Ioc (Inf s) (Sup s), Ioo (Inf s) (Sup s),
    Ici (Inf s), Ioi (Inf s), Iic (Sup s), Iio (Sup s), univ, ‚àÖ} : set (set Œ±)) :=
begin
  rcases s.eq_empty_or_nonempty with rfl|hne,
  { apply_rules [or.inr, mem_singleton] },
  have hs' : is_connected s := ‚ü®hne, hs‚ü©,
  by_cases hb : bdd_below s; by_cases ha : bdd_above s,
  { rcases mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset (hs'.Ioo_cInf_cSup_subset hb ha)
      (subset_Icc_cInf_cSup hb ha) with hs|hs|hs|hs,
    { exact (or.inl hs) },
    { exact (or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inr $ or.inl hs) } },
  { refine (or.inr $ or.inr $ or.inr $ or.inr _),
    cases mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_cInf_subset hb ha) (Œª x hx, cInf_le hb hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 6 { apply or.inr },
    cases mem_Iic_Iio_of_subset_of_subset (hs.Iio_cSup_subset hb ha) (Œª x hx, le_cSup ha hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 8 { apply or.inr },
    exact or.inl (hs.eq_univ_of_unbounded hb ha) }
end

/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,
`Iic`, `Iio`, or `univ`, or `‚àÖ`. The converse statement requires `Œ±` to be densely ordererd. Though
one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve
readability. -/
lemma set_of_is_preconnected_subset_of_ordered :
  {s : set Œ± | is_preconnected s} ‚äÜ
    -- bounded intervals
    (range (uncurry Icc) ‚à™ range (uncurry Ico) ‚à™ range (uncurry Ioc) ‚à™ range (uncurry Ioo)) ‚à™
    -- unbounded intervals and `univ`
    (range Ici ‚à™ range Ioi ‚à™ range Iic ‚à™ range Iio ‚à™ {univ, ‚àÖ}) :=
begin
  intros s hs,
  rcases hs.mem_intervals with hs|hs|hs|hs|hs|hs|hs|hs|hs|hs,
  { exact (or.inl $ or.inl $ or.inl $ or.inl ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inl $ or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inl ‚ü®Inf s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inr ‚ü®Inf s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl  $ or.inr ‚ü®Sup s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $  or.inr ‚ü®Sup s, hs.symm‚ü©) },
  { exact (or.inr $ or.inr $ or.inl hs) },
  { exact (or.inr $ or.inr $ or.inr hs) }
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and the set `s ‚à© [a, b)` has no maximal point, then `b ‚àà s`. -/
lemma is_closed.mem_of_ge_of_forall_exists_gt {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© Icc a b))
  (ha : a ‚àà s) (hab : a ‚â§ b) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, (s ‚à© Ioc x b).nonempty) :
  b ‚àà s :=
begin
  let S := s ‚à© Icc a b,
  replace ha : a ‚àà S, from ‚ü®ha, left_mem_Icc.2 hab‚ü©,
  have Sbd : bdd_above S, from ‚ü®b, Œª z hz, hz.2.2‚ü©,
  let c := Sup (s ‚à© Icc a b),
  have c_mem : c ‚àà S, from hs.cSup_mem ‚ü®_, ha‚ü© Sbd,
  have c_le : c ‚â§ b, from cSup_le ‚ü®_, ha‚ü© (Œª x hx, hx.2.2),
  cases eq_or_lt_of_le c_le with hc hc, from hc ‚ñ∏ c_mem.1,
  exfalso,
  rcases hgt c ‚ü®c_mem.1, c_mem.2.1, hc‚ü© with ‚ü®x, xs, cx, xb‚ü©,
  exact not_lt_of_le (le_cSup Sbd ‚ü®xs, le_trans (le_cSup Sbd ha) (le_of_lt cx), xb‚ü©) cx
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `a ‚â§ x < y ‚â§ b`, `x ‚àà s`, the set `s ‚à© (x, y]`
is not empty, then `[a, b] ‚äÜ s`. -/
lemma is_closed.Icc_subset_of_forall_exists_gt {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© Icc a b))
  (ha : a ‚àà s) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, ‚àÄ y ‚àà Ioi x,  (s ‚à© Ioc x y).nonempty) :
  Icc a b ‚äÜ s :=
begin
  assume y hy,
  have : is_closed (s ‚à© Icc a y),
  { suffices : s ‚à© Icc a y = s ‚à© Icc a b ‚à© Icc a y,
    { rw this, exact is_closed_inter hs is_closed_Icc },
    rw [inter_assoc],
    congr,
    exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm },
  exact is_closed.mem_of_ge_of_forall_exists_gt this ha hy.1
    (Œª x hx, hgt x ‚ü®hx.1, Ico_subset_Ico_right hy.2 hx.2‚ü© y hx.2.2)
end
section densely_ordered

variables [densely_ordered Œ±] {a b : Œ±}

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `x ‚àà s ‚à© [a, b)` the set `s` includes some open
neighborhood of `x` within `(x, +‚àû)`, then `[a, b] ‚äÜ s`. -/
lemma is_closed.Icc_subset_of_forall_mem_nhds_within {a b : Œ±} {s : set Œ±}
  (hs : is_closed (s ‚à© Icc a b)) (ha : a ‚àà s)
  (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, s ‚àà ùìù[Ioi x] x) :
  Icc a b ‚äÜ s :=
begin
  apply hs.Icc_subset_of_forall_exists_gt ha,
  rintros x ‚ü®hxs, hxab‚ü© y hyxb,
  have : s ‚à© Ioc x y ‚àà ùìù[Ioi x] x,
    from inter_mem_sets (hgt x ‚ü®hxs, hxab‚ü©) (Ioc_mem_nhds_within_Ioi ‚ü®le_refl _, hyxb‚ü©),
  exact (nhds_within_Ioi_self_ne_bot' hxab.2).nonempty_of_mem this
end

/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/
lemma is_preconnected_Icc : is_preconnected (Icc a b) :=
is_preconnected_closed_iff.2
begin
  rintros s t hs ht hab ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©,
  wlog hxy : x ‚â§ y := le_total x y using [x y s t, y x t s],
  have xyab : Icc x y ‚äÜ Icc a b := Icc_subset_Icc hx.1.1 hy.1.2,
  by_contradiction hst,
  suffices : Icc x y ‚äÜ s,
    from hst ‚ü®y, xyab $ right_mem_Icc.2 hxy, this $ right_mem_Icc.2 hxy, hy.2‚ü©,
  apply (is_closed_inter hs is_closed_Icc).Icc_subset_of_forall_mem_nhds_within hx.2,
  rintros z ‚ü®zs, hz‚ü©,
  have zt : z ‚àà t·∂ú, from Œª zt, hst ‚ü®z, xyab $ Ico_subset_Icc_self hz, zs, zt‚ü©,
  have : t·∂ú ‚à© Ioc z y ‚àà ùìù[Ioi z] z,
  { rw [‚Üê nhds_within_Ioc_eq_nhds_within_Ioi hz.2],
    exact mem_nhds_within.2 ‚ü®t·∂ú, ht, zt, subset.refl _‚ü©},
  apply mem_sets_of_superset this,
  have : Ioc z y ‚äÜ s ‚à™ t, from Œª w hw, hab (xyab ‚ü®le_trans hz.1 (le_of_lt hw.1), hw.2‚ü©),
  exact Œª w ‚ü®wt, wzy‚ü©, (this wzy).elim id (Œª h, (wt h).elim)
end

lemma is_preconnected_interval : is_preconnected (interval a b) := is_preconnected_Icc

lemma is_preconnected_iff_ord_connected {s : set Œ±} :
  is_preconnected s ‚Üî ord_connected s :=
‚ü®Œª h x hx y hy, h.Icc_subset hx hy, Œª h, is_preconnected_of_forall_pair $ Œª x y hx hy,
  ‚ü®interval x y, h.interval_subset hx hy, left_mem_interval, right_mem_interval,
    is_preconnected_interval‚ü©‚ü©

alias is_preconnected_iff_ord_connected ‚Üî
  is_preconnected.ord_connected set.ord_connected.is_preconnected

lemma is_preconnected_Ici : is_preconnected (Ici a) := ord_connected_Ici.is_preconnected
lemma is_preconnected_Iic : is_preconnected (Iic a) := ord_connected_Iic.is_preconnected
lemma is_preconnected_Iio : is_preconnected (Iio a) := ord_connected_Iio.is_preconnected
lemma is_preconnected_Ioi : is_preconnected (Ioi a) := ord_connected_Ioi.is_preconnected
lemma is_preconnected_Ioo : is_preconnected (Ioo a b) := ord_connected_Ioo.is_preconnected
lemma is_preconnected_Ioc : is_preconnected (Ioc a b) := ord_connected_Ioc.is_preconnected
lemma is_preconnected_Ico : is_preconnected (Ico a b) := ord_connected_Ico.is_preconnected

@[priority 100]
instance ordered_connected_space : preconnected_space Œ± :=
‚ü®ord_connected_univ.is_preconnected‚ü©

/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly
the set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-‚àû, +‚àû)`,
or `‚àÖ`. Though one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of
possible cases to improve readability. -/
lemma set_of_is_preconnected_eq_of_ordered :
  {s : set Œ± | is_preconnected s} =
    -- bounded intervals
    (range (uncurry Icc) ‚à™ range (uncurry Ico) ‚à™ range (uncurry Ioc) ‚à™ range (uncurry Ioo)) ‚à™
    -- unbounded intervals and `univ`
    (range Ici ‚à™ range Ioi ‚à™ range Iic ‚à™ range Iio ‚à™ {univ, ‚àÖ}) :=
begin
  refine subset.antisymm set_of_is_preconnected_subset_of_ordered _,
  simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp_distrib, forall_and_distrib,
    mem_union, mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true,
    is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc,
    is_preconnected_Ioo, is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici,
    is_preconnected_Iic, is_preconnected_univ, is_preconnected_empty],
end

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ‚â§ t ‚â§ f b`.-/
lemma intermediate_value_Icc {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f (Icc a b)) :
  Icc (f a) (f b) ‚äÜ f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ‚â• t ‚â• f b`.-/
lemma intermediate_value_Icc' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f (Icc a b)) :
  Icc (f b) (f a) ‚äÜ f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf

/-- A continuous function which tendsto `at_top` `at_top` and to `at_bot` `at_bot` is surjective. -/
lemma surjective_of_continuous {f : Œ± ‚Üí Œ≤} (hf : continuous f) (h_top : tendsto f at_top at_top)
  (h_bot : tendsto f at_bot at_bot) :
  function.surjective f :=
begin
  intros p,
  obtain ‚ü®b, hb‚ü© : ‚àÉ b, p ‚â§ f b,
    { rcases ((tendsto_at_top_at_top _).mp h_top) p with ‚ü®b, hb‚ü©,
      exact ‚ü®b, hb b rfl.ge‚ü© },
  obtain ‚ü®a, hab, ha‚ü© : ‚àÉ a, a ‚â§ b ‚àß f a ‚â§ p,
  { rcases ((tendsto_at_bot_at_bot _).mp h_bot) p with ‚ü®x, hx‚ü©,
    exact ‚ü®min x b, min_le_right x b, hx (min x b) (min_le_left x b)‚ü© },
  rcases intermediate_value_Icc hab hf.continuous_on ‚ü®ha, hb‚ü© with ‚ü®x, _, hx‚ü©,
  exact ‚ü®x, hx‚ü©
end

/-- A continuous function which tendsto `at_bot` `at_top` and to `at_top` `at_bot` is surjective. -/
lemma surjective_of_continuous' {f : Œ± ‚Üí Œ≤} (hf : continuous f) (h_top : tendsto f at_bot at_top)
  (h_bot : tendsto f at_top at_bot) :
  function.surjective f :=
@surjective_of_continuous (order_dual Œ±) Œ≤ _ _ _ _ _ _ _ _ hf h_top h_bot

end densely_ordered

lemma is_compact.Inf_mem {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  Inf s ‚àà s :=
hs.is_closed.cInf_mem ne_s hs.bdd_below

lemma is_compact.Sup_mem {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  Sup s ‚àà s :=
@is_compact.Inf_mem (order_dual Œ±) _ _ _ _ hs ne_s

lemma is_compact.is_glb_Inf {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_glb s (Inf s) :=
is_glb_cInf ne_s hs.bdd_below

lemma is_compact.is_lub_Sup {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_lub s (Sup s) :=
@is_compact.is_glb_Inf (order_dual Œ±) _ _ _ _ hs ne_s

lemma is_compact.is_least_Inf {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_least s (Inf s) :=
‚ü®hs.Inf_mem ne_s, (hs.is_glb_Inf ne_s).1‚ü©

lemma is_compact.is_greatest_Sup {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_greatest s (Sup s) :=
@is_compact.is_least_Inf (order_dual Œ±) _ _ _ _ hs ne_s

lemma is_compact.exists_is_least {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  ‚àÉ x, is_least s x :=
‚ü®_, hs.is_least_Inf ne_s‚ü©

lemma is_compact.exists_is_greatest {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  ‚àÉ x, is_greatest s x :=
‚ü®_, hs.is_greatest_Sup ne_s‚ü©

lemma is_compact.exists_is_glb {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  ‚àÉ x ‚àà s, is_glb s x :=
‚ü®_, hs.Inf_mem ne_s, hs.is_glb_Inf ne_s‚ü©

lemma is_compact.exists_is_lub {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) :
  ‚àÉ x ‚àà s, is_lub s x :=
‚ü®_, hs.Sup_mem ne_s, hs.is_lub_Sup ne_s‚ü©

lemma is_compact.exists_Inf_image_eq {Œ± : Type u} [topological_space Œ±]
  {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f s) :
  ‚àÉ x ‚àà s,  Inf (f '' s) = f x :=
let ‚ü®x, hxs, hx‚ü© := (hs.image_of_continuous_on hf).Inf_mem (ne_s.image f)
in ‚ü®x, hxs, hx.symm‚ü©

/-- The extreme value theorem: a continuous function realizes its minimum on a compact set -/
lemma is_compact.exists_forall_le {Œ± : Type u} [topological_space Œ±]
  {s : set Œ±} (hs : is_compact s) (ne_s : s.nonempty) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f s) :
  ‚àÉx‚ààs, ‚àÄy‚ààs, f x ‚â§ f y :=
begin
  rcases hs.exists_Inf_image_eq ne_s hf with ‚ü®x, hxs, hx‚ü©,
  refine ‚ü®x, hxs, Œª y hy, _‚ü©,
  rw ‚Üê hx,
  exact ((hs.image_of_continuous_on hf).is_glb_Inf (ne_s.image f)).1 (mem_image_of_mem _ hy)
end

/-- The extreme value theorem: a continuous function realizes its maximum on a compact set -/
lemma is_compact.exists_forall_ge {Œ± : Type u} [topological_space Œ±]:
  ‚àÄ {s : set Œ±}, is_compact s ‚Üí s.nonempty ‚Üí ‚àÄ {f : Œ± ‚Üí Œ≤}, continuous_on f s ‚Üí
  ‚àÉx‚ààs, ‚àÄy‚ààs, f y ‚â§ f x :=
@is_compact.exists_forall_le (order_dual Œ≤) _ _ _ _ _

lemma is_compact.exists_Sup_image_eq {Œ± : Type u} [topological_space Œ±]:
  ‚àÄ {s : set Œ±}, is_compact s ‚Üí s.nonempty ‚Üí ‚àÄ {f : Œ± ‚Üí Œ≤}, continuous_on f s ‚Üí
  ‚àÉ x ‚àà s,  Sup (f '' s) = f x :=
@is_compact.exists_Inf_image_eq (order_dual Œ≤) _ _ _ _ _

lemma eq_Icc_of_connected_compact {s : set Œ±} (h‚ÇÅ : is_connected s) (h‚ÇÇ : is_compact s) :
  s = Icc (Inf s) (Sup s) :=
eq_Icc_cInf_cSup_of_connected_bdd_closed h‚ÇÅ h‚ÇÇ.bdd_below h‚ÇÇ.bdd_above
  h‚ÇÇ.is_closed

end conditionally_complete_linear_order

section liminf_limsup

section order_closed_topology
variables [semilattice_sup Œ±] [topological_space Œ±] [order_topology Œ±]

lemma is_bounded_le_nhds (a : Œ±) : (ùìù a).is_bounded (‚â§) :=
match forall_le_or_exists_lt_sup a with
| or.inl h := ‚ü®a, eventually_of_forall h‚ü©
| or.inr ‚ü®b, hb‚ü© := ‚ü®b, ge_mem_nhds hb‚ü©
end

lemma filter.tendsto.is_bounded_under_le {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â§) u :=
(is_bounded_le_nhds a).mono h

lemma is_cobounded_ge_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â•) :=
(is_bounded_le_nhds a).is_cobounded_flip

lemma filter.tendsto.is_cobounded_under_ge {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  [ne_bot f] (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â•) u :=
h.is_bounded_under_le.is_cobounded_flip

end order_closed_topology

section order_closed_topology
variables [semilattice_inf Œ±] [topological_space Œ±] [order_topology Œ±]

lemma is_bounded_ge_nhds (a : Œ±) : (ùìù a).is_bounded (‚â•) :=
@is_bounded_le_nhds (order_dual Œ±) _ _ _ a

lemma filter.tendsto.is_bounded_under_ge {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â•) u :=
(is_bounded_ge_nhds a).mono h

lemma is_cobounded_le_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â§) :=
(is_bounded_ge_nhds a).is_cobounded_flip

lemma filter.tendsto.is_cobounded_under_le {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  [ne_bot f] (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â§) u :=
h.is_bounded_under_ge.is_cobounded_flip

end order_closed_topology

section conditionally_complete_linear_order
variables [conditionally_complete_linear_order Œ±]

theorem lt_mem_sets_of_Limsup_lt {f : filter Œ±} {b} (h : f.is_bounded (‚â§)) (l : f.Limsup < b) :
  ‚àÄ·∂† a in f, a < b :=
let ‚ü®c, (h : ‚àÄ·∂† a in f, a ‚â§ c), hcb‚ü© := exists_lt_of_cInf_lt h l in
mem_sets_of_superset h $ assume a hac, lt_of_le_of_lt hac hcb

theorem gt_mem_sets_of_Liminf_gt : ‚àÄ {f : filter Œ±} {b}, f.is_bounded (‚â•) ‚Üí b < f.Liminf ‚Üí
  ‚àÄ·∂† a in f, b < a :=
@lt_mem_sets_of_Limsup_lt (order_dual Œ±) _

variables [topological_space Œ±] [order_topology Œ±]

/-- If the liminf and the limsup of a filter coincide, then this filter converges to
their common value, at least if the filter is eventually bounded above and below. -/
theorem le_nhds_of_Limsup_eq_Liminf {f : filter Œ±} {a : Œ±}
  (hl : f.is_bounded (‚â§)) (hg : f.is_bounded (‚â•)) (hs : f.Limsup = a) (hi : f.Liminf = a) :
  f ‚â§ ùìù a :=
tendsto_order.2 $ and.intro
  (assume b hb, gt_mem_sets_of_Liminf_gt hg $ hi.symm ‚ñ∏ hb)
  (assume b hb, lt_mem_sets_of_Limsup_lt hl $ hs.symm ‚ñ∏ hb)

theorem Limsup_nhds (a : Œ±) : Limsup (ùìù a) = a :=
cInf_intro (is_bounded_le_nhds a)
  (assume a' (h : {n : Œ± | n ‚â§ a'} ‚àà ùìù a), show a ‚â§ a', from @mem_of_nhds Œ± _ a _ h)
  (assume b (hba : a < b), show ‚àÉc (h : {n : Œ± | n ‚â§ c} ‚àà ùìù a), c < b, from
    match dense_or_discrete a b with
    | or.inl ‚ü®c, hac, hcb‚ü© := ‚ü®c, ge_mem_nhds hac, hcb‚ü©
    | or.inr ‚ü®_, h‚ü©        := ‚ü®a, (ùìù a).sets_of_superset (gt_mem_nhds hba) h, hba‚ü©
    end)

theorem Liminf_nhds : ‚àÄ (a : Œ±), Liminf (ùìù a) = a :=
@Limsup_nhds (order_dual Œ±) _ _ _

/-- If a filter is converging, its limsup coincides with its limit. -/
theorem Liminf_eq_of_le_nhds {f : filter Œ±} {a : Œ±} [ne_bot f] (h : f ‚â§ ùìù a) : f.Liminf = a :=
have hb_ge : is_bounded (‚â•) f, from (is_bounded_ge_nhds a).mono h,
have hb_le : is_bounded (‚â§) f, from (is_bounded_le_nhds a).mono h,
le_antisymm
  (calc f.Liminf ‚â§ f.Limsup : Liminf_le_Limsup hb_le hb_ge
    ... ‚â§ (ùìù a).Limsup :
      Limsup_le_Limsup_of_le h hb_ge.is_cobounded_flip (is_bounded_le_nhds a)
    ... = a : Limsup_nhds a)
  (calc a = (ùìù a).Liminf : (Liminf_nhds a).symm
    ... ‚â§ f.Liminf :
      Liminf_le_Liminf_of_le h (is_bounded_ge_nhds a) hb_le.is_cobounded_flip)

/-- If a filter is converging, its liminf coincides with its limit. -/
theorem Limsup_eq_of_le_nhds : ‚àÄ {f : filter Œ±} {a : Œ±} [ne_bot f], f ‚â§ ùìù a ‚Üí f.Limsup = a :=
@Liminf_eq_of_le_nhds (order_dual Œ±) _ _ _

/-- If a function has a limit, then its limsup coincides with its limit. -/
theorem filter.tendsto.limsup_eq {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} [ne_bot f]
  (h : tendsto u f (ùìù a)) : limsup f u = a :=
Limsup_eq_of_le_nhds h

/-- If a function has a limit, then its liminf coincides with its limit. -/
theorem filter.tendsto.liminf_eq {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} [ne_bot f]
  (h : tendsto u f (ùìù a)) : liminf f u = a :=
Liminf_eq_of_le_nhds h

end conditionally_complete_linear_order

section complete_linear_order
variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
-- In complete_linear_order, the above theorems take a simpler form

/-- If the liminf and the limsup of a function coincide, then the limit of the function
exists and has the same value -/
theorem tendsto_of_liminf_eq_limsup {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hinf : liminf f u = a) (hsup : limsup f u = a) : tendsto u f (ùìù a) :=
le_nhds_of_Limsup_eq_Liminf is_bounded_le_of_top is_bounded_ge_of_bot hsup hinf

/-- If a number `a` is less than or equal to the `liminf` of a function `f` at some filter
and is greater than or equal to the `limsup` of `f`, then `f` tends to `a` along this filter. -/
theorem tendsto_of_le_liminf_of_limsup_le {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hinf : a ‚â§ liminf f u) (hsup : limsup f u ‚â§ a) :
  tendsto u f (ùìù a) :=
if hf : f = ‚ä• then hf.symm ‚ñ∏ tendsto_bot
else by haveI : ne_bot f := hf; exact tendsto_of_liminf_eq_limsup
  (le_antisymm (le_trans liminf_le_limsup hsup) hinf)
  (le_antisymm hsup (le_trans hinf liminf_le_limsup))

end complete_linear_order

end liminf_limsup

end order_topology

lemma order_topology_of_nhds_abs
  {Œ± : Type*} [decidable_linear_ordered_add_comm_group Œ±] [topological_space Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, ùìü {b | abs (a - b) < r})) : order_topology Œ± :=
order_topology.mk $ eq_of_nhds_eq_nhds $ assume a:Œ±, le_antisymm_iff.mpr
begin
  simp [infi_and, topological_space.nhds_generate_from,
        h_nhds, le_infi_iff, -le_principal_iff, and_comm],
  refine ‚ü®Œª s ha b hs, _, Œª r hr, _‚ü©,
  { rcases hs with rfl | rfl,
    { refine infi_le_of_le (a - b)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < a - b), _),
      have : a - c < a - b := lt_of_le_of_lt (le_abs_self _) hc,
      exact lt_of_neg_lt_neg (lt_of_add_lt_add_left this) },
    { refine infi_le_of_le (b - a)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < b - a), _),
      have : abs (c - a) < b - a, {rw abs_sub; simpa using hc},
      have : c - a < b - a := lt_of_le_of_lt (le_abs_self _) this,
      exact lt_of_add_lt_add_right this } },
  { have h : {b | abs (a - b) < r} = {b | a - r < b} ‚à© {b | b < a + r},
      from set.ext (assume b,
        by simp [abs_lt, sub_lt, lt_sub_iff_add_lt, sub_lt_iff_lt_add']; cc),
    rw [h, ‚Üê inf_principal],
    apply le_inf _ _,
    { exact infi_le_of_le {b : Œ± | a - r < b} (infi_le_of_le (sub_lt_self a hr) $
        infi_le_of_le (a - r) $ infi_le _ (or.inl rfl)) },
    { exact infi_le_of_le {b : Œ± | b < a + r} (infi_le_of_le (lt_add_of_pos_right _ hr) $
        infi_le_of_le (a + r) $ infi_le _ (or.inr rfl)) } }
end

lemma tendsto_at_top_supr_nat [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : monotone f) : tendsto f at_top (ùìù (‚®Üi, f i)) :=
tendsto_order.2 $ and.intro
  (assume a ha, let ‚ü®n, hn‚ü© := lt_supr_iff.1 ha in
    mem_at_top_sets.2 ‚ü®n, assume i hi, lt_of_lt_of_le hn (hf hi)‚ü©)
  (assume a ha, univ_mem_sets' (assume n, lt_of_le_of_lt (le_supr _ n) ha))

lemma tendsto_at_top_infi_nat [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : ‚àÄ{n m}, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù (‚®Öi, f i)) :=
@tendsto_at_top_supr_nat (order_dual Œ±) _ _ _ _ @hf

lemma supr_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : monotone f) : tendsto f at_top (ùìù a) ‚Üí supr f = a :=
tendsto_nhds_unique (tendsto_at_top_supr_nat f hf)

lemma infi_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : ‚àÄn m, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù a) ‚Üí infi f = a :=
tendsto_nhds_unique (tendsto_at_top_infi_nat f hf)

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_top_at_top [decidable_linear_ordered_add_comm_group Œ±] :
  tendsto (abs : Œ± ‚Üí Œ±) at_top at_top :=
tendsto_at_top_mono (Œª n, le_abs_self _) tendsto_id

local notation `|` x `|` := abs x

lemma decidable_linear_ordered_add_comm_group.tendsto_nhds
  [decidable_linear_ordered_add_comm_group Œ±] [topological_space Œ±] [order_topology Œ±] {Œ≤ : Type*}
  (f : Œ≤ ‚Üí Œ±) (x : filter Œ≤) (a : Œ±) :
  filter.tendsto f x (nhds a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ :=
begin
  rw (show _, from @tendsto_order Œ±), -- does not work without `show` for some reason
  split,
  { rintros ‚ü®hyp_lt_a, hyp_gt_a‚ü© Œµ Œµ_pos,
    suffices : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff],
    have set1 : {b : Œ≤ | a - f b < Œµ} ‚àà x,
    { have : {b : Œ≤ | a - Œµ < f b} ‚àà x, from hyp_lt_a (a - Œµ) (sub_lt_self a Œµ_pos),
      have : ‚àÄ b, a - f b < Œµ ‚Üî a - Œµ < f b, by { intro _, exact sub_lt },
      simpa only [this] },
    have set2 : {b : Œ≤ | f b - a < Œµ} ‚àà x,
    { have : {b : Œ≤ | a + Œµ > f b} ‚àà x, from hyp_gt_a (a + Œµ) (lt_add_of_pos_right a Œµ_pos),
      have : ‚àÄ b, f b - a < Œµ ‚Üî a + Œµ > f b, by { intro _, exact sub_lt_iff_lt_add' },
      simpa only [this] },
    exact (x.inter_sets set2 set1) },
  { assume hyp_Œµ_pos,
    split,
    { assume a' a'_lt_a,
      let Œµ := a - a',
      have : {b : Œ≤ | |f b - a| < Œµ} ‚àà x, from hyp_Œµ_pos Œµ (sub_pos.elim_right a'_lt_a),
      have : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff] using this,
      have : {b : Œ≤ | a - f b < Œµ} ‚àà x, from x.sets_of_superset this (set.inter_subset_right _ _),
      have : ‚àÄ b, a' < f b ‚Üî a - f b < Œµ, by {intro b, rw [sub_lt, sub_sub_self] },
      simpa only [this] },
    { assume a' a'_gt_a,
      let Œµ := a' - a,
      have : {b : Œ≤ | |f b - a| < Œµ} ‚àà x, from hyp_Œµ_pos Œµ (sub_pos.elim_right a'_gt_a),
      have : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff] using this,
      have : {b : Œ≤ | f b - a < Œµ} ‚àà x, from x.sets_of_superset this (set.inter_subset_left _ _),
      have : ‚àÄ b, f b < a' ‚Üî f b - a < Œµ, by { intro b, simp [lt_sub_iff_add_lt] },
      simpa only [this] }}
end

/-!
Here is a counter-example to a version of the following with `conditionally_complete_lattice Œ±`.
Take `Œ± = [0, 1) ‚Üí ‚Ñù` with the natural lattice structure, `Œπ = ‚Ñï`. Put `f n x = -x^n`. Then
`‚®Ü n, f n = 0` while none of `f n` is strictly greater than the constant function `-0.5`.
-/

lemma tendsto_at_top_csupr {Œπ Œ± : Type*} [preorder Œπ] [topological_space Œ±]
  [conditionally_complete_linear_order Œ±] [order_topology Œ±]
  {f : Œπ ‚Üí Œ±} (h_mono : monotone f) (hbdd : bdd_above $ range f) :
  tendsto f at_top (ùìù (‚®Üi, f i)) :=
begin
  by_cases hi : nonempty Œπ,
  { resetI,
    rw tendsto_order,
    split,
    { intros a h,
      cases exists_lt_of_lt_csupr h with N hN,
      apply eventually.mono (mem_at_top N),
      exact Œª i hi, lt_of_lt_of_le hN (h_mono hi) },
    { exact Œª a h, eventually_of_forall (Œª n, lt_of_le_of_lt (le_csupr hbdd n) h) } },
  { exact tendsto_of_not_nonempty hi }
end

lemma tendsto_at_top_supr {Œπ Œ± : Type*} [preorder Œπ] [topological_space Œ±]
  [complete_linear_order Œ±] [order_topology Œ±] {f : Œπ ‚Üí Œ±} (h_mono : monotone f) :
  tendsto f at_top (ùìù (‚®Üi, f i)) :=
tendsto_at_top_csupr h_mono (order_top.bdd_above _)

lemma tendsto_of_monotone {Œπ Œ± : Type*} [preorder Œπ] [topological_space Œ±]
  [conditionally_complete_linear_order Œ±] [order_topology Œ±] {f : Œπ ‚Üí Œ±} (h_mono : monotone f) :
  tendsto f at_top at_top ‚à® (‚àÉ l, tendsto f at_top (ùìù l)) :=
if H : bdd_above (range f) then or.inr ‚ü®_, tendsto_at_top_csupr h_mono H‚ü©
else or.inl $ tendsto_at_top_at_top_of_monotone' h_mono H

@[to_additive] lemma tendsto_inv_nhds_within_Ioi [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Ioi a] a) (ùìù[Iio (a‚Åª¬π)] (a‚Åª¬π)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Iio [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Iio a] a) (ùìù[Ioi (a‚Åª¬π)] (a‚Åª¬π)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Ioi_inv [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Ioi (a‚Åª¬π)] (a‚Åª¬π)) (ùìù[Iio a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Ioi _ _ _ _ (a‚Åª¬π)

@[to_additive] lemma tendsto_inv_nhds_within_Iio_inv [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Iio (a‚Åª¬π)] (a‚Åª¬π)) (ùìù[Ioi a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Iio _ _ _ _ (a‚Åª¬π)

@[to_additive] lemma tendsto_inv_nhds_within_Ici [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Ici a] a) (ùìù[Iic (a‚Åª¬π)] (a‚Åª¬π)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Iic [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Iic a] a) (ùìù[Ici (a‚Åª¬π)] (a‚Åª¬π)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Ici_inv [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Ici (a‚Åª¬π)] (a‚Åª¬π)) (ùìù[Iic a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Ici _ _ _ _ (a‚Åª¬π)

@[to_additive] lemma tendsto_inv_nhds_within_Iic_inv [ordered_comm_group Œ±]
  [topological_space Œ±] [topological_group Œ±] {a : Œ±} :
  tendsto has_inv.inv (ùìù[Iic (a‚Åª¬π)] (a‚Åª¬π)) (ùìù[Ici a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Iic _ _ _ _ (a‚Åª¬π)

lemma nhds_left_sup_nhds_right (a : Œ±) [topological_space Œ±] [linear_order Œ±] :
  nhds_within a (Iic a) ‚äî nhds_within a (Ici a) = ùìù a :=
by rw [‚Üê nhds_within_union, Iic_union_Ici, nhds_within_univ]

lemma nhds_left'_sup_nhds_right (a : Œ±) [topological_space Œ±] [linear_order Œ±] :
  nhds_within a (Iio a) ‚äî nhds_within a (Ici a) = ùìù a :=
by rw [‚Üê nhds_within_union, Iio_union_Ici, nhds_within_univ]

lemma nhds_left_sup_nhds_right' (a : Œ±) [topological_space Œ±] [linear_order Œ±] :
  nhds_within a (Iic a) ‚äî nhds_within a (Ioi a) = ùìù a :=
by rw [‚Üê nhds_within_union, Iic_union_Ioi, nhds_within_univ]

lemma continuous_at_iff_continuous_left_right [topological_space Œ±] [linear_order Œ±]
  [topological_space Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  continuous_at f a ‚Üî continuous_within_at f (Iic a) a ‚àß continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, continuous_at, ‚Üê tendsto_sup, nhds_left_sup_nhds_right]

lemma continuous_on_Icc_extend_from_Ioo [topological_space Œ±] [linear_order Œ±] [densely_ordered Œ±]
  [order_topology Œ±] [topological_space Œ≤] [regular_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±}
  {la lb : Œ≤} (hab : a < b) (hf : continuous_on f (Ioo a b))
  (ha : tendsto f (nhds_within a $ Ioi a) (ùìù la))
  (hb : tendsto f (nhds_within b $ Iio b) (ùìù lb)) :
  continuous_on (extend_from (Ioo a b) f) (Icc a b) :=
begin
  apply continuous_on_extend_from,
  { rw closure_Ioo hab, },
  { intros x x_in,
    rcases mem_Ioo_or_eq_endpoints_of_mem_Icc x_in with rfl | rfl | h,
    { use la,
      simpa [hab] },
    { use lb,
      simpa [hab] },
    { use [f x, hf x h] } }
end

lemma eq_lim_at_left_extend_from_Ioo [topological_space Œ±] [linear_order Œ±] [densely_ordered Œ±]
  [order_topology Œ±] [topological_space Œ≤] [t2_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±}
  {la : Œ≤} (hab : a < b) (ha : tendsto f (nhds_within a $ Ioi a) (ùìù la)) :
  extend_from (Ioo a b) f a = la :=
begin
  apply extend_from_eq,
  { rw closure_Ioo hab,
    simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc] },
  { simpa [hab] }
end

lemma eq_lim_at_right_extend_from_Ioo [topological_space Œ±] [linear_order Œ±] [densely_ordered Œ±]
  [order_topology Œ±] [topological_space Œ≤] [t2_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±}
  {lb : Œ≤} (hab : a < b) (hb : tendsto f (nhds_within b $ Iio b) (ùìù lb)) :
  extend_from (Ioo a b) f b = lb :=
begin
  apply extend_from_eq,
  { rw closure_Ioo hab,
    simp only [le_of_lt hab, left_mem_Icc, right_mem_Icc] },
  { simpa [hab] }
end

lemma continuous_on_Ico_extend_from_Ioo [topological_space Œ±]
  [linear_order Œ±] [densely_ordered Œ±] [order_topology Œ±] [topological_space Œ≤]
  [regular_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±} {la : Œ≤} (hab : a < b) (hf : continuous_on f (Ioo a b))
  (ha : tendsto f (nhds_within a $ Ioi a) (ùìù la)) :
  continuous_on (extend_from (Ioo a b) f) (Ico a b) :=
begin
  apply continuous_on_extend_from,
  { rw [closure_Ioo hab], exact Ico_subset_Icc_self, },
  { intros x x_in,
    rcases mem_Ioo_or_eq_left_of_mem_Ico x_in with rfl | h,
    { use la,
      simpa [hab] },
    { use [f x, hf x h] } }
end

lemma continuous_on_Ioc_extend_from_Ioo [topological_space Œ±]
  [linear_order Œ±] [densely_ordered Œ±] [order_topology Œ±] [topological_space Œ≤]
  [regular_space Œ≤] {f : Œ± ‚Üí Œ≤} {a b : Œ±} {lb : Œ≤} (hab : a < b) (hf : continuous_on f (Ioo a b))
  (hb : tendsto f (nhds_within b $ Iio b) (ùìù lb)) :
  continuous_on (extend_from (Ioo a b) f) (Ioc a b) :=
begin
  have := @continuous_on_Ico_extend_from_Ioo (order_dual Œ±) _ _ _ _ _ _ _ f _ _ _ hab,
  erw [dual_Ico, dual_Ioi, dual_Ioo] at this,
  exact this hf hb
end

lemma continuous_within_at_Ioi_iff_Ici {Œ± Œ≤ : Type*} [topological_space Œ±] [partial_order Œ±]
  [topological_space Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  continuous_within_at f (Ioi a) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [‚Üê Ici_diff_left, continuous_within_at_diff_self]

lemma continuous_within_at_Iio_iff_Iic
  {Œ± Œ≤ : Type*} [topological_space Œ±] [linear_order Œ±] [topological_space Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  continuous_within_at f (Iio a) a ‚Üî continuous_within_at f (Iic a) a :=
begin
  have := @continuous_within_at_Ioi_iff_Ici (order_dual Œ±) _ _ _ _ _ f,
  erw [dual_Ici, dual_Ioi] at this,
  exact this,
end

lemma continuous_at_iff_continuous_left'_right' [topological_space Œ±] [linear_order Œ±]
  [topological_space Œ≤] {a : Œ±} {f : Œ± ‚Üí Œ≤} :
  continuous_at f a ‚Üî continuous_within_at f (Iio a) a ‚àß continuous_within_at f (Ioi a) a :=
by rw [continuous_within_at_Ioi_iff_Ici, continuous_within_at_Iio_iff_Iic,
  continuous_at_iff_continuous_left_right]

section homeomorphisms
variables [topological_space Œ±] [topological_space Œ≤]

section linear_order
variables [linear_order Œ±] [order_topology Œ±]
variables [linear_order Œ≤] [order_topology Œ≤]

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and surjective, it is everywhere continuous. -/
lemma continuous_at_of_strict_mono_surjective
  {f : Œ± ‚Üí Œ≤} (h_mono : strict_mono f) (h_surj : function.surjective f) (a : Œ±) :
  continuous_at f a :=
continuous_at_iff_continuous_left_right.mpr
  ‚ü®continuous_left_of_strict_mono_surjective h_mono h_surj a,
  continuous_right_of_strict_mono_surjective h_mono h_surj a‚ü©

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and surjective, it is continuous. -/
lemma continuous_of_strict_mono_surjective
  {f : Œ± ‚Üí Œ≤} (h_mono : strict_mono f) (h_surj : function.surjective f) :
  continuous f :=
continuous_iff_continuous_at.mpr (continuous_at_of_strict_mono_surjective h_mono h_surj)

/-- If `f : Œ± ‚âÉ Œ≤` is strictly monotone, its inverse is continuous. -/
lemma continuous_inv_of_strict_mono_equiv (e : Œ± ‚âÉ Œ≤) (h_mono : strict_mono e.to_fun) :
  continuous e.inv_fun :=
begin
  have hinv_mono : strict_mono e.inv_fun,
  { intros x y hxy,
    rw [‚Üê h_mono.lt_iff_lt, e.right_inv, e.right_inv],
    exact hxy },
  have hinv_surj : function.surjective e.inv_fun,
  { intros x,
    exact ‚ü®e.to_fun x, e.left_inv x‚ü© },
  exact continuous_of_strict_mono_surjective hinv_mono hinv_surj
end

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and surjective, it is a homeomorphism. -/
noncomputable def homeomorph_of_strict_mono_surjective
  (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (h_surj : function.surjective f) :
  homeomorph Œ± Œ≤ :=
{ to_equiv := equiv.of_bijective f ‚ü®strict_mono.injective h_mono, h_surj‚ü©,
  continuous_to_fun := continuous_of_strict_mono_surjective h_mono h_surj,
  continuous_inv_fun := continuous_inv_of_strict_mono_equiv
    (equiv.of_bijective f ‚ü®strict_mono.injective h_mono, h_surj‚ü©) h_mono }

@[simp] lemma coe_homeomorph_of_strict_mono_surjective
  (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (h_surj : function.surjective f) :
  (homeomorph_of_strict_mono_surjective f h_mono h_surj : Œ± ‚Üí Œ≤) = f := rfl

end linear_order

section conditionally_complete_linear_order
variables [conditionally_complete_linear_order Œ±] [densely_ordered Œ±] [order_topology Œ±]
variables [conditionally_complete_linear_order Œ≤] [order_topology Œ≤]

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and continuous, and tendsto `at_top` `at_top` and to
`at_bot` `at_bot`, then it is a homeomorphism. -/
noncomputable def homeomorph_of_strict_mono_continuous
  (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (h_cont : continuous f) (h_top : tendsto f at_top at_top)
  (h_bot : tendsto f at_bot at_bot) :
  homeomorph Œ± Œ≤ :=
homeomorph_of_strict_mono_surjective f h_mono (surjective_of_continuous h_cont h_top h_bot)

@[simp] lemma coe_homeomorph_of_strict_mono_continuous
  (f : Œ± ‚Üí Œ≤) (h_mono : strict_mono f) (h_cont : continuous f) (h_top : tendsto f at_top at_top)
  (h_bot : tendsto f at_bot at_bot) :
  (homeomorph_of_strict_mono_continuous f h_mono h_cont h_top h_bot : Œ± ‚Üí Œ≤) = f := rfl

/- Now we prove a relative version of the above result.  This (`Ioo` to `univ`) is provided as a
sample; there are at least 16 possible variations with open intervals (`univ` to `Ioo`, `Ioi` to
`univ`, ...), not to mention the possibilities with closed or half-closed intervals. -/
variables {a b : Œ±}

/-- If `f : Œ± ‚Üí Œ≤` is strictly monotone and continuous on the interval `Ioo a b` of `Œ±`, and tends
to `at_top` within `ùìù[Iio b] b` and to `at_bot` within `ùìù[Ioi a] a`, then it restricts to a
homeomorphism from `Ioo a b` to `Œ≤`. -/
noncomputable def homeomorph_of_strict_mono_continuous_Ioo
  (f : Œ± ‚Üí Œ≤) (h : a < b)
  (h_mono : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, a < x ‚Üí y < b ‚Üí x < y ‚Üí f x < f y)
  (h_cont : continuous_on f (Ioo a b))
  (h_top : tendsto f (ùìù[Iio b] b) at_top)
  (h_bot : tendsto f (ùìù[Ioi a] a) at_bot) :
  homeomorph (Ioo a b) Œ≤ :=
@homeomorph_of_strict_mono_continuous _ _ _ _
(@ord_connected_subset_conditionally_complete_linear_order Œ± (Ioo a b) _
  ‚ü®classical.choice (nonempty_Ioo_subtype h)‚ü© _)
_ _ _ _
(restrict f (Ioo a b))
(Œª x y, h_mono x.2.1 y.2.2)
(continuous_on_iff_continuous_restrict.mp h_cont)
begin
  rw [restrict_eq f (Ioo a b), Ioo_at_top_eq_nhds_within h],
  exact h_top.comp tendsto_comap
end
begin
  rw [restrict_eq f (Ioo a b), Ioo_at_bot_eq_nhds_within h],
  exact h_bot.comp tendsto_comap
end

@[simp] lemma coe_homeomorph_of_strict_mono_continuous_Ioo
  (f : Œ± ‚Üí Œ≤) (h : a < b)
  (h_mono : ‚àÄ ‚¶Éx y : Œ±‚¶Ñ, a < x ‚Üí y < b ‚Üí x < y ‚Üí f x < f y)
  (h_cont : continuous_on f (Ioo a b))
  (h_top : tendsto f (ùìù[Iio b] b) at_top)
  (h_bot : tendsto f (ùìù[Ioi a] a) at_bot) :
  (homeomorph_of_strict_mono_continuous_Ioo f h h_mono h_cont h_top h_bot : Ioo a b ‚Üí Œ≤)
  = restrict f (Ioo a b) :=
rfl

end conditionally_complete_linear_order

end homeomorphisms
