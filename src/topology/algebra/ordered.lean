/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import tactic.tfae
import order.liminf_limsup
import data.set.intervals
import topology.algebra.group

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±`(which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements (`order_closed_topology`
vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc) see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

### Connected sets and Intermediate Value Theorem

* `is_preconnected_I??` : all intervals `I??` are preconnected,
* `is_preconnected.intermediate_value`, `intermediate_value_univ` : Intermediate Value Theorem for
  connected sets and connected spaces, respectively;
* `intermediate_value_Icc`, `intermediate_value_Icc'`: Intermediate Value Theorem for functions
  on closed intervals.

### Miscellaneous facts

* `compact.exists_forall_le`, `compact.exists_forall_ge` : extreme value theorem, a continuous
  function on a compact set takes its minimum and maximum values.
* `is_closed.Icc_subset_of_forall_mem_nhds_within` : ‚ÄúContinuous induction‚Äù principle;
  if `s ‚à© [a, b]` is closed, `a ‚àà s`, and for each `x ‚àà [a, b) ‚à© s` some of its right neighborhoods
  is included `s`, then `[a, b] ‚äÜ s`.
* `is_closed.Icc_subset_of_forall_exists_gt`, `is_closed.mem_of_ge_of_forall_exists_gt` : two
  other versions of the ‚Äúcontinuous induction‚Äù principle.

## Implementation

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/

open classical set filter topological_space
open function (curry uncurry)
open_locale topological_space classical filter

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ‚â§ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class order_closed_topology (Œ± : Type*) [topological_space Œ±] [preorder Œ±] : Prop :=
(is_closed_le' : is_closed {p:Œ±√óŒ± | p.1 ‚â§ p.2})

instance : Œ† [topological_space Œ±], topological_space (order_dual Œ±) := id

section order_closed_topology

section preorder
variables [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±]
include t

lemma is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b ‚â§ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ t.is_closed_le'

lemma is_closed_le' (a : Œ±) : is_closed {b | b ‚â§ a} :=
is_closed_le continuous_id continuous_const

lemma is_closed_Iic {a : Œ±} : is_closed (Iic a) :=
is_closed_le' a

lemma is_closed_ge' (a : Œ±) : is_closed {b | a ‚â§ b} :=
is_closed_le continuous_const continuous_id

lemma is_closed_Ici {a : Œ±} : is_closed (Ici a) :=
is_closed_ge' a

instance : order_closed_topology (order_dual Œ±) :=
‚ü®continuous_swap _ (@order_closed_topology.is_closed_le' Œ± _ _ _)‚ü©

lemma is_closed_Icc {a b : Œ±} : is_closed (Icc a b) :=
is_closed_inter is_closed_Ici is_closed_Iic

lemma le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hb : b ‚â† ‚ä•)
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ·∂† x in b, f x ‚â§ g x) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
have tendsto (Œªb, (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (a‚ÇÅ, a‚ÇÇ) ‚àà {p:Œ±√óŒ± | p.1 ‚â§ p.2},
  from mem_of_closed_of_tendsto hb this t.is_closed_le' h

lemma le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hb : b ‚â† ‚ä•)
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
le_of_tendsto_of_tendsto hb hf hg (eventually_of_forall _ h)

lemma le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto_of_tendsto nt lim tendsto_const_nhds h

lemma le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto nt lim (eventually_of_forall _ h)

lemma ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, b ‚â§ f c) : b ‚â§ a :=
le_of_tendsto_of_tendsto nt tendsto_const_nhds lim h

lemma ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  (nt : x ‚â† ‚ä•) (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, b ‚â§ f c) : b ‚â§ a :=
ge_of_tendsto nt lim (eventually_of_forall _ h)

@[simp]
lemma closure_le_eq [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b ‚â§ g b} = {b | f b ‚â§ g b} :=
closure_eq_iff_is_closed.mpr $ is_closed_le hf hg

lemma closure_lt_subset_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f)
  (hg : continuous g) :
  closure {b | f b < g b} ‚äÜ {b | f b ‚â§ g b} :=
by { rw [‚Üêclosure_le_eq hf hg], exact closure_mono (Œª b, le_of_lt) }

lemma continuous_within_at.closure_le [topological_space Œ≤]
 {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} {x : Œ≤} (hx : x ‚àà closure s)
 (hf : continuous_within_at f s x)
 (hg : continuous_within_at g s x)
 (h : ‚àÄ y ‚àà s, f y ‚â§ g y) : f x ‚â§ g x :=
begin
  show (f x, g x) ‚àà {p : Œ± √ó Œ± | p.1 ‚â§ p.2},
  suffices : (f x, g x) ‚àà closure {p : Œ± √ó Œ± | p.1 ‚â§ p.2},
    begin
      rwa closure_eq_of_is_closed at this,
      exact order_closed_topology.is_closed_le'
    end,
  exact (continuous_within_at.prod hf hg).mem_closure hx h
end

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. -/
lemma is_closed.is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (hs : is_closed s)
  (hf : continuous_on f s) (hg : continuous_on g s) :
  is_closed {x ‚àà s | f x ‚â§ g x} :=
(hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'

end preorder

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_closed_topology Œ±]
include t

private lemma is_closed_eq : is_closed {p : Œ± √ó Œ± | p.1 = p.2} :=
by simp [le_antisymm_iff];
   exact is_closed_inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

@[priority 90] -- see Note [lower instance priority]
instance order_closed_topology.to_t2_space : t2_space Œ± :=
{ t2 :=
  have is_open {p : Œ± √ó Œ± | p.1 ‚â† p.2}, from is_closed_eq,
  assume a b h,
  let ‚ü®u, v, hu, hv, ha, hb, h‚ü© := is_open_prod_iff.mp this a b h in
  ‚ü®u, v, hu, hv, ha, hb,
    set.eq_empty_iff_forall_not_mem.2 $ assume a ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    have a ‚â† a, from @h (a, a) ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©,
    this rfl‚ü© }

end partial_order

section linear_order
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±]

lemma is_open_lt [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_open {b | f b < g b} :=
by simp [lt_iff_not_ge, -not_le]; exact is_closed_le hg hf

variables {a b : Œ±}

lemma is_open_Iio : is_open (Iio a) :=
is_open_lt continuous_id continuous_const

lemma is_open_Ioi : is_open (Ioi a) :=
is_open_lt continuous_const continuous_id

lemma is_open_Ioo : is_open (Ioo a b) :=
is_open_inter is_open_Ioi is_open_Iio

@[simp] lemma interior_Ioi : interior (Ioi a) = Ioi a :=
interior_eq_of_open is_open_Ioi

@[simp] lemma interior_Iio : interior (Iio a) = Iio a :=
interior_eq_of_open is_open_Iio

@[simp] lemma interior_Ioo : interior (Ioo a b) = Ioo a b :=
interior_eq_of_open is_open_Ioo

/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions
on a preconnected space and `f a ‚â§ g a` and `g b ‚â§ f b`, then for some `x` we have `f x = g x`. -/
lemma intermediate_value_univ‚ÇÇ {Œ≥ : Type*} [topological_space Œ≥] [preconnected_space Œ≥] {a b : Œ≥}
  {f g : Œ≥ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) (ha : f a ‚â§ g a) (hb : g b ‚â§ f b) :
  ‚àÉ x, f x = g x :=
begin
  obtain ‚ü®x, h, hfg, hgf‚ü© : (univ ‚à© {x | f x ‚â§ g x ‚àß g x ‚â§ f x}).nonempty,
    from is_preconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _
      (is_closed_le hf hg) (is_closed_le hg hf) (Œª x hx, le_total _ _) ‚ü®a, trivial, ha‚ü©
      ‚ü®b, trivial, hb‚ü©,
  exact ‚ü®x, le_antisymm hfg hgf‚ü©
end

/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous
on a preconnected set `s` and for some `a b ‚àà s` we have `f a ‚â§ g a` and `g b ‚â§ f b`,
then for some `x ‚àà s` we have `f x = g x`. -/
lemma is_preconnected.intermediate_value‚ÇÇ {Œ≥ : Type*} [topological_space Œ≥] {s : set Œ≥}
  (hs : is_preconnected s) {a b : Œ≥} (ha : a ‚àà s) (hb : b ‚àà s) {f g : Œ≥ ‚Üí Œ±}
  (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a ‚â§ g a) (hb' : g b ‚â§ f b) :
  ‚àÉ x ‚àà s, f x = g x :=
let ‚ü®x, hx‚ü© := @intermediate_value_univ‚ÇÇ Œ± _ _ _ s _ (subtype.preconnected_space hs) ‚ü®a, ha‚ü© ‚ü®b, hb‚ü©
  _ _ (continuous_on_iff_continuous_restrict.1 hf) (continuous_on_iff_continuous_restrict.1 hg)
  ha' hb'
in ‚ü®x, x.2, hx‚ü©

/-- Intermediate Value Theorem for continuous functions on connected sets. -/
lemma is_preconnected.intermediate_value {Œ≥ : Type*} [topological_space Œ≥] {s : set Œ≥}
  (hs : is_preconnected s) {a b : Œ≥} (ha : a ‚àà s) (hb : b ‚àà s) {f : Œ≥ ‚Üí Œ±}
  (hf : continuous_on f s) :
  Icc (f a) (f b) ‚äÜ f '' s :=
Œª x hx, mem_image_iff_bex.2 $ hs.intermediate_value‚ÇÇ ha hb hf continuous_on_const hx.1 hx.2

/-- Intermediate Value Theorem for continuous functions on connected spaces. -/
lemma intermediate_value_univ {Œ≥ : Type*} [topological_space Œ≥] [preconnected_space Œ≥]
  (a b : Œ≥) {f : Œ≥ ‚Üí Œ±} (hf : continuous f) :
  Icc (f a) (f b) ‚äÜ range f :=
Œª x hx, intermediate_value_univ‚ÇÇ hf continuous_const hx.1 hx.2

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
lemma is_preconnected.Icc_subset {s : set Œ±} (hs : is_preconnected s)
  {a b : Œ±} (ha : a ‚àà s) (hb : b ‚àà s) :
  Icc a b ‚äÜ s :=
by simpa only [image_id] using hs.intermediate_value ha hb continuous_on_id

/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole
space. -/
lemma is_preconnected.eq_univ_of_unbounded {s : set Œ±} (hs : is_preconnected s) (hb : ¬¨bdd_below s)
  (ha : ¬¨bdd_above s) :
  s = univ :=
begin
  refine eq_univ_of_forall (Œª x, _),
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := not_bdd_below_iff.1 hb x,
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
end

end linear_order

section decidable_linear_order
variables [topological_space Œ±] [decidable_linear_order Œ±] [order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±}

section
variables [topological_space Œ≤] (hf : continuous f) (hg : continuous g)
include hf hg

lemma frontier_le_subset_eq : frontier {b | f b ‚â§ g b} ‚äÜ {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _),
  convert hb‚ÇÇ using 2, simp only [not_le.symm], refl
end

lemma frontier_lt_subset_eq : frontier {b | f b < g b} ‚äÜ {b | f b = g b} :=
by rw ‚Üê frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]

lemma continuous.max : continuous (Œªb, max (f b) (g b)) :=
have ‚àÄb‚ààfrontier {b | f b ‚â§ g b}, g b = f b, from assume b hb, (frontier_le_subset_eq hf hg hb).symm,
continuous_if this hg hf

lemma continuous.min : continuous (Œªb, min (f b) (g b)) :=
have ‚àÄb‚ààfrontier {b | f b ‚â§ g b}, f b = g b, from assume b hb, frontier_le_subset_eq hf hg hb,
continuous_if this hf hg

end

lemma tendsto.max {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, max p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (max a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.max continuous_snd) _
    end
    (hf.prod_mk hg)

lemma tendsto.min {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
show tendsto ((Œªp:Œ±√óŒ±, min p.1 p.2) ‚àò (Œªb, (f b, g b))) b (ùìù (min a‚ÇÅ a‚ÇÇ)),
  from tendsto.comp
    begin
      rw [‚Üênhds_prod_eq],
      from continuous_iff_continuous_at.mp (continuous_fst.min continuous_snd) _
    end
    (hf.prod_mk hg)

end decidable_linear_order

end order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class order_topology (Œ± : Type*) [t : topological_space Œ±] [preorder Œ±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | ‚àÉa, s = Ioi a ‚à® s = Iio a})

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def preorder.topology (Œ± : Type*) [preorder Œ±] : topological_space Œ± :=
generate_from {s : set Œ± | ‚àÉ (a : Œ±), s = {b : Œ± | a < b} ‚à® s = {b : Œ± | b < a}}

section order_topology

instance {Œ± : Type*} [topological_space Œ±] [partial_order Œ±] [order_topology Œ±] :
  order_topology (order_dual Œ±) :=
‚ü®by convert @order_topology.topology_eq_generate_intervals Œ± _ _ _;
  conv in (_ ‚à® _) { rw or.comm }; refl‚ü©

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_topology Œ±]
include t

lemma is_open_iff_generate_intervals {s : set Œ±} :
  is_open s ‚Üî generate_open {s | ‚àÉa, s = Ioi a ‚à® s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl

lemma is_open_lt' (a : Œ±) : is_open {b:Œ± | a < b} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©

lemma is_open_gt' (a : Œ±) : is_open {b:Œ± | b < a} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©

lemma lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
mem_nhds_sets (is_open_lt' _) h

lemma le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
(ùìù b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
mem_nhds_sets (is_open_gt' _) h

lemma ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
(ùìù a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma nhds_eq_order (a : Œ±) :
  ùìù a = (‚®Öb ‚àà Iio a, ùìü (Ioi b)) ‚äì (‚®Öb ‚àà Ioi a, ùìü (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | b < c} $ infi_le _ ‚ü®hb, b, or.inl rfl‚ü©)
    (le_infi $ assume b, le_infi $ assume hb,
      infi_le_of_le {c : Œ± | c < b} $ infi_le _ ‚ü®hb, b, or.inr rfl‚ü©))
  (le_infi $ assume s, le_infi $ assume ‚ü®ha, b, hs‚ü©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_left_of_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_right_of_le $ infi_le_of_le b $ infi_le _ h
    end)

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß (‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a') :=
by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a))
  (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b) (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) :
  tendsto f b (ùìù a) :=
tendsto_order.2
  ‚ü®assume a' h',
    have ‚àÄ·∂† b in b, a' < g b, from (tendsto_order.1 hg).left a' h',
    by filter_upwards [this, hgf] assume a, lt_of_lt_of_le,
    assume a' h',
    have ‚àÄ·∂† b in b, h b < a', from (tendsto_order.1 hh).right a' h',
    by filter_upwards [this, hfh] assume a h‚ÇÅ h‚ÇÇ, lt_of_le_of_lt h‚ÇÇ h‚ÇÅ‚ü©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
  tendsto f b (ùìù a) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh
  (eventually_of_forall _ hgf) (eventually_of_forall _ hfh)

lemma nhds_order_unbounded {a : Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  ùìù a = (‚®Öl (h‚ÇÇ : l < a) u (h‚ÇÇ : a < u), ùìü (Ioo l u)) :=
let ‚ü®u, hu‚ü© := hu, ‚ü®l, hl‚ü© := hl in
calc ùìù a = (‚®Öb<a, ùìü {c | b < c}) ‚äì (‚®Öb>a, ùìü {c | c < b}) : nhds_eq_order a
  ... = (‚®Öb<a, ùìü {c | b < c} ‚äì (‚®Öb>a, ùìü {c | c < b})) :
    binfi_inf hl
  ... = (‚®Öl<a, (‚®Öu>a, ùìü {c | c < u} ‚äì ùìü {c | l < c})) :
    begin
      congr, funext x,
      congr, funext hx,
      rw [inf_comm],
      apply binfi_inf hu
    end
  ... = _ : by simp [inter_comm]; refl

lemma tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤}
  (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) (h : ‚àÄl u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
  tendsto f x (ùìù a) :=
by rw [nhds_order_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)

end partial_order

@[nolint ge_or_gt] -- see Note [nolint_ge]
theorem induced_order_topology' {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b)
  (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
  @order_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { exact mem_comap_sets.2 ‚ü®{x | f b < x},
        mem_inf_sets_of_left $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© },
    { exact mem_comap_sets.2 ‚ü®{x | x < f b},
        mem_inf_sets_of_right $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _); simp,
    { rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inl rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_sets _ (mem_infi_sets ‚ü®ab, b, or.inr rfl‚ü© (mem_principal_sets.2 _)),
      exact Œª c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end

theorem induced_order_topology {Œ± : Type u} {Œ≤ : Type v}
  [partial_order Œ±] [ta : topological_space Œ≤] [partial_order Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @order_topology _ (induced f ta) _ :=
induced_order_topology' f @hf
  (Œª a x xa, let ‚ü®b, xb, ba‚ü© := H xa in ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
  (Œª a x ax, let ‚ü®b, ab, bx‚ü© := H ax in ‚ü®b, hf.1 ab, le_of_lt bx‚ü©)

lemma nhds_top_order [topological_space Œ±] [order_top Œ±] [order_topology Œ±] :
  ùìù (‚ä§:Œ±) = (‚®Öl (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l)) :=
by simp [nhds_eq_order (‚ä§:Œ±)]

lemma nhds_bot_order [topological_space Œ±] [order_bot Œ±] [order_topology Œ±] :
  ùìù (‚ä•:Œ±) = (‚®Öl (h‚ÇÇ : ‚ä• < l), ùìü (Iio l)) :=
by simp [nhds_eq_order (‚ä•:Œ±)]

section linear_order

variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]

lemma exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
  ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
begin
  rw [nhds_eq_order a] at hs,
  rcases hs with ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hts‚ü©,
  -- First we show that `t‚ÇÇ` includes `(-‚àû, a]`, so it suffices to show `(l', ‚àû) ‚äÜ t‚ÇÅ`
  suffices : ‚àÉ l' ‚àà Ico l a, Ioi l' ‚äÜ t‚ÇÅ,
  { have A : ùìü (Iic a) ‚â§ ‚®Ö b ‚àà Ioi a, ùìü (Iio b),
      from (le_infi $ Œª b, le_infi $ Œª hb, principal_mono.2 $ Iic_subset_Iio.2 hb),
    have B : t‚ÇÅ ‚à© Iic a ‚äÜ s,
      from subset.trans (inter_subset_inter_right _ (A ht‚ÇÇ)) hts,
    from this.imp (Œª l', Exists.imp $ Œª hl' hl x hx, B ‚ü®hl hx.1, hx.2‚ü©) },
  clear hts ht‚ÇÇ t‚ÇÇ,
  -- Now we find `l` such that `(l', ‚àû) ‚äÜ t‚ÇÅ`
  letI := classical.DLO Œ±,
  rw [mem_binfi] at ht‚ÇÅ,
  { rcases ht‚ÇÅ with ‚ü®b, hb, hb'‚ü©,
    exact ‚ü®max b l, ‚ü®le_max_right _ _, max_lt hb hl‚ü©,
      Œª x hx, hb' $ Ioi_subset_Ioi (le_max_left _ _) hx‚ü© },
  { intros b hb b' hb', simp only [mem_Iio] at hb hb',
    use [max b b', max_lt hb hb'],
    simp [le_refl] },
  exact ‚ü®l, hl‚ü©
end

lemma exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
  ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s :=
begin
  convert @exists_Ioc_subset_of_mem_nhds' (order_dual Œ±) _ _ _ _ _ hs _ hu,
  ext, rw [dual_Ico, dual_Ioc]
end

lemma exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
  ‚àÉ l < a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ioc_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.2, hl.snd‚ü©

lemma exists_Ico_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
  ‚àÉ u (_ : a < u), Ico a u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h in let ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.1, hl.snd‚ü©

lemma mem_nhds_unbounded {a : Œ±} {s : set Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  s ‚àà ùìù a ‚Üî (‚àÉl u, l < a ‚àß a < u ‚àß ‚àÄb, l < b ‚Üí b < u ‚Üí b ‚àà s) :=
let ‚ü®l, hl'‚ü© := hl, ‚ü®u, hu'‚ü© := hu in
have ùìù a = (‚®Öp : {l // l < a} √ó {u // a < u}, ùìü (Ioo p.1.val p.2.val)),
  by simp [nhds_order_unbounded hu hl, infi_subtype, infi_prod],
iff.intro
  (assume hs, by rw [this] at hs; from infi_sets_induct hs
    ‚ü®l, u, hl', hu', by simp‚ü©
    begin
      intro p, rcases p with ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü©,
      simp [set.subset_def],
      intros s‚ÇÅ s‚ÇÇ hs‚ÇÅ l' hl' u' hu' hs‚ÇÇ,
      letI := classical.DLO Œ±,
      refine ‚ü®max l l', _, min u u', _‚ü©;
      simp [*, lt_min_iff, max_lt_iff] {contextual := tt}
    end
    (assume s‚ÇÅ s‚ÇÇ h ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©, ‚ü®l, u, h‚ÇÅ, h‚ÇÇ, assume b hu hl, h $ h‚ÇÉ _ hu hl‚ü©))
  (assume ‚ü®l, u, hl, hu, h‚ü©,
    by rw [this]; exact mem_infi_sets ‚ü®‚ü®l, hl‚ü©, ‚ü®u, hu‚ü©‚ü© (assume b ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, h b h‚ÇÅ h‚ÇÇ))

lemma order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
  ‚àÉu v : set Œ±, is_open u ‚àß is_open v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß (‚àÄb‚ÇÅ‚ààu, ‚àÄb‚ÇÇ‚ààv, b‚ÇÅ < b‚ÇÇ) :=
match dense_or_discrete a‚ÇÅ a‚ÇÇ with
| or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, {a' | a < a'}, is_open_gt' a, is_open_lt' a, ha‚ÇÅ, ha‚ÇÇ,
    assume b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ, lt_trans h‚ÇÅ h‚ÇÇ‚ü©
| or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a | a < a‚ÇÇ}, {a | a‚ÇÅ < a}, is_open_gt' a‚ÇÇ, is_open_lt' a‚ÇÅ, h, h,
    assume b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ,
    calc b‚ÇÅ ‚â§ a‚ÇÅ : h‚ÇÇ _ hb‚ÇÅ
      ... < a‚ÇÇ : h
      ... ‚â§ b‚ÇÇ : h‚ÇÅ _ hb‚ÇÇ‚ü©
end

@[priority 100] -- see Note [lower instance priority]
instance order_topology.to_order_closed_topology : order_closed_topology Œ± :=
{ is_closed_le' :=
    is_open_prod_iff.mpr $ assume a‚ÇÅ a‚ÇÇ (h : ¬¨ a‚ÇÅ ‚â§ a‚ÇÇ),
      have h : a‚ÇÇ < a‚ÇÅ, from lt_of_not_ge h,
      let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h in
      ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, assume ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, not_le_of_gt $ h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü© }

lemma order_topology.t2_space : t2_space Œ± := by apply_instance

@[priority 100] -- see Note [lower instance priority]
instance order_topology.regular_space : regular_space Œ± :=
{ regular := assume s a hs ha,
    have hs' : s·∂ú ‚àà ùìù a, from mem_nhds_sets hs ha,
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄl‚àà s, l < a ‚Üí l ‚àà t) ‚àß ùìù a ‚äì ùìü t = ‚ä•,
      from by_cases
        (assume h : ‚àÉl, l < a,
          let ‚ü®l, hl, h‚ü© := exists_Ioc_subset_of_mem_nhds hs' h in
          match dense_or_discrete l a with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | a < b}, is_open_gt' _,
              assume c hcs hca, show c < b,
                from lt_of_not_ge $ assume hbc, h ‚ü®lt_of_lt_of_le hb‚ÇÅ hbc, le_of_lt hca‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hb‚ÇÇ) $
                assume x (hx : b < x), show ¬¨ x < b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, is_open_gt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_lt' _) hl) $
                assume x (hx : l < x), show ¬¨ x < a, from not_lt.2 $ h‚ÇÅ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉl, l < a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          by rw [principal_empty, inf_bot_eq]‚ü©),
    let ‚ü®t‚ÇÅ, ht‚ÇÅo, ht‚ÇÅs, ht‚ÇÅa‚ü© := this in
    have ‚àÉt:set Œ±, is_open t ‚àß (‚àÄu‚àà s, u>a ‚Üí u ‚àà t) ‚àß ùìù a ‚äì ùìü t = ‚ä•,
      from by_cases
        (assume h : ‚àÉu, u > a,
          let ‚ü®u, hu, h‚ü© := exists_Ico_subset_of_mem_nhds hs' h in
          match dense_or_discrete a u with
          | or.inl ‚ü®b, hb‚ÇÅ, hb‚ÇÇ‚ü© := ‚ü®{a | b < a}, is_open_lt' _,
              assume c hcs hca, show c > b,
                from lt_of_not_ge $ assume hbc, h ‚ü®le_of_lt hca, lt_of_le_of_lt hbc hb‚ÇÇ‚ü© hcs,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hb‚ÇÅ) $
                assume x (hx : b > x), show ¬¨ x > b, from not_lt.2 $ le_of_lt hx‚ü©
          | or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a' | a' > a}, is_open_lt' _, assume b hbs hba, hba,
              inf_principal_eq_bot $ (ùìù a).sets_of_superset (mem_nhds_sets (is_open_gt' _) hu) $
                assume x (hx : u > x), show ¬¨ x > a, from not_lt.2 $ h‚ÇÇ _ hx‚ü©
          end)
        (assume : ¬¨ ‚àÉu, u > a, ‚ü®‚àÖ, is_open_empty, assume l _ hl, (this ‚ü®l, hl‚ü©).elim,
          by rw [principal_empty, inf_bot_eq]‚ü©),
    let ‚ü®t‚ÇÇ, ht‚ÇÇo, ht‚ÇÇs, ht‚ÇÇa‚ü© := this in
    ‚ü®t‚ÇÅ ‚à™ t‚ÇÇ, is_open_union ht‚ÇÅo ht‚ÇÇo,
      assume x hx,
      have x ‚â† a, from assume eq, ha $ eq ‚ñ∏ hx,
      (ne_iff_lt_or_gt.mp this).imp (ht‚ÇÅs _ hx) (ht‚ÇÇs _ hx),
      by rw [‚Üêsup_principal, inf_sup_left, ht‚ÇÅa, ht‚ÇÇa, bot_sup_eq]‚ü©,
  ..order_topology.t2_space }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
lemma mem_nhds_iff_exists_Ioo_subset' {a l' u' : Œ±} {s : set Œ±}
  (hl' : l' < a) (hu' : a < u') :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds' h hu' with ‚ü®u, au, hu‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds' h hl' with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, u, ‚ü®la.2, au.1‚ü©, Œªx hx, _‚ü©,
    cases le_total a x with hax hax,
    { exact hu ‚ü®hax, hx.2‚ü© },
    { exact hl ‚ü®hx.1, hax‚ü© } },
  { rintros ‚ü®l, u, ha, h‚ü©,
    apply mem_sets_of_superset (mem_nhds_sets is_open_Ioo ha) h }
end

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`. -/
lemma mem_nhds_iff_exists_Ioo_subset [no_top_order Œ±] [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_iff_exists_Ioo_subset' hl' hu'

lemma Iio_mem_nhds {a b : Œ±} (h : a < b) : Iio b ‚àà ùìù a :=
mem_nhds_sets is_open_Iio h

lemma Ioi_mem_nhds {a b : Œ±} (h : a < b) : Ioi a ‚àà ùìù b :=
mem_nhds_sets is_open_Ioi h

lemma Ioo_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioo a b ‚àà ùìù x :=
mem_nhds_sets is_open_Ioo ‚ü®ha, hb‚ü©

lemma disjoint_nhds_at_top [no_top_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_top :=
begin
  rw filter.disjoint_iff,
  cases no_top x with a ha,
  use [Iio a, Ici a, Iio_mem_nhds ha, mem_at_top a],
  rw [inter_comm, Ici_inter_Iio, Ico_self]
end

@[simp] lemma inf_nhds_at_top [no_top_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_top = ‚ä• :=
disjoint_iff.1 (disjoint_nhds_at_top x)

lemma disjoint_nhds_at_bot [no_bot_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_bot :=
@disjoint_nhds_at_top (order_dual Œ±) _ _ _ _ x

@[simp] lemma inf_nhds_at_bot [no_bot_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_bot = ‚ä• :=
@inf_nhds_at_top (order_dual Œ±) _ _ _ _ x

lemma not_tendsto_nhds_of_tendsto_at_top [no_top_order Œ±]
  {F : filter Œ≤} (hF : F ‚â† ‚ä•) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_top) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto hF (disjoint_nhds_at_top x).symm

lemma not_tendsto_at_top_of_tendsto_nhds [no_top_order Œ±]
  {F : filter Œ≤} (hF : F ‚â† ‚ä•) {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_top :=
hf.not_tendsto hF (disjoint_nhds_at_top x)

lemma not_tendsto_nhds_of_tendsto_at_bot [no_bot_order Œ±]
  {F : filter Œ≤} (hF : F ‚â† ‚ä•) {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_bot) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto hF (disjoint_nhds_at_bot x).symm

lemma not_tendsto_at_bot_of_tendsto_nhds [no_bot_order Œ±]
  {F : filter Œ≤} (hF : F ‚â† ‚ä•) {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_bot :=
hf.not_tendsto hF (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `nhds_within a (Ioi a)` and
`nhds_wihin a (Ici a)` on the right, and similarly on the left. Such neighborhoods can be
characterized as the sets containing suitable intervals to the right or to the left of `a`.
We give now these characterizations. -/

-- NB: If you extend the list, append to the end please to avoid breaking the API
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ioi {a b : Œ±} (hab : a < b) (s : set Œ±) :
  tfae [s ‚àà nhds_within a (Ioi a), -- 0 : `s` is a neighborhood of `a` within `(a, +‚àû)`
    s ‚àà nhds_within a (Ioc a b),   -- 1 : `s` is a neighborhood of `a` within `(a, b]`
    s ‚àà nhds_within a (Ioo a b),   -- 2 : `s` is a neighborhood of `a` within `(a, b)`
    ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,    -- 3 : `s` includes `(a, u)` for some `u ‚àà (a, b]`
    ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] :=   -- 4 : `s` includes `(a, u)` for some `u > a`
begin
  tfae_have : 1 ‚Üí 2, from Œª h, nhds_within_mono _ Ioc_subset_Ioi_self h,
  tfae_have : 2 ‚Üí 3, from Œª h, nhds_within_mono _ Ioo_subset_Ioc_self h,
  tfae_have : 4 ‚Üí 5, from Œª ‚ü®u, umem, hu‚ü©, ‚ü®u, umem.1, hu‚ü©,
  tfae_have : 5 ‚Üí 1,
  { rintros ‚ü®u, hau, hu‚ü©,
    exact mem_nhds_within.2 ‚ü®Iio u, is_open_Iio, hau, by rwa [inter_comm, Ioi_inter_Iio]‚ü© },
  tfae_have : 3 ‚Üí 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, _‚ü©,
    exact Ioo_subset_Ioo_right au.2 hx  },
  tfae_finish
end

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  nhds_within a (Ioc a b) = nhds_within a (Ioi a) :=
filter.ext $ Œª s, (tfae_mem_nhds_within_Ioi h s).out 1 0

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Ioi {a b : Œ±} (hu : a < b) :
  nhds_within a (Ioo a b) = nhds_within a (Ioi a) :=
filter.ext $ Œª s, (tfae_mem_nhds_within_Ioi hu s).out 2 0

lemma mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu ‚àà Ioc a u', Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Ioi a) ‚Üî ‚àÉu ‚àà Ioi a, Ioc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
end

lemma Ioo_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioo a c ‚àà nhds_within b (Ioi b) :=
(mem_nhds_within_Ioi_iff_exists_Ioo_subset' H.2).2 ‚ü®c, H.2, Ioo_subset_Ioo_left H.1‚ü©

lemma Ioc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioc a c ‚àà nhds_within b (Ioi b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà nhds_within b (Ioi b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

lemma Icc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà nhds_within b (Ioi b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
lemma tfae_mem_nhds_within_Iio {a b : Œ±} (h : a < b) (s : set Œ±) :
  tfae [s ‚àà nhds_within b (Iio b), -- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`
    s ‚àà nhds_within b (Ico a b),   -- 1 : `s` is a neighborhood of `b` within `[a, b)`
    s ‚àà nhds_within b (Ioo a b),   -- 2 : `s` is a neighborhood of `b` within `(a, b)`
    ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,    -- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`
    ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] :=   -- 4 : `s` includes `(l, b)` for some `l < b`
begin
  have := @tfae_mem_nhds_within_Ioi (order_dual Œ±) _ _ _ _ _ h s,
  -- If we call `convert` here, it generates wrong equations, so we need to simplify first
  simp only [exists_prop] at this ‚ä¢,
  rw [dual_Ioi, dual_Ioc, dual_Ioo] at this,
  convert this; ext l; rw [dual_Ioo]
end

@[simp] lemma nhds_within_Ico_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  nhds_within b (Ico a b) = nhds_within b (Iio b) :=
filter.ext $ Œª s, (tfae_mem_nhds_within_Iio h s).out 1 0

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  nhds_within b (Ioo a b) = nhds_within b (Iio b) :=
filter.ext $ Œª s, (tfae_mem_nhds_within_Iio h s).out 2 0

lemma mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl ‚àà Ico l' a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Iio a) ‚Üî ‚àÉl ‚àà Iio a, Ico l a ‚äÜ s :=
begin
  convert @mem_nhds_within_Ioi_iff_exists_Ioc_subset (order_dual Œ±) _ _ _ _ _ _ _,
  simp only [dual_Ioc], refl
end

lemma Ioo_mem_nhds_within_Iio {a b c : Œ±} (h : b ‚àà Ioc a c) :
  Ioo a c ‚àà nhds_within b (Iio b) :=
(mem_nhds_within_Iio_iff_exists_Ioo_subset' h.1).2 ‚ü®a, h.1, Ioo_subset_Ioo_right h.2‚ü©

lemma Ioc_mem_nhds_within_Iio {a b c : Œ±} (h : b ‚àà Ioc a c) :
  Ioc a c ‚àà nhds_within b (Iio b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio h) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Iio {a b c : Œ±} (h : b ‚àà Ioc a c) :
  Ico a c ‚àà nhds_within b (Iio b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio h) Ioo_subset_Ico_self

lemma Icc_mem_nhds_within_Iio {a b c : Œ±} (h : b ‚àà Ioc a c) :
  Icc a c ‚àà nhds_within b (Iio b) :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio h) Ioo_subset_Icc_self

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Ico a u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds va ‚ü®u', hu'‚ü© with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.1‚ü©,
    exact hu hx },
  { rintros ‚ü®u, au, hu‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Iio u, mem_nhds_sets is_open_Iio au, _‚ü©,
    rwa [inter_comm, Ici_inter_Iio] }
end

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_top_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Ico a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := no_top a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_top_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Ici a) ‚Üî ‚àÉu, a < u ‚àß Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases dense au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Ioc l a ‚äÜ s :=
begin
  split,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds va ‚ü®l', hl'‚ü© with ‚ü®l, la, hl‚ü©,
    refine ‚ü®l, la, Œªx hx, _‚ü©,
    refine hv ‚ü®_, hx.2‚ü©,
    exact hl hx },
  { rintros ‚ü®l, la, ha‚ü©,
    rw mem_nhds_within_iff_exists_mem_nhds_inter,
    refine ‚ü®Ioi l, mem_nhds_sets is_open_Ioi la, _‚ü©,
    rwa [Ioi_inter_Iic] }
end

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_bot_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := no_bot a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_bot_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà nhds_within a (Iic a) ‚Üî ‚àÉl, l < a ‚àß Icc l a ‚äÜ s :=
begin
  rw mem_nhds_within_Iic_iff_exists_Ioc_subset,
  split,
  { rintros ‚ü®l, la, as‚ü©,
    rcases dense la with ‚ü®v, hv‚ü©,
    refine ‚ü®v, hv.2, Œªx hx, as ‚ü®lt_of_lt_of_le hv.1 hx.1, hx.2‚ü©‚ü©, },
  { rintros ‚ü®l, la, as‚ü©,
    exact ‚ü®l, la, subset.trans Ioc_subset_Icc_self as‚ü© }
end

end linear_order

lemma preimage_neg [add_group Œ±] : preimage (has_neg.neg : Œ± ‚Üí Œ±) = image (has_neg.neg : Œ± ‚Üí Œ±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm

lemma filter.map_neg [add_group Œ±] : map (has_neg.neg : Œ± ‚Üí Œ±) = comap (has_neg.neg : Œ± ‚Üí Œ±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

section topological_add_group

variables [topological_space Œ±] [ordered_add_comm_group Œ±] [topological_add_group Œ±]

lemma neg_preimage_closure {s : set Œ±} : (Œªr:Œ±, -r) ‚Åª¬π' closure s = closure ((Œªr:Œ±, -r) '' s) :=
have (Œªr:Œ±, -r) ‚àò (Œªr:Œ±, -r) = id, from funext neg_neg,
by rw [preimage_neg]; exact
  (subset.antisymm (image_closure_subset_closure_image continuous_neg) $
    calc closure ((Œª (r : Œ±), -r) '' s) = (Œªr, -r) '' ((Œªr, -r) '' closure ((Œª (r : Œ±), -r) '' s)) :
        by rw [‚Üêimage_comp, this, image_id]
      ... ‚äÜ (Œªr, -r) '' closure ((Œªr, -r) '' ((Œª (r : Œ±), -r) '' s)) :
        monotone_image $ image_closure_subset_closure_image continuous_neg
      ... = _ : by rw [‚Üêimage_comp, this, image_id])

end topological_add_group

section order_topology

variables [topological_space Œ±] [topological_space Œ≤]
  [linear_order Œ±] [linear_order Œ≤] [order_topology Œ±] [order_topology Œ≤]

lemma is_lub.nhds_within_ne_bot {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  nhds_within a s ‚â† ‚ä• :=
let ‚ü®a', ha'‚ü© := hs in
forall_sets_nonempty_iff_ne_bot.mp $ assume t ht,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, ht‚ü© := mem_inf_sets.mp ht in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ, from mem_of_nhds ht‚ÇÅ,
      have a ‚àà t‚ÇÇ, from ht‚ÇÇ $ by rwa [h],
      ‚ü®a, ht ‚ü®‚Äπa ‚àà t‚ÇÅ‚Ä∫, ‚Äπa ‚àà t‚ÇÇ‚Ä∫‚ü©‚ü©)
    (assume : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ‚Äπa' ‚àà s‚Ä∫) this.symm,
      let ‚ü®l, hl, hlt‚ÇÅ‚ü© := exists_Ioc_subset_of_mem_nhds ht‚ÇÅ ‚ü®a', this‚ü© in
      have ‚àÉa'‚ààs, l < a',
        from classical.by_contradiction $ assume : ¬¨ ‚àÉa'‚ààs, l < a',
          have ‚àÄa'‚ààs, a' ‚â§ l, from assume a ha, not_lt.1 $ assume ha', this ‚ü®a, ha, ha'‚ü©,
          have ¬¨ l < a, from not_lt.2 $ ha.right this,
          this ‚Äπl < a‚Ä∫,
      let ‚ü®a', ha', ha'l‚ü© := this in
      have a' ‚àà t‚ÇÅ, from hlt‚ÇÅ ‚ü®‚Äπl < a'‚Ä∫, ha.left ha'‚ü©,
      ‚ü®a', ht ‚ü®‚Äπa' ‚àà t‚ÇÅ‚Ä∫, ht‚ÇÇ ‚Äπa' ‚àà s‚Ä∫‚ü©‚ü©)

lemma is_glb.nhds_within_ne_bot : ‚àÄ {a : Œ±} {s : set Œ±}, is_glb s a ‚Üí s.nonempty ‚Üí
  nhds_within a s ‚â† ‚ä• :=
@is_lub.nhds_within_ne_bot (order_dual Œ±) _ _ _

lemma is_lub_of_mem_nhds {s : set Œ±} {a : Œ±} {f : filter Œ±}
  (hsa : a ‚àà upper_bounds s) (hsf : s ‚àà f) (hfa : f ‚äì ùìù a ‚â† ‚ä•) : is_lub s a :=
‚ü®hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s ‚à© {a | b < a} ‚àà f ‚äì ùìù a,
    from inter_mem_inf_sets hsf (mem_nhds_sets (is_open_lt' _) hba),
  let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := nonempty_of_mem_sets hfa this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b this‚ü©

lemma is_glb_of_mem_nhds : ‚àÄ {s : set Œ±} {a : Œ±} {f : filter Œ±},
  a ‚àà lower_bounds s ‚Üí s ‚àà f ‚Üí f ‚äì ùìù a ‚â† ‚ä• ‚Üí is_glb s a :=
@is_lub_of_mem_nhds (order_dual Œ±) _ _ _

lemma is_lub_of_is_lub_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) (ha : is_lub s a) (hs : s.nonempty)
  (hb : tendsto f (nhds_within a s) (ùìù b)) : is_lub (f '' s) b :=
have hnbot : nhds_within a s ‚â† ‚ä•, from ha.nhds_within_ne_bot hs,
have ‚àÄa'‚ààs, ¬¨ b < f a',
  from assume a' ha' h,
  have ‚àÄ·∂† x in ùìù b, x < f a', from mem_nhds_sets (is_open_gt' _) h,
  let ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, hs‚ü© := mem_inf_sets.mp (hb this) in
  by_cases
    (assume h : a = a',
      have a ‚àà t‚ÇÅ ‚à© t‚ÇÇ, from ‚ü®mem_of_nhds ht‚ÇÅ, ht‚ÇÇ $ by rwa [h]‚ü©,
      have f a < f a', from hs this,
      lt_irrefl (f a') $ by rwa [h] at this)
    (assume h : a ‚â† a',
      have a' < a, from lt_of_le_of_ne (ha.left ha') h.symm,
      have {x | a' < x} ‚àà ùìù a, from mem_nhds_sets (is_open_lt' _) this,
      have {x | a' < x} ‚à© t‚ÇÅ ‚àà ùìù a, from inter_mem_sets this ht‚ÇÅ,
      have ({x | a' < x} ‚à© t‚ÇÅ) ‚à© s ‚àà ùìù a ‚äì ùìü s,
        from inter_mem_inf_sets this (subset.refl s),
      let ‚ü®x, ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©, hx‚ÇÉ‚ü© := nonempty_of_mem_sets hnbot this in
      have hxa' : f x < f a', from hs ‚ü®hx‚ÇÇ, ht‚ÇÇ hx‚ÇÉ‚ü©,
      have ha'x : f a' ‚â§ f x, from hf _ ha' _ hx‚ÇÉ $ le_of_lt hx‚ÇÅ,
      lt_irrefl _ (lt_of_le_of_lt ha'x hxa')),
and.intro
  (assume b' ‚ü®a', ha', h_eq‚ü©, h_eq ‚ñ∏ not_lt.1 $ this _ ha')
  (assume b' hb', le_of_tendsto hnbot hb $
      mem_inf_sets_of_right $ assume x hx, hb' $ mem_image_of_mem _ hx)

lemma is_glb_of_is_glb_of_tendsto {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤}
  (hf : ‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f x ‚â§ f y) : is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (nhds_within a s) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto (order_dual Œ±) (order_dual Œ≤) _ _ _ _ _ _ f s a b
  (Œª x hx y hy, hf y hy x hx)

lemma is_glb_of_is_lub_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_lub s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù a ‚äì ùìü s) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub_of_is_lub_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma is_lub_of_is_glb_of_tendsto : ‚àÄ {f : Œ± ‚Üí Œ≤} {s : set Œ±} {a : Œ±} {b : Œ≤},
  (‚àÄx‚ààs, ‚àÄy‚ààs, x ‚â§ y ‚Üí f y ‚â§ f x) ‚Üí is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù a ‚äì ùìü s) (ùìù b) ‚Üí is_lub (f '' s) b :=
@is_glb_of_is_glb_of_tendsto Œ± (order_dual Œ≤) _ _ _ _ _ _

lemma mem_closure_of_is_lub {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  a ‚àà closure s :=
by rw closure_eq_cluster_pts; exact ha.nhds_within_ne_bot hs

lemma mem_of_is_lub_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêclosure_eq_of_is_closed sc; exact mem_closure_of_is_lub ha hs

lemma mem_closure_of_is_glb {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  a ‚àà closure s :=
by rw closure_eq_cluster_pts; exact ha.nhds_within_ne_bot hs

lemma mem_of_is_glb_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
by rw ‚Üêclosure_eq_of_is_closed sc; exact mem_closure_of_is_glb ha hs

/-- A compact set is bounded below -/
lemma bdd_below_of_compact {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [order_closed_topology Œ±] [nonempty Œ±] {s : set Œ±} (hs : compact s) : bdd_below s :=
begin
  by_contra H,
  letI := classical.DLO Œ±,
  rcases hs.elim_finite_subcover_image (Œª x (_ : x ‚àà s), @is_open_Ioi _ _ _ _ x) _
    with ‚ü®t, st, ft, ht‚ü©,
  { refine H (ft.bdd_below.imp $ Œª C hC y hy, _),
    rcases mem_bUnion_iff.1 (ht hy) with ‚ü®x, hx, xy‚ü©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Œª x hx, mem_bUnion_iff.2 (not_imp_comm.1 _ H),
    exact Œª h, ‚ü®x, Œª y hy, le_of_not_lt (h.imp $ Œª ys, ‚ü®_, hy, ys‚ü©)‚ü© }
end

/-- A compact set is bounded above -/
lemma bdd_above_of_compact {Œ± : Type u} [topological_space Œ±] [linear_order Œ±]
  [order_topology Œ±] : Œ† [nonempty Œ±] {s : set Œ±}, compact s ‚Üí bdd_above s :=
@bdd_below_of_compact (order_dual Œ±) _ _ _

end order_topology

section linear_order

variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±]

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
lemma closure_Ioi' {a b : Œ±} (hab : a < b) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioi_subset_Ici_self is_closed_Ici },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb is_glb_Ioi ‚ü®_, hab‚ü© },
    { exact subset_closure (lt_of_le_of_ne hx (ne.symm h)) } }
end

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
lemma closure_Ioi (a : Œ±) [no_top_order Œ±] :
  closure (Ioi a) = Ici a :=
let ‚ü®b, hb‚ü© := no_top a in closure_Ioi' hb

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
lemma closure_Iio' {a b : Œ±} (hab : b < a) :
  closure (Iio a) = Iic a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Iio_subset_Iic_self is_closed_Iic },
  { assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_lub is_lub_Iio ‚ü®_, hab‚ü© },
    { apply subset_closure, by simpa [h] using lt_or_eq_of_le hx } }
end

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
lemma closure_Iio (a : Œ±) [no_bot_order Œ±] :
  closure (Iio a) = Iic a :=
let ‚ü®b, hb‚ü© := no_bot a in closure_Iio' hb

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
lemma closure_Ioo {a b : Œ±} (hab : a < b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioo_subset_Icc_self is_closed_Icc },
  { have hab' : (Ioo a b).nonempty, from nonempty_Ioo.2 hab,
    assume x hx,
    by_cases h : x = a,
    { rw h, exact mem_closure_of_is_glb (is_glb_Ioo hab) hab' },
    by_cases h' : x = b,
    { rw h', refine mem_closure_of_is_lub (is_lub_Ioo hab) hab' },
    exact subset_closure ‚ü®lt_of_le_of_ne hx.1 (ne.symm h), by simpa [h'] using lt_or_eq_of_le hx.2‚ü© }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
lemma closure_Ioc {a b : Œ±} (hab : a < b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioc_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
lemma closure_Ico {a b : Œ±} (hab : a < b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ico_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end

@[simp] lemma interior_Ici [no_bot_order Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
by rw [‚Üê compl_Iio, interior_compl, closure_Iio, compl_Iic]

@[simp] lemma interior_Iic [no_top_order Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
by rw [‚Üê compl_Ioi, interior_compl, closure_Ioi, compl_Ici]

@[simp] lemma interior_Icc [no_bot_order Œ±] [no_top_order Œ±] {a b : Œ±}:
  interior (Icc a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp] lemma interior_Ico [no_bot_order Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp] lemma interior_Ioc [no_top_order Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b :=
by rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

lemma nhds_within_Ioi_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : a ‚â§ b) :
  nhds_within b (Ioi a) ‚â† ‚ä• :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Ioi' H‚ÇÅ], exact H‚ÇÇ }

lemma nhds_within_Ioi_ne_bot [no_top_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  nhds_within b (Ioi a) ‚â† ‚ä• :=
let ‚ü®c, hc‚ü© := no_top a in nhds_within_Ioi_ne_bot' hc H

lemma nhds_within_Ioi_self_ne_bot' {a b : Œ±} (H : a < b) :
  nhds_within a (Ioi a) ‚â† ‚ä• :=
nhds_within_Ioi_ne_bot' H (le_refl a)

lemma nhds_within_Ioi_self_ne_bot [no_top_order Œ±] (a : Œ±) :
  nhds_within a (Ioi a) ‚â† ‚ä• :=
nhds_within_Ioi_ne_bot (le_refl a)

lemma nhds_within_Iio_ne_bot' {a b c : Œ±} (H‚ÇÅ : a < c) (H‚ÇÇ : b ‚â§ c) :
  nhds_within b (Iio c) ‚â† ‚ä• :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Iio' H‚ÇÅ], exact H‚ÇÇ }

lemma nhds_within_Iio_ne_bot [no_bot_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  nhds_within a (Iio b) ‚â† ‚ä• :=
let ‚ü®c, hc‚ü© := no_bot b in nhds_within_Iio_ne_bot' hc H

lemma nhds_within_Iio_self_ne_bot' {a b : Œ±} (H : a < b) :
  nhds_within b (Iio b) ‚â† ‚ä• :=
nhds_within_Iio_ne_bot' H (le_refl b)

lemma nhds_within_Iio_self_ne_bot [no_bot_order Œ±] (a : Œ±) :
  nhds_within a (Iio a) ‚â† ‚ä• :=
nhds_within_Iio_ne_bot (le_refl a)

end linear_order

section complete_linear_order

variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]

lemma Sup_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {s : set Œ±} (hs : s.nonempty) : Sup s ‚àà closure s :=
mem_closure_of_is_lub (is_lub_Sup _) hs

lemma Inf_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {s : set Œ±} (hs : s.nonempty) : Inf s ‚àà closure s :=
mem_closure_of_is_glb (is_glb_Inf _) hs

lemma Sup_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) : Sup s ‚àà s :=
mem_of_is_lub_of_is_closed (is_lub_Sup _) hs hc

lemma Inf_mem_of_is_closed {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) : Inf s ‚àà s :=
mem_of_is_glb_of_is_closed (is_glb_Inf _) hs hc

/-- A continuous monotone function sends supremum to supremum for nonempty sets. -/
lemma Sup_of_continuous' {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (hs : s.nonempty) : f (Sup s) = Sup (f '' s) :=
--This is a particular case of the more general is_lub_of_is_lub_of_tendsto
(is_lub_of_is_lub_of_tendsto (Œª x hx y hy xy, Cf xy) (is_lub_Sup _) hs $
  tendsto_le_left inf_le_left (Mf.tendsto _)).Sup_eq.symm

/-- A continuous monotone function sending bot to bot sends supremum to supremum. -/
lemma Sup_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  (fbot : f ‚ä• = ‚ä•) {s : set Œ±} : f (Sup s) = Sup (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simp [h, fbot] },
  { exact Sup_of_continuous' Mf Cf h }
end

/-- A continuous monotone function sends indexed supremum to indexed supremum. -/
lemma supr_of_continuous' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) : f (supr g) = supr (f ‚àò g) :=
by rw [supr, Sup_of_continuous' Mf Cf (range_nonempty g), ‚Üê range_comp, supr]

/-- A continuous monotone function sends indexed supremum to indexed supremum. -/
lemma supr_of_continuous {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (fbot : f ‚ä• = ‚ä•) : f (supr g) = supr (f ‚àò g) :=
by rw [supr, Sup_of_continuous Mf Cf fbot, ‚Üê range_comp, supr]

/-- A continuous monotone function sends infimum to infimum for nonempty sets. -/
lemma Inf_of_continuous' {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (hs : s.nonempty) : f (Inf s) = Inf (f '' s) :=
(is_glb_of_is_glb_of_tendsto (Œª x hx y hy xy, Cf xy) (is_glb_Inf _) hs $
  tendsto_le_left inf_le_left (Mf.tendsto _)).Inf_eq.symm

/-- A continuous monotone function sending top to top sends infimum to infimum. -/
lemma Inf_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  (ftop : f ‚ä§ = ‚ä§) {s : set Œ±} : f (Inf s) = Inf (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simpa [h] },
  { exact Inf_of_continuous' Mf Cf h }
end

/-- A continuous monotone function sends indexed infimum to indexed infimum. -/
lemma infi_of_continuous' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) : f (infi g) = infi (f ‚àò g) :=
by rw [infi, Inf_of_continuous' Mf Cf (range_nonempty g), ‚Üê range_comp, infi]

/-- A continuous monotone function sends indexed infimum to indexed infimum. -/
lemma infi_of_continuous {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (ftop : f ‚ä§ = ‚ä§) : f (infi g) = infi (f ‚àò g) :=
by rw [infi, Inf_of_continuous Mf Cf ftop, ‚Üê range_comp, infi]

end complete_linear_order


section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤] [nonempty Œ≥]

lemma cSup_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_above s) : Sup s ‚àà closure s :=
mem_closure_of_is_lub (is_lub_cSup hs B) hs

lemma cInf_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_below s) : Inf s ‚àà closure s :=
mem_closure_of_is_glb (is_glb_cInf hs B) hs

lemma cSup_mem_of_is_closed {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) (B : bdd_above s) :
  Sup s ‚àà s :=
mem_of_is_lub_of_is_closed (is_lub_cSup hs B) hs hc

lemma cInf_mem_of_is_closed {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) (B : bdd_below s) :
  Inf s ‚àà s :=
mem_of_is_glb_of_is_closed (is_glb_cInf hs B) hs hc

/-- A continuous monotone function sends supremum to supremum in conditionally complete
linear order, under a boundedness assumption. -/
lemma cSup_of_cSup_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (ne : s.nonempty) (H : bdd_above s) : f (Sup s) = Sup (f '' s) :=
begin
  refine ((is_lub_cSup (ne.image f) (Cf.map_bdd_above H)).unique _).symm,
  refine is_lub_of_is_lub_of_tendsto (Œªx hx y hy xy, Cf xy) (is_lub_cSup ne H) ne _,
  exact tendsto_le_left inf_le_left (Mf.tendsto _)
end

/-- A continuous monotone function sends indexed supremum to indexed supremum in conditionally
complete linear order, under a boundedness assumption. -/
lemma csupr_of_csupr_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (H : bdd_above (range g)) : f (supr g) = supr (f ‚àò g) :=
by rw [supr, cSup_of_cSup_of_monotone_of_continuous Mf Cf (range_nonempty _) H, ‚Üê range_comp, supr]

/-- A continuous monotone function sends infimum to infimum in conditionally complete
linear order, under a boundedness assumption. -/
lemma cInf_of_cInf_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} (Mf : continuous f) (Cf : monotone f)
  {s : set Œ±} (ne : s.nonempty) (H : bdd_below s) : f (Inf s) = Inf (f '' s) :=
begin
  refine ((is_glb_cInf (ne.image _) (Cf.map_bdd_below H)).unique _).symm,
  refine is_glb_of_is_glb_of_tendsto (Œªx hx y hy xy, Cf xy) (is_glb_cInf ne H) ne _,
  exact tendsto_le_left inf_le_left (Mf.tendsto _)
end

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
lemma cinfi_of_cinfi_of_monotone_of_continuous {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Mf : continuous f) (Cf : monotone f) (H : bdd_below (range g)) : f (infi g) = infi (f ‚àò g) :=
by rw [infi, cInf_of_cInf_of_monotone_of_continuous Mf Cf (range_nonempty _) H, ‚Üê range_comp, infi]

/-- A bounded connected subset of a conditionally complete linear order includes the open interval
`(Inf s, Sup s)`. -/
lemma is_connected.Ioo_cInf_cSup_subset {s : set Œ±} (hs : is_connected s) (hb : bdd_below s)
  (ha : bdd_above s) :
  Ioo (Inf s) (Sup s) ‚äÜ s :=
Œª x hx, let ‚ü®y, ys, hy‚ü© := (is_glb_lt_iff (is_glb_cInf hs.nonempty hb)).1 hx.1 in
let ‚ü®z, zs, hz‚ü© := (lt_is_lub_iff (is_lub_cSup hs.nonempty ha)).1 hx.2 in
hs.is_preconnected.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©

lemma is_preconnected.Ioi_cInf_subset {s : set Œ±} (hs : is_preconnected s) (hb : bdd_below s)
  (ha : ¬¨bdd_above s) :
  Ioi (Inf s) ‚äÜ s :=
begin
  have sne : s.nonempty := @nonempty_of_not_bdd_above Œ± _ s ‚ü®Inf ‚àÖ‚ü© ha,
  intros x hx,
  obtain ‚ü®y, ys, hy‚ü© : ‚àÉ y ‚àà s, y < x := (is_glb_lt_iff (is_glb_cInf sne hb)).1 hx,
  obtain ‚ü®z, zs, hz‚ü© : ‚àÉ z ‚àà s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs ‚ü®le_of_lt hy, le_of_lt hz‚ü©
end

lemma is_preconnected.Iio_cSup_subset {s : set Œ±} (hs : is_preconnected s) (hb : ¬¨bdd_below s)
  (ha : bdd_above s) :
  Iio (Sup s) ‚äÜ s :=
@is_preconnected.Ioi_cInf_subset (order_dual Œ±) _ _ _ s hs ha hb

/-- A preconnected set in a conditionally complete linear order is either one of the intervals
`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +‚àû)`,
`(Inf s, +‚àû)`, `(-‚àû, Sup s]`, `(-‚àû, Sup s)`, `(-‚àû, +‚àû)`, or `‚àÖ`. The converse statement requires
`Œ±` to be densely ordererd. -/
lemma is_preconnected.mem_intervals {s : set Œ±} (hs : is_preconnected s) :
  s ‚àà ({Icc (Inf s) (Sup s), Ico (Inf s) (Sup s), Ioc (Inf s) (Sup s), Ioo (Inf s) (Sup s),
    Ici (Inf s), Ioi (Inf s), Iic (Sup s), Iio (Sup s), univ, ‚àÖ} : set (set Œ±)) :=
begin
  rcases s.eq_empty_or_nonempty with rfl|hne,
  { apply_rules [or.inr, mem_singleton] },
  have hs' : is_connected s := ‚ü®hne, hs‚ü©,
  by_cases hb : bdd_below s; by_cases ha : bdd_above s,
  { rcases mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset (hs'.Ioo_cInf_cSup_subset hb ha)
      (Œª x hx, ‚ü®cInf_le hb hx, le_cSup ha hx‚ü©) with hs|hs|hs|hs,
    { exact (or.inl hs) },
    { exact (or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inr $ or.inl hs) } },
  { refine (or.inr $ or.inr $ or.inr $ or.inr _),
    cases mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_cInf_subset hb ha) (Œª x hx, cInf_le hb hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 6 { apply or.inr },
    cases mem_Iic_Iio_of_subset_of_subset (hs.Iio_cSup_subset hb ha) (Œª x hx, le_cSup ha hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 8 { apply or.inr },
    exact or.inl (hs.eq_univ_of_unbounded hb ha) }
end

/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,
`Iic`, `Iio`, or `univ`, or `‚àÖ`. The converse statement requires `Œ±` to be densely ordererd. Though
one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve
readability. -/
lemma set_of_is_preconnected_subset_of_ordered :
  {s : set Œ± | is_preconnected s} ‚äÜ
    -- bounded intervals
    (range (uncurry Icc) ‚à™ range (uncurry Ico) ‚à™ range (uncurry Ioc) ‚à™ range (uncurry Ioo)) ‚à™
    -- unbounded intervals and `univ`
    (range Ici ‚à™ range Ioi ‚à™ range Iic ‚à™ range Iio ‚à™ {univ, ‚àÖ}) :=
begin
  intros s hs,
  rcases hs.mem_intervals with hs|hs|hs|hs|hs|hs|hs|hs|hs|hs,
  { exact (or.inl $ or.inl $ or.inl $ or.inl ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inl $ or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inl $ or.inr ‚ü®(Inf s, Sup s), hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inl ‚ü®Inf s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inr ‚ü®Inf s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $ or.inl  $ or.inr ‚ü®Sup s, hs.symm‚ü©) },
  { exact (or.inr $ or.inl $  or.inr ‚ü®Sup s, hs.symm‚ü©) },
  { exact (or.inr $ or.inr $ or.inl hs) },
  { exact (or.inr $ or.inr $ or.inr hs) }
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and the set `s ‚à© [a, b)` has no maximal point, then `b ‚àà s`. -/
lemma is_closed.mem_of_ge_of_forall_exists_gt {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© Icc a b))
  (ha : a ‚àà s) (hab : a ‚â§ b) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, (s ‚à© Ioc x b).nonempty) :
  b ‚àà s :=
begin
  let S := s ‚à© Icc a b,
  replace ha : a ‚àà S, from ‚ü®ha, left_mem_Icc.2 hab‚ü©,
  have Sbd : bdd_above S, from ‚ü®b, Œª z hz, hz.2.2‚ü©,
  let c := Sup (s ‚à© Icc a b),
  have c_mem : c ‚àà S, from cSup_mem_of_is_closed ‚ü®_, ha‚ü© hs Sbd,
  have c_le : c ‚â§ b, from cSup_le ‚ü®_, ha‚ü© (Œª x hx, hx.2.2),
  cases eq_or_lt_of_le c_le with hc hc, from hc ‚ñ∏ c_mem.1,
  exfalso,
  rcases hgt c ‚ü®c_mem.1, c_mem.2.1, hc‚ü© with ‚ü®x, xs, cx, xb‚ü©,
  exact not_lt_of_le (le_cSup Sbd ‚ü®xs, le_trans (le_cSup Sbd ha) (le_of_lt cx), xb‚ü©) cx
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `a ‚â§ x < y ‚â§ b`, `x ‚àà s`, the set `s ‚à© (x, y]`
is not empty, then `[a, b] ‚äÜ s`. -/
lemma is_closed.Icc_subset_of_forall_exists_gt {a b : Œ±} {s : set Œ±} (hs : is_closed (s ‚à© Icc a b))
  (ha : a ‚àà s) (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, ‚àÄ y ‚àà Ioi x,  (s ‚à© Ioc x y).nonempty) :
  Icc a b ‚äÜ s :=
begin
  assume y hy,
  have : is_closed (s ‚à© Icc a y),
  { suffices : s ‚à© Icc a y = s ‚à© Icc a b ‚à© Icc a y,
    { rw this, exact is_closed_inter hs is_closed_Icc },
    rw [inter_assoc],
    congr,
    exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm },
  exact is_closed.mem_of_ge_of_forall_exists_gt this ha hy.1
    (Œª x hx, hgt x ‚ü®hx.1, Ico_subset_Ico_right hy.2 hx.2‚ü© y hx.2.2)
end
section densely_ordered

variables [densely_ordered Œ±] {a b : Œ±}

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `x ‚àà s ‚à© [a, b)` the set `s` includes some open
neighborhood of `x` within `(x, +‚àû)`, then `[a, b] ‚äÜ s`. -/
lemma is_closed.Icc_subset_of_forall_mem_nhds_within {a b : Œ±} {s : set Œ±}
  (hs : is_closed (s ‚à© Icc a b)) (ha : a ‚àà s)
  (hgt : ‚àÄ x ‚àà s ‚à© Ico a b, s ‚àà nhds_within x (Ioi x)) :
  Icc a b ‚äÜ s :=
begin
  apply hs.Icc_subset_of_forall_exists_gt ha,
  rintros x ‚ü®hxs, hxab‚ü© y hyxb,
  have : s ‚à© Ioc x y ‚àà nhds_within x (Ioi x),
    from inter_mem_sets (hgt x ‚ü®hxs, hxab‚ü©) (Ioc_mem_nhds_within_Ioi ‚ü®le_refl _, hyxb‚ü©),
  exact nonempty_of_mem_sets (nhds_within_Ioi_self_ne_bot' hxab.2) this
end

/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/
lemma is_preconnected_Icc : is_preconnected (Icc a b) :=
is_preconnected_closed_iff.2
begin
  rintros s t hs ht hab ‚ü®x, hx‚ü© ‚ü®y, hy‚ü©,
  wlog hxy : x ‚â§ y := le_total x y using [x y s t, y x t s],
  have xyab : Icc x y ‚äÜ Icc a b := Icc_subset_Icc hx.1.1 hy.1.2,
  by_contradiction hst,
  suffices : Icc x y ‚äÜ s,
    from hst ‚ü®y, xyab $ right_mem_Icc.2 hxy, this $ right_mem_Icc.2 hxy, hy.2‚ü©,
  apply (is_closed_inter hs is_closed_Icc).Icc_subset_of_forall_mem_nhds_within hx.2,
  rintros z ‚ü®zs, hz‚ü©,
  have zt : z ‚àà t·∂ú, from Œª zt, hst ‚ü®z, xyab $ Ico_subset_Icc_self hz, zs, zt‚ü©,
  have : t·∂ú ‚à© Ioc z y ‚àà nhds_within z (Ioi z),
  { rw [‚Üê nhds_within_Ioc_eq_nhds_within_Ioi hz.2],
    exact mem_nhds_within.2 ‚ü®t·∂ú, ht, zt, subset.refl _‚ü©},
  apply mem_sets_of_superset this,
  have : Ioc z y ‚äÜ s ‚à™ t, from Œª w hw, hab (xyab ‚ü®le_trans hz.1 (le_of_lt hw.1), hw.2‚ü©),
  exact Œª w ‚ü®wt, wzy‚ü©, (this wzy).elim id (Œª h, (wt h).elim)
end

lemma is_preconnected_iff_forall_Icc_subset {s : set Œ±} :
  is_preconnected s ‚Üî ‚àÄ x y ‚àà s, x ‚â§ y ‚Üí Icc x y ‚äÜ s :=
‚ü®Œª h x y hx hy hxy, h.Icc_subset hx hy, Œª h, is_preconnected_of_forall_pair $ Œª x y hx hy,
  ‚ü®Icc (min x y) (max x y), h (min x y) (max x y)
    ((min_choice x y).elim (Œª h', by rwa h') (Œª h', by rwa h'))
    ((max_choice x y).elim (Œª h', by rwa h') (Œª h', by rwa h')) min_le_max,
    ‚ü®min_le_left x y, le_max_left x y‚ü©, ‚ü®min_le_right x y, le_max_right x y‚ü©, is_preconnected_Icc‚ü©‚ü©

lemma is_preconnected_Ici : is_preconnected (Ici a) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Ici_iff hxy).2 hx

lemma is_preconnected_Iic : is_preconnected (Iic a) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Iic_iff hxy).2 hy

lemma is_preconnected_Iio : is_preconnected (Iio a) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Iio_iff hxy).2 hy

lemma is_preconnected_Ioi : is_preconnected (Ioi a) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Ioi_iff hxy).2 hx

lemma is_preconnected_Ioo : is_preconnected (Ioo a b) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Ioo_iff hxy).2 ‚ü®hx.1, hy.2‚ü©

lemma is_preconnected_Ioc : is_preconnected (Ioc a b) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Ioc_iff hxy).2 ‚ü®hx.1, hy.2‚ü©

lemma is_preconnected_Ico : is_preconnected (Ico a b) :=
is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, (Icc_subset_Ico_iff hxy).2 ‚ü®hx.1, hy.2‚ü©

@[priority 100]
instance ordered_connected_space : preconnected_space Œ± :=
‚ü®is_preconnected_iff_forall_Icc_subset.2 $ Œª x y hx hy hxy, subset_univ _‚ü©

/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly
the set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-‚àû, +‚àû)`,
or `‚àÖ`. Though one can represent `‚àÖ` as `(Inf s, Inf s)`, we include it into the list of
possible cases to improve readability. -/
lemma set_of_is_preconnected_eq_of_ordered :
  {s : set Œ± | is_preconnected s} =
    -- bounded intervals
    (range (uncurry Icc) ‚à™ range (uncurry Ico) ‚à™ range (uncurry Ioc) ‚à™ range (uncurry Ioo)) ‚à™
    -- unbounded intervals and `univ`
    (range Ici ‚à™ range Ioi ‚à™ range Iic ‚à™ range Iio ‚à™ {univ, ‚àÖ}) :=
begin
  refine subset.antisymm set_of_is_preconnected_subset_of_ordered _,
  simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp_distrib, forall_and_distrib,
    mem_union, mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true,
    is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc,
    is_preconnected_Ioo, is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici,
    is_preconnected_Iic, is_preconnected_univ, is_preconnected_empty],
end

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ‚â§ t ‚â§ f b`.-/
lemma intermediate_value_Icc {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f (Icc a b)) :
  Icc (f a) (f b) ‚äÜ f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf

/--Intermediate Value Theorem for continuous functions on closed intervals, case `f a ‚â• t ‚â• f b`.-/
lemma intermediate_value_Icc' {a b : Œ±} (hab : a ‚â§ b) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f (Icc a b)) :
  Icc (f b) (f a) ‚äÜ f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf

end densely_ordered

/-- The extreme value theorem: a continuous function realizes its minimum on a compact set -/
lemma compact.exists_forall_le {Œ± : Type u} [topological_space Œ±]
  {s : set Œ±} (hs : compact s) (ne_s : s.nonempty) {f : Œ± ‚Üí Œ≤} (hf : continuous_on f s) :
  ‚àÉx‚ààs, ‚àÄy‚ààs, f x ‚â§ f y :=
begin
  have C : compact (f '' s) := hs.image_of_continuous_on hf,
  haveI := has_Inf_to_nonempty Œ≤,
  have B : bdd_below (f '' s) := bdd_below_of_compact C,
  have : Inf (f '' s) ‚àà f '' s :=
    cInf_mem_of_is_closed (ne_s.image _) (closed_of_compact _ C) B,
  rcases (mem_image _ _ _).1 this with ‚ü®x, xs, hx‚ü©,
  exact ‚ü®x, xs, Œª y hy, hx.symm ‚ñ∏ cInf_le B ‚ü®_, hy, rfl‚ü©‚ü©
end

/-- The extreme value theorem: a continuous function realizes its maximum on a compact set -/
lemma compact.exists_forall_ge {Œ± : Type u} [topological_space Œ±]:
  ‚àÄ {s : set Œ±}, compact s ‚Üí s.nonempty ‚Üí ‚àÄ {f : Œ± ‚Üí Œ≤}, continuous_on f s ‚Üí
  ‚àÉx‚ààs, ‚àÄy‚ààs, f y ‚â§ f x :=
@compact.exists_forall_le (order_dual Œ≤) _ _ _ _ _

end conditionally_complete_linear_order

section liminf_limsup

section order_closed_topology
variables [semilattice_sup Œ±] [topological_space Œ±] [order_topology Œ±]

lemma is_bounded_le_nhds (a : Œ±) : (ùìù a).is_bounded (‚â§) :=
match forall_le_or_exists_lt_sup a with
| or.inl h := ‚ü®a, eventually_of_forall _ h‚ü©
| or.inr ‚ü®b, hb‚ü© := ‚ü®b, ge_mem_nhds hb‚ü©
end

lemma is_bounded_under_le_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â§) u :=
is_bounded_of_le h (is_bounded_le_nhds a)

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma is_cobounded_ge_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â•) :=
is_cobounded_of_is_bounded nhds_ne_bot (is_bounded_le_nhds a)

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma is_cobounded_under_ge_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hf : f ‚â† ‚ä•) (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â•) u :=
is_cobounded_of_is_bounded (map_ne_bot hf) (is_bounded_under_le_of_tendsto h)

end order_closed_topology

section order_closed_topology
variables [semilattice_inf Œ±] [topological_space Œ±] [order_topology Œ±]

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma is_bounded_ge_nhds (a : Œ±) : (ùìù a).is_bounded (‚â•) :=
match forall_le_or_exists_lt_inf a with
| or.inl h := ‚ü®a, eventually_of_forall _ h‚ü©
| or.inr ‚ü®b, hb‚ü© := ‚ü®b, le_mem_nhds hb‚ü©
end

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma is_bounded_under_ge_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : tendsto u f (ùìù a)) : f.is_bounded_under (‚â•) u :=
is_bounded_of_le h (is_bounded_ge_nhds a)

lemma is_cobounded_le_nhds (a : Œ±) : (ùìù a).is_cobounded (‚â§) :=
is_cobounded_of_is_bounded nhds_ne_bot (is_bounded_ge_nhds a)

lemma is_cobounded_under_le_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (hf : f ‚â† ‚ä•) (h : tendsto u f (ùìù a)) : f.is_cobounded_under (‚â§) u :=
is_cobounded_of_is_bounded (map_ne_bot hf) (is_bounded_under_ge_of_tendsto h)

end order_closed_topology

section conditionally_complete_linear_order
variables [conditionally_complete_linear_order Œ±]

theorem lt_mem_sets_of_Limsup_lt {f : filter Œ±} {b} (h : f.is_bounded (‚â§)) (l : f.Limsup < b) :
  ‚àÄ·∂† a in f, a < b :=
let ‚ü®c, (h : ‚àÄ·∂† a in f, a ‚â§ c), hcb‚ü© := exists_lt_of_cInf_lt h l in
mem_sets_of_superset h $ assume a hac, lt_of_le_of_lt hac hcb

@[nolint ge_or_gt] -- see Note [nolint_ge]
theorem gt_mem_sets_of_Liminf_gt : ‚àÄ {f : filter Œ±} {b}, f.is_bounded (‚â•) ‚Üí f.Liminf > b ‚Üí
  ‚àÄ·∂† a in f, a > b :=
@lt_mem_sets_of_Limsup_lt (order_dual Œ±) _

variables [topological_space Œ±] [order_topology Œ±]

/-- If the liminf and the limsup of a filter coincide, then this filter converges to
their common value, at least if the filter is eventually bounded above and below. -/
@[nolint ge_or_gt] -- see Note [nolint_ge]
theorem le_nhds_of_Limsup_eq_Liminf {f : filter Œ±} {a : Œ±}
  (hl : f.is_bounded (‚â§)) (hg : f.is_bounded (‚â•)) (hs : f.Limsup = a) (hi : f.Liminf = a) :
  f ‚â§ ùìù a :=
tendsto_order.2 $ and.intro
  (assume b hb, gt_mem_sets_of_Liminf_gt hg $ hi.symm ‚ñ∏ hb)
  (assume b hb, lt_mem_sets_of_Limsup_lt hl $ hs.symm ‚ñ∏ hb)

theorem Limsup_nhds (a : Œ±) : Limsup (ùìù a) = a :=
cInf_intro (is_bounded_le_nhds a)
  (assume a' (h : {n : Œ± | n ‚â§ a'} ‚àà ùìù a), show a ‚â§ a', from @mem_of_nhds Œ± _ a _ h)
  (assume b (hba : a < b), show ‚àÉc (h : {n : Œ± | n ‚â§ c} ‚àà ùìù a), c < b, from
    match dense_or_discrete a b with
    | or.inl ‚ü®c, hac, hcb‚ü© := ‚ü®c, ge_mem_nhds hac, hcb‚ü©
    | or.inr ‚ü®_, h‚ü©        := ‚ü®a, (ùìù a).sets_of_superset (gt_mem_nhds hba) h, hba‚ü©
    end)

theorem Liminf_nhds : ‚àÄ (a : Œ±), Liminf (ùìù a) = a :=
@Limsup_nhds (order_dual Œ±) _ _ _

/-- If a filter is converging, its limsup coincides with its limit. -/
theorem Liminf_eq_of_le_nhds {f : filter Œ±} {a : Œ±} (hf : f ‚â† ‚ä•) (h : f ‚â§ ùìù a) : f.Liminf = a :=
have hb_ge : is_bounded (‚â•) f, from is_bounded_of_le h (is_bounded_ge_nhds a),
have hb_le : is_bounded (‚â§) f, from is_bounded_of_le h (is_bounded_le_nhds a),
le_antisymm
  (calc f.Liminf ‚â§ f.Limsup : Liminf_le_Limsup hf hb_le hb_ge
    ... ‚â§ (ùìù a).Limsup :
      Limsup_le_Limsup_of_le h (is_cobounded_of_is_bounded hf hb_ge) (is_bounded_le_nhds a)
    ... = a : Limsup_nhds a)
  (calc a = (ùìù a).Liminf : (Liminf_nhds a).symm
    ... ‚â§ f.Liminf :
      Liminf_le_Liminf_of_le h (is_bounded_ge_nhds a) (is_cobounded_of_is_bounded hf hb_le))

/-- If a filter is converging, its liminf coincides with its limit. -/
theorem Limsup_eq_of_le_nhds : ‚àÄ {f : filter Œ±} {a : Œ±}, f ‚â† ‚ä• ‚Üí f ‚â§ ùìù a ‚Üí f.Limsup = a :=
@Liminf_eq_of_le_nhds (order_dual Œ±) _ _ _

end conditionally_complete_linear_order

section complete_linear_order
variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
-- In complete_linear_order, the above theorems take a simpler form

/-- If the liminf and the limsup of a function coincide, then the limit of the function
exists and has the same value -/
theorem tendsto_of_liminf_eq_limsup {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±}
  (h : liminf f u = a ‚àß limsup f u = a) : tendsto u f (ùìù a) :=
  le_nhds_of_Limsup_eq_Liminf is_bounded_le_of_top is_bounded_ge_of_bot h.2 h.1

/-- If a function has a limit, then its limsup coincides with its limit-/
theorem limsup_eq_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : f ‚â† ‚ä•)
  (h : tendsto u f (ùìù a)) : limsup f u = a :=
  Limsup_eq_of_le_nhds (map_ne_bot hf) h

/-- If a function has a limit, then its liminf coincides with its limit-/
theorem liminf_eq_of_tendsto {f : filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} (hf : f ‚â† ‚ä•)
  (h : tendsto u f (ùìù a)) : liminf f u = a :=
  Liminf_eq_of_le_nhds (map_ne_bot hf) h

end complete_linear_order

end liminf_limsup

end order_topology

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma order_topology_of_nhds_abs
  {Œ± : Type*} [decidable_linear_ordered_add_comm_group Œ±] [topological_space Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, ùìü {b | abs (a - b) < r})) : order_topology Œ± :=
order_topology.mk $ eq_of_nhds_eq_nhds $ assume a:Œ±, le_antisymm_iff.mpr
begin
  simp [infi_and, topological_space.nhds_generate_from,
        h_nhds, le_infi_iff, -le_principal_iff, and_comm],
  refine ‚ü®Œª s ha b hs, _, Œª r hr, _‚ü©,
  { rcases hs with rfl | rfl,
    { refine infi_le_of_le (a - b)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < a - b), _),
      have : a - c < a - b := lt_of_le_of_lt (le_abs_self _) hc,
      exact lt_of_neg_lt_neg (lt_of_add_lt_add_left this) },
    { refine infi_le_of_le (b - a)
        (infi_le_of_le (lt_sub_left_of_add_lt $ by simpa using ha) $
          principal_mono.mpr $ assume c (hc : abs (a - c) < b - a), _),
      have : abs (c - a) < b - a, {rw abs_sub; simpa using hc},
      have : c - a < b - a := lt_of_le_of_lt (le_abs_self _) this,
      exact lt_of_add_lt_add_right this } },
  { have h : {b | abs (a - b) < r} = {b | a - r < b} ‚à© {b | b < a + r},
      from set.ext (assume b,
        by simp [abs_lt, sub_lt, lt_sub_iff_add_lt, sub_lt_iff_lt_add']; cc),
    rw [h, ‚Üê inf_principal],
    apply le_inf _ _,
    { exact infi_le_of_le {b : Œ± | a - r < b} (infi_le_of_le (sub_lt_self a hr) $
        infi_le_of_le (a - r) $ infi_le _ (or.inl rfl)) },
    { exact infi_le_of_le {b : Œ± | b < a + r} (infi_le_of_le (lt_add_of_pos_right _ hr) $
        infi_le_of_le (a + r) $ infi_le _ (or.inr rfl)) } }
end

lemma tendsto_at_top_supr_nat [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : monotone f) : tendsto f at_top (ùìù (‚®Üi, f i)) :=
tendsto_order.2 $ and.intro
  (assume a ha, let ‚ü®n, hn‚ü© := lt_supr_iff.1 ha in
    mem_at_top_sets.2 ‚ü®n, assume i hi, lt_of_lt_of_le hn (hf hi)‚ü©)
  (assume a ha, univ_mem_sets' (assume n, lt_of_le_of_lt (le_supr _ n) ha))

lemma tendsto_at_top_infi_nat [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  (f : ‚Ñï ‚Üí Œ±) (hf : ‚àÄ{n m}, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù (‚®Öi, f i)) :=
@tendsto_at_top_supr_nat (order_dual Œ±) _ _ _ _ @hf

lemma supr_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : monotone f) : tendsto f at_top (ùìù a) ‚Üí supr f = a :=
tendsto_nhds_unique at_top_ne_bot (tendsto_at_top_supr_nat f hf)

lemma infi_eq_of_tendsto {Œ±} [topological_space Œ±] [complete_linear_order Œ±] [order_topology Œ±]
  {f : ‚Ñï ‚Üí Œ±} {a : Œ±} (hf : ‚àÄn m, n ‚â§ m ‚Üí f m ‚â§ f n) : tendsto f at_top (ùìù a) ‚Üí infi f = a :=
tendsto_nhds_unique at_top_ne_bot (tendsto_at_top_infi_nat f hf)

/-- $\lim_{x\to+\infty}|x|=+\infty$ -/
lemma tendsto_abs_at_top_at_top [decidable_linear_ordered_add_comm_group Œ±] :
  tendsto (abs : Œ± ‚Üí Œ±) at_top at_top :=
tendsto_at_top_mono _ (Œª n, le_abs_self _) tendsto_id

local notation `|` x `|` := abs x

@[nolint ge_or_gt] -- see Note [nolint_ge]
lemma decidable_linear_ordered_add_comm_group.tendsto_nhds
  [decidable_linear_ordered_add_comm_group Œ±] [topological_space Œ±] [order_topology Œ±] {Œ≤ : Type*}
  (f : Œ≤ ‚Üí Œ±) (x : filter Œ≤) (a : Œ±) :
  filter.tendsto f x (nhds a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ :=
begin
  rw (show _, from @tendsto_order Œ±), -- does not work without `show` for some reason
  split,
  { rintros ‚ü®hyp_lt_a, hyp_gt_a‚ü© Œµ Œµ_pos,
    suffices : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff],
    have set1 : {b : Œ≤ | a - f b < Œµ} ‚àà x,
    { have : {b : Œ≤ | a - Œµ < f b} ‚àà x, from hyp_lt_a (a - Œµ) (sub_lt_self a Œµ_pos),
      have : ‚àÄ b, a - f b < Œµ ‚Üî a - Œµ < f b, by { intro _, exact sub_lt },
      simpa only [this] },
    have set2 : {b : Œ≤ | f b - a < Œµ} ‚àà x,
    { have : {b : Œ≤ | a + Œµ > f b} ‚àà x, from hyp_gt_a (a + Œµ) (lt_add_of_pos_right a Œµ_pos),
      have : ‚àÄ b, f b - a < Œµ ‚Üî a + Œµ > f b, by { intro _, exact sub_lt_iff_lt_add' },
      simpa only [this] },
    exact (x.inter_sets set2 set1) },
  { assume hyp_Œµ_pos,
    split,
    { assume a' a'_lt_a,
      let Œµ := a - a',
      have : {b : Œ≤ | |f b - a| < Œµ} ‚àà x, from hyp_Œµ_pos Œµ (sub_pos.elim_right a'_lt_a),
      have : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff] using this,
      have : {b : Œ≤ | a - f b < Œµ} ‚àà x, from x.sets_of_superset this (set.inter_subset_right _ _),
      have : ‚àÄ b, a' < f b ‚Üî a - f b < Œµ, by {intro b, rw [sub_lt, sub_sub_self] },
      simpa only [this] },
    { assume a' a'_gt_a,
      let Œµ := a' - a,
      have : {b : Œ≤ | |f b - a| < Œµ} ‚àà x, from hyp_Œµ_pos Œµ (sub_pos.elim_right a'_gt_a),
      have : {b : Œ≤ | f b - a < Œµ ‚àß a - f b < Œµ} ‚àà x, by simpa only [abs_sub_lt_iff] using this,
      have : {b : Œ≤ | f b - a < Œµ} ‚àà x, from x.sets_of_superset this (set.inter_subset_left _ _),
      have : ‚àÄ b, f b < a' ‚Üî f b - a < Œµ, by { intro b, simp [lt_sub_iff_add_lt] },
      simpa only [this] }}
end
