/-
Copyright (c) 2017 Johannes HÃ¶lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes HÃ¶lzl, Mario Carneiro, Yury Kudryashov
-/
import tactic.tfae
import algebra.group_with_zero.power
import data.set.intervals.pi
import topology.algebra.group
import order.filter.interval

/-!
# Theory of topology on ordered spaces

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-âˆ, a)` and `(b, +âˆ)`). We define it as `preorder.topology Î±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Î±`). Instead,
we introduce a class `order_topology Î±` (which is a `Prop`, also known as a mixin) saying that on
the type `Î±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Î±` saying that the set of points
`(x, y)` with `x â‰¤ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x â‰¤ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x â‰¤ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z âˆˆ (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z âˆˆ [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x â‰¤ g x`, then `a â‰¤ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x â‰¤ b`
  (resp., `b â‰¤ f x`), then `a â‰¤ b` (resp., `b â‰¤ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x â‰¤ f x â‰¤ h x`, then `f` converges to `a`.

### Connected sets and Intermediate Value Theorem

* `is_preconnected_I??` : all intervals `I??` are preconnected,
* `is_preconnected.intermediate_value`, `intermediate_value_univ` : Intermediate Value Theorem for
  connected sets and connected spaces, respectively;
* `intermediate_value_Icc`, `intermediate_value_Icc'`: Intermediate Value Theorem for functions
  on closed intervals.

### Miscellaneous facts

* `is_compact.exists_forall_le`, `is_compact.exists_forall_ge` : extreme value theorem, a continuous
  function on a compact set takes its minimum and maximum values.
* `is_closed.Icc_subset_of_forall_mem_nhds_within` : â€œContinuous inductionâ€ principle;
  if `s âˆ© [a, b]` is closed, `a âˆˆ s`, and for each `x âˆˆ [a, b) âˆ© s` some of its right neighborhoods
  is included `s`, then `[a, b] âŠ† s`.
* `is_closed.Icc_subset_of_forall_exists_gt`, `is_closed.mem_of_ge_of_forall_exists_gt` : two
  other versions of the â€œcontinuous inductionâ€ principle.

## Implementation

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `â„•` or `â„¤`, or `â„` that could inherit a topology as the completion of `â„š`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Î±` though, that can be registered as an instance when necessary, or
for specific types.
-/

open classical set filter topological_space
open function
open_locale topological_space classical filter

universes u v w
variables {Î± : Type u} {Î² : Type v} {Î³ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x â‰¤ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class order_closed_topology (Î± : Type*) [topological_space Î±] [preorder Î±] : Prop :=
(is_closed_le' : is_closed {p:Î±Ã—Î± | p.1 â‰¤ p.2})

instance : Î  [topological_space Î±], topological_space (order_dual Î±) := id

@[to_additive]
instance [topological_space Î±] [has_mul Î±] [h : has_continuous_mul Î±] :
  has_continuous_mul (order_dual Î±) := h

section order_closed_topology

section preorder
variables [topological_space Î±] [preorder Î±] [t : order_closed_topology Î±]
include t

lemma is_closed_le_prod : is_closed {p : Î± Ã— Î± | p.1 â‰¤ p.2} :=
t.is_closed_le'

lemma is_closed_le [topological_space Î²] {f g : Î² â†’ Î±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b â‰¤ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod

lemma is_closed_le' (a : Î±) : is_closed {b | b â‰¤ a} :=
is_closed_le continuous_id continuous_const

lemma is_closed_Iic {a : Î±} : is_closed (Iic a) :=
is_closed_le' a

lemma is_closed_ge' (a : Î±) : is_closed {b | a â‰¤ b} :=
is_closed_le continuous_const continuous_id

lemma is_closed_Ici {a : Î±} : is_closed (Ici a) :=
is_closed_ge' a

instance : order_closed_topology (order_dual Î±) :=
âŸ¨(@order_closed_topology.is_closed_le' Î± _ _ _).preimage continuous_swapâŸ©

lemma is_closed_Icc {a b : Î±} : is_closed (Icc a b) :=
is_closed.inter is_closed_Ici is_closed_Iic

@[simp] lemma closure_Icc (a b : Î±) : closure (Icc a b) = Icc a b :=
is_closed_Icc.closure_eq

@[simp] lemma closure_Iic (a : Î±) : closure (Iic a) = Iic a :=
is_closed_Iic.closure_eq

@[simp] lemma closure_Ici (a : Î±) : closure (Ici a) = Ici a :=
is_closed_Ici.closure_eq

lemma le_of_tendsto_of_tendsto {f g : Î² â†’ Î±} {b : filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b]
  (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) (h : f â‰¤á¶ [b] g) :
  aâ‚ â‰¤ aâ‚‚ :=
have tendsto (Î»b, (f b, g b)) b (ğ“ (aâ‚, aâ‚‚)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (aâ‚, aâ‚‚) âˆˆ {p:Î±Ã—Î± | p.1 â‰¤ p.2},
  from t.is_closed_le'.mem_of_tendsto this h

lemma le_of_tendsto_of_tendsto' {f g : Î² â†’ Î±} {b : filter Î²} {aâ‚ aâ‚‚ : Î±} [ne_bot b]
  (hf : tendsto f b (ğ“ aâ‚)) (hg : tendsto g b (ğ“ aâ‚‚)) (h : âˆ€ x, f x â‰¤ g x) :
  aâ‚ â‰¤ aâ‚‚ :=
le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

lemma le_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : filter Î²}
  [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€á¶  c in x, f c â‰¤ b) : a â‰¤ b :=
le_of_tendsto_of_tendsto lim tendsto_const_nhds h

lemma le_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : filter Î²}
  [ne_bot x] (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, f c â‰¤ b) : a â‰¤ b :=
le_of_tendsto lim (eventually_of_forall h)

lemma ge_of_tendsto {f : Î² â†’ Î±} {a b : Î±} {x : filter Î²} [ne_bot x]
  (lim : tendsto f x (ğ“ a)) (h : âˆ€á¶  c in x, b â‰¤ f c) : b â‰¤ a :=
le_of_tendsto_of_tendsto tendsto_const_nhds lim h

lemma ge_of_tendsto' {f : Î² â†’ Î±} {a b : Î±} {x : filter Î²} [ne_bot x]
  (lim : tendsto f x (ğ“ a)) (h : âˆ€ c, b â‰¤ f c) : b â‰¤ a :=
ge_of_tendsto lim (eventually_of_forall h)

@[simp]
lemma closure_le_eq [topological_space Î²] {f g : Î² â†’ Î±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b â‰¤ g b} = {b | f b â‰¤ g b} :=
(is_closed_le hf hg).closure_eq

lemma closure_lt_subset_le [topological_space Î²] {f g : Î² â†’ Î±} (hf : continuous f)
  (hg : continuous g) :
  closure {b | f b < g b} âŠ† {b | f b â‰¤ g b} :=
by { rw [â†closure_le_eq hf hg], exact closure_mono (Î» b, le_of_lt) }

lemma continuous_within_at.closure_le [topological_space Î²]
 {f g : Î² â†’ Î±} {s : set Î²} {x : Î²} (hx : x âˆˆ closure s)
 (hf : continuous_within_at f s x)
 (hg : continuous_within_at g s x)
 (h : âˆ€ y âˆˆ s, f y â‰¤ g y) : f x â‰¤ g x :=
show (f x, g x) âˆˆ {p : Î± Ã— Î± | p.1 â‰¤ p.2},
from order_closed_topology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x âˆˆ s | f x â‰¤ g x}` is a closed set. -/
lemma is_closed.is_closed_le [topological_space Î²] {f g : Î² â†’ Î±} {s : set Î²} (hs : is_closed s)
  (hf : continuous_on f s) (hg : continuous_on g s) :
  is_closed {x âˆˆ s | f x â‰¤ g x} :=
(hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'

omit t

lemma nhds_within_Ici_ne_bot {a b : Î±} (Hâ‚‚ : a â‰¤ b) :
  ne_bot (ğ“[Ici a] b) :=
nhds_within_ne_bot_of_mem Hâ‚‚

@[instance] lemma nhds_within_Ici_self_ne_bot (a : Î±) :
  ne_bot (ğ“[Ici a] a) :=
nhds_within_Ici_ne_bot (le_refl a)

lemma nhds_within_Iic_ne_bot {a b : Î±} (H : a â‰¤ b) :
  ne_bot (ğ“[Iic b] a) :=
nhds_within_ne_bot_of_mem H

@[instance] lemma nhds_within_Iic_self_ne_bot (a : Î±) :
  ne_bot (ğ“[Iic a] a) :=
nhds_within_Iic_ne_bot (le_refl a)

end preorder

section partial_order
variables [topological_space Î±] [partial_order Î±] [t : order_closed_topology Î±]
include t

private lemma is_closed_eq_aux : is_closed {p : Î± Ã— Î± | p.1 = p.2} :=
by simp only [le_antisymm_iff];
   exact is_closed.inter t.is_closed_le' (is_closed_le continuous_snd continuous_fst)

@[priority 90] -- see Note [lower instance priority]
instance order_closed_topology.to_t2_space : t2_space Î± :=
{ t2 :=
  have is_open {p : Î± Ã— Î± | p.1 â‰  p.2} := is_closed_eq_aux.is_open_compl,
  assume a b h,
  let âŸ¨u, v, hu, hv, ha, hb, hâŸ© := is_open_prod_iff.mp this a b h in
  âŸ¨u, v, hu, hv, ha, hb,
    set.eq_empty_iff_forall_not_mem.2 $ assume a âŸ¨hâ‚, hâ‚‚âŸ©,
    have a â‰  a, from @h (a, a) âŸ¨hâ‚, hâ‚‚âŸ©,
    this rflâŸ© }

end partial_order

section linear_order
variables [topological_space Î±] [linear_order Î±] [order_closed_topology Î±]

lemma is_open_lt_prod : is_open {p : Î± Ã— Î± | p.1 < p.2} :=
by { simp_rw [â† is_closed_compl_iff, compl_set_of, not_lt],
     exact is_closed_le continuous_snd continuous_fst }

lemma is_open_lt [topological_space Î²] {f g : Î² â†’ Î±} (hf : continuous f) (hg : continuous g) :
  is_open {b | f b < g b} :=
by simp [lt_iff_not_ge, -not_le]; exact (is_closed_le hg hf).is_open_compl

variables {a b : Î±}

lemma is_open_Iio : is_open (Iio a) :=
is_open_lt continuous_id continuous_const

lemma is_open_Ioi : is_open (Ioi a) :=
is_open_lt continuous_const continuous_id

lemma is_open_Ioo : is_open (Ioo a b) :=
is_open.inter is_open_Ioi is_open_Iio

@[simp] lemma interior_Ioi : interior (Ioi a) = Ioi a :=
is_open_Ioi.interior_eq

@[simp] lemma interior_Iio : interior (Iio a) = Iio a :=
is_open_Iio.interior_eq

@[simp] lemma interior_Ioo : interior (Ioo a b) = Ioo a b :=
is_open_Ioo.interior_eq

lemma eventually_le_of_tendsto_lt {l : filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : v < u)
  (h : tendsto f l (ğ“ v)) : âˆ€á¶  a in l, f a â‰¤ u :=
eventually.mono (tendsto_nhds.1 h (< u) is_open_Iio hv) (Î» v, le_of_lt)

lemma eventually_ge_of_tendsto_gt {l : filter Î³} {f : Î³ â†’ Î±} {u v : Î±} (hv : u < v)
  (h : tendsto f l (ğ“ v)) : âˆ€á¶  a in l, u â‰¤ f a :=
eventually.mono (tendsto_nhds.1 h (> u) is_open_Ioi hv) (Î» v, le_of_lt)

variables [topological_space Î³]

/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions
on a preconnected space and `f a â‰¤ g a` and `g b â‰¤ f b`, then for some `x` we have `f x = g x`. -/
lemma intermediate_value_univâ‚‚ [preconnected_space Î³] {a b : Î³} {f g : Î³ â†’ Î±} (hf : continuous f)
  (hg : continuous g) (ha : f a â‰¤ g a) (hb : g b â‰¤ f b) :
  âˆƒ x, f x = g x :=
begin
  obtain âŸ¨x, h, hfg, hgfâŸ© : (univ âˆ© {x | f x â‰¤ g x âˆ§ g x â‰¤ f x}).nonempty,
    from is_preconnected_closed_iff.1 preconnected_space.is_preconnected_univ _ _
      (is_closed_le hf hg) (is_closed_le hg hf) (Î» x hx, le_total _ _) âŸ¨a, trivial, haâŸ©
      âŸ¨b, trivial, hbâŸ©,
  exact âŸ¨x, le_antisymm hfg hgfâŸ©
end

lemma intermediate_value_univâ‚‚_eventuallyâ‚ [preconnected_space Î³] {a : Î³} {l : filter Î³} [ne_bot l]
  {f g : Î³ â†’ Î±} (hf : continuous f) (hg : continuous g) (ha : f a â‰¤ g a) (he : g â‰¤á¶ [l] f) :
  âˆƒ x, f x = g x :=
let âŸ¨c, hcâŸ© := he.frequently.exists in intermediate_value_univâ‚‚ hf hg ha hc

lemma intermediate_value_univâ‚‚_eventuallyâ‚‚ [preconnected_space Î³] {lâ‚ lâ‚‚ : filter Î³}
  [ne_bot lâ‚] [ne_bot lâ‚‚] {f g : Î³ â†’ Î±} (hf : continuous f) (hg : continuous g)
  (heâ‚ : f â‰¤á¶ [lâ‚] g ) (heâ‚‚ : g â‰¤á¶ [lâ‚‚] f) :
  âˆƒ x, f x = g x :=
let âŸ¨câ‚, hcâ‚âŸ© := heâ‚.frequently.exists, âŸ¨câ‚‚, hcâ‚‚âŸ© := heâ‚‚.frequently.exists in
intermediate_value_univâ‚‚ hf hg hcâ‚ hcâ‚‚

/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous
on a preconnected set `s` and for some `a b âˆˆ s` we have `f a â‰¤ g a` and `g b â‰¤ f b`,
then for some `x âˆˆ s` we have `f x = g x`. -/
lemma is_preconnected.intermediate_valueâ‚‚ {s : set Î³} (hs : is_preconnected s)
  {a b : Î³} (ha : a âˆˆ s) (hb : b âˆˆ s) {f g : Î³ â†’ Î±}
  (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a â‰¤ g a) (hb' : g b â‰¤ f b) :
  âˆƒ x âˆˆ s, f x = g x :=
let âŸ¨x, hxâŸ© := @intermediate_value_univâ‚‚ Î± s _ _ _ _ (subtype.preconnected_space hs) âŸ¨a, haâŸ© âŸ¨b, hbâŸ©
  _ _ (continuous_on_iff_continuous_restrict.1 hf) (continuous_on_iff_continuous_restrict.1 hg)
  ha' hb'
in âŸ¨x, x.2, hxâŸ©

lemma is_preconnected.intermediate_valueâ‚‚_eventuallyâ‚ {s : set Î³} (hs : is_preconnected s)
  {a : Î³} {l : filter Î³} (ha : a âˆˆ s) [ne_bot l] (hl : l â‰¤ ğ“Ÿ s) {f g : Î³ â†’ Î±}
  (hf : continuous_on f s) (hg : continuous_on g s) (ha' : f a â‰¤ g a) (he : g â‰¤á¶ [l] f) :
  âˆƒ x âˆˆ s, f x = g x :=
begin
  rw continuous_on_iff_continuous_restrict at hf hg,
  obtain âŸ¨b, hâŸ© := @intermediate_value_univâ‚‚_eventuallyâ‚ _ _ _ _ _ _ (subtype.preconnected_space hs)
    âŸ¨a, haâŸ© _ (comap_coe_ne_bot_of_le_principal hl) _ _ hf hg ha' (eventually_comap' he),
  exact âŸ¨b, b.prop, hâŸ©,
end

lemma is_preconnected.intermediate_valueâ‚‚_eventuallyâ‚‚ {s : set Î³} (hs : is_preconnected s)
  {lâ‚ lâ‚‚ : filter Î³} [ne_bot lâ‚] [ne_bot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f g : Î³ â†’ Î±}
  (hf : continuous_on f s) (hg : continuous_on g s) (heâ‚ : f â‰¤á¶ [lâ‚] g) (heâ‚‚ : g â‰¤á¶ [lâ‚‚] f) :
  âˆƒ x âˆˆ s, f x = g x :=
begin
  rw continuous_on_iff_continuous_restrict at hf hg,
  obtain âŸ¨b, hâŸ© := @intermediate_value_univâ‚‚_eventuallyâ‚‚ _ _ _ _ _ _ (subtype.preconnected_space hs)
    _ _ (comap_coe_ne_bot_of_le_principal hlâ‚) (comap_coe_ne_bot_of_le_principal hlâ‚‚)
    _ _ hf hg (eventually_comap' heâ‚) (eventually_comap' heâ‚‚),
  exact âŸ¨b, b.prop, hâŸ©,
end

/-- **Intermediate Value Theorem** for continuous functions on connected sets. -/
lemma is_preconnected.intermediate_value {s : set Î³} (hs : is_preconnected s)
  {a b : Î³} (ha : a âˆˆ s) (hb : b âˆˆ s) {f : Î³ â†’ Î±} (hf : continuous_on f s) :
  Icc (f a) (f b) âŠ† f '' s :=
Î» x hx, mem_image_iff_bex.2 $ hs.intermediate_valueâ‚‚ ha hb hf continuous_on_const hx.1 hx.2

lemma is_preconnected.intermediate_value_Ico {s : set Î³} (hs : is_preconnected s)
  {a : Î³} {l : filter Î³} (ha : a âˆˆ s) [ne_bot l] (hl : l â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) {v : Î±} (ht : tendsto f l (ğ“ v)) :
  Ico (f a) v âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl
  hf continuous_on_const h.1 (eventually_ge_of_tendsto_gt h.2 ht)

lemma is_preconnected.intermediate_value_Ioc {s : set Î³} (hs : is_preconnected s)
  {a : Î³} {l : filter Î³} (ha : a âˆˆ s) [ne_bot l] (hl : l â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) {v : Î±} (ht : tendsto f l (ğ“ v)) :
  Ioc v (f a) âŠ† f '' s :=
Î» y h, bex_def.1 $ bex.imp_right (Î» x _, eq.symm) $ hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl
  continuous_on_const hf h.2 (eventually_le_of_tendsto_lt h.1 ht)

lemma is_preconnected.intermediate_value_Ioo {s : set Î³} (hs : is_preconnected s)
  {lâ‚ lâ‚‚ : filter Î³} [ne_bot lâ‚] [ne_bot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) {vâ‚ vâ‚‚ : Î±} (htâ‚ : tendsto f lâ‚ (ğ“ vâ‚)) (htâ‚‚ : tendsto f lâ‚‚ (ğ“ vâ‚‚)) :
  Ioo vâ‚ vâ‚‚ âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚
  hf continuous_on_const (eventually_le_of_tendsto_lt h.1 htâ‚) (eventually_ge_of_tendsto_gt h.2 htâ‚‚)

lemma is_preconnected.intermediate_value_Ici {s : set Î³} (hs : is_preconnected s)
  {a : Î³} {l : filter Î³} (ha : a âˆˆ s) [ne_bot l] (hl : l â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) (ht : tendsto f l at_top) :
  Ici (f a) âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl
  hf continuous_on_const h (tendsto_at_top.1 ht y)

lemma is_preconnected.intermediate_value_Iic {s : set Î³} (hs : is_preconnected s)
  {a : Î³} {l : filter Î³} (ha : a âˆˆ s) [ne_bot l] (hl : l â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) (ht : tendsto f l at_bot) :
  Iic (f a) âŠ† f '' s :=
Î» y h, bex_def.1 $ bex.imp_right (Î» x _, eq.symm) $ hs.intermediate_valueâ‚‚_eventuallyâ‚ ha hl
  continuous_on_const hf h (tendsto_at_bot.1 ht y)

lemma is_preconnected.intermediate_value_Ioi {s : set Î³} (hs : is_preconnected s)
  {lâ‚ lâ‚‚ : filter Î³} [ne_bot lâ‚] [ne_bot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) {v : Î±} (htâ‚ : tendsto f lâ‚ (ğ“ v)) (htâ‚‚ : tendsto f lâ‚‚ at_top) :
  Ioi v âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚
  hf continuous_on_const (eventually_le_of_tendsto_lt h htâ‚) (tendsto_at_top.1 htâ‚‚ y)

lemma is_preconnected.intermediate_value_Iio {s : set Î³} (hs : is_preconnected s)
  {lâ‚ lâ‚‚ : filter Î³} [ne_bot lâ‚] [ne_bot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) {v : Î±} (htâ‚ : tendsto f lâ‚ at_bot) (htâ‚‚ : tendsto f lâ‚‚ (ğ“ v)) :
  Iio v âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚
  hf continuous_on_const (tendsto_at_bot.1 htâ‚ y) (eventually_ge_of_tendsto_gt h htâ‚‚)

lemma is_preconnected.intermediate_value_Iii {s : set Î³} (hs : is_preconnected s)
  {lâ‚ lâ‚‚ : filter Î³} [ne_bot lâ‚] [ne_bot lâ‚‚] (hlâ‚ : lâ‚ â‰¤ ğ“Ÿ s) (hlâ‚‚ : lâ‚‚ â‰¤ ğ“Ÿ s) {f : Î³ â†’ Î±}
  (hf : continuous_on f s) (htâ‚ : tendsto f lâ‚ at_bot) (htâ‚‚ : tendsto f lâ‚‚ at_top) :
  univ âŠ† f '' s :=
Î» y h, bex_def.1 $ hs.intermediate_valueâ‚‚_eventuallyâ‚‚ hlâ‚ hlâ‚‚
  hf continuous_on_const (tendsto_at_bot.1 htâ‚ y) (tendsto_at_top.1 htâ‚‚ y)

/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/
lemma intermediate_value_univ [preconnected_space Î³] (a b : Î³) {f : Î³ â†’ Î±} (hf : continuous f) :
  Icc (f a) (f b) âŠ† range f :=
Î» x hx, intermediate_value_univâ‚‚ hf continuous_const hx.1 hx.2

/-- **Intermediate Value Theorem** for continuous functions on connected spaces. -/
lemma mem_range_of_exists_le_of_exists_ge [preconnected_space Î³] {c : Î±} {f : Î³ â†’ Î±}
  (hf : continuous f) (hâ‚ : âˆƒ a, f a â‰¤ c) (hâ‚‚ : âˆƒ b, c â‰¤ f b) :
  c âˆˆ range f :=
let âŸ¨a, haâŸ© := hâ‚, âŸ¨b, hbâŸ© := hâ‚‚ in intermediate_value_univ a b hf âŸ¨ha, hbâŸ©

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
lemma is_preconnected.Icc_subset {s : set Î±} (hs : is_preconnected s)
  {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) :
  Icc a b âŠ† s :=
by simpa only [image_id] using hs.intermediate_value ha hb continuous_on_id

/-- If a preconnected set contains endpoints of an interval, then it includes the whole interval. -/
lemma is_connected.Icc_subset {s : set Î±} (hs : is_connected s)
  {a b : Î±} (ha : a âˆˆ s) (hb : b âˆˆ s) :
  Icc a b âŠ† s :=
hs.2.Icc_subset ha hb

/-- If preconnected set in a linear order space is unbounded below and above, then it is the whole
space. -/
lemma is_preconnected.eq_univ_of_unbounded {s : set Î±} (hs : is_preconnected s) (hb : Â¬bdd_below s)
  (ha : Â¬bdd_above s) :
  s = univ :=
begin
  refine eq_univ_of_forall (Î» x, _),
  obtain âŸ¨y, ys, hyâŸ© : âˆƒ y âˆˆ s, y < x := not_bdd_below_iff.1 hb x,
  obtain âŸ¨z, zs, hzâŸ© : âˆƒ z âˆˆ s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs âŸ¨le_of_lt hy, le_of_lt hzâŸ©
end

/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ğ“[Ioi a] a` and
`ğ“[Ici a] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Î±` -/

/-!
#### Right neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) :
  Ioo a c âˆˆ ğ“[Ioi b] b :=
mem_nhds_within.2 âŸ¨Iio c, is_open_Iio, H.2,
  by rw [inter_comm, Ioi_inter_Iio]; exact Ioo_subset_Ioo_left H.1âŸ©

lemma Ioc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) :
  Ioc a c âˆˆ ğ“[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) :
  Ico a c âˆˆ ğ“[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

lemma Icc_mem_nhds_within_Ioi {a b c : Î±} (H : b âˆˆ Ico a c) :
  Icc a c âˆˆ ğ“[Ioi b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Ioi {a b : Î±} (h : a < b) :
  ğ“[Ioc a b] a = ğ“[Ioi a] a :=
le_antisymm (nhds_within_mono _ Ioc_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioc_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Ioi {a b : Î±} (h : a < b) :
  ğ“[Ioo a b] a = ğ“[Ioi a] a :=
le_antisymm (nhds_within_mono _ Ioo_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioo_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Ioc_iff_Ioi [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Ioc a b) a â†” continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
lemma continuous_within_at_Ioo_iff_Ioi [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Ioo a b) a â†” continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Ioo a c âˆˆ ğ“[Iio b] b :=
by simpa only [dual_Ioo] using @Ioo_mem_nhds_within_Ioi (order_dual Î±) _ _ _ _ _ _ âŸ¨H.2, H.1âŸ©

lemma Ico_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Ico a c âˆˆ ğ“[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Ioc a c âˆˆ ğ“[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

lemma Icc_mem_nhds_within_Iio {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Icc a c âˆˆ ğ“[Iio b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ico_eq_nhds_within_Iio {a b : Î±} (h : a < b) :
  ğ“[Ico a b] b = ğ“[Iio b] b :=
by simpa only [dual_Ioc] using @nhds_within_Ioc_eq_nhds_within_Ioi (order_dual Î±) _ _ _ _ _ h

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Iio {a b : Î±} (h : a < b) :
  ğ“[Ioo a b] b = ğ“[Iio b] b :=
by simpa only [dual_Ioo] using @nhds_within_Ioo_eq_nhds_within_Ioi (order_dual Î±) _ _ _ _ _ h

@[simp] lemma continuous_within_at_Ico_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  continuous_within_at f (Ico a b) b â†” continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp] lemma continuous_within_at_Ioo_iff_Iio {a b : Î±} {f : Î± â†’ Î³} (h : a < b) :
  continuous_within_at f (Ioo a b) b â†” continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) :
  Ioo a c âˆˆ ğ“[Ici b] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H

lemma Ioc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ioo a c) :
  Ioc a c âˆˆ ğ“[Ici b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) :
  Ico a c âˆˆ ğ“[Ici b] b :=
mem_nhds_within.2 âŸ¨Iio c, is_open_Iio, H.2,
  by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]âŸ©

lemma Icc_mem_nhds_within_Ici {a b c : Î±} (H : b âˆˆ Ico a c) :
  Icc a c âˆˆ ğ“[Ici b] b :=
mem_sets_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Ici {a b : Î±} (h : a < b) :
  ğ“[Icc a b] a = ğ“[Ici a] a :=
le_antisymm (nhds_within_mono _ Icc_subset_Ici_self) $
  nhds_within_le_of_mem $ Icc_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ico_eq_nhds_within_Ici {a b : Î±} (h : a < b) :
  ğ“[Ico a b] a = ğ“[Ici a] a :=
le_antisymm (nhds_within_mono _ (Î» x, and.left)) $
  nhds_within_le_of_mem $ Ico_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Icc_iff_Ici [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Icc a b) a â†” continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
lemma continuous_within_at_Ico_iff_Ici [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Ico a b) a â†” continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) :
  Ioo a c âˆˆ ğ“[Iic b] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H

lemma Ico_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioo a c) :
  Ico a c âˆˆ ğ“[Iic b] b :=
mem_sets_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Ioc a c âˆˆ ğ“[Iic b] b :=
by simpa only [dual_Ico] using @Ico_mem_nhds_within_Ici (order_dual Î±) _ _ _ _ _ _ âŸ¨H.2, H.1âŸ©

lemma Icc_mem_nhds_within_Iic {a b c : Î±} (H : b âˆˆ Ioc a c) :
  Icc a c âˆˆ ğ“[Iic b] b :=
mem_sets_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Iic {a b : Î±} (h : a < b) :
  ğ“[Icc a b] b = ğ“[Iic b] b :=
by simpa only [dual_Icc] using @nhds_within_Icc_eq_nhds_within_Ici (order_dual Î±) _ _ _ _ _ h

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Iic {a b : Î±} (h : a < b) :
  ğ“[Ioc a b] b = ğ“[Iic b] b :=
by simpa only [dual_Ico] using @nhds_within_Ico_eq_nhds_within_Ici (order_dual Î±) _ _ _ _ _ h

@[simp]
lemma continuous_within_at_Icc_iff_Iic [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Icc a b) b â†” continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
lemma continuous_within_at_Ioc_iff_Iic [topological_space Î²] {a b : Î±} {f : Î± â†’ Î²} (h : a < b) :
  continuous_within_at f (Ioc a b) b â†” continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]

end linear_order

section linear_order
variables [topological_space Î±] [linear_order Î±] [order_closed_topology Î±] {f g : Î² â†’ Î±}

section
variables [topological_space Î²]

lemma frontier_le_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b â‰¤ g b} âŠ† {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b âŸ¨hbâ‚, hbâ‚‚âŸ©,
  refine le_antisymm hbâ‚ (closure_lt_subset_le hg hf _),
  convert hbâ‚‚ using 2, simp only [not_le.symm], refl
end

lemma frontier_Iic_subset (a : Î±) : frontier (Iic a) âŠ† {a} :=
frontier_le_subset_eq (@continuous_id Î± _) continuous_const

lemma frontier_Ici_subset (a : Î±) : frontier (Ici a) âŠ† {a} :=
@frontier_Iic_subset (order_dual Î±) _ _ _ _

lemma frontier_lt_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b < g b} âŠ† {b | f b = g b} :=
by rw â† frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]

lemma continuous_if_le [topological_space Î³] [Î  x, decidable (f x â‰¤ g x)]
  {f' g' : Î² â†’ Î³} (hf : continuous f) (hg : continuous g)
  (hf' : continuous_on f' {x | f x â‰¤ g x}) (hg' : continuous_on g' {x | g x â‰¤ f x})
  (hfg : âˆ€ x, f x = g x â†’ f' x = g' x) :
  continuous (Î» x, if f x â‰¤ g x then f' x else g' x) :=
begin
  refine continuous_if (Î» a ha, hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _),
  { rwa [(is_closed_le hf hg).closure_eq] },
  { simp only [not_le], exact closure_lt_subset_le hg hf }
end

lemma continuous.if_le [topological_space Î³] [Î  x, decidable (f x â‰¤ g x)] {f' g' : Î² â†’ Î³}
  (hf' : continuous f') (hg' : continuous g') (hf : continuous f) (hg : continuous g)
  (hfg : âˆ€ x, f x = g x â†’ f' x = g' x) :
  continuous (Î» x, if f x â‰¤ g x then f' x else g' x) :=
continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg

@[continuity] lemma continuous.min (hf : continuous f) (hg : continuous g) :
  continuous (Î»b, min (f b) (g b)) :=
hf.if_le hg hf hg (Î» x, id)

@[continuity] lemma continuous.max (hf : continuous f) (hg : continuous g) :
  continuous (Î»b, max (f b) (g b)) :=
@continuous.min (order_dual Î±) _ _ _ _ _ _ _ hf hg

end

lemma continuous_min : continuous (Î» p : Î± Ã— Î±, min p.1 p.2) := continuous_fst.min continuous_snd

lemma continuous_max : continuous (Î» p : Î± Ã— Î±, max p.1 p.2) := continuous_fst.max continuous_snd

lemma filter.tendsto.max {b : filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (Î»b, max (f b) (g b)) b (ğ“ (max aâ‚ aâ‚‚)) :=
(continuous_max.tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

lemma filter.tendsto.min {b : filter Î²} {aâ‚ aâ‚‚ : Î±} (hf : tendsto f b (ğ“ aâ‚))
  (hg : tendsto g b (ğ“ aâ‚‚)) :
  tendsto (Î»b, min (f b) (g b)) b (ğ“ (min aâ‚ aâ‚‚)) :=
(continuous_min.tendsto (aâ‚, aâ‚‚)).comp (hf.prod_mk_nhds hg)

lemma is_preconnected.ord_connected {s : set Î±} (h : is_preconnected s) :
  ord_connected s :=
âŸ¨Î» x hx y hy, h.Icc_subset hx hyâŸ©

end linear_order

end order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class order_topology (Î± : Type*) [t : topological_space Î±] [preorder Î±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | âˆƒa, s = Ioi a âˆ¨ s = Iio a})

/-- (Order) topology on a partial order `Î±` generated by the subbase of open intervals
`(a, âˆ) = { x âˆ£ a < x }, (-âˆ , b) = {x âˆ£ x < b}` for all `a, b` in `Î±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def preorder.topology (Î± : Type*) [preorder Î±] : topological_space Î± :=
generate_from {s : set Î± | âˆƒ (a : Î±), s = {b : Î± | a < b} âˆ¨ s = {b : Î± | b < a}}

section order_topology

instance {Î± : Type*} [topological_space Î±] [partial_order Î±] [order_topology Î±] :
  order_topology (order_dual Î±) :=
âŸ¨by convert @order_topology.topology_eq_generate_intervals Î± _ _ _;
  conv in (_ âˆ¨ _) { rw or.comm }; reflâŸ©

section partial_order
variables [topological_space Î±] [partial_order Î±] [t : order_topology Î±]
include t

lemma is_open_iff_generate_intervals {s : set Î±} :
  is_open s â†” generate_open {s | âˆƒa, s = Ioi a âˆ¨ s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl

lemma is_open_lt' (a : Î±) : is_open {b:Î± | a < b} :=
by rw [@is_open_iff_generate_intervals Î± _ _ t]; exact generate_open.basic _ âŸ¨a, or.inl rflâŸ©

lemma is_open_gt' (a : Î±) : is_open {b:Î± | b < a} :=
by rw [@is_open_iff_generate_intervals Î± _ _ t]; exact generate_open.basic _ âŸ¨a, or.inr rflâŸ©

lemma lt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a < x :=
is_open.mem_nhds (is_open_lt' _) h

lemma le_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ b, a â‰¤ x :=
(ğ“ b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma gt_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x < b :=
is_open.mem_nhds (is_open_gt' _) h

lemma ge_mem_nhds {a b : Î±} (h : a < b) : âˆ€á¶  x in ğ“ a, x â‰¤ b :=
(ğ“ a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma nhds_eq_order (a : Î±) :
  ğ“ a = (â¨…b âˆˆ Iio a, ğ“Ÿ (Ioi b)) âŠ“ (â¨…b âˆˆ Ioi a, ğ“Ÿ (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_binfi $ assume b hb, infi_le_of_le {c : Î± | b < c} $ infi_le _ âŸ¨hb, b, or.inl rflâŸ©)
    (le_binfi $ assume b hb, infi_le_of_le {c : Î± | c < b} $ infi_le _ âŸ¨hb, b, or.inr rflâŸ©))
  (le_infi $ assume s, le_infi $ assume âŸ¨ha, b, hsâŸ©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_of_left_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_of_right_le $ infi_le_of_le b $ infi_le _ h
    end)

lemma tendsto_order {f : Î² â†’ Î±} {a : Î±} {x : filter Î²} :
  tendsto f x (ğ“ a) â†” (âˆ€ a' < a, âˆ€á¶  b in x, a' < f b) âˆ§ (âˆ€ a' > a, âˆ€á¶  b in x, f b < a') :=
by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Î±) : tendsto_Ixx_class Icc (ğ“ a) (ğ“ a) :=
begin
  simp only [nhds_eq_order, infi_subtype'],
  refine ((has_basis_infi_principal_finite _).inf
    (has_basis_infi_principal_finite _)).tendsto_Ixx_class (Î» s hs, _),
  refine ((ord_connected_bInter _).inter (ord_connected_bInter _)).out; intros _ _,
  exacts [ord_connected_Ioi, ord_connected_Iio]
end

instance tendsto_Ico_class_nhds (a : Î±) : tendsto_Ixx_class Ico (ğ“ a) (ğ“ a) :=
tendsto_Ixx_class_of_subset (Î» _ _, Ico_subset_Icc_self)

instance tendsto_Ioc_class_nhds (a : Î±) : tendsto_Ixx_class Ioc (ğ“ a) (ğ“ a) :=
tendsto_Ixx_class_of_subset (Î» _ _, Ioc_subset_Icc_self)

instance tendsto_Ioo_class_nhds (a : Î±) : tendsto_Ixx_class Ioo (ğ“ a) (ğ“ a) :=
tendsto_Ixx_class_of_subset (Î» _ _, Ioo_subset_Icc_self)

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
eventually for the filter. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Î² â†’ Î±} {b : filter Î²} {a : Î±}
  (hg : tendsto g b (ğ“ a)) (hh : tendsto h b (ğ“ a))
  (hgf : âˆ€á¶  b in b, g b â‰¤ f b) (hfh : âˆ€á¶  b in b, f b â‰¤ h b) :
  tendsto f b (ğ“ a) :=
tendsto_order.2
  âŸ¨assume a' h',
    have âˆ€á¶  b in b, a' < g b, from (tendsto_order.1 hg).left a' h',
    by filter_upwards [this, hgf] assume a, lt_of_lt_of_le,
    assume a' h',
    have âˆ€á¶  b in b, h b < a', from (tendsto_order.1 hh).right a' h',
    by filter_upwards [this, hfh] assume a hâ‚ hâ‚‚, lt_of_le_of_lt hâ‚‚ hâ‚âŸ©

/-- Also known as squeeze or sandwich theorem. This version assumes that inequalities hold
everywhere. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Î² â†’ Î±} {b : filter Î²} {a : Î±}
  (hg : tendsto g b (ğ“ a)) (hh : tendsto h b (ğ“ a)) (hgf : g â‰¤ f) (hfh : f â‰¤ h) :
  tendsto f b (ğ“ a) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh
  (eventually_of_forall hgf) (eventually_of_forall hfh)

lemma nhds_order_unbounded {a : Î±} (hu : âˆƒu, a < u) (hl : âˆƒl, l < a) :
  ğ“ a = (â¨…l (hâ‚‚ : l < a) u (hâ‚‚ : a < u), ğ“Ÿ (Ioo l u)) :=
have âˆƒ u, u âˆˆ Ioi a, from hu, have âˆƒ l, l âˆˆ Iio a, from hl,
by { simp only [nhds_eq_order, inf_binfi, binfi_inf, *, inf_principal, Ioi_inter_Iio], refl }

lemma tendsto_order_unbounded {f : Î² â†’ Î±} {a : Î±} {x : filter Î²}
  (hu : âˆƒu, a < u) (hl : âˆƒl, l < a) (h : âˆ€l u, l < a â†’ a < u â†’ âˆ€á¶  b in x, l < f b âˆ§ f b < u) :
  tendsto f x (ğ“ a) :=
by rw [nhds_order_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)

end partial_order

instance tendsto_Ixx_nhds_within {Î± : Type*} [preorder Î±] [topological_space Î±]
  (a : Î±) {s t : set Î±} {Ixx}
  [tendsto_Ixx_class Ixx (ğ“ a) (ğ“ a)] [tendsto_Ixx_class Ixx (ğ“Ÿ s) (ğ“Ÿ t)]:
  tendsto_Ixx_class Ixx (ğ“[s] a) (ğ“[t] a) :=
filter.tendsto_Ixx_class_inf

instance tendsto_Icc_class_nhds_pi {Î¹ : Type*} {Î± : Î¹ â†’ Type*}
  [Î  i, partial_order (Î± i)] [Î  i, topological_space (Î± i)] [âˆ€ i, order_topology (Î± i)]
  (f : Î  i, Î± i) :
  tendsto_Ixx_class Icc (ğ“ f) (ğ“ f) :=
begin
  constructor,
  conv in ((ğ“ f).lift' powerset) { rw [nhds_pi] },
  simp only [lift'_infi_powerset, comap_lift'_eq2 monotone_powerset, tendsto_infi, tendsto_lift',
    mem_powerset_iff, subset_def, mem_preimage],
  intros i s hs,
  have : tendsto (Î» g : Î  i, Î± i, g i) (ğ“ f) (ğ“ (f i)) := ((continuous_apply i).tendsto f),
  refine (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _,
  exact Î» p hp g hg, hp âŸ¨hg.1 _, hg.2 _âŸ©
end

theorem induced_order_topology' {Î± : Type u} {Î² : Type v}
  [partial_order Î±] [ta : topological_space Î²] [partial_order Î²] [order_topology Î²]
  (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y)
  (Hâ‚ : âˆ€ {a x}, x < f a â†’ âˆƒ b < a, x â‰¤ f b)
  (Hâ‚‚ : âˆ€ {a x}, f a < x â†’ âˆƒ b > a, f b â‰¤ x) :
  @order_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine âŸ¨eq_of_nhds_eq_nhds (Î» a, _)âŸ©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)],
  apply le_antisymm,
  { refine le_infi (Î» s, le_infi $ Î» hs, le_principal_iff.2 _),
    rcases hs with âŸ¨ab, b, rfl|rflâŸ©,
    { exact mem_comap_sets.2 âŸ¨{x | f b < x},
        mem_inf_sets_of_left $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Î» x, hf.1âŸ© },
    { exact mem_comap_sets.2 âŸ¨{x | x < f b},
        mem_inf_sets_of_right $ mem_infi_sets _ $ mem_infi_sets (hf.2 ab) $ mem_principal_self _,
        Î» x, hf.1âŸ© } },
  { rw [â† map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Î» x, le_infi $ Î» h, le_principal_iff.2 _); simp,
    { rcases Hâ‚ h with âŸ¨b, ab, xbâŸ©,
      refine mem_infi_sets _ (mem_infi_sets âŸ¨ab, b, or.inl rflâŸ© (mem_principal_sets.2 _)),
      exact Î» c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases Hâ‚‚ h with âŸ¨b, ab, xbâŸ©,
      refine mem_infi_sets _ (mem_infi_sets âŸ¨ab, b, or.inr rflâŸ© (mem_principal_sets.2 _)),
      exact Î» c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end

theorem induced_order_topology {Î± : Type u} {Î² : Type v}
  [partial_order Î±] [ta : topological_space Î²] [partial_order Î²] [order_topology Î²]
  (f : Î± â†’ Î²) (hf : âˆ€ {x y}, f x < f y â†” x < y)
  (H : âˆ€ {x y}, x < y â†’ âˆƒ a, x < f a âˆ§ f a < y) :
  @order_topology _ (induced f ta) _ :=
induced_order_topology' f @hf
  (Î» a x xa, let âŸ¨b, xb, baâŸ© := H xa in âŸ¨b, hf.1 ba, le_of_lt xbâŸ©)
  (Î» a x ax, let âŸ¨b, ab, bxâŸ© := H ax in âŸ¨b, hf.1 ab, le_of_lt bxâŸ©)

/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected {Î± : Type u}
  [ta : topological_space Î±] [linear_order Î±] [order_topology Î±]
  {t : set Î±} [ht : ord_connected t] :
  order_topology t :=
begin
  letI := induced (coe : t â†’ Î±) ta,
  refine âŸ¨eq_of_nhds_eq_nhds (Î» a, _)âŸ©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Î±)],
  apply le_antisymm,
  { refine le_infi (Î» s, le_infi $ Î» hs, le_principal_iff.2 _),
    rcases hs with âŸ¨ab, b, rfl|rflâŸ©,
    { refine âŸ¨Ioi b, _, Î» _, idâŸ©,
      refine mem_inf_sets_of_left (mem_infi_sets b _),
      exact mem_infi_sets ab (mem_principal_self (Ioi â†‘b)) },
    { refine âŸ¨Iio b, _, Î» _, idâŸ©,
      refine mem_inf_sets_of_right (mem_infi_sets b _),
      exact mem_infi_sets ab (mem_principal_self (Iio b)) } },
  { rw [â† map_le_iff_le_comap],
    refine le_inf _ _,
    { refine le_infi (Î» x, le_infi $ Î» h, le_principal_iff.2 _),
      by_cases hx : x âˆˆ t,
      { refine mem_infi_sets (Ioi âŸ¨x, hxâŸ©) (mem_infi_sets âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, or.inl rflâŸ©âŸ© _),
        exact Î» _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map],
      convert univ_sets _,
      suffices hx' : âˆ€ (y : t), â†‘y âˆˆ Ioi x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Î» hx, ht.out y.2 a.2 âŸ¨le_of_not_gt hx, le_of_lt hâŸ© },
    { refine le_infi (Î» x, le_infi $ Î» h, le_principal_iff.2 _),
      by_cases hx : x âˆˆ t,
      { refine mem_infi_sets (Iio âŸ¨x, hxâŸ©) (mem_infi_sets âŸ¨h, âŸ¨âŸ¨x, hxâŸ©, or.inr rflâŸ©âŸ© _),
        exact Î» _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map],
      convert univ_sets _,
      suffices hx' : âˆ€ (y : t), â†‘y âˆˆ Iio x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Î» hx, ht.out a.2 y.2 âŸ¨le_of_lt h, le_of_not_gt hxâŸ© } }
end

lemma nhds_top_order [topological_space Î±] [order_top Î±] [order_topology Î±] :
  ğ“ (âŠ¤:Î±) = (â¨…l (hâ‚‚ : l < âŠ¤), ğ“Ÿ (Ioi l)) :=
by simp [nhds_eq_order (âŠ¤:Î±)]

lemma nhds_bot_order [topological_space Î±] [order_bot Î±] [order_topology Î±] :
  ğ“ (âŠ¥:Î±) = (â¨…l (hâ‚‚ : âŠ¥ < l), ğ“Ÿ (Iio l)) :=
by simp [nhds_eq_order (âŠ¥:Î±)]

lemma nhds_basis_top [topological_space Î±] [semilattice_sup_top Î±]
  [is_total Î± has_le.le] [order_topology Î±] [nontrivial Î±] :
  (ğ“ âŠ¤).has_basis (Î» a : Î±, a < âŠ¤) (Î» a : Î±, set.Ioi a) :=
âŸ¨ begin
    simp only [nhds_top_order],
    refine @filter.mem_binfi Î± Î± (Î» a, ğ“Ÿ (Ioi a)) (Î» a, a < âŠ¤) _ _,
    { rintros a (ha : a < âŠ¤) b (hb : b < âŠ¤),
      use a âŠ” b,
      simp only [filter.le_principal_iff, ge_iff_le, order.preimage],
      exact âŸ¨sup_lt_iff.mpr âŸ¨ha, hbâŸ©, Ioi_subset_Ioi le_sup_left, Ioi_subset_Ioi le_sup_rightâŸ© },
    { obtain âŸ¨a, haâŸ© : âˆƒ a : Î±, a â‰  âŠ¤ := exists_ne âŠ¤,
      exact âŸ¨a, lt_top_iff_ne_top.mpr haâŸ© }
  end âŸ©

lemma nhds_basis_bot [topological_space Î±] [semilattice_inf_bot Î±]
  [is_total Î± has_le.le] [order_topology Î±] [nontrivial Î±] :
  (ğ“ âŠ¥).has_basis (Î» a : Î±, âŠ¥ < a) (Î» a : Î±, Iio a) :=
@nhds_basis_top (order_dual Î±) _ _ _ _ _

lemma tendsto_nhds_top_mono [topological_space Î²] [order_top Î²] [order_topology Î²] {l : filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤á¶ [l] g) :
  tendsto g l (ğ“ âŠ¤) :=
begin
  simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf âŠ¢,
  intros x hx,
  filter_upwards [hf x hx, hg],
  exact Î» x, lt_of_lt_of_le
end

lemma tendsto_nhds_bot_mono [topological_space Î²] [order_bot Î²] [order_topology Î²] {l : filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤á¶ [l] f) :
  tendsto g l (ğ“ âŠ¥) :=
@tendsto_nhds_top_mono Î± (order_dual Î²) _ _ _ _ _ _ hf hg

lemma tendsto_nhds_top_mono' [topological_space Î²] [order_top Î²] [order_topology Î²] {l : filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¤)) (hg : f â‰¤ g) :
  tendsto g l (ğ“ âŠ¤) :=
tendsto_nhds_top_mono hf (eventually_of_forall hg)

lemma tendsto_nhds_bot_mono' [topological_space Î²] [order_bot Î²] [order_topology Î²] {l : filter Î±}
  {f g : Î± â†’ Î²} (hf : tendsto f l (ğ“ âŠ¥)) (hg : g â‰¤ f) :
  tendsto g l (ğ“ âŠ¥) :=
tendsto_nhds_bot_mono hf (eventually_of_forall hg)

section linear_order

variables [topological_space Î±] [linear_order Î±] [order_topology Î±]

lemma exists_Ioc_subset_of_mem_nhds' {a : Î±} {s : set Î±} (hs : s âˆˆ ğ“ a) {l : Î±} (hl : l < a) :
  âˆƒ l' âˆˆ Ico l a, Ioc l' a âŠ† s :=
begin
  rw [nhds_eq_order a] at hs,
  rcases hs with âŸ¨tâ‚, htâ‚, tâ‚‚, htâ‚‚, htsâŸ©,
  -- First we show that `tâ‚‚` includes `(-âˆ, a]`, so it suffices to show `(l', âˆ) âŠ† tâ‚`
  suffices : âˆƒ l' âˆˆ Ico l a, Ioi l' âŠ† tâ‚,
  { have A : ğ“Ÿ (Iic a) â‰¤ â¨… b âˆˆ Ioi a, ğ“Ÿ (Iio b),
      from (le_infi $ Î» b, le_infi $ Î» hb, principal_mono.2 $ Iic_subset_Iio.2 hb),
    have B : tâ‚ âˆ© Iic a âŠ† s,
      from subset.trans (inter_subset_inter_right _ (A htâ‚‚)) hts,
    from this.imp (Î» l', Exists.imp $ Î» hl' hl x hx, B âŸ¨hl hx.1, hx.2âŸ©) },
  clear hts htâ‚‚ tâ‚‚,
  -- Now we find `l` such that `(l', âˆ) âŠ† tâ‚`
  rw [mem_binfi] at htâ‚,
  { rcases htâ‚ with âŸ¨b, hb, hb'âŸ©,
    exact âŸ¨max b l, âŸ¨le_max_right _ _, max_lt hb hlâŸ©,
      Î» x hx, hb' $ Ioi_subset_Ioi (le_max_left _ _) hxâŸ© },
  { intros b hb b' hb', simp only [mem_Iio] at hb hb',
    use [max b b', max_lt hb hb'],
    simp [le_refl] },
  exact âŸ¨l, hlâŸ©
end

lemma exists_Ico_subset_of_mem_nhds' {a : Î±} {s : set Î±} (hs : s âˆˆ ğ“ a) {u : Î±} (hu : a < u) :
  âˆƒ u' âˆˆ Ioc a u, Ico a u' âŠ† s :=
begin
  convert @exists_Ioc_subset_of_mem_nhds' (order_dual Î±) _ _ _ _ _ hs _ hu,
  ext, rw [dual_Ico, dual_Ioc]
end

lemma exists_Ioc_subset_of_mem_nhds {a : Î±} {s : set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ l, l < a) :
  âˆƒ l < a, Ioc l a âŠ† s :=
let âŸ¨l', hl'âŸ© := h in let âŸ¨l, hlâŸ© := exists_Ioc_subset_of_mem_nhds' hs hl' in âŸ¨l, hl.fst.2, hl.sndâŸ©

lemma exists_Ico_subset_of_mem_nhds {a : Î±} {s : set Î±} (hs : s âˆˆ ğ“ a) (h : âˆƒ u, a < u) :
  âˆƒ u (_ : a < u), Ico a u âŠ† s :=
let âŸ¨l', hl'âŸ© := h in let âŸ¨l, hlâŸ© := exists_Ico_subset_of_mem_nhds' hs hl' in âŸ¨l, hl.fst.1, hl.sndâŸ©

lemma order_separated {aâ‚ aâ‚‚ : Î±} (h : aâ‚ < aâ‚‚) :
  âˆƒu v : set Î±, is_open u âˆ§ is_open v âˆ§ aâ‚ âˆˆ u âˆ§ aâ‚‚ âˆˆ v âˆ§ (âˆ€bâ‚âˆˆu, âˆ€bâ‚‚âˆˆv, bâ‚ < bâ‚‚) :=
match dense_or_discrete aâ‚ aâ‚‚ with
| or.inl âŸ¨a, haâ‚, haâ‚‚âŸ© := âŸ¨{a' | a' < a}, {a' | a < a'}, is_open_gt' a, is_open_lt' a, haâ‚, haâ‚‚,
    assume bâ‚ hâ‚ bâ‚‚ hâ‚‚, lt_trans hâ‚ hâ‚‚âŸ©
| or.inr âŸ¨hâ‚, hâ‚‚âŸ© := âŸ¨{a | a < aâ‚‚}, {a | aâ‚ < a}, is_open_gt' aâ‚‚, is_open_lt' aâ‚, h, h,
    assume bâ‚ hbâ‚ bâ‚‚ hbâ‚‚,
    calc bâ‚ â‰¤ aâ‚ : hâ‚‚ _ hbâ‚
      ... < aâ‚‚ : h
      ... â‰¤ bâ‚‚ : hâ‚ _ hbâ‚‚âŸ©
end

@[priority 100] -- see Note [lower instance priority]
instance order_topology.to_order_closed_topology : order_closed_topology Î± :=
{ is_closed_le' :=
    is_open_compl_iff.1 $ is_open_prod_iff.mpr $ assume aâ‚ aâ‚‚ (h : Â¬ aâ‚ â‰¤ aâ‚‚),
      have h : aâ‚‚ < aâ‚, from lt_of_not_ge h,
      let âŸ¨u, v, hu, hv, haâ‚, haâ‚‚, hâŸ© := order_separated h in
      âŸ¨v, u, hv, hu, haâ‚‚, haâ‚, assume âŸ¨bâ‚, bâ‚‚âŸ© âŸ¨hâ‚, hâ‚‚âŸ©, not_le_of_gt $ h bâ‚‚ hâ‚‚ bâ‚ hâ‚âŸ© }

lemma order_topology.t2_space : t2_space Î± := by apply_instance

@[priority 100] -- see Note [lower instance priority]
instance order_topology.regular_space : regular_space Î± :=
{ regular := assume s a hs ha,
    have hs' : sá¶œ âˆˆ ğ“ a, from is_open.mem_nhds hs.is_open_compl ha,
    have âˆƒt:set Î±, is_open t âˆ§ (âˆ€lâˆˆ s, l < a â†’ l âˆˆ t) âˆ§ ğ“[t] a = âŠ¥,
      from by_cases
        (assume h : âˆƒl, l < a,
          let âŸ¨l, hl, hâŸ© := exists_Ioc_subset_of_mem_nhds hs' h in
          match dense_or_discrete l a with
          | or.inl âŸ¨b, hbâ‚, hbâ‚‚âŸ© := âŸ¨{a | a < b}, is_open_gt' _,
              assume c hcs hca, show c < b,
                from lt_of_not_ge $ assume hbc, h âŸ¨lt_of_lt_of_le hbâ‚ hbc, le_of_lt hcaâŸ© hcs,
              inf_principal_eq_bot.2 $ (ğ“ a).sets_of_superset ((is_open_lt' _).mem_nhds hbâ‚‚) $
                assume x (hx : b < x), show Â¬ x < b, from not_lt.2 $ le_of_lt hxâŸ©
          | or.inr âŸ¨hâ‚, hâ‚‚âŸ© := âŸ¨{a' | a' < a}, is_open_gt' _, assume b hbs hba, hba,
              inf_principal_eq_bot.2 $ (ğ“ a).sets_of_superset ((is_open_lt' _).mem_nhds hl) $
                assume x (hx : l < x), show Â¬ x < a, from not_lt.2 $ hâ‚ _ hxâŸ©
          end)
        (assume : Â¬ âˆƒl, l < a, âŸ¨âˆ…, is_open_empty, assume l _ hl, (this âŸ¨l, hlâŸ©).elim,
          nhds_within_empty _âŸ©),
    let âŸ¨tâ‚, htâ‚o, htâ‚s, htâ‚aâŸ© := this in
    have âˆƒt:set Î±, is_open t âˆ§ (âˆ€uâˆˆ s, u>a â†’ u âˆˆ t) âˆ§ ğ“[t] a = âŠ¥,
      from by_cases
        (assume h : âˆƒu, u > a,
          let âŸ¨u, hu, hâŸ© := exists_Ico_subset_of_mem_nhds hs' h in
          match dense_or_discrete a u with
          | or.inl âŸ¨b, hbâ‚, hbâ‚‚âŸ© := âŸ¨{a | b < a}, is_open_lt' _,
              assume c hcs hca, show c > b,
                from lt_of_not_ge $ assume hbc, h âŸ¨le_of_lt hca, lt_of_le_of_lt hbc hbâ‚‚âŸ© hcs,
              inf_principal_eq_bot.2 $ (ğ“ a).sets_of_superset ((is_open_gt' _).mem_nhds hbâ‚) $
                assume x (hx : b > x), show Â¬ x > b, from not_lt.2 $ le_of_lt hxâŸ©
          | or.inr âŸ¨hâ‚, hâ‚‚âŸ© := âŸ¨{a' | a' > a}, is_open_lt' _, assume b hbs hba, hba,
              inf_principal_eq_bot.2 $ (ğ“ a).sets_of_superset ((is_open_gt' _).mem_nhds hu) $
                assume x (hx : u > x), show Â¬ x > a, from not_lt.2 $ hâ‚‚ _ hxâŸ©
          end)
        (assume : Â¬ âˆƒu, u > a, âŸ¨âˆ…, is_open_empty, assume l _ hl, (this âŸ¨l, hlâŸ©).elim,
          nhds_within_empty _âŸ©),
    let âŸ¨tâ‚‚, htâ‚‚o, htâ‚‚s, htâ‚‚aâŸ© := this in
    âŸ¨tâ‚ âˆª tâ‚‚, is_open.union htâ‚o htâ‚‚o,
      assume x hx,
      have x â‰  a, from assume eq, ha $ eq â–¸ hx,
      (ne_iff_lt_or_gt.mp this).imp (htâ‚s _ hx) (htâ‚‚s _ hx),
      by rw [nhds_within_union, htâ‚a, htâ‚‚a, bot_sup_eq]âŸ©,
  ..order_topology.t2_space }

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
lemma mem_nhds_iff_exists_Ioo_subset' {a : Î±} {s : set Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  s âˆˆ ğ“ a â†” âˆƒl u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds h hu with âŸ¨u, au, huâŸ©,
    rcases exists_Ioc_subset_of_mem_nhds h hl with âŸ¨l, la, hlâŸ©,
    refine âŸ¨l, u, âŸ¨la, auâŸ©, Î»x hx, _âŸ©,
    cases le_total a x with hax hax,
    { exact hu âŸ¨hax, hx.2âŸ© },
    { exact hl âŸ¨hx.1, haxâŸ© } },
  { rintros âŸ¨l, u, ha, hâŸ©,
    apply mem_sets_of_superset (is_open.mem_nhds is_open_Ioo ha) h }
end

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
lemma mem_nhds_iff_exists_Ioo_subset [no_top_order Î±] [no_bot_order Î±] {a : Î±} {s : set Î±} :
  s âˆˆ ğ“ a â†” âˆƒl u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† s :=
mem_nhds_iff_exists_Ioo_subset' (no_bot a) (no_top a)

lemma nhds_basis_Ioo' {a : Î±} (hl : âˆƒ l, l < a) (hu : âˆƒ u, a < u) :
  (ğ“ a).has_basis (Î» b : Î± Ã— Î±, b.1 < a âˆ§ a < b.2) (Î» b, Ioo b.1 b.2) :=
âŸ¨Î» s, (mem_nhds_iff_exists_Ioo_subset' hl hu).trans $ by simpâŸ©

lemma nhds_basis_Ioo [no_top_order Î±] [no_bot_order Î±] (a : Î±) :
  (ğ“ a).has_basis (Î» b : Î± Ã— Î±, b.1 < a âˆ§ a < b.2) (Î» b, Ioo b.1 b.2) :=
nhds_basis_Ioo' (no_bot a) (no_top a)

lemma filter.eventually.exists_Ioo_subset [no_top_order Î±] [no_bot_order Î±] {a : Î±} {p : Î± â†’ Prop}
  (hp : âˆ€á¶  x in ğ“ a, p x) :
  âˆƒ l u, a âˆˆ Ioo l u âˆ§ Ioo l u âŠ† {x | p x} :=
mem_nhds_iff_exists_Ioo_subset.1 hp

lemma Iio_mem_nhds {a b : Î±} (h : a < b) : Iio b âˆˆ ğ“ a :=
is_open.mem_nhds is_open_Iio h

lemma Ioi_mem_nhds {a b : Î±} (h : a < b) : Ioi a âˆˆ ğ“ b :=
is_open.mem_nhds is_open_Ioi h

lemma Iic_mem_nhds {a b : Î±} (h : a < b) : Iic b âˆˆ ğ“ a :=
mem_sets_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self

lemma Ici_mem_nhds {a b : Î±} (h : a < b) : Ici a âˆˆ ğ“ b :=
mem_sets_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self

lemma Ioo_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioo a b âˆˆ ğ“ x :=
is_open.mem_nhds is_open_Ioo âŸ¨ha, hbâŸ©

lemma Ioc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ioc a b âˆˆ ğ“ x :=
mem_sets_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self

lemma Ico_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Ico a b âˆˆ ğ“ x :=
mem_sets_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self

lemma Icc_mem_nhds {a b x : Î±} (ha : a < x) (hb : x < b) : Icc a b âˆˆ ğ“ x :=
mem_sets_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self

section pi

/-!
### Intervals in `Î  i, Ï€ i` belong to `ğ“ x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Î¹ â†’ â„`.
-/

variables {Î¹ : Type*} {Ï€ : Î¹ â†’ Type*} [fintype Î¹] [Î  i, linear_order (Ï€ i)]
  [Î  i, topological_space (Ï€ i)] [âˆ€ i, order_topology (Ï€ i)] {a b x : Î  i, Ï€ i} {a' b' x' : Î¹ â†’ Î±}

lemma pi_Iic_mem_nhds (ha : âˆ€ i, x i < a i) : Iic a âˆˆ ğ“ x :=
pi_univ_Iic a â–¸ set_pi_mem_nhds (finite.of_fintype _) (Î» i _, Iic_mem_nhds (ha _))

lemma pi_Iic_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iic a' âˆˆ ğ“ x' :=
pi_Iic_mem_nhds ha

lemma pi_Ici_mem_nhds (ha : âˆ€ i, a i < x i) : Ici a âˆˆ ğ“ x :=
pi_univ_Ici a â–¸ set_pi_mem_nhds (finite.of_fintype _) (Î» i _, Ici_mem_nhds (ha _))

lemma pi_Ici_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ici a' âˆˆ ğ“ x' :=
pi_Ici_mem_nhds ha

lemma pi_Icc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Icc a b âˆˆ ğ“ x :=
pi_univ_Icc a b â–¸ set_pi_mem_nhds (finite.of_fintype _) (Î» i _, Icc_mem_nhds (ha _) (hb _))

lemma pi_Icc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Icc a' b' âˆˆ ğ“ x' :=
pi_Icc_mem_nhds ha hb

variables [nonempty Î¹]

lemma pi_Iio_mem_nhds (ha : âˆ€ i, x i < a i) : Iio a âˆˆ ğ“ x :=
begin
  refine mem_sets_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Î» i _, _))
    (pi_univ_Iio_subset a),
  exact Iio_mem_nhds (ha i)
end

lemma pi_Iio_mem_nhds' (ha : âˆ€ i, x' i < a' i) : Iio a' âˆˆ ğ“ x' :=
pi_Iio_mem_nhds ha

lemma pi_Ioi_mem_nhds (ha : âˆ€ i, a i < x i) : Ioi a âˆˆ ğ“ x :=
@pi_Iio_mem_nhds Î¹ (Î» i, order_dual (Ï€ i)) _ _ _ _ _ _ _ ha

lemma pi_Ioi_mem_nhds' (ha : âˆ€ i, a' i < x' i) : Ioi a' âˆˆ ğ“ x' :=
pi_Ioi_mem_nhds ha

lemma pi_Ioc_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioc a b âˆˆ ğ“ x :=
begin
  refine mem_sets_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Î» i _, _))
    (pi_univ_Ioc_subset a b),
  exact Ioc_mem_nhds (ha i) (hb i)
end

lemma pi_Ioc_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioc a' b' âˆˆ ğ“ x' :=
pi_Ioc_mem_nhds ha hb

lemma pi_Ico_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ico a b âˆˆ ğ“ x :=
begin
  refine mem_sets_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Î» i _, _))
    (pi_univ_Ico_subset a b),
  exact Ico_mem_nhds (ha i) (hb i)
end

lemma pi_Ico_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ico a' b' âˆˆ ğ“ x' :=
pi_Ico_mem_nhds ha hb

lemma pi_Ioo_mem_nhds (ha : âˆ€ i, a i < x i) (hb : âˆ€ i, x i < b i) : Ioo a b âˆˆ ğ“ x :=
begin
  refine mem_sets_of_superset (set_pi_mem_nhds (finite.of_fintype _) (Î» i _, _))
    (pi_univ_Ioo_subset a b),
  exact Ioo_mem_nhds (ha i) (hb i)
end

lemma pi_Ioo_mem_nhds' (ha : âˆ€ i, a' i < x' i) (hb : âˆ€ i, x' i < b' i) : Ioo a' b' âˆˆ ğ“ x' :=
pi_Ioo_mem_nhds ha hb

end pi

lemma disjoint_nhds_at_top [no_top_order Î±] (x : Î±) :
  disjoint (ğ“ x) at_top :=
begin
  rw filter.disjoint_iff,
  cases no_top x with a ha,
  use [Iio a, Iio_mem_nhds ha, Ici a, mem_at_top a],
  rw [inter_comm, Ici_inter_Iio, Ico_self]
end

@[simp] lemma inf_nhds_at_top [no_top_order Î±] (x : Î±) :
  ğ“ x âŠ“ at_top = âŠ¥ :=
disjoint_iff.1 (disjoint_nhds_at_top x)

lemma disjoint_nhds_at_bot [no_bot_order Î±] (x : Î±) :
  disjoint (ğ“ x) at_bot :=
@disjoint_nhds_at_top (order_dual Î±) _ _ _ _ x

@[simp] lemma inf_nhds_at_bot [no_bot_order Î±] (x : Î±) :
  ğ“ x âŠ“ at_bot = âŠ¥ :=
@inf_nhds_at_top (order_dual Î±) _ _ _ _ x

lemma not_tendsto_nhds_of_tendsto_at_top [no_top_order Î±]
  {F : filter Î²} [ne_bot F] {f : Î² â†’ Î±} (hf : tendsto f F at_top) (x : Î±) :
  Â¬ tendsto f F (ğ“ x) :=
hf.not_tendsto (disjoint_nhds_at_top x).symm

lemma not_tendsto_at_top_of_tendsto_nhds [no_top_order Î±]
  {F : filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±} (hf : tendsto f F (ğ“ x)) :
  Â¬  tendsto f F at_top :=
hf.not_tendsto (disjoint_nhds_at_top x)

lemma not_tendsto_nhds_of_tendsto_at_bot [no_bot_order Î±]
  {F : filter Î²} [ne_bot F] {f : Î² â†’ Î±} (hf : tendsto f F at_bot) (x : Î±) :
  Â¬ tendsto f F (ğ“ x) :=
hf.not_tendsto (disjoint_nhds_at_bot x).symm

lemma not_tendsto_at_bot_of_tendsto_nhds [no_bot_order Î±]
  {F : filter Î²} [ne_bot F] {f : Î² â†’ Î±} {x : Î±} (hf : tendsto f F (ğ“ x)) :
  Â¬  tendsto f F at_bot :=
hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/

-- NB: If you extend the list, append to the end please to avoid breaking the API
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +âˆ)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ioi {a b : Î±} (hab : a < b) (s : set Î±) :
  tfae [s âˆˆ ğ“[Ioi a] a, -- 0 : `s` is a neighborhood of `a` within `(a, +âˆ)`
    s âˆˆ ğ“[Ioc a b] a,   -- 1 : `s` is a neighborhood of `a` within `(a, b]`
    s âˆˆ ğ“[Ioo a b] a,   -- 2 : `s` is a neighborhood of `a` within `(a, b)`
    âˆƒ u âˆˆ Ioc a b, Ioo a u âŠ† s,    -- 3 : `s` includes `(a, u)` for some `u âˆˆ (a, b]`
    âˆƒ u âˆˆ Ioi a, Ioo a u âŠ† s] :=   -- 4 : `s` includes `(a, u)` for some `u > a`
begin
  tfae_have : 1 â†” 2, by rw [nhds_within_Ioc_eq_nhds_within_Ioi hab],
  tfae_have : 1 â†” 3, by rw [nhds_within_Ioo_eq_nhds_within_Ioi hab],
  tfae_have : 4 â†’ 5, from Î» âŸ¨u, umem, huâŸ©, âŸ¨u, umem.1, huâŸ©,
  tfae_have : 5 â†’ 1,
  { rintros âŸ¨u, hau, huâŸ©,
    exact mem_sets_of_superset (Ioo_mem_nhds_within_Ioi âŸ¨le_refl a, hauâŸ©) hu },
  tfae_have : 1 â†’ 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©,
    refine âŸ¨u, au, Î»x hx, _âŸ©,
    refine hv âŸ¨hu âŸ¨le_of_lt hx.1, hx.2âŸ©, _âŸ©,
    exact hx.1 },
  tfae_finish
end

lemma mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Î±} {s : set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒu âˆˆ Ioc a u', Ioo a u âŠ† s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Î±} {s : set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒu âˆˆ Ioi a, Ioo a u âŠ† s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_top_order Î±] {a : Î±} {s : set Î±} :
  s âˆˆ ğ“[Ioi a] a â†” âˆƒu âˆˆ Ioi a, Ioo a u âŠ† s :=
let âŸ¨u', hu'âŸ© := no_top a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +âˆ)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_top_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Ioi a] a â†” âˆƒu âˆˆ Ioi a, Ioc a u âŠ† s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros âŸ¨u, au, asâŸ©,
    rcases exists_between au with âŸ¨v, hvâŸ©,
    exact âŸ¨v, hv.1, Î»x hx, as âŸ¨hx.1, lt_of_le_of_lt hx.2 hv.2âŸ©âŸ© },
  { rintros âŸ¨u, au, asâŸ©,
    exact âŸ¨u, au, subset.trans Ioo_subset_Ioc_self asâŸ© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
lemma tfae_mem_nhds_within_Iio {a b : Î±} (h : a < b) (s : set Î±) :
  tfae [s âˆˆ ğ“[Iio b] b, -- 0 : `s` is a neighborhood of `b` within `(-âˆ, b)`
    s âˆˆ ğ“[Ico a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b)`
    s âˆˆ ğ“[Ioo a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b)`
    âˆƒ l âˆˆ Ico a b, Ioo l b âŠ† s,    -- 3 : `s` includes `(l, b)` for some `l âˆˆ [a, b)`
    âˆƒ l âˆˆ Iio b, Ioo l b âŠ† s] :=   -- 4 : `s` includes `(l, b)` for some `l < b`
begin
  have := @tfae_mem_nhds_within_Ioi (order_dual Î±) _ _ _ _ _ h s,
  -- If we call `convert` here, it generates wrong equations, so we need to simplify first
  simp only [exists_prop] at this âŠ¢,
  rw [dual_Ioi, dual_Ioc, dual_Ioo] at this,
  convert this; ext l; rw [dual_Ioo]
end

lemma mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Î±} {s : set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒl âˆˆ Ico l' a, Ioo l a âŠ† s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Î±} {s : set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iio a] a â†” âˆƒl âˆˆ Iio a, Ioo l a âŠ† s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_bot_order Î±] {a : Î±} {s : set Î±} :
  s âˆˆ ğ“[Iio a] a â†” âˆƒl âˆˆ Iio a, Ioo l a âŠ† s :=
let âŸ¨l', hl'âŸ© := no_bot a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

/-- A set is a neighborhood of `a` within `(-âˆ, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_bot_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Iio a] a â†” âˆƒl âˆˆ Iio a, Ico l a âŠ† s :=
begin
  convert @mem_nhds_within_Ioi_iff_exists_Ioc_subset (order_dual Î±) _ _ _ _ _ _ _,
  simp only [dual_Ioc], refl
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +âˆ)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u âˆˆ (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ici {a b : Î±} (hab : a < b) (s : set Î±) :
  tfae [s âˆˆ ğ“[Ici a] a, -- 0 : `s` is a neighborhood of `a` within `[a, +âˆ)`
    s âˆˆ ğ“[Icc a b] a,   -- 1 : `s` is a neighborhood of `a` within `[a, b]`
    s âˆˆ ğ“[Ico a b] a,   -- 2 : `s` is a neighborhood of `a` within `[a, b)`
    âˆƒ u âˆˆ Ioc a b, Ico a u âŠ† s,    -- 3 : `s` includes `[a, u)` for some `u âˆˆ (a, b]`
    âˆƒ u âˆˆ Ioi a, Ico a u âŠ† s] :=   -- 4 : `s` includes `[a, u)` for some `u > a`
begin
  tfae_have : 1 â†” 2, by rw [nhds_within_Icc_eq_nhds_within_Ici hab],
  tfae_have : 1 â†” 3, by rw [nhds_within_Ico_eq_nhds_within_Ici hab],
  tfae_have : 4 â†’ 5, from Î» âŸ¨u, umem, huâŸ©, âŸ¨u, umem.1, huâŸ©,
  tfae_have : 5 â†’ 1,
  { rintros âŸ¨u, hau, huâŸ©,
    exact mem_sets_of_superset (Ico_mem_nhds_within_Ici âŸ¨le_refl a, hauâŸ©) hu },
  tfae_have : 1 â†’ 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with âŸ¨v, va, hvâŸ©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with âŸ¨u, au, huâŸ©,
    refine âŸ¨u, au, Î»x hx, _âŸ©,
    refine hv âŸ¨hu âŸ¨hx.1, hx.2âŸ©, _âŸ©,
    exact hx.1 },
  tfae_finish
end

lemma mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Î±} {s : set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒu âˆˆ Ioc a u', Ico a u âŠ† s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Î±} {s : set Î±} (hu' : a < u') :
  s âˆˆ ğ“[Ici a] a â†” âˆƒu âˆˆ Ioi a, Ico a u âŠ† s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_top_order Î±] {a : Î±} {s : set Î±} :
  s âˆˆ ğ“[Ici a] a â†” âˆƒu âˆˆ Ioi a, Ico a u âŠ† s :=
let âŸ¨u', hu'âŸ© := no_top a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset' [no_top_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Ici a] a â†” âˆƒu âˆˆ Ioi a, Icc a u âŠ† s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros âŸ¨u, au, asâŸ©,
    rcases exists_between au with âŸ¨v, hvâŸ©,
    exact âŸ¨v, hv.1, Î»x hx, as âŸ¨hx.1, lt_of_le_of_lt hx.2 hv.2âŸ©âŸ© },
  { rintros âŸ¨u, au, asâŸ©,
    exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-âˆ, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l âˆˆ [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
lemma tfae_mem_nhds_within_Iic {a b : Î±} (h : a < b) (s : set Î±) :
  tfae [s âˆˆ ğ“[Iic b] b, -- 0 : `s` is a neighborhood of `b` within `(-âˆ, b]`
    s âˆˆ ğ“[Icc a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b]`
    s âˆˆ ğ“[Ioc a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b]`
    âˆƒ l âˆˆ Ico a b, Ioc l b âŠ† s,    -- 3 : `s` includes `(l, b]` for some `l âˆˆ [a, b)`
    âˆƒ l âˆˆ Iio b, Ioc l b âŠ† s] :=   -- 4 : `s` includes `(l, b]` for some `l < b`
begin
  have := @tfae_mem_nhds_within_Ici (order_dual Î±) _ _ _ _ _ h s,
  -- If we call `convert` here, it generates wrong equations, so we need to simplify first
  simp only [exists_prop] at this âŠ¢,
  rw [dual_Icc, dual_Ioc, dual_Ioi] at this,
  convert this; ext l; rw [dual_Ico]
end

lemma mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Î±} {s : set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒl âˆˆ Ico l' a, Ioc l a âŠ† s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Î±} {s : set Î±} (hl' : l' < a) :
  s âˆˆ ğ“[Iic a] a â†” âˆƒl âˆˆ Iio a, Ioc l a âŠ† s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_bot_order Î±] {a : Î±} {s : set Î±} :
  s âˆˆ ğ“[Iic a] a â†” âˆƒl âˆˆ Iio a, Ioc l a âŠ† s :=
let âŸ¨l', hl'âŸ© := no_bot a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset' [no_bot_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Iic a] a â†” âˆƒl âˆˆ Iio a, Icc l a âŠ† s :=
begin
  convert @mem_nhds_within_Ici_iff_exists_Icc_subset' (order_dual Î±) _ _ _ _ _ _ _,
  simp_rw (show âˆ€ u : order_dual Î±, @Icc (order_dual Î±) _ a u = @Icc Î± _ u a, from Î» u, dual_Icc),
  refl,
end

/-- A set is a neighborhood of `a` within `[a, +âˆ)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_top_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Ici a] a â†” âˆƒu, a < u âˆ§ Icc a u âŠ† s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros âŸ¨u, au, asâŸ©,
    rcases exists_between au with âŸ¨v, hvâŸ©,
    exact âŸ¨v, hv.1, Î»x hx, as âŸ¨hx.1, lt_of_le_of_lt hx.2 hv.2âŸ©âŸ© },
  { rintros âŸ¨u, au, asâŸ©,
    exact âŸ¨u, au, subset.trans Ico_subset_Icc_self asâŸ© }
end

/-- A set is a neighborhood of `a` within `(-âˆ, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_bot_order Î±] [densely_ordered Î±]
  {a : Î±} {s : set Î±} : s âˆˆ ğ“[Iic a] a â†” âˆƒl, l < a âˆ§ Icc l a âŠ† s :=
begin
  rw mem_nhds_within_Iic_iff_exists_Ioc_subset,
  split,
  { rintros âŸ¨l, la, asâŸ©,
    rcases exists_between la with âŸ¨v, hvâŸ©,
    refine âŸ¨v, hv.2, Î»x hx, as âŸ¨lt_of_lt_of_le hv.1 hx.1, hx.2âŸ©âŸ©, },
  { rintros âŸ¨l, la, asâŸ©,
    exact âŸ¨l, la, subset.trans Ioc_subset_Icc_self asâŸ© }
end

end linear_order

section linear_ordered_add_comm_group
variables [topological_space Î±] [linear_ordered_add_comm_group Î±] [order_topology Î±]
variables {l : filter Î²} {f g : Î² â†’ Î±}

local notation `|` x `|` := abs x

lemma nhds_eq_infi_abs_sub (a : Î±) : ğ“ a = (â¨…r>0, ğ“Ÿ {b | |a - b| < r}) :=
begin
  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi,
    mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt _ _ _ _ a, set_of_and],
  refine âŸ¨_, _, _âŸ©,
  { intros Îµ Îµ0,
    exact inter_mem_inf_sets
      (mem_infi_sets (a - Îµ) $ mem_infi_sets (sub_lt_self a Îµ0) (mem_principal_self _))
      (mem_infi_sets (Îµ + a) $ mem_infi_sets (by simpa) (mem_principal_self _)) },
  { intros b hb,
    exact mem_infi_sets (a - b) (mem_infi_sets (sub_pos.2 hb) (by simp [Ioi])) },
  { intros b hb,
    exact mem_infi_sets (b - a) (mem_infi_sets (sub_pos.2 hb) (by simp [Iio])) }
end

lemma order_topology_of_nhds_abs {Î± : Type*} [topological_space Î±] [linear_ordered_add_comm_group Î±]
  (h_nhds : âˆ€a:Î±, ğ“ a = (â¨…r>0, ğ“Ÿ {b | |a - b| < r})) : order_topology Î± :=
begin
  refine âŸ¨eq_of_nhds_eq_nhds $ Î» a, _âŸ©,
  rw [h_nhds],
  letI := preorder.topology Î±, letI : order_topology Î± := âŸ¨rflâŸ©,
  exact (nhds_eq_infi_abs_sub a).symm
end

lemma linear_ordered_add_comm_group.tendsto_nhds {x : filter Î²} {a : Î±} :
  tendsto f x (ğ“ a) â†” âˆ€ Îµ > (0 : Î±), âˆ€á¶  b in x, |f b - a| < Îµ :=
by simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

lemma eventually_abs_sub_lt (a : Î±) {Îµ : Î±} (hÎµ : 0 < Îµ) : âˆ€á¶  x in ğ“ a, |x - a| < Îµ :=
(nhds_eq_infi_abs_sub a).symm â–¸ mem_infi_sets Îµ
  (mem_infi_sets hÎµ $ by simp only [abs_sub_comm, mem_principal_self])

@[priority 100] -- see Note [lower instance priority]
instance linear_ordered_add_comm_group.topological_add_group : topological_add_group Î± :=
{ continuous_add :=
    begin
      refine continuous_iff_continuous_at.2 _,
      rintro âŸ¨a, bâŸ©,
      refine linear_ordered_add_comm_group.tendsto_nhds.2 (Î» Îµ Îµ0, _),
      rcases dense_or_discrete 0 Îµ with (âŸ¨Î´, Î´0, Î´ÎµâŸ©|âŸ¨hâ‚, hâ‚‚âŸ©),
      { -- If there exists `Î´ âˆˆ (0, Îµ)`, then we choose `Î´`-nhd of `a` and `(Îµ-Î´)`-nhd of `b`
        filter_upwards [prod_is_open.mem_nhds (eventually_abs_sub_lt a Î´0)
          (eventually_abs_sub_lt b (sub_pos.2 Î´Îµ))],
        rintros âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Î´, hy : |y - b| < Îµ - Î´âŸ©,
        rw [add_sub_comm],
        calc |x - a + (y - b)| â‰¤ |x - a| + |y - b| : abs_add _ _
        ... < Î´ + (Îµ - Î´) : add_lt_add hx hy
        ... = Îµ : add_sub_cancel'_right _ _ },
      { -- Otherewise `Îµ`-nhd of each point `a` is `{a}`
        have hÎµ : âˆ€ {x y}, abs (x - y) < Îµ â†’ x = y,
        { intros x y h,
          simpa [sub_eq_zero] using hâ‚‚ _ h },
        filter_upwards [prod_is_open.mem_nhds (eventually_abs_sub_lt a Îµ0)
          (eventually_abs_sub_lt b Îµ0)],
        rintros âŸ¨x, yâŸ© âŸ¨hx : |x - a| < Îµ, hy : |y - b| < ÎµâŸ©,
        simpa [hÎµ hx, hÎµ hy] }
    end,
  continuous_neg := continuous_iff_continuous_at.2 $ Î» a,
    linear_ordered_add_comm_group.tendsto_nhds.2 $ Î» Îµ Îµ0,
      (eventually_abs_sub_lt a Îµ0).mono $ Î» x hx, by rwa [neg_sub_neg, abs_sub_comm] }

@[continuity]
lemma continuous_abs : continuous (abs : Î± â†’ Î±) := continuous_id.max continuous_neg

lemma filter.tendsto.abs {f : Î² â†’ Î±} {a : Î±} {l : filter Î²} (h : tendsto f l (ğ“ a)) :
  tendsto (Î» x, |f x|) l (ğ“ (|a|)) :=
(continuous_abs.tendsto _).comp h

lemma nhds_basis_Ioo_pos [no_bot_order Î±] [no_top_order Î±] (a : Î±) :
  (ğ“ a).has_basis (Î» Îµ : Î±, (0 : Î±) < Îµ) (Î» Îµ, Ioo (a-Îµ) (a+Îµ)) :=
âŸ¨begin
  refine Î» t, (nhds_basis_Ioo a).mem_iff.trans âŸ¨_, _âŸ©,
  { rintros âŸ¨âŸ¨l, uâŸ©, âŸ¨hl : l < a, hu : a < uâŸ©, h' : Ioo l u âŠ† tâŸ©,
    refine âŸ¨min (a-l) (u-a), by apply lt_min; rwa sub_pos, _âŸ©,
    rintros x âŸ¨hx, hx'âŸ©,
    apply h',
    rw [sub_lt, lt_min_iff, sub_lt_sub_iff_left] at hx,
    rw [â† sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx',
    exact âŸ¨hx.1, hx'.2âŸ© },
  { rintros âŸ¨Îµ, Îµ_pos, hâŸ©,
    exact âŸ¨(a-Îµ, a+Îµ), by simp [Îµ_pos], hâŸ© },
endâŸ©

lemma nhds_basis_abs_sub_lt [no_bot_order Î±] [no_top_order Î±] (a : Î±) :
  (ğ“ a).has_basis (Î» Îµ : Î±, (0 : Î±) < Îµ) (Î» Îµ, {b | abs (b - a) < Îµ}) :=
begin
  convert nhds_basis_Ioo_pos a,
  { ext Îµ,
    change abs (x - a) < Îµ â†” a - Îµ < x âˆ§ x < a + Îµ,
    simp [abs_lt, sub_lt_iff_lt_add, add_comm Îµ a, add_comm x Îµ] }
end

variable (Î±)

lemma nhds_basis_zero_abs_sub_lt [no_bot_order Î±] [no_top_order Î±] :
  (ğ“ (0 : Î±)).has_basis (Î» Îµ : Î±, (0 : Î±) < Îµ) (Î» Îµ, {b | abs b < Îµ}) :=
by simpa using nhds_basis_abs_sub_lt (0 : Î±)

variable {Î±}

/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
lemma nhds_basis_Ioo_pos_of_pos [no_bot_order Î±] [no_top_order Î±]
  {a : Î±} (ha : 0 < a) :
  (ğ“ a).has_basis (Î» Îµ : Î±, (0 : Î±) < Îµ âˆ§ Îµ â‰¤ a) (Î» Îµ, Ioo (a-Îµ) (a+Îµ)) :=
âŸ¨ Î» t, (nhds_basis_Ioo_pos a).mem_iff.trans
  âŸ¨Î» h, let âŸ¨i, hi, hitâŸ© := h in
    âŸ¨min i a, âŸ¨lt_min hi ha, min_le_right i aâŸ©, trans (Ioo_subset_Ioo
    (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hitâŸ©,
  Î» h, let âŸ¨i, hi, hitâŸ© := h in âŸ¨i, hi.1, hitâŸ© âŸ© âŸ©

section

variables [topological_space Î²] {b : Î²} {a : Î±} {s : set Î²}

lemma continuous.abs (h : continuous f) : continuous (Î» x, |f x|) := continuous_abs.comp h

lemma continuous_at.abs (h : continuous_at f b) : continuous_at (Î» x, |f x|) b := h.abs

lemma continuous_within_at.abs (h : continuous_within_at f s b) :
  continuous_within_at (Î» x, |f x|) s b := h.abs

lemma continuous_on.abs (h : continuous_on f s) : continuous_on (Î» x, |f x|) s :=
Î» x hx, (h x hx).abs

lemma tendsto_abs_nhds_within_zero : tendsto (abs : Î± â†’ Î±) (ğ“[{0}á¶œ] 0) (ğ“[Ioi 0] 0) :=
(continuous_abs.tendsto' (0 : Î±) 0 abs_zero).inf $ tendsto_principal_principal.2 $ Î» x, abs_pos.2

end

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.add_at_top {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_top) :
  tendsto (Î» x, f x + g x) l at_top :=
begin
  nontriviality Î±,
  obtain âŸ¨C', hC'âŸ© : âˆƒ C', C' < C := no_bot C,
  refine tendsto_at_top_add_left_of_le' _ C' _ hg,
  exact (hf.eventually (lt_mem_nhds hC')).mono (Î» x, le_of_lt)
end

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.add_at_bot {C : Î±} (hf : tendsto f l (ğ“ C)) (hg : tendsto g l at_bot) :
  tendsto (Î» x, f x + g x) l at_bot :=
@filter.tendsto.add_at_top (order_dual Î±) _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.at_top_add {C : Î±} (hf : tendsto f l at_top) (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, f x + g x) l at_top :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.at_bot_add {C : Î±} (hf : tendsto f l at_bot) (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, f x + g x) l at_bot :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }

end linear_ordered_add_comm_group

section linear_ordered_field
variables [linear_ordered_field Î±] [topological_space Î±] [order_topology Î±]
variables {l : filter Î²} {f g : Î² â†’ Î±}

section continuous_mul

lemma mul_tendsto_nhds_zero_right (x : Î±) :
  tendsto (uncurry ((*) : Î± â†’ Î± â†’ Î±)) (ğ“ 0 Ã—á¶  ğ“ x) $ ğ“ 0 :=
begin
  have hx : 0 < 2 * (1 + abs x) := (mul_pos (zero_lt_two) $
    lt_of_lt_of_le zero_lt_one $ le_add_of_le_of_nonneg le_rfl (abs_nonneg x)),
  rw ((nhds_basis_zero_abs_sub_lt Î±).prod $ nhds_basis_abs_sub_lt x).tendsto_iff
     (nhds_basis_zero_abs_sub_lt Î±),
  refine Î» Îµ Îµ_pos, âŸ¨(Îµ/(2 * (1 + abs x)), 1), âŸ¨div_pos Îµ_pos hx, zero_lt_oneâŸ©, _âŸ©,
  suffices : âˆ€ (a b : Î±), abs a < Îµ / (2 * (1 + abs x)) â†’ abs (b - x) < 1 â†’ (abs a) * (abs b) < Îµ,
  by simpa only [and_imp, prod.forall, mem_prod, â† abs_mul],
  intros a b h h',
  refine lt_of_le_of_lt (mul_le_mul_of_nonneg_left _ (abs_nonneg a)) ((lt_div_iff hx).1 h),
  calc abs b = abs ((b - x) + x) : by rw sub_add_cancel b x
    ... â‰¤ abs (b - x) + abs x : abs_add (b - x) x
    ... â‰¤ 1 + abs x : add_le_add_right (le_of_lt h') (abs x)
    ... â‰¤ 2 * (1 + abs x) : by linarith,
end

lemma mul_tendsto_nhds_zero_left (x : Î±) :
  tendsto (uncurry ((*) : Î± â†’ Î± â†’ Î±)) (ğ“ x Ã—á¶  ğ“ 0) $ ğ“ 0 :=
begin
  intros s hs,
  have := mul_tendsto_nhds_zero_right x hs,
  rw [filter.mem_map, mem_prod_iff] at this âŠ¢,
  obtain âŸ¨U, hU, V, hV, hâŸ© := this,
  exact âŸ¨V, hV, U, hU, Î» y hy, ((mul_comm y.2 y.1) â–¸
    h (âŸ¨hy.2, hy.1âŸ© : (prod.mk y.2 y.1) âˆˆ (U.prod V)) : y.1 * y.2 âˆˆ s)âŸ©,
end

lemma nhds_eq_map_mul_left_nhds_one {xâ‚€ : Î±} (hxâ‚€ : xâ‚€ â‰  0) :
  ğ“ xâ‚€ = map (Î» x, xâ‚€*x) (ğ“ 1) :=
begin
  have hxâ‚€' : 0 < abs xâ‚€ := abs_pos.2 hxâ‚€,
  refine filter.ext (Î» t, _),
  simp only [exists_prop, set_of_subset_set_of, (nhds_basis_abs_sub_lt xâ‚€).mem_iff,
    (nhds_basis_abs_sub_lt (1 : Î±)).mem_iff, filter.mem_map],
  refine âŸ¨Î» h, _, Î» h, _âŸ©,
  { obtain âŸ¨i, hi, hitâŸ© := h,
    refine âŸ¨i / (abs xâ‚€), div_pos hi (abs_pos.2 hxâ‚€), Î» x hx, hit _âŸ©,
    calc abs (xâ‚€ * x - xâ‚€) = abs (xâ‚€ * (x - 1)) : congr_arg abs (by ring_nf)
      ... = abs xâ‚€ * abs (x - 1) : abs_mul xâ‚€ (x - 1)
      ... < abs xâ‚€ * (i / abs xâ‚€) : mul_lt_mul' le_rfl hx (abs_nonneg (x - 1)) (abs_pos.2 hxâ‚€)
      ... = abs xâ‚€ * i / abs xâ‚€ : by ring
      ... = i : mul_div_cancel_left i (Î» h, hxâ‚€ (abs_eq_zero.1 h)) },
  { obtain âŸ¨i, hi, hitâŸ© := h,
    refine âŸ¨i * (abs xâ‚€), mul_pos hi (abs_pos.2 hxâ‚€), Î» x hx, _âŸ©,
    have : abs (x / xâ‚€ - 1) < i,
    calc abs (x / xâ‚€ - 1) = abs (x / xâ‚€ - xâ‚€ / xâ‚€) : (by rw div_self hxâ‚€)
    ... = abs ((x - xâ‚€) / xâ‚€) : congr_arg abs (sub_div x xâ‚€ xâ‚€).symm
    ... = abs (x - xâ‚€) / abs xâ‚€ : abs_div (x - xâ‚€) xâ‚€
    ... < i * abs xâ‚€ / abs xâ‚€ : div_lt_div hx le_rfl
      (mul_nonneg (le_of_lt hi) (abs_nonneg xâ‚€)) (abs_pos.2 hxâ‚€)
    ... = i : by rw [â† mul_div_assoc', div_self (ne_of_lt $ abs_pos.2 hxâ‚€).symm, mul_one],
    specialize hit (x / xâ‚€) this,
    rwa [mul_div_assoc', mul_div_cancel_left x hxâ‚€] at hit }
end

lemma nhds_eq_map_mul_right_nhds_one {xâ‚€ : Î±} (hxâ‚€ : xâ‚€ â‰  0) :
  ğ“ xâ‚€ = map (Î» x, x*xâ‚€) (ğ“ 1) :=
by simp_rw [mul_comm _ xâ‚€, nhds_eq_map_mul_left_nhds_one hxâ‚€]

lemma mul_tendsto_nhds_one_nhds_one :
  tendsto (uncurry ((*) : Î± â†’ Î± â†’ Î±)) (ğ“ 1 Ã—á¶  ğ“ 1) $ ğ“ 1 :=
begin
  rw ((nhds_basis_Ioo_pos (1 : Î±)).prod $ nhds_basis_Ioo_pos (1 : Î±)).tendsto_iff
     (nhds_basis_Ioo_pos_of_pos (zero_lt_one : (0 : Î±) < 1)),
  intros Îµ hÎµ,
  have hÎµ' : 0 â‰¤ 1 - Îµ / 4 := by linarith,
  have Îµ_pos : 0 < Îµ / 4 := by linarith,
  have Îµ_pos' : 0 < Îµ / 2 := by linarith,
  simp only [and_imp, prod.forall, mem_Ioo, function.uncurry_apply_pair, mem_prod, prod.exists],
  refine âŸ¨Îµ/4, Îµ/4, âŸ¨Îµ_pos, Îµ_posâŸ©, Î» a b ha ha' hb hb', _âŸ©,
  have ha0 : 0 â‰¤ a := le_trans hÎµ' (le_of_lt ha),
  have hb0 : 0 â‰¤ b := le_trans hÎµ' (le_of_lt hb),
  refine âŸ¨lt_of_le_of_lt _ (mul_lt_mul'' ha hb hÎµ' hÎµ'),
    lt_of_lt_of_le (mul_lt_mul'' ha' hb' ha0 hb0) _âŸ©,
  { calc 1 - Îµ = 1 - Îµ / 2 - Îµ/2 : by ring_nf
    ... â‰¤ 1 - Îµ/2 - Îµ/2 + (Îµ/2)*(Îµ/2) : le_add_of_nonneg_right (le_of_lt (mul_pos Îµ_pos' Îµ_pos'))
    ... = (1 - Îµ/2) * (1 - Îµ/2) : by ring_nf
    ... â‰¤ (1 - Îµ/4) * (1 - Îµ/4) : mul_le_mul (by linarith) (by linarith) (by linarith) hÎµ' },
  { calc (1 + Îµ/4) * (1 + Îµ/4) = 1 + Îµ/2 + (Îµ/4)*(Îµ/4) : by ring_nf
    ... = 1 + Îµ/2 + (Îµ * Îµ) / 16 : by ring_nf
    ... â‰¤ 1 + Îµ/2 + Îµ/2 : add_le_add_left (div_le_div (le_of_lt hÎµ.1) (le_trans
      ((mul_le_mul_left hÎµ.1).2 hÎµ.2) (le_of_eq $ mul_one Îµ)) zero_lt_two (by linarith)) (1 + Îµ/2)
    ... â‰¤ 1 + Îµ : by ring_nf }
end

@[priority 100]
instance linear_ordered_field.has_continuous_mul : has_continuous_mul Î± :=
âŸ¨begin
  rw continuous_iff_continuous_at,
  rintro âŸ¨xâ‚€, yâ‚€âŸ©,
  by_cases hxâ‚€ : xâ‚€ = 0,
  { rw [hxâ‚€, continuous_at, zero_mul, nhds_prod_eq],
    exact mul_tendsto_nhds_zero_right yâ‚€ },
  by_cases hyâ‚€ : yâ‚€ = 0,
  { rw [hyâ‚€, continuous_at, mul_zero, nhds_prod_eq],
    exact mul_tendsto_nhds_zero_left xâ‚€ },
  have hxy : xâ‚€ * yâ‚€ â‰  0 := mul_ne_zero hxâ‚€ hyâ‚€,
  have key : (Î» p : Î± Ã— Î±, xâ‚€ * p.1 * (p.2 * yâ‚€)) = ((Î» x, xâ‚€*x) âˆ˜ (Î» x, x*yâ‚€)) âˆ˜ (uncurry (*)),
  { ext p, simp [uncurry, mul_assoc] },
  have keyâ‚‚ : (Î» x, xâ‚€*x) âˆ˜ (Î» x, yâ‚€*x) = Î» x, (xâ‚€ *yâ‚€)*x,
  { ext x, simp },
  calc map (uncurry (*)) (ğ“ (xâ‚€, yâ‚€))
      = map (uncurry (*)) (ğ“ xâ‚€ Ã—á¶  ğ“ yâ‚€) : by rw nhds_prod_eq
  ... = map (Î» (p : Î± Ã— Î±), xâ‚€ * p.1 * (p.2 * yâ‚€)) ((ğ“ 1) Ã—á¶  (ğ“ 1))
          : by rw [uncurry, nhds_eq_map_mul_left_nhds_one hxâ‚€, nhds_eq_map_mul_right_nhds_one hyâ‚€,
                    prod_map_map_eq, filter.map_map]
  ... = map ((Î» x, xâ‚€ * x) âˆ˜ Î» x, x * yâ‚€) (map (uncurry (*)) (ğ“ 1 Ã—á¶  ğ“ 1))
          : by rw [key, â† filter.map_map]
  ... â‰¤ map ((Î» (x : Î±), xâ‚€ * x) âˆ˜ Î» x, x * yâ‚€) (ğ“ 1) : map_mono (mul_tendsto_nhds_one_nhds_one)
  ... = ğ“ (xâ‚€*yâ‚€) : by rw [â† filter.map_map, â† nhds_eq_map_mul_right_nhds_one hyâ‚€,
    nhds_eq_map_mul_left_nhds_one hyâ‚€, filter.map_map, keyâ‚‚, â† nhds_eq_map_mul_left_nhds_one hxy],
endâŸ©

end continuous_mul

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a positive constant `C` then `f * g` tends to `at_top`. -/
lemma filter.tendsto.at_top_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_top)
  (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, (f x * g x)) l at_top :=
begin
  refine tendsto_at_top_mono' _ _ (hf.at_top_mul_const (half_pos hC)),
  filter_upwards [hg.eventually (lt_mem_nhds (half_lt_self hC)),
    hf.eventually (eventually_ge_at_top 0)],
  exact Î» x hg hf, mul_le_mul_of_nonneg_left hg.le hf
end

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_top`. -/
lemma filter.tendsto.mul_at_top {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C))
  (hg : tendsto g l at_top) :
  tendsto (Î» x, (f x * g x)) l at_top :=
by simpa only [mul_comm] using hg.at_top_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_top` and `g` tends to
a negative constant `C` then `f * g` tends to `at_bot`. -/
lemma filter.tendsto.at_top_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_top)
  (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, (f x * g x)) l at_bot :=
by simpa only [(âˆ˜), neg_mul_eq_mul_neg, neg_neg]
  using tendsto_neg_at_top_at_bot.comp (hf.at_top_mul (neg_pos.2 hC) hg.neg)

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_top` then `f * g` tends to `at_bot`. -/
lemma filter.tendsto.neg_mul_at_top {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C))
  (hg : tendsto g l at_top) :
  tendsto (Î» x, (f x * g x)) l at_bot :=
by simpa only [mul_comm] using hg.at_top_mul_neg hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a positive constant `C` then `f * g` tends to `at_bot`. -/
lemma filter.tendsto.at_bot_mul {C : Î±} (hC : 0 < C) (hf : tendsto f l at_bot)
  (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, (f x * g x)) l at_bot :=
by simpa [(âˆ˜)]
  using tendsto_neg_at_top_at_bot.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to `at_bot` and `g` tends to
a negative constant `C` then `f * g` tends to `at_top`. -/
lemma filter.tendsto.at_bot_mul_neg {C : Î±} (hC : C < 0) (hf : tendsto f l at_bot)
  (hg : tendsto g l (ğ“ C)) :
  tendsto (Î» x, (f x * g x)) l at_top :=
by simpa [(âˆ˜)]
  using tendsto_neg_at_bot_at_top.comp ((tendsto_neg_at_bot_at_top.comp hf).at_top_mul_neg hC hg)

/-- In a linearly ordered field with the order topology, if `f` tends to a positive constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_bot`. -/
lemma filter.tendsto.mul_at_bot {C : Î±} (hC : 0 < C) (hf : tendsto f l (ğ“ C))
  (hg : tendsto g l at_bot) :
  tendsto (Î» x, (f x * g x)) l at_bot :=
by simpa only [mul_comm] using hg.at_bot_mul hC hf

/-- In a linearly ordered field with the order topology, if `f` tends to a negative constant `C` and
`g` tends to `at_bot` then `f * g` tends to `at_top`. -/
lemma filter.tendsto.neg_mul_at_bot {C : Î±} (hC : C < 0) (hf : tendsto f l (ğ“ C))
  (hg : tendsto g l at_bot) :
  tendsto (Î» x, (f x * g x)) l at_top :=
by simpa only [mul_comm] using hg.at_bot_mul_neg hC hf

/-- The function `x â†¦ xâ»Â¹` tends to `+âˆ` on the right of `0`. -/
lemma tendsto_inv_zero_at_top : tendsto (Î»x:Î±, xâ»Â¹) (ğ“[set.Ioi (0:Î±)] 0) at_top :=
begin
  refine (at_top_basis' 1).tendsto_right_iff.2 (Î» b hb, _),
  have hb' : 0 < b := zero_lt_one.trans_le hb,
  filter_upwards [Ioc_mem_nhds_within_Ioi âŸ¨le_rfl, inv_pos.2 hb'âŸ©],
  exact Î» x hx, (le_inv hx.1 hb').1 hx.2
end

/-- The function `r â†¦ râ»Â¹` tends to `0` on the right as `r â†’ +âˆ`. -/
lemma tendsto_inv_at_top_zero' : tendsto (Î»r:Î±, râ»Â¹) at_top (ğ“[set.Ioi (0:Î±)] 0) :=
begin
  refine (has_basis.tendsto_iff at_top_basis âŸ¨Î» s, mem_nhds_within_Ioi_iff_exists_Ioc_subsetâŸ©).2 _,
  refine Î» b hb, âŸ¨bâ»Â¹, trivial, Î» x hx, _âŸ©,
  have : 0 < x := lt_of_lt_of_le (inv_pos.2 hb) hx,
  exact âŸ¨inv_pos.2 this, (inv_le this hb).2 hxâŸ©
end

lemma tendsto_inv_at_top_zero : tendsto (Î»r:Î±, râ»Â¹) at_top (ğ“ 0) :=
tendsto_inv_at_top_zero'.mono_right inf_le_left

lemma filter.tendsto.div_at_top [has_continuous_mul Î±] {f g : Î² â†’ Î±} {l : filter Î²} {a : Î±}
  (h : tendsto f l (ğ“ a)) (hg : tendsto g l at_top) : tendsto (Î» x, f x / g x) l (ğ“ 0) :=
by { simp only [div_eq_mul_inv], exact mul_zero a â–¸ h.mul (tendsto_inv_at_top_zero.comp hg) }

lemma filter.tendsto.inv_tendsto_at_top (h : tendsto f l at_top) : tendsto (fâ»Â¹) l (ğ“ 0) :=
tendsto_inv_at_top_zero.comp h

lemma filter.tendsto.inv_tendsto_zero (h : tendsto f l (ğ“[set.Ioi 0] 0)) :
  tendsto (fâ»Â¹) l at_top :=
tendsto_inv_zero_at_top.comp h

/-- The function `x^(-n)` tends to `0` at `+âˆ` for any positive natural `n`.
A version for positive real powers exists as `tendsto_rpow_neg_at_top`. -/
lemma tendsto_pow_neg_at_top {n : â„•} (hn : 1 â‰¤ n) : tendsto (Î» x : Î±, x ^ (-(n:â„¤))) at_top (ğ“ 0) :=
tendsto.congr (Î» x, (fpow_neg x n).symm)
  (filter.tendsto.inv_tendsto_at_top (by simpa [gpow_coe_nat] using tendsto_pow_at_top hn))

lemma tendsto_fpow_at_top_zero {n : â„¤} (hn : n < 0) :
  tendsto (Î» x : Î±, x^n) at_top (ğ“ 0) :=
begin
  have : 1 â‰¤ -n := le_neg.mp (int.le_of_lt_add_one (hn.trans_le (neg_add_self 1).symm.le)),
  apply tendsto.congr (show âˆ€ x : Î±, x^-(-n) = x^n, by simp),
  lift -n to â„• using le_of_lt (neg_pos.mpr hn) with N,
  exact tendsto_pow_neg_at_top (by exact_mod_cast this)
end

lemma tendsto_const_mul_fpow_at_top_zero {n : â„¤} {c : Î±} (hn : n < 0) :
  tendsto (Î» x, c * x ^ n) at_top (ğ“ 0) :=
(mul_zero c) â–¸ (filter.tendsto.const_mul c (tendsto_fpow_at_top_zero hn))

lemma tendsto_const_mul_pow_nhds_iff {n : â„•} {c d : Î±} (hc : c â‰  0) :
  tendsto (Î» x : Î±, c * x ^ n) at_top (ğ“ d) â†” n = 0 âˆ§ c = d :=
begin
  refine âŸ¨Î» h, _, Î» h, _âŸ©,
  { have hn : n = 0,
    { by_contradiction hn,
      have hn : 1 â‰¤ n := nat.succ_le_iff.2 (lt_of_le_of_ne (zero_le _) (ne.symm hn)),
      by_cases hc' : 0 < c,
      { have := (tendsto_const_mul_pow_at_top_iff c n).2 âŸ¨hn, hc'âŸ©,
        exact not_tendsto_nhds_of_tendsto_at_top this d h },
      { have := (tendsto_neg_const_mul_pow_at_top_iff c n).2 âŸ¨hn, lt_of_le_of_ne (not_lt.1 hc') hcâŸ©,
        exact not_tendsto_nhds_of_tendsto_at_bot this d h } },
    have : (Î» x : Î±, c * x ^ n) = (Î» x : Î±, c), by simp [hn],
    rw [this, tendsto_const_nhds_iff] at h,
    exact âŸ¨hn, hâŸ© },
  { obtain âŸ¨hn, hcdâŸ© := h,
    simpa [hn, hcd] using tendsto_const_nhds }
end

lemma tendsto_const_mul_fpow_at_top_zero_iff {n : â„¤} {c d : Î±} (hc : c â‰  0) :
  tendsto (Î» x : Î±, c * x ^ n) at_top (ğ“ d) â†”
    (n = 0 âˆ§ c = d) âˆ¨ (n < 0 âˆ§ d = 0) :=
begin
  refine âŸ¨Î» h, _, Î» h, _âŸ©,
  { by_cases hn : 0 â‰¤ n,
    { lift n to â„• using hn,
      simp only [gpow_coe_nat] at h,
      rw [tendsto_const_mul_pow_nhds_iff hc, â† int.coe_nat_eq_zero] at h,
      exact or.inl h },
    { rw not_le at hn,
      refine or.inr âŸ¨hn, tendsto_nhds_unique h (tendsto_const_mul_fpow_at_top_zero hn)âŸ© } },
  { cases h,
    { simp only [h.left, h.right, gpow_zero, mul_one],
      exact tendsto_const_nhds },
    { exact h.2.symm â–¸ tendsto_const_mul_fpow_at_top_zero h.1} }
end

end linear_ordered_field

lemma preimage_neg [add_group Î±] : preimage (has_neg.neg : Î± â†’ Î±) = image (has_neg.neg : Î± â†’ Î±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm

lemma filter.map_neg [add_group Î±] : map (has_neg.neg : Î± â†’ Î±) = comap (has_neg.neg : Î± â†’ Î±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

section order_topology

variables [topological_space Î±] [topological_space Î²]
  [linear_order Î±] [linear_order Î²] [order_topology Î±] [order_topology Î²]

lemma is_lub.frequently_mem {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty) :
  âˆƒá¶  x in ğ“[Iic a] a, x âˆˆ s :=
begin
  rcases hs with âŸ¨a', ha'âŸ©,
  intro h,
  rcases (ha.1 ha').eq_or_lt with (rfl|ha'a),
  { exact h.self_of_nhds_within le_rfl ha' },
  { rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h
      with âŸ¨b, hba, hbâŸ©,
    rcases ha.exists_between hba with âŸ¨b', hb's, hb'âŸ©,
    exact hb hb' hb's },
end

lemma is_lub.frequently_nhds_mem {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty) :
  âˆƒá¶  x in ğ“ a, x âˆˆ s :=
(ha.frequently_mem hs).filter_mono inf_le_left

lemma is_glb.frequently_mem {a : Î±} {s : set Î±} (ha : is_glb s a) (hs : s.nonempty) :
  âˆƒá¶  x in ğ“[Ici a] a, x âˆˆ s :=
@is_lub.frequently_mem (order_dual Î±) _ _ _ _ _ ha hs

lemma is_glb.frequently_nhds_mem {a : Î±} {s : set Î±} (ha : is_glb s a) (hs : s.nonempty) :
  âˆƒá¶  x in ğ“ a, x âˆˆ s :=
(ha.frequently_mem hs).filter_mono inf_le_left

lemma is_lub.mem_closure {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty) :
  a âˆˆ closure s :=
(ha.frequently_nhds_mem hs).mem_closure

lemma is_glb.mem_closure {a : Î±} {s : set Î±} (ha : is_glb s a) (hs : s.nonempty) :
  a âˆˆ closure s :=
(ha.frequently_nhds_mem hs).mem_closure

lemma is_lub.nhds_within_ne_bot {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty) :
  ne_bot (ğ“[s] a) :=
mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)

lemma is_glb.nhds_within_ne_bot : âˆ€ {a : Î±} {s : set Î±}, is_glb s a â†’ s.nonempty â†’
  ne_bot (ğ“[s] a) :=
@is_lub.nhds_within_ne_bot (order_dual Î±) _ _ _

lemma is_lub_of_mem_nhds {s : set Î±} {a : Î±} {f : filter Î±}
  (hsa : a âˆˆ upper_bounds s) (hsf : s âˆˆ f) [ne_bot (f âŠ“ ğ“ a)] : is_lub s a :=
âŸ¨hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s âˆ© {a | b < a} âˆˆ f âŠ“ ğ“ a,
    from inter_mem_inf_sets hsf (is_open.mem_nhds (is_open_lt' _) hba),
  let âŸ¨x, âŸ¨hxs, hxbâŸ©âŸ© := nonempty_of_mem_sets this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b thisâŸ©

lemma is_glb_of_mem_nhds : âˆ€ {s : set Î±} {a : Î±} {f : filter Î±},
  a âˆˆ lower_bounds s â†’ s âˆˆ f â†’ ne_bot (f âŠ“ ğ“ a) â†’ is_glb s a :=
@is_lub_of_mem_nhds (order_dual Î±) _ _ _

lemma is_lub.mem_upper_bounds_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f x â‰¤ f y) (ha : is_lub s a)
  (hb : tendsto f (ğ“[s] a) (ğ“ b)) : b âˆˆ upper_bounds (f '' s) :=
begin
  rintro _ âŸ¨x, hx, rflâŸ©,
  replace ha := ha.inter_Ici_of_mem hx,
  haveI := ha.nhds_within_ne_bot âŸ¨x, hx, le_rflâŸ©,
  refine ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _,
  exact mem_sets_of_superset self_mem_nhds_within (Î» y hy, hf _ hx _ hy.1 hy.2)
end

-- For a version of this theorem in which the convergence considered on the domain `Î±` is as
-- `x : Î±` tends to infinity, rather than tending to a point `x` in `Î±`, see `is_lub_of_tendsto`,
-- below
lemma is_lub.is_lub_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f x â‰¤ f y) (ha : is_lub s a) (hs : s.nonempty)
  (hb : tendsto f (ğ“[s] a) (ğ“ b)) : is_lub (f '' s) b :=
begin
  haveI := ha.nhds_within_ne_bot hs,
  exact âŸ¨ha.mem_upper_bounds_of_tendsto hf hb, Î» b' hb', le_of_tendsto hb
    (mem_sets_of_superset self_mem_nhds_within $ Î» x hx, hb' $ mem_image_of_mem _ hx)âŸ©
end

lemma is_glb.mem_lower_bounds_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f x â‰¤ f y) (ha : is_glb s a)
  (hb : tendsto f (ğ“[s] a) (ğ“ b)) : b âˆˆ lower_bounds (f '' s) :=
@is_lub.mem_upper_bounds_of_tendsto (order_dual Î±) (order_dual Î³) _ _ _ _ _ _ _ _ _ _
  (Î» x hx y hy, hf y hy x hx) ha hb

-- For a version of this theorem in which the convergence considered on the domain `Î±` is as
-- `x : Î±` tends to negative infinity, rather than tending to a point `x` in `Î±`, see
-- `is_glb_of_tendsto`, below
lemma is_glb.is_glb_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f x â‰¤ f y) : is_glb s a â†’ s.nonempty â†’
  tendsto f (ğ“[s] a) (ğ“ b) â†’ is_glb (f '' s) b :=
@is_lub.is_lub_of_tendsto (order_dual Î±) (order_dual Î³) _ _ _ _ _ _ f s a b
  (Î» x hx y hy, hf y hy x hx)

lemma is_lub.mem_lower_bounds_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f y â‰¤ f x) (ha : is_lub s a)
  (hb : tendsto f (ğ“[s] a) (ğ“ b)) : b âˆˆ lower_bounds (f '' s) :=
@is_lub.mem_upper_bounds_of_tendsto Î± (order_dual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

lemma is_lub.is_glb_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] : âˆ€ {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³},
  (âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f y â‰¤ f x) â†’ is_lub s a â†’ s.nonempty â†’
  tendsto f (ğ“[s] a) (ğ“ b) â†’ is_glb (f '' s) b :=
@is_lub.is_lub_of_tendsto Î± (order_dual Î³) _ _ _ _ _ _

lemma is_glb.mem_upper_bounds_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³}
  (hf : âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f y â‰¤ f x) (ha : is_glb s a)
  (hb : tendsto f (ğ“[s] a) (ğ“ b)) : b âˆˆ upper_bounds (f '' s) :=
@is_glb.mem_lower_bounds_of_tendsto Î± (order_dual Î³) _ _ _ _ _ _ _ _ _ _ hf ha hb

lemma is_glb.is_lub_of_tendsto [preorder Î³] [topological_space Î³]
  [order_closed_topology Î³] : âˆ€ {f : Î± â†’ Î³} {s : set Î±} {a : Î±} {b : Î³},
  (âˆ€xâˆˆs, âˆ€yâˆˆs, x â‰¤ y â†’ f y â‰¤ f x) â†’ is_glb s a â†’ s.nonempty â†’
  tendsto f (ğ“[s] a) (ğ“ b) â†’ is_lub (f '' s) b :=
@is_glb.is_glb_of_tendsto Î± (order_dual Î³) _ _ _ _ _ _

lemma is_lub.mem_of_is_closed {a : Î±} {s : set Î±} (ha : is_lub s a) (hs : s.nonempty)
  (sc : is_closed s) : a âˆˆ s :=
sc.closure_subset $ ha.mem_closure hs

alias is_lub.mem_of_is_closed â† is_closed.is_lub_mem

lemma is_glb.mem_of_is_closed {a : Î±} {s : set Î±} (ha : is_glb s a) (hs : s.nonempty)
  (sc : is_closed s) : a âˆˆ s :=
sc.closure_subset $ ha.mem_closure hs

alias is_glb.mem_of_is_closed â† is_closed.is_glb_mem

/-- A compact set is bounded below -/
lemma is_compact.bdd_below {Î± : Type u} [topological_space Î±] [linear_order Î±]
  [order_closed_topology Î±] [nonempty Î±] {s : set Î±} (hs : is_compact s) : bdd_below s :=
begin
  by_contra H,
  rcases hs.elim_finite_subcover_image (Î» x (_ : x âˆˆ s), @is_open_Ioi _ _ _ _ x) _
    with âŸ¨t, st, ft, htâŸ©,
  { refine H (ft.bdd_below.imp $ Î» C hC y hy, _),
    rcases mem_bUnion_iff.1 (ht hy) with âŸ¨x, hx, xyâŸ©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Î» x hx, mem_bUnion_iff.2 (not_imp_comm.1 _ H),
    exact Î» h, âŸ¨x, Î» y hy, le_of_not_lt (h.imp $ Î» ys, âŸ¨_, hy, ysâŸ©)âŸ© }
end

/-- A compact set is bounded above -/
lemma is_compact.bdd_above {Î± : Type u} [topological_space Î±] [linear_order Î±]
  [order_topology Î±] : Î  [nonempty Î±] {s : set Î±}, is_compact s â†’ bdd_above s :=
@is_compact.bdd_below (order_dual Î±) _ _ _

end order_topology

section linear_order

variables [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±]

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`, unless `a` is a top
element. -/
lemma closure_Ioi' {a b : Î±} (hab : a < b) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioi_subset_Ici_self is_closed_Ici },
  { rw [â† diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff],
    exact is_glb_Ioi.mem_closure âŸ¨_, habâŸ© }
end

/-- The closure of the interval `(a, +âˆ)` is the closed interval `[a, +âˆ)`. -/
@[simp] lemma closure_Ioi (a : Î±) [no_top_order Î±] :
  closure (Ioi a) = Ici a :=
let âŸ¨b, hbâŸ© := no_top a in closure_Ioi' hb

/-- The closure of the interval `(-âˆ, a)` is the closed interval `(-âˆ, a]`, unless `a` is a bottom
element. -/
lemma closure_Iio' {a b : Î±} (hab : b < a) :
  closure (Iio a) = Iic a :=
@closure_Ioi' (order_dual Î±) _ _ _ _ _ _ hab

/-- The closure of the interval `(-âˆ, a)` is the interval `(-âˆ, a]`. -/
@[simp] lemma closure_Iio (a : Î±) [no_bot_order Î±] :
  closure (Iio a) = Iic a :=
let âŸ¨b, hbâŸ© := no_bot a in closure_Iio' hb

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioo {a b : Î±} (hab : a < b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioo_subset_Icc_self is_closed_Icc },
  { rw [â† diff_subset_closure_iff, Icc_diff_Ioo_same hab.le],
    have hab' : (Ioo a b).nonempty, from nonempty_Ioo.2 hab,
    simp only [insert_subset, singleton_subset_iff],
    exact âŸ¨(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'âŸ© }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioc {a b : Î±} (hab : a < b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioc_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ico {a b : Î±} (hab : a < b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ico_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end

@[simp] lemma interior_Ici [no_bot_order Î±] {a : Î±} : interior (Ici a) = Ioi a :=
by rw [â† compl_Iio, interior_compl, closure_Iio, compl_Iic]

@[simp] lemma interior_Iic [no_top_order Î±] {a : Î±} : interior (Iic a) = Iio a :=
by rw [â† compl_Ioi, interior_compl, closure_Ioi, compl_Ici]

@[simp] lemma interior_Icc [no_bot_order Î±] [no_top_order Î±] {a b : Î±}:
  interior (Icc a b) = Ioo a b :=
by rw [â† Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp] lemma interior_Ico [no_bot_order Î±] {a b : Î±} : interior (Ico a b) = Ioo a b :=
by rw [â† Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp] lemma interior_Ioc [no_top_order Î±] {a b : Î±} : interior (Ioc a b) = Ioo a b :=
by rw [â† Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

@[simp] lemma frontier_Ici [no_bot_order Î±] {a : Î±} : frontier (Ici a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Iic [no_top_order Î±] {a : Î±} : frontier (Iic a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Ioi [no_top_order Î±] {a : Î±} : frontier (Ioi a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Iio [no_bot_order Î±] {a : Î±} : frontier (Iio a) = {a} :=
by simp [frontier]

@[simp] lemma frontier_Icc [no_bot_order Î±] [no_top_order Î±] {a b : Î±} (h : a < b) :
  frontier (Icc a b) = {a, b} :=
by simp [frontier, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ioo {a b : Î±} (h : a < b) : frontier (Ioo a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ico [no_bot_order Î±] {a b : Î±} (h : a < b) : frontier (Ico a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ioc [no_top_order Î±] {a b : Î±} (h : a < b) : frontier (Ioc a b) = {a, b} :=
by simp [frontier, h, le_of_lt h, Icc_diff_Ioo_same]

lemma nhds_within_Ioi_ne_bot' {a b c : Î±} (Hâ‚ : a < c) (Hâ‚‚ : a â‰¤ b) :
  ne_bot (ğ“[Ioi a] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Ioi' Hâ‚], exact Hâ‚‚ }

lemma nhds_within_Ioi_ne_bot [no_top_order Î±] {a b : Î±} (H : a â‰¤ b) :
  ne_bot (ğ“[Ioi a] b) :=
let âŸ¨c, hcâŸ© := no_top a in nhds_within_Ioi_ne_bot' hc H

lemma nhds_within_Ioi_self_ne_bot' {a b : Î±} (H : a < b) :
  ne_bot (ğ“[Ioi a] a) :=
nhds_within_Ioi_ne_bot' H (le_refl a)

@[instance]
lemma nhds_within_Ioi_self_ne_bot [no_top_order Î±] (a : Î±) :
  ne_bot (ğ“[Ioi a] a) :=
nhds_within_Ioi_ne_bot (le_refl a)

lemma nhds_within_Iio_ne_bot' {a b c : Î±} (Hâ‚ : a < c) (Hâ‚‚ : b â‰¤ c) :
  ne_bot (ğ“[Iio c] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by { rw [closure_Iio' Hâ‚], exact Hâ‚‚ }

lemma nhds_within_Iio_ne_bot [no_bot_order Î±] {a b : Î±} (H : a â‰¤ b) :
  ne_bot (ğ“[Iio b] a) :=
let âŸ¨c, hcâŸ© := no_bot b in nhds_within_Iio_ne_bot' hc H

lemma nhds_within_Iio_self_ne_bot' {a b : Î±} (H : a < b) :
  ne_bot (ğ“[Iio b] b) :=
nhds_within_Iio_ne_bot' H (le_refl b)

@[instance]
lemma nhds_within_Iio_self_ne_bot [no_bot_order Î±] (a : Î±) :
  ne_bot (ğ“[Iio a] a) :=
nhds_within_Iio_ne_bot (le_refl a)

lemma right_nhds_within_Ico_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ico a b] b) :=
(is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)

lemma left_nhds_within_Ioc_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioc a b] a) :=
(is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)

lemma left_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] a) :=
(is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

lemma right_nhds_within_Ioo_ne_bot {a b : Î±} (H : a < b) : ne_bot (ğ“[Ioo a b] b) :=
(is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

end linear_order

section linear_order

variables [topological_space Î±] [linear_order Î±] [order_topology Î±] [densely_ordered Î±]
  {a b : Î±} {s : set Î±}

lemma comap_coe_nhds_within_Iio_of_Ioo_subset (hb : s âŠ† Iio b)
  (hs : s.nonempty â†’ âˆƒ a < b, Ioo a b âŠ† s) :
  comap (coe : s â†’ Î±) (ğ“[Iio b] b) = at_top :=
begin
  nontriviality,
  haveI : nonempty s := nontrivial_iff_nonempty.1 â€¹_â€º,
  rcases hs (nonempty_subtype.1 â€¹_â€º) with âŸ¨a, h, hsâŸ©,
  ext u, split,
  { rintros âŸ¨t, ht, htsâŸ©,
    obtain âŸ¨x, âŸ¨hxa : a â‰¤ x, hxb : x < bâŸ©, hxt : Ioo x b âŠ† tâŸ© :=
      (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht,
    obtain âŸ¨y, hxy, hybâŸ© := exists_between hxb,
    refine mem_sets_of_superset (mem_at_top âŸ¨y, hs âŸ¨hxa.trans_lt hxy, hybâŸ©âŸ©) _,
    rintros âŸ¨z, hzsâŸ© (hyz : y â‰¤ z),
    refine hts (hxt âŸ¨hxy.trans_le _, hb _âŸ©); assumption },
  { intros hu,
    obtain âŸ¨x : s, hx : âˆ€ z, x â‰¤ z â†’ z âˆˆ uâŸ© := mem_at_top_sets.1 hu,
    exact âŸ¨Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), Î» z hz, hx _ hz.1.leâŸ© }
end

lemma comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s âŠ† Ioi a)
  (hs : s.nonempty â†’ âˆƒ b > a, Ioo a b âŠ† s) :
  comap (coe : s â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
begin
  refine @comap_coe_nhds_within_Iio_of_Ioo_subset (order_dual Î±) _ _ _ _ _ _ ha (Î» h, _),
  rcases hs h with âŸ¨b, hab, hâŸ©,
  use [b, hab],
  rwa dual_Ioo
end

lemma map_coe_at_top_of_Ioo_subset (hb : s âŠ† Iio b)
  (hs : âˆ€ a' < b, âˆƒ a < b, Ioo a b âŠ† s) :
  map (coe : s â†’ Î±) at_top = ğ“[Iio b] b :=
begin
  rcases eq_empty_or_nonempty (Iio b) with (hb'|âŸ¨a, haâŸ©),
  { rw [filter_eq_bot_of_not_nonempty at_top, map_bot, hb', nhds_within_empty],
    exact Î» âŸ¨âŸ¨x, hxâŸ©âŸ©, not_nonempty_iff_eq_empty.2 hb' âŸ¨x, hb hxâŸ© },
  { rw [â† comap_coe_nhds_within_Iio_of_Ioo_subset hb (Î» _, hs a ha), map_comap_of_mem],
    rw subtype.range_coe,
    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha) },
end

lemma map_coe_at_bot_of_Ioo_subset (ha : s âŠ† Ioi a)
  (hs : âˆ€ b' > a, âˆƒ b > a, Ioo a b âŠ† s) :
  map (coe : s â†’ Î±) at_bot = (ğ“[Ioi a] a) :=
begin
  refine @map_coe_at_top_of_Ioo_subset (order_dual Î±) _ _ _ _ a s ha (Î» b' hb', _),
  rcases hs b' hb' with âŸ¨b, hab, hbsâŸ©,
  use [b, hab],
  rwa dual_Ioo
end

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
lemma comap_coe_Ioo_nhds_within_Iio (a b : Î±) :
  comap (coe : Ioo a b â†’ Î±) (ğ“[Iio b] b) = at_top :=
comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self $
  Î» h, âŸ¨a, nonempty_Ioo.1 h, subset.refl _âŸ©

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
lemma comap_coe_Ioo_nhds_within_Ioi (a b : Î±) :
  comap (coe : Ioo a b â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self $
  Î» h, âŸ¨b, nonempty_Ioo.1 h, subset.refl _âŸ©

lemma comap_coe_Ioi_nhds_within_Ioi (a : Î±) : comap (coe : Ioi a â†’ Î±) (ğ“[Ioi a] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _) $
  Î» âŸ¨x, hxâŸ©, âŸ¨x, hx, Ioo_subset_Ioi_selfâŸ©

lemma comap_coe_Iio_nhds_within_Iio (a : Î±) :
  comap (coe : Iio a â†’ Î±) (ğ“[Iio a] a) = at_top :=
@comap_coe_Ioi_nhds_within_Ioi (order_dual Î±) _ _ _ _ a

@[simp] lemma map_coe_Ioo_at_top {a b : Î±} (h : a < b) :
  map (coe : Ioo a b â†’ Î±) at_top = ğ“[Iio b] b :=
map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self $ Î» _ _, âŸ¨_, h, subset.refl _âŸ©

@[simp] lemma map_coe_Ioo_at_bot {a b : Î±} (h : a < b) :
  map (coe : Ioo a b â†’ Î±) at_bot = ğ“[Ioi a] a :=
map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self $ Î» _ _, âŸ¨_, h, subset.refl _âŸ©

@[simp] lemma map_coe_Ioi_at_bot (a : Î±) :
  map (coe : Ioi a â†’ Î±) at_bot = ğ“[Ioi a] a :=
map_coe_at_bot_of_Ioo_subset (subset.refl _) $ Î» b hb, âŸ¨b, hb, Ioo_subset_Ioi_selfâŸ©

@[simp] lemma map_coe_Iio_at_top (a : Î±) :
  map (coe : Iio a â†’ Î±) at_top = ğ“[Iio a] a :=
@map_coe_Ioi_at_bot (order_dual Î±) _ _ _ _ _

variables {l : filter Î²} {f : Î± â†’ Î²}

@[simp] lemma tendsto_comp_coe_Ioo_at_top (h : a < b) :
  tendsto (Î» x : Ioo a b, f x) at_top l â†” tendsto f (ğ“[Iio b] b) l :=
by rw [â† map_coe_Ioo_at_top h, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ioo_at_bot (h : a < b) :
  tendsto (Î» x : Ioo a b, f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
by rw [â† map_coe_Ioo_at_bot h, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ioi_at_bot :
  tendsto (Î» x : Ioi a, f x) at_bot l â†” tendsto f (ğ“[Ioi a] a) l :=
by rw [â† map_coe_Ioi_at_bot, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iio_at_top :
  tendsto (Î» x : Iio a, f x) at_top l â†” tendsto f (ğ“[Iio a] a) l :=
by rw [â† map_coe_Iio_at_top, tendsto_map'_iff]

@[simp] lemma tendsto_Ioo_at_top {f : Î² â†’ Ioo a b} :
  tendsto f l at_top â†” tendsto (Î» x, (f x : Î±)) l (ğ“[Iio b] b) :=
by rw [â† comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]

@[simp] lemma tendsto_Ioo_at_bot {f : Î² â†’ Ioo a b} :
  tendsto f l at_bot â†” tendsto (Î» x, (f x : Î±)) l (ğ“[Ioi a] a) :=
by rw [â† comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]

@[simp] lemma tendsto_Ioi_at_bot {f : Î² â†’ Ioi a} :
  tendsto f l at_bot â†” tendsto (Î» x, (f x : Î±)) l (ğ“[Ioi a] a) :=
by rw [â† comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]

@[simp] lemma tendsto_Iio_at_top {f : Î² â†’ Iio a} :
  tendsto f l at_top â†” tendsto (Î» x, (f x : Î±)) l (ğ“[Iio a] a) :=
by rw [â† comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]

end linear_order

section complete_linear_order

variables [complete_linear_order Î±] [topological_space Î±] [order_topology Î±]
  [complete_linear_order Î²] [topological_space Î²] [order_topology Î²] [nonempty Î³]

lemma Sup_mem_closure {Î± : Type u} [topological_space Î±] [complete_linear_order Î±]
  [order_topology Î±] {s : set Î±} (hs : s.nonempty) :
  Sup s âˆˆ closure s :=
(is_lub_Sup s).mem_closure hs

lemma Inf_mem_closure {Î± : Type u} [topological_space Î±] [complete_linear_order Î±]
  [order_topology Î±] {s : set Î±} (hs : s.nonempty) :
  Inf s âˆˆ closure s :=
(is_glb_Inf s).mem_closure hs

lemma is_closed.Sup_mem {Î± : Type u} [topological_space Î±] [complete_linear_order Î±]
  [order_topology Î±] {s : set Î±} (hs : s.nonempty) (hc : is_closed s) :
  Sup s âˆˆ s :=
(is_lub_Sup s).mem_of_is_closed hs hc

lemma is_closed.Inf_mem {Î± : Type u} [topological_space Î±] [complete_linear_order Î±]
  [order_topology Î±] {s : set Î±} (hs : s.nonempty) (hc : is_closed s) :
  Inf s âˆˆ s :=
(is_glb_Inf s).mem_of_is_closed hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
lemma map_Sup_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Sup s) = Sup (f '' s) :=
--This is a particular case of the more general is_lub.is_lub_of_tendsto
((is_lub_Sup _).is_lub_of_tendsto (Î» x hx y hy xy, Mf xy) hs $
  Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `s` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
lemma map_Sup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (fbot : f âŠ¥ = âŠ¥) :
  f (Sup s) = Sup (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simp [h, fbot] },
  { exact map_Sup_of_continuous_at_of_monotone' Cf Mf h }
end

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
lemma map_supr_of_continuous_at_of_monotone' {Î¹ : Sort*} [nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) :
  f (â¨† i, g i) = â¨† i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone' Cf Mf (range_nonempty g), â† range_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
lemma map_supr_of_continuous_at_of_monotone {Î¹ : Sort*} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f âŠ¥ = âŠ¥) :
  f (â¨† i, g i) = â¨† i, f (g i) :=
by rw [supr, map_Sup_of_continuous_at_of_monotone Cf Mf fbot, â† range_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
lemma map_Inf_of_continuous_at_of_monotone' {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone' (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ f s Cf
  Mf.order_dual hs

/-- A monotone function `s` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
lemma map_Inf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ftop : f âŠ¤ = âŠ¤) :
  f (Inf s) = Inf (f '' s) :=
@map_Sup_of_continuous_at_of_monotone (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ f s Cf
  Mf.order_dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
lemma map_infi_of_continuous_at_of_monotone' {Î¹ : Sort*} [nonempty Î¹] {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) :
  f (â¨… i, g i) = â¨… i, f (g i) :=
@map_supr_of_continuous_at_of_monotone' (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ Î¹ _ f g Cf
  Mf.order_dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
lemma map_infi_of_continuous_at_of_monotone {Î¹ : Sort*} {f : Î± â†’ Î²} {g : Î¹ â†’ Î±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f âŠ¤ = âŠ¤) :
  f (infi g) = infi (f âˆ˜ g) :=
@map_supr_of_continuous_at_of_monotone (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ Î¹ f g Cf
  Mf.order_dual ftop

end complete_linear_order

section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Î±] [topological_space Î±] [order_topology Î±]
  [conditionally_complete_linear_order Î²] [topological_space Î²] [order_topology Î²] [nonempty Î³]

lemma cSup_mem_closure {s : set Î±} (hs : s.nonempty) (B : bdd_above s) : Sup s âˆˆ closure s :=
(is_lub_cSup hs B).mem_closure hs

lemma cInf_mem_closure {s : set Î±} (hs : s.nonempty) (B : bdd_below s) : Inf s âˆˆ closure s :=
(is_glb_cInf hs B).mem_closure hs

lemma is_closed.cSup_mem {s : set Î±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_above s) :
  Sup s âˆˆ s :=
(is_lub_cSup hs B).mem_of_is_closed hs hc

lemma is_closed.cInf_mem {s : set Î±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_below s) :
  Inf s âˆˆ s :=
(is_glb_cInf hs B).mem_of_is_closed hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
lemma map_cSup_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) :
  f (Sup s) = Sup (f '' s) :=
begin
  refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm,
  refine (is_lub_cSup ne H).is_lub_of_tendsto (Î»x hx y hy xy, Mf xy)  ne _,
  exact Cf.mono_left inf_le_left
end

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
lemma map_csupr_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±}
  (Cf : continuous_at f (â¨† i, g i)) (Mf : monotone f) (H : bdd_above (range g)) :
  f (â¨† i, g i) = â¨† i, f (g i) :=
by rw [supr, map_cSup_of_continuous_at_of_monotone Cf Mf (range_nonempty _) H, â† range_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
lemma map_cInf_of_continuous_at_of_monotone {f : Î± â†’ Î²} {s : set Î±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) :
  f (Inf s) = Inf (f '' s) :=
@map_cSup_of_continuous_at_of_monotone (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ f s Cf
  Mf.order_dual ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
lemma map_cinfi_of_continuous_at_of_monotone {f : Î± â†’ Î²} {g : Î³ â†’ Î±}
  (Cf : continuous_at f (â¨… i, g i)) (Mf : monotone f) (H : bdd_below (range g)) :
  f (â¨… i, g i) = â¨… i, f (g i) :=
@map_csupr_of_continuous_at_of_monotone (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ _ _ _ _
  Cf Mf.order_dual H

/-- A bounded connected subset of a conditionally complete linear order includes the open interval
`(Inf s, Sup s)`. -/
lemma is_connected.Ioo_cInf_cSup_subset {s : set Î±} (hs : is_connected s) (hb : bdd_below s)
  (ha : bdd_above s) :
  Ioo (Inf s) (Sup s) âŠ† s :=
Î» x hx, let âŸ¨y, ys, hyâŸ© := (is_glb_lt_iff (is_glb_cInf hs.nonempty hb)).1 hx.1 in
let âŸ¨z, zs, hzâŸ© := (lt_is_lub_iff (is_lub_cSup hs.nonempty ha)).1 hx.2 in
hs.Icc_subset ys zs âŸ¨le_of_lt hy, le_of_lt hzâŸ©

lemma eq_Icc_cInf_cSup_of_connected_bdd_closed {s : set Î±} (hc : is_connected s) (hb : bdd_below s)
  (ha : bdd_above s) (hcl : is_closed s) :
  s = Icc (Inf s) (Sup s) :=
subset.antisymm (subset_Icc_cInf_cSup hb ha) $
  hc.Icc_subset (hcl.cInf_mem hc.nonempty hb) (hcl.cSup_mem hc.nonempty ha)

lemma is_preconnected.Ioi_cInf_subset {s : set Î±} (hs : is_preconnected s) (hb : bdd_below s)
  (ha : Â¬bdd_above s) :
  Ioi (Inf s) âŠ† s :=
begin
  have sne : s.nonempty := @nonempty_of_not_bdd_above Î± _ s âŸ¨Inf âˆ…âŸ© ha,
  intros x hx,
  obtain âŸ¨y, ys, hyâŸ© : âˆƒ y âˆˆ s, y < x := (is_glb_lt_iff (is_glb_cInf sne hb)).1 hx,
  obtain âŸ¨z, zs, hzâŸ© : âˆƒ z âˆˆ s, x < z := not_bdd_above_iff.1 ha x,
  exact hs.Icc_subset ys zs âŸ¨le_of_lt hy, le_of_lt hzâŸ©
end

lemma is_preconnected.Iio_cSup_subset {s : set Î±} (hs : is_preconnected s) (hb : Â¬bdd_below s)
  (ha : bdd_above s) :
  Iio (Sup s) âŠ† s :=
@is_preconnected.Ioi_cInf_subset (order_dual Î±) _ _ _ s hs ha hb

/-- A preconnected set in a conditionally complete linear order is either one of the intervals
`[Inf s, Sup s]`, `[Inf s, Sup s)`, `(Inf s, Sup s]`, `(Inf s, Sup s)`, `[Inf s, +âˆ)`,
`(Inf s, +âˆ)`, `(-âˆ, Sup s]`, `(-âˆ, Sup s)`, `(-âˆ, +âˆ)`, or `âˆ…`. The converse statement requires
`Î±` to be densely ordererd. -/
lemma is_preconnected.mem_intervals {s : set Î±} (hs : is_preconnected s) :
  s âˆˆ ({Icc (Inf s) (Sup s), Ico (Inf s) (Sup s), Ioc (Inf s) (Sup s), Ioo (Inf s) (Sup s),
    Ici (Inf s), Ioi (Inf s), Iic (Sup s), Iio (Sup s), univ, âˆ…} : set (set Î±)) :=
begin
  rcases s.eq_empty_or_nonempty with rfl|hne,
  { apply_rules [or.inr, mem_singleton] },
  have hs' : is_connected s := âŸ¨hne, hsâŸ©,
  by_cases hb : bdd_below s; by_cases ha : bdd_above s,
  { rcases mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset (hs'.Ioo_cInf_cSup_subset hb ha)
      (subset_Icc_cInf_cSup hb ha) with hs|hs|hs|hs,
    { exact (or.inl hs) },
    { exact (or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inl hs) },
    { exact (or.inr $ or.inr $ or.inr $ or.inl hs) } },
  { refine (or.inr $ or.inr $ or.inr $ or.inr _),
    cases mem_Ici_Ioi_of_subset_of_subset (hs.Ioi_cInf_subset hb ha) (Î» x hx, cInf_le hb hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 6 { apply or.inr },
    cases mem_Iic_Iio_of_subset_of_subset (hs.Iio_cSup_subset hb ha) (Î» x hx, le_cSup ha hx)
      with hs hs,
    { exact or.inl hs },
    { exact or.inr (or.inl hs) } },
  { iterate 8 { apply or.inr },
    exact or.inl (hs.eq_univ_of_unbounded hb ha) }
end

/-- A preconnected set is either one of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`,
`Iic`, `Iio`, or `univ`, or `âˆ…`. The converse statement requires `Î±` to be densely ordererd. Though
one can represent `âˆ…` as `(Inf s, Inf s)`, we include it into the list of possible cases to improve
readability. -/
lemma set_of_is_preconnected_subset_of_ordered :
  {s : set Î± | is_preconnected s} âŠ†
    -- bounded intervals
    (range (uncurry Icc) âˆª range (uncurry Ico) âˆª range (uncurry Ioc) âˆª range (uncurry Ioo)) âˆª
    -- unbounded intervals and `univ`
    (range Ici âˆª range Ioi âˆª range Iic âˆª range Iio âˆª {univ, âˆ…}) :=
begin
  intros s hs,
  rcases hs.mem_intervals with hs|hs|hs|hs|hs|hs|hs|hs|hs|hs,
  { exact (or.inl $ or.inl $ or.inl $ or.inl âŸ¨(Inf s, Sup s), hs.symmâŸ©) },
  { exact (or.inl $ or.inl $ or.inl $ or.inr âŸ¨(Inf s, Sup s), hs.symmâŸ©) },
  { exact (or.inl $ or.inl $ or.inr âŸ¨(Inf s, Sup s), hs.symmâŸ©) },
  { exact (or.inl $ or.inr âŸ¨(Inf s, Sup s), hs.symmâŸ©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inl âŸ¨Inf s, hs.symmâŸ©) },
  { exact (or.inr $ or.inl $ or.inl $ or.inl $ or.inr âŸ¨Inf s, hs.symmâŸ©) },
  { exact (or.inr $ or.inl $ or.inl  $ or.inr âŸ¨Sup s, hs.symmâŸ©) },
  { exact (or.inr $ or.inl $  or.inr âŸ¨Sup s, hs.symmâŸ©) },
  { exact (or.inr $ or.inr $ or.inl hs) },
  { exact (or.inr $ or.inr $ or.inr hs) }
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and the set `s âˆ© [a, b)` has no maximal point, then `b âˆˆ s`. -/
lemma is_closed.mem_of_ge_of_forall_exists_gt {a b : Î±} {s : set Î±} (hs : is_closed (s âˆ© Icc a b))
  (ha : a âˆˆ s) (hab : a â‰¤ b) (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, (s âˆ© Ioc x b).nonempty) :
  b âˆˆ s :=
begin
  let S := s âˆ© Icc a b,
  replace ha : a âˆˆ S, from âŸ¨ha, left_mem_Icc.2 habâŸ©,
  have Sbd : bdd_above S, from âŸ¨b, Î» z hz, hz.2.2âŸ©,
  let c := Sup (s âˆ© Icc a b),
  have c_mem : c âˆˆ S, from hs.cSup_mem âŸ¨_, haâŸ© Sbd,
  have c_le : c â‰¤ b, from cSup_le âŸ¨_, haâŸ© (Î» x hx, hx.2.2),
  cases eq_or_lt_of_le c_le with hc hc, from hc â–¸ c_mem.1,
  exfalso,
  rcases hgt c âŸ¨c_mem.1, c_mem.2.1, hcâŸ© with âŸ¨x, xs, cx, xbâŸ©,
  exact not_lt_of_le (le_cSup Sbd âŸ¨xs, le_trans (le_cSup Sbd ha) (le_of_lt cx), xbâŸ©) cx
end

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `a â‰¤ x < y â‰¤ b`, `x âˆˆ s`, the set `s âˆ© (x, y]`
is not empty, then `[a, b] âŠ† s`. -/
lemma is_closed.Icc_subset_of_forall_exists_gt {a b : Î±} {s : set Î±} (hs : is_closed (s âˆ© Icc a b))
  (ha : a âˆˆ s) (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, âˆ€ y âˆˆ Ioi x, (s âˆ© Ioc x y).nonempty) :
  Icc a b âŠ† s :=
begin
  assume y hy,
  have : is_closed (s âˆ© Icc a y),
  { suffices : s âˆ© Icc a y = s âˆ© Icc a b âˆ© Icc a y,
    { rw this, exact is_closed.inter hs is_closed_Icc },
    rw [inter_assoc],
    congr,
    exact (inter_eq_self_of_subset_right $ Icc_subset_Icc_right hy.2).symm },
  exact is_closed.mem_of_ge_of_forall_exists_gt this ha hy.1
    (Î» x hx, hgt x âŸ¨hx.1, Ico_subset_Ico_right hy.2 hx.2âŸ© y hx.2.2)
end

section densely_ordered

variables [densely_ordered Î±] {a b : Î±}

/-- A "continuous induction principle" for a closed interval: if a set `s` meets `[a, b]`
on a closed subset, contains `a`, and for any `x âˆˆ s âˆ© [a, b)` the set `s` includes some open
neighborhood of `x` within `(x, +âˆ)`, then `[a, b] âŠ† s`. -/
lemma is_closed.Icc_subset_of_forall_mem_nhds_within {a b : Î±} {s : set Î±}
  (hs : is_closed (s âˆ© Icc a b)) (ha : a âˆˆ s)
  (hgt : âˆ€ x âˆˆ s âˆ© Ico a b, s âˆˆ ğ“[Ioi x] x) :
  Icc a b âŠ† s :=
begin
  apply hs.Icc_subset_of_forall_exists_gt ha,
  rintros x âŸ¨hxs, hxabâŸ© y hyxb,
  have : s âˆ© Ioc x y âˆˆ ğ“[Ioi x] x,
    from inter_mem_sets (hgt x âŸ¨hxs, hxabâŸ©) (Ioc_mem_nhds_within_Ioi âŸ¨le_refl _, hyxbâŸ©),
  exact (nhds_within_Ioi_self_ne_bot' hxab.2).nonempty_of_mem this
end

/-- A closed interval in a densely ordered conditionally complete linear order is preconnected. -/
lemma is_preconnected_Icc : is_preconnected (Icc a b) :=
is_preconnected_closed_iff.2
begin
  rintros s t hs ht hab âŸ¨x, hxâŸ© âŸ¨y, hyâŸ©,
  wlog hxy : x â‰¤ y := le_total x y using [x y s t, y x t s],
  have xyab : Icc x y âŠ† Icc a b := Icc_subset_Icc hx.1.1 hy.1.2,
  by_contradiction hst,
  suffices : Icc x y âŠ† s,
    from hst âŸ¨y, xyab $ right_mem_Icc.2 hxy, this $ right_mem_Icc.2 hxy, hy.2âŸ©,
  apply (is_closed.inter hs is_closed_Icc).Icc_subset_of_forall_mem_nhds_within hx.2,
  rintros z âŸ¨zs, hzâŸ©,
  have zt : z âˆˆ tá¶œ, from Î» zt, hst âŸ¨z, xyab $ Ico_subset_Icc_self hz, zs, ztâŸ©,
  have : tá¶œ âˆ© Ioc z y âˆˆ ğ“[Ioi z] z,
  { rw [â† nhds_within_Ioc_eq_nhds_within_Ioi hz.2],
    exact mem_nhds_within.2 âŸ¨tá¶œ, ht.is_open_compl, zt, subset.refl _âŸ©},
  apply mem_sets_of_superset this,
  have : Ioc z y âŠ† s âˆª t, from Î» w hw, hab (xyab âŸ¨le_trans hz.1 (le_of_lt hw.1), hw.2âŸ©),
  exact Î» w âŸ¨wt, wzyâŸ©, (this wzy).elim id (Î» h, (wt h).elim)
end

lemma is_preconnected_interval : is_preconnected (interval a b) := is_preconnected_Icc

lemma set.ord_connected.is_preconnected {s : set Î±} (h : s.ord_connected) :
  is_preconnected s :=
is_preconnected_of_forall_pair $ Î» x y hx hy, âŸ¨interval x y, h.interval_subset hx hy,
  left_mem_interval, right_mem_interval, is_preconnected_intervalâŸ©

lemma is_preconnected_iff_ord_connected {s : set Î±} :
  is_preconnected s â†” ord_connected s :=
âŸ¨is_preconnected.ord_connected, set.ord_connected.is_preconnectedâŸ©

lemma is_preconnected_Ici : is_preconnected (Ici a) := ord_connected_Ici.is_preconnected
lemma is_preconnected_Iic : is_preconnected (Iic a) := ord_connected_Iic.is_preconnected
lemma is_preconnected_Iio : is_preconnected (Iio a) := ord_connected_Iio.is_preconnected
lemma is_preconnected_Ioi : is_preconnected (Ioi a) := ord_connected_Ioi.is_preconnected
lemma is_preconnected_Ioo : is_preconnected (Ioo a b) := ord_connected_Ioo.is_preconnected
lemma is_preconnected_Ioc : is_preconnected (Ioc a b) := ord_connected_Ioc.is_preconnected
lemma is_preconnected_Ico : is_preconnected (Ico a b) := ord_connected_Ico.is_preconnected

@[priority 100]
instance ordered_connected_space : preconnected_space Î± :=
âŸ¨ord_connected_univ.is_preconnectedâŸ©

/-- In a dense conditionally complete linear order, the set of preconnected sets is exactly
the set of the intervals `Icc`, `Ico`, `Ioc`, `Ioo`, `Ici`, `Ioi`, `Iic`, `Iio`, `(-âˆ, +âˆ)`,
or `âˆ…`. Though one can represent `âˆ…` as `(Inf s, Inf s)`, we include it into the list of
possible cases to improve readability. -/
lemma set_of_is_preconnected_eq_of_ordered :
  {s : set Î± | is_preconnected s} =
    -- bounded intervals
    (range (uncurry Icc) âˆª range (uncurry Ico) âˆª range (uncurry Ioc) âˆª range (uncurry Ioo)) âˆª
    -- unbounded intervals and `univ`
    (range Ici âˆª range Ioi âˆª range Iic âˆª range Iio âˆª {univ, âˆ…}) :=
begin
  refine subset.antisymm set_of_is_preconnected_subset_of_ordered _,
  simp only [subset_def, -mem_range, forall_range_iff, uncurry, or_imp_distrib, forall_and_distrib,
    mem_union, mem_set_of_eq, insert_eq, mem_singleton_iff, forall_eq, forall_true_iff, and_true,
    is_preconnected_Icc, is_preconnected_Ico, is_preconnected_Ioc,
    is_preconnected_Ioo, is_preconnected_Ioi, is_preconnected_Iio, is_preconnected_Ici,
    is_preconnected_Iic, is_preconnected_univ, is_preconnected_empty],
end

variables {Î´ : Type*} [linear_order Î´] [topological_space Î´] [order_closed_topology Î´]

/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case
`f a â‰¤ t â‰¤ f b`.-/
lemma intermediate_value_Icc {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Icc (f a) (f b) âŠ† f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (left_mem_Icc.2 hab) (right_mem_Icc.2 hab) hf

/-- **Intermediate Value Theorem** for continuous functions on closed intervals, case
`f a â‰¥ t â‰¥ f b`.-/
lemma intermediate_value_Icc' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Icc (f b) (f a) âŠ† f '' (Icc a b) :=
is_preconnected_Icc.intermediate_value (right_mem_Icc.2 hab) (left_mem_Icc.2 hab) hf

/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/
lemma intermediate_value_interval {a b : Î±} {f : Î± â†’ Î´} (hf : continuous_on f (interval a b)) :
  interval (f a) (f b) âŠ† f '' interval a b :=
by cases le_total (f a) (f b); simp [*, is_preconnected_interval.intermediate_value]

lemma intermediate_value_Ico {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ico (f a) (f b) âŠ† f '' (Ico a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.2 (not_lt_of_le (he â–¸ h.1)))
(Î» hlt, @is_preconnected.intermediate_value_Ico _ _ _ _ _ _ _ (is_preconnected_Ico)
  _ _ âŸ¨refl a, hltâŸ© (right_nhds_within_Ico_ne_bot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self)
  _ ((hf.continuous_within_at âŸ¨hab, refl bâŸ©).mono Ico_subset_Icc_self))

lemma intermediate_value_Ico' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ioc (f b) (f a) âŠ† f '' (Ico a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.1 (not_lt_of_le (he â–¸ h.2)))
(Î» hlt, @is_preconnected.intermediate_value_Ioc _ _ _ _ _ _ _ (is_preconnected_Ico)
  _ _ âŸ¨refl a, hltâŸ© (right_nhds_within_Ico_ne_bot hlt) inf_le_right _ (hf.mono Ico_subset_Icc_self)
  _ ((hf.continuous_within_at âŸ¨hab, refl bâŸ©).mono Ico_subset_Icc_self))

lemma intermediate_value_Ioc {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ioc (f a) (f b) âŠ† f '' (Ioc a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.2 (not_le_of_lt (he â–¸ h.1)))
(Î» hlt, @is_preconnected.intermediate_value_Ioc _ _ _ _ _ _ _ (is_preconnected_Ioc)
  _ _ âŸ¨hlt, refl bâŸ© (left_nhds_within_Ioc_ne_bot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self)
  _ ((hf.continuous_within_at âŸ¨refl a, habâŸ©).mono Ioc_subset_Icc_self))

lemma intermediate_value_Ioc' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ico (f b) (f a) âŠ† f '' (Ioc a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.1 (not_le_of_lt (he â–¸ h.2)))
(Î» hlt, @is_preconnected.intermediate_value_Ico _ _ _ _ _ _ _ (is_preconnected_Ioc)
  _ _ âŸ¨hlt, refl bâŸ© (left_nhds_within_Ioc_ne_bot hlt) inf_le_right _ (hf.mono Ioc_subset_Icc_self)
  _ ((hf.continuous_within_at âŸ¨refl a, habâŸ©).mono Ioc_subset_Icc_self))

lemma intermediate_value_Ioo {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ioo (f a) (f b) âŠ† f '' (Ioo a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.2 (not_lt_of_lt (he â–¸ h.1)))
(Î» hlt, @is_preconnected.intermediate_value_Ioo _ _ _ _ _ _ _ (is_preconnected_Ioo)
  _ _ (left_nhds_within_Ioo_ne_bot hlt) (right_nhds_within_Ioo_ne_bot hlt)
  inf_le_right inf_le_right _ (hf.mono Ioo_subset_Icc_self)
  _ _ ((hf.continuous_within_at âŸ¨refl a, habâŸ©).mono Ioo_subset_Icc_self)
  ((hf.continuous_within_at âŸ¨hab, refl bâŸ©).mono Ioo_subset_Icc_self))

lemma intermediate_value_Ioo' {a b : Î±} (hab : a â‰¤ b) {f : Î± â†’ Î´} (hf : continuous_on f (Icc a b)) :
  Ioo (f b) (f a) âŠ† f '' (Ioo a b) :=
or.elim (eq_or_lt_of_le hab) (Î» he y h, absurd h.1 (not_lt_of_lt (he â–¸ h.2)))
(Î» hlt, @is_preconnected.intermediate_value_Ioo _ _ _ _ _ _ _ (is_preconnected_Ioo)
  _ _ (right_nhds_within_Ioo_ne_bot hlt) (left_nhds_within_Ioo_ne_bot hlt)
  inf_le_right inf_le_right _ (hf.mono Ioo_subset_Icc_self)
  _ _ ((hf.continuous_within_at âŸ¨hab, refl bâŸ©).mono Ioo_subset_Icc_self)
  ((hf.continuous_within_at âŸ¨refl a, habâŸ©).mono Ioo_subset_Icc_self))

/-- A continuous function which tendsto `at_top` `at_top` and to `at_bot` `at_bot` is surjective. -/
lemma continuous.surjective {f : Î± â†’ Î´} (hf : continuous f) (h_top : tendsto f at_top at_top)
  (h_bot : tendsto f at_bot at_bot) :
  function.surjective f :=
Î» p, mem_range_of_exists_le_of_exists_ge hf
  (h_bot.eventually (eventually_le_at_bot p)).exists
  (h_top.eventually (eventually_ge_at_top p)).exists

/-- A continuous function which tendsto `at_bot` `at_top` and to `at_top` `at_bot` is surjective. -/
lemma continuous.surjective' {f : Î± â†’ Î´} (hf : continuous f) (h_top : tendsto f at_bot at_top)
  (h_bot : tendsto f at_top at_bot) :
  function.surjective f :=
@continuous.surjective (order_dual Î±) _ _ _ _ _ _ _ _ _ hf h_top h_bot

/-- If a function `f : Î± â†’ Î²` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_bot : filter Î²` along `at_bot : filter â†¥s` and tends to `at_top : filter Î²` along
`at_top : filter â†¥s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
lemma continuous_on.surj_on_of_tendsto {f : Î± â†’ Î²} {s : set Î±} [ord_connected s]
  (hs : s.nonempty) (hf : continuous_on f s) (hbot : tendsto (Î» x : s, f x) at_bot at_bot)
  (htop : tendsto (Î» x : s, f x) at_top at_top) :
  surj_on f s univ :=
by haveI := inhabited_of_nonempty hs.to_subtype;
  exact (surj_on_iff_surjective.2 $
    (continuous_on_iff_continuous_restrict.1 hf).surjective htop hbot)

/-- If a function `f : Î± â†’ Î²` is continuous on a nonempty interval `s`, its restriction to `s`
tends to `at_top : filter Î²` along `at_bot : filter â†¥s` and tends to `at_bot : filter Î²` along
`at_top : filter â†¥s`, then the restriction of `f` to `s` is surjective. We formulate the
conclusion as `surj_on f s univ`. -/
lemma continuous_on.surj_on_of_tendsto' {f : Î± â†’ Î²} {s : set Î±} [ord_connected s]
  (hs : s.nonempty) (hf : continuous_on f s) (hbot : tendsto (Î» x : s, f x) at_bot at_top)
  (htop : tendsto (Î» x : s, f x) at_top at_bot) :
  surj_on f s univ :=
@continuous_on.surj_on_of_tendsto Î± (order_dual Î²) _ _ _ _ _ _ _ _ _ _ hs hf hbot htop

end densely_ordered

/-- A closed interval in a conditionally complete linear order is compact. -/
lemma is_compact_Icc {a b : Î±} : is_compact (Icc a b) :=
begin
  cases le_or_lt a b with hab hab, swap, { simp [hab] },
  refine is_compact_iff_ultrafilter_le_nhds.2 (Î» f hf, _),
  contrapose! hf,
  rw [le_principal_iff],
  have hpt : âˆ€ x âˆˆ Icc a b, {x} âˆ‰ f,
    from Î» x hx hxf, hf x hx ((le_pure_iff.2 hxf).trans (pure_le_nhds x)),
  set s := {x âˆˆ Icc a b | Icc a x âˆ‰ f},
  have hsb : b âˆˆ upper_bounds s, from Î» x hx, hx.1.2,
  have sbd : bdd_above s, from âŸ¨b, hsbâŸ©,
  have ha : a âˆˆ s, by simp [hpt, hab],
  rcases hab.eq_or_lt with rfl|hlt, { exact ha.2 },
  set c := Sup s,
  have hsc : is_lub s c, from is_lub_cSup âŸ¨a, haâŸ© sbd,
  have hc : c âˆˆ Icc a b, from âŸ¨hsc.1 ha, hsc.2 hsbâŸ©,
  specialize hf c hc,
  have hcs : c âˆˆ s,
  { cases hc.1.eq_or_lt with heq hlt, { rwa â† heq },
    refine âŸ¨hc, Î» hcf, hf (Î» U hU, _)âŸ©,
    rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' hlt).1 (mem_nhds_within_of_mem_nhds hU)
      with âŸ¨x, hxc, hxUâŸ©,
    rcases ((hsc.frequently_mem âŸ¨a, haâŸ©).and_eventually
      (Ioc_mem_nhds_within_Iic âŸ¨hxc, le_rflâŸ©)).exists
      with âŸ¨y, âŸ¨hyab, hyfâŸ©, hyâŸ©,
    refine mem_sets_of_superset(f.diff_mem_iff.2 âŸ¨hcf, hyfâŸ©) (subset.trans _ hxU),
    rw diff_subset_iff,
    exact subset.trans Icc_subset_Icc_union_Ioc
      (union_subset_union subset.rfl $ Ioc_subset_Ioc_left hy.1.le) },
  cases hc.2.eq_or_lt with heq hlt, { rw â† heq, exact hcs.2 },
  contrapose! hf,
  intros U hU,
  rcases (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1 (mem_nhds_within_of_mem_nhds hU)
    with âŸ¨y, hxy, hyUâŸ©,
  refine mem_sets_of_superset _ hyU, clear_dependent U,
  have hy : y âˆˆ Icc a b, from âŸ¨hc.1.trans hxy.1.le, hxy.2âŸ©,
  by_cases hay : Icc a y âˆˆ f,
  { refine mem_sets_of_superset (f.diff_mem_iff.2 âŸ¨f.diff_mem_iff.2 âŸ¨hay, hcs.2âŸ©, hpt y hyâŸ©) _,
    rw [diff_subset_iff, union_comm, Ico_union_right hxy.1.le, diff_subset_iff],
    exact Icc_subset_Icc_union_Icc },
  { exact ((hsc.1 âŸ¨hy, hayâŸ©).not_lt hxy.1).elim },
end

/-- An unordered closed interval in a conditionally complete linear order is compact. -/
lemma is_compact_interval {a b : Î±} : is_compact (interval a b) := is_compact_Icc

lemma is_compact_pi_Icc {Î¹ : Type*} {Î± : Î¹ â†’ Type*} [Î  i, conditionally_complete_linear_order (Î± i)]
  [Î  i, topological_space (Î± i)] [Î  i, order_topology (Î± i)] (a b : Î  i, Î± i) :
  is_compact (Icc a b) :=
pi_univ_Icc a b â–¸ is_compact_univ_pi $ Î» i, is_compact_Icc

instance compact_space_Icc (a b : Î±) : compact_space (Icc a b) :=
is_compact_iff_compact_space.mp is_compact_Icc

instance compact_space_pi_Icc {Î¹ : Type*} {Î± : Î¹ â†’ Type*}
  [Î  i, conditionally_complete_linear_order (Î± i)] [Î  i, topological_space (Î± i)]
  [Î  i, order_topology (Î± i)] (a b : Î  i, Î± i) : compact_space (Icc a b) :=
is_compact_iff_compact_space.mp (is_compact_pi_Icc a b)

@[priority 100] -- See note [lower instance priority]
instance compact_space_of_complete_linear_order {Î± : Type*} [complete_linear_order Î±]
  [topological_space Î±] [order_topology Î±] :
  compact_space Î± :=
âŸ¨by simp only [â† Icc_bot_top, is_compact_Icc]âŸ©

lemma is_compact.Inf_mem {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  Inf s âˆˆ s :=
hs.is_closed.cInf_mem ne_s hs.bdd_below

lemma is_compact.Sup_mem {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  Sup s âˆˆ s :=
@is_compact.Inf_mem (order_dual Î±) _ _ _ _ hs ne_s

lemma is_compact.is_glb_Inf {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_glb s (Inf s) :=
is_glb_cInf ne_s hs.bdd_below

lemma is_compact.is_lub_Sup {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_lub s (Sup s) :=
@is_compact.is_glb_Inf (order_dual Î±) _ _ _ _ hs ne_s

lemma is_compact.is_least_Inf {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_least s (Inf s) :=
âŸ¨hs.Inf_mem ne_s, (hs.is_glb_Inf ne_s).1âŸ©

lemma is_compact.is_greatest_Sup {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  is_greatest s (Sup s) :=
@is_compact.is_least_Inf (order_dual Î±) _ _ _ _ hs ne_s

lemma is_compact.exists_is_least {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  âˆƒ x, is_least s x :=
âŸ¨_, hs.is_least_Inf ne_sâŸ©

lemma is_compact.exists_is_greatest {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  âˆƒ x, is_greatest s x :=
âŸ¨_, hs.is_greatest_Sup ne_sâŸ©

lemma is_compact.exists_is_glb {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  âˆƒ x âˆˆ s, is_glb s x :=
âŸ¨_, hs.Inf_mem ne_s, hs.is_glb_Inf ne_sâŸ©

lemma is_compact.exists_is_lub {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) :
  âˆƒ x âˆˆ s, is_lub s x :=
âŸ¨_, hs.Sup_mem ne_s, hs.is_lub_Sup ne_sâŸ©

lemma is_compact.exists_Inf_image_eq {Î± : Type u} [topological_space Î±]
  {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) {f : Î± â†’ Î²} (hf : continuous_on f s) :
  âˆƒ x âˆˆ s,  Inf (f '' s) = f x :=
let âŸ¨x, hxs, hxâŸ© := (hs.image_of_continuous_on hf).Inf_mem (ne_s.image f)
in âŸ¨x, hxs, hx.symmâŸ©

lemma is_compact.exists_Sup_image_eq {Î± : Type u} [topological_space Î±]:
  âˆ€ {s : set Î±}, is_compact s â†’ s.nonempty â†’ âˆ€ {f : Î± â†’ Î²}, continuous_on f s â†’
  âˆƒ x âˆˆ s,  Sup (f '' s) = f x :=
@is_compact.exists_Inf_image_eq (order_dual Î²) _ _ _ _ _

lemma eq_Icc_of_connected_compact {s : set Î±} (hâ‚ : is_connected s) (hâ‚‚ : is_compact s) :
  s = Icc (Inf s) (Sup s) :=
eq_Icc_cInf_cSup_of_connected_bdd_closed hâ‚ hâ‚‚.bdd_below hâ‚‚.bdd_above hâ‚‚.is_closed

/-- The extreme value theorem: a continuous function realizes its minimum on a compact set -/
lemma is_compact.exists_forall_le {Î± : Type u} [topological_space Î±]
  {s : set Î±} (hs : is_compact s) (ne_s : s.nonempty) {f : Î± â†’ Î²} (hf : continuous_on f s) :
  âˆƒxâˆˆs, âˆ€yâˆˆs, f x â‰¤ f y :=
begin
  rcases hs.exists_Inf_image_eq ne_s hf with âŸ¨x, hxs, hxâŸ©,
  refine âŸ¨x, hxs, Î» y hy, _âŸ©,
  rw â† hx,
  exact ((hs.image_of_continuous_on hf).is_glb_Inf (ne_s.image f)).1 (mem_image_of_mem _ hy)
end

/-- The extreme value theorem: a continuous function realizes its maximum on a compact set -/
lemma is_compact.exists_forall_ge {Î± : Type u} [topological_space Î±]:
  âˆ€ {s : set Î±}, is_compact s â†’ s.nonempty â†’ âˆ€ {f : Î± â†’ Î²}, continuous_on f s â†’
  âˆƒxâˆˆs, âˆ€yâˆˆs, f y â‰¤ f x :=
@is_compact.exists_forall_le (order_dual Î²) _ _ _ _ _

/-- The extreme value theorem: if a continuous function `f` tends to infinity away from compact
sets, then it has a global minimum. -/
lemma continuous.exists_forall_le {Î± : Type*} [topological_space Î±] [nonempty Î±] {f : Î± â†’ Î²}
  (hf : continuous f) (hlim : tendsto f (cocompact Î±) at_top) :
  âˆƒ x, âˆ€ y, f x â‰¤ f y :=
begin
  inhabit Î±,
  obtain âŸ¨s : set Î±, hsc : is_compact s, hsf : âˆ€ x âˆ‰ s, f (default Î±) â‰¤ f xâŸ© :=
    (has_basis_cocompact.tendsto_iff at_top_basis).1 hlim (f $ default Î±) trivial,
  obtain âŸ¨x, -, hxâŸ© :=
    (hsc.insert (default Î±)).exists_forall_le (nonempty_insert _ _) hf.continuous_on,
  refine âŸ¨x, Î» y, _âŸ©,
  by_cases hy : y âˆˆ s,
  exacts [hx y (or.inr hy), (hx _ (or.inl rfl)).trans (hsf y hy)]
end

/-- The extreme value theorem: if a continuous function `f` tends to negative infinity away from
compactx sets, then it has a global maximum. -/
lemma continuous.exists_forall_ge {Î± : Type*} [topological_space Î±] [nonempty Î±] {f : Î± â†’ Î²}
  (hf : continuous f) (hlim : tendsto f (cocompact Î±) at_bot) :
  âˆƒ x, âˆ€ y, f y â‰¤ f x :=
@continuous.exists_forall_le (order_dual Î²) _ _ _ _ _ _ _ hf hlim

end conditionally_complete_linear_order

end order_topology

/-!
### Bounded monotone sequences converge

The first result in this section is that in a linear order `Î±`, if the range of a monotone function
`f : Î± â†’ Î¹` admits a least upper bound `a`, then `f` converges to `a`.

Later results specialize this to the case of (conditionally) complete linear orders, where the
existence of a least upper bound `Î±` is automatic.  In these settings the result is that `f`
converges to its supremum, `â¨† i, f i`.

Here is a counter-example to show that the order must be a linear (i.e., total) order. Take
`Î± = [0, 1) â†’ â„` with the natural lattice structure; this is a `conditionally_complete_lattice`.
Take `Î¹ = â„•` and `f n x = -x^n`. Then `â¨† n, f n = 0` while none of `f n` is strictly greater than
the constant function `-0.5`.
-/

lemma tendsto_at_top_is_lub {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±] [linear_order Î±]
  [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : monotone f) {a : Î±} (ha : is_lub (set.range f) a) :
  tendsto f at_top (ğ“ a) :=
begin
  by_cases hi : nonempty Î¹,
  { resetI,
    rw tendsto_order,
    split,
    { intros a' ha',
      obtain âŸ¨_, âŸ¨N, rflâŸ©, hNâŸ© : âˆƒ x âˆˆ set.range f, a' < x := (lt_is_lub_iff ha).mp ha',
      have := ha.2,
      apply eventually.mono (mem_at_top N),
      exact Î» i hi, lt_of_lt_of_le hN (h_mono hi) },
    { intros a' ha',
      exact eventually_of_forall (Î» i, lt_of_le_of_lt (ha.1 (set.mem_range_self i)) ha') } },
  { exact tendsto_of_not_nonempty hi }
end

lemma tendsto_at_bot_is_glb {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±] [linear_order Î±]
  [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : monotone f) {a : Î±} (ha : is_glb (set.range f) a) :
  tendsto f at_bot (ğ“ a) :=
@tendsto_at_top_is_lub (order_dual Î¹) (order_dual Î±) _ _ _ _ _ h_mono.order_dual _ ha

lemma tendsto_at_top_csupr {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [conditionally_complete_linear_order Î±] [order_topology Î±]
  {f : Î¹ â†’ Î±} (h_mono : monotone f) (hbdd : bdd_above $ range f) :
  tendsto f at_top (ğ“ (â¨†i, f i)) :=
begin
  by_cases hi : nonempty Î¹,
  { resetI,
    exact tendsto_at_top_is_lub h_mono (is_lub_cSup (range_nonempty f) hbdd) },
  { exact tendsto_of_not_nonempty hi }
end

lemma tendsto_at_bot_cinfi {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [conditionally_complete_linear_order Î±] [order_topology Î±]
  {f : Î¹ â†’ Î±} (h_mono : monotone f) (hbdd : bdd_below $ range f) :
  tendsto f at_bot (ğ“ (â¨…i, f i)) :=
@tendsto_at_top_csupr (order_dual Î¹) (order_dual Î±) _ _ _ _ _ h_mono.order_dual hbdd

lemma tendsto_at_top_cinfi {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [conditionally_complete_linear_order Î±] [order_topology Î±]
  {f : Î¹ â†’ Î±} (h_mono : âˆ€ â¦ƒi jâ¦„, i â‰¤ j â†’ f j â‰¤ f i) (hbdd : bdd_below $ range f) :
  tendsto f at_top (ğ“ (â¨…i, f i)) :=
@tendsto_at_top_csupr _ (order_dual Î±) _ _ _ _ _ @h_mono hbdd

lemma tendsto_at_bot_csupr {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [conditionally_complete_linear_order Î±] [order_topology Î±]
  {f : Î¹ â†’ Î±} (h_mono : âˆ€ â¦ƒi jâ¦„, i â‰¤ j â†’ f j â‰¤ f i) (hbdd : bdd_above $ range f) :
  tendsto f at_bot (ğ“ (â¨†i, f i)) :=
@tendsto_at_bot_cinfi Î¹ (order_dual Î±) _ _ _ _ _ h_mono hbdd

lemma tendsto_at_top_supr {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [complete_linear_order Î±] [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : monotone f) :
  tendsto f at_top (ğ“ (â¨†i, f i)) :=
tendsto_at_top_csupr h_mono (order_top.bdd_above _)

lemma tendsto_at_bot_infi {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [complete_linear_order Î±] [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : monotone f) :
  tendsto f at_bot (ğ“ (â¨…i, f i)) :=
tendsto_at_bot_cinfi h_mono (order_bot.bdd_below _)

lemma tendsto_at_top_infi {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [complete_linear_order Î±] [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : âˆ€ â¦ƒi jâ¦„, i â‰¤ j â†’ f j â‰¤ f i) :
  tendsto f at_top (ğ“ (â¨…i, f i)) :=
tendsto_at_top_cinfi @h_mono (order_bot.bdd_below _)

lemma tendsto_at_bot_supr {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [complete_linear_order Î±] [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : âˆ€ â¦ƒi jâ¦„, i â‰¤ j â†’ f j â‰¤ f i) :
  tendsto f at_bot (ğ“ (â¨†i, f i)) :=
tendsto_at_bot_csupr h_mono (order_top.bdd_above _)

lemma tendsto_of_monotone {Î¹ Î± : Type*} [preorder Î¹] [topological_space Î±]
  [conditionally_complete_linear_order Î±] [order_topology Î±] {f : Î¹ â†’ Î±} (h_mono : monotone f) :
  tendsto f at_top at_top âˆ¨ (âˆƒ l, tendsto f at_top (ğ“ l)) :=
if H : bdd_above (range f) then or.inr âŸ¨_, tendsto_at_top_csupr h_mono HâŸ©
else or.inl $ tendsto_at_top_at_top_of_monotone' h_mono H

lemma tendsto_iff_tendsto_subseq_of_monotone {Î¹â‚ Î¹â‚‚ Î± : Type*} [semilattice_sup Î¹â‚] [preorder Î¹â‚‚]
  [nonempty Î¹â‚] [topological_space Î±] [conditionally_complete_linear_order Î±] [order_topology Î±]
  [no_top_order Î±] {f : Î¹â‚‚ â†’ Î±} {Ï† : Î¹â‚ â†’ Î¹â‚‚} {l : Î±} (hf : monotone f)
  (hg : tendsto Ï† at_top at_top) :
  tendsto f at_top (ğ“ l) â†” tendsto (f âˆ˜ Ï†) at_top (ğ“ l) :=
begin
  split; intro h,
  { exact h.comp hg },
  { rcases tendsto_of_monotone hf with h' | âŸ¨l', hl'âŸ©,
    { exact (not_tendsto_at_top_of_tendsto_nhds h (h'.comp hg)).elim },
    { rwa tendsto_nhds_unique h (hl'.comp hg) } }
end

/-! The next family of results, such as `is_lub_of_tendsto` and `supr_eq_of_tendsto`, are converses
to the standard fact that bounded monotone functions converge. They state, that if a monotone
function `f` tends to `a` along `at_top`, then that value `a` is a least upper bound for the range
of `f`.

Related theorems above (`is_lub.is_lub_of_tendsto`, `is_glb.is_glb_of_tendsto` etc) cover the case
when `f x` tends to `a` as `x` tends to some point `b` in the domain. -/

lemma monotone.ge_of_tendsto {Î± Î² : Type*} [topological_space Î±] [preorder Î±]
  [order_closed_topology Î±] [semilattice_sup Î²] {f : Î² â†’ Î±} {a : Î±} (hf : monotone f)
  (ha : tendsto f at_top (ğ“ a)) (b : Î²) :
  f b â‰¤ a :=
begin
  haveI : nonempty Î² := nonempty.intro b,
  exact ge_of_tendsto ha ((eventually_ge_at_top b).mono (Î» _ hxy, hf hxy))
end

lemma monotone.le_of_tendsto {Î± Î² : Type*} [topological_space Î±] [preorder Î±]
  [order_closed_topology Î±] [semilattice_inf Î²] {f : Î² â†’ Î±} {a : Î±} (hf : monotone f)
  (ha : tendsto f at_bot (ğ“ a)) (b : Î²) :
  a â‰¤ f b :=
@monotone.ge_of_tendsto (order_dual Î±) (order_dual Î²) _ _ _ _ f _ hf.order_dual ha b

lemma is_lub_of_tendsto {Î± Î² : Type*} [topological_space Î±] [preorder Î±] [order_closed_topology Î±]
  [nonempty Î²] [semilattice_sup Î²] {f : Î² â†’ Î±} {a : Î±} (hf : monotone f)
  (ha : tendsto f at_top (ğ“ a)) :
  is_lub (set.range f) a :=
begin
  split,
  { rintros _ âŸ¨b, rflâŸ©,
    exact hf.ge_of_tendsto ha b },
  { exact Î» _ hb, le_of_tendsto' ha (Î» x, hb (set.mem_range_self x)) }
end

lemma is_glb_of_tendsto {Î± Î² : Type*} [topological_space Î±] [preorder Î±] [order_closed_topology Î±]
  [nonempty Î²] [semilattice_inf Î²] {f : Î² â†’ Î±} {a : Î±} (hf : monotone f)
  (ha : tendsto f at_bot (ğ“ a)) :
  is_glb (set.range f) a :=
@is_lub_of_tendsto (order_dual Î±) (order_dual Î²) _ _ _ _ _ _ _ hf.order_dual ha

lemma supr_eq_of_tendsto {Î± Î²} [topological_space Î±] [complete_linear_order Î±] [order_topology Î±]
  [nonempty Î²] [semilattice_sup Î²] {f : Î² â†’ Î±} {a : Î±} (hf : monotone f) :
  tendsto f at_top (ğ“ a) â†’ supr f = a :=
tendsto_nhds_unique (tendsto_at_top_supr hf)

lemma infi_eq_of_tendsto {Î±} [topological_space Î±] [complete_linear_order Î±] [order_topology Î±]
  [nonempty Î²] [semilattice_sup Î²] {f : Î² â†’ Î±} {a : Î±} (hf : âˆ€n m, n â‰¤ m â†’ f m â‰¤ f n) :
  tendsto f at_top (ğ“ a) â†’ infi f = a :=
tendsto_nhds_unique (tendsto_at_top_infi hf)

lemma supr_eq_supr_subseq_of_monotone {Î¹â‚ Î¹â‚‚ Î± : Type*} [preorder Î¹â‚‚] [complete_lattice Î±]
  {l : filter Î¹â‚} [l.ne_bot] {f : Î¹â‚‚ â†’ Î±} {Ï† : Î¹â‚ â†’ Î¹â‚‚} (hf : monotone f)
  (hÏ† : tendsto Ï† l at_top) :
  (â¨† i, f i) = (â¨† i, f (Ï† i)) :=
le_antisymm
  (supr_le_supr2 $ Î» i, exists_imp_exists (Î» j (hj : i â‰¤ Ï† j), hf hj)
    (hÏ†.eventually $ eventually_ge_at_top i).exists)
  (supr_le_supr2 $ Î» i, âŸ¨Ï† i, le_refl _âŸ©)

lemma infi_eq_infi_subseq_of_monotone {Î¹â‚ Î¹â‚‚ Î± : Type*} [preorder Î¹â‚‚] [complete_lattice Î±]
  {l : filter Î¹â‚} [l.ne_bot] {f : Î¹â‚‚ â†’ Î±} {Ï† : Î¹â‚ â†’ Î¹â‚‚} (hf : monotone f)
  (hÏ† : tendsto Ï† l at_bot) :
  (â¨… i, f i) = (â¨… i, f (Ï† i)) :=
le_antisymm
  (infi_le_infi2 $ Î» i, âŸ¨Ï† i, le_refl _âŸ©)
  (infi_le_infi2 $ Î» i, exists_imp_exists (Î» j (hj : Ï† j â‰¤ i), hf hj)
    (hÏ†.eventually $ eventually_le_at_bot i).exists)

@[to_additive] lemma tendsto_inv_nhds_within_Ioi [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Ioi a] a) (ğ“[Iio (aâ»Â¹)] (aâ»Â¹)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Iio [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Iio a] a) (ğ“[Ioi (aâ»Â¹)] (aâ»Â¹)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Ioi_inv [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Ioi (aâ»Â¹)] (aâ»Â¹)) (ğ“[Iio a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Ioi _ _ _ _ (aâ»Â¹)

@[to_additive] lemma tendsto_inv_nhds_within_Iio_inv [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Iio (aâ»Â¹)] (aâ»Â¹)) (ğ“[Ioi a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Iio _ _ _ _ (aâ»Â¹)

@[to_additive] lemma tendsto_inv_nhds_within_Ici [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Ici a] a) (ğ“[Iic (aâ»Â¹)] (aâ»Â¹)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Iic [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Iic a] a) (ğ“[Ici (aâ»Â¹)] (aâ»Â¹)) :=
(continuous_inv.tendsto a).inf $ by simp [tendsto_principal_principal]

@[to_additive] lemma tendsto_inv_nhds_within_Ici_inv [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Ici (aâ»Â¹)] (aâ»Â¹)) (ğ“[Iic a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Ici _ _ _ _ (aâ»Â¹)

@[to_additive] lemma tendsto_inv_nhds_within_Iic_inv [ordered_comm_group Î±]
  [topological_space Î±] [topological_group Î±] {a : Î±} :
  tendsto has_inv.inv (ğ“[Iic (aâ»Â¹)] (aâ»Â¹)) (ğ“[Ici a] a) :=
by simpa only [inv_inv] using @tendsto_inv_nhds_within_Iic _ _ _ _ (aâ»Â¹)

lemma nhds_left_sup_nhds_right (a : Î±) [topological_space Î±] [linear_order Î±] :
  ğ“[Iic a] a âŠ” ğ“[Ici a] a = ğ“ a :=
by rw [â† nhds_within_union, Iic_union_Ici, nhds_within_univ]

lemma nhds_left'_sup_nhds_right (a : Î±) [topological_space Î±] [linear_order Î±] :
  ğ“[Iio a] a âŠ” ğ“[Ici a] a = ğ“ a :=
by rw [â† nhds_within_union, Iio_union_Ici, nhds_within_univ]

lemma nhds_left_sup_nhds_right' (a : Î±) [topological_space Î±] [linear_order Î±] :
  ğ“[Iic a] a âŠ” ğ“[Ioi a] a = ğ“ a :=
by rw [â† nhds_within_union, Iic_union_Ioi, nhds_within_univ]

lemma continuous_at_iff_continuous_left_right [topological_space Î±] [linear_order Î±]
  [topological_space Î²] {a : Î±} {f : Î± â†’ Î²} :
  continuous_at f a â†” continuous_within_at f (Iic a) a âˆ§ continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, continuous_at, â† tendsto_sup, nhds_left_sup_nhds_right]

lemma continuous_within_at_Ioi_iff_Ici {Î± Î² : Type*} [topological_space Î±] [partial_order Î±]
  [topological_space Î²] {a : Î±} {f : Î± â†’ Î²} :
  continuous_within_at f (Ioi a) a â†” continuous_within_at f (Ici a) a :=
by simp only [â† Ici_diff_left, continuous_within_at_diff_self]

lemma continuous_within_at_Iio_iff_Iic
  {Î± Î² : Type*} [topological_space Î±] [linear_order Î±] [topological_space Î²] {a : Î±} {f : Î± â†’ Î²} :
  continuous_within_at f (Iio a) a â†” continuous_within_at f (Iic a) a :=
begin
  have := @continuous_within_at_Ioi_iff_Ici (order_dual Î±) _ _ _ _ _ f,
  erw [dual_Ici, dual_Ioi] at this,
  exact this,
end

lemma continuous_at_iff_continuous_left'_right' [topological_space Î±] [linear_order Î±]
  [topological_space Î²] {a : Î±} {f : Î± â†’ Î²} :
  continuous_at f a â†” continuous_within_at f (Iio a) a âˆ§ continuous_within_at f (Ioi a) a :=
by rw [continuous_within_at_Ioi_iff_Ici, continuous_within_at_Iio_iff_Iic,
  continuous_at_iff_continuous_left_right]

/-!
### Continuity of monotone functions

In this section we prove the following fact: if `f` is a monotone function on a neighborhood of `a`
and the image of this neighborhood is a neighborhood of `f a`, then `f` is continuous at `a`, see
`continuous_at_of_mono_incr_on_of_image_mem_nhds`, as well as several similar facts.
-/

section linear_order
variables [linear_order Î±] [topological_space Î±] [order_topology Î±]
variables [linear_order Î²] [topological_space Î²] [order_topology Î²]

/-- If `f` is a function strictly monotonically increasing on a right neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(f a, b]`, `b > f a`, then `f` is
continuous at `a` from the right.

The assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` is required because otherwise the
function `f : â„ â†’ â„` given by `f x = if x â‰¤ 0 then x else x + 1` would be a counter-example at
`a = 0`. -/
lemma strict_mono_incr_on.continuous_at_right_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Ici a] a)
  (hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b) :
  continuous_within_at f (Ici a) a :=
begin
  have ha : a âˆˆ Ici a := left_mem_Ici,
  have has : a âˆˆ s := mem_of_mem_nhds_within ha hs,
  refine tendsto_order.2 âŸ¨Î» b hb, _, Î» b hb, _âŸ©,
  { filter_upwards [hs, self_mem_nhds_within],
    intros x hxs hxa,
    exact hb.trans_le ((h_mono.le_iff_le has hxs).2 hxa) },
  { rcases hfs b hb with âŸ¨c, hcs, hac, hcbâŸ©,
    rw [h_mono.lt_iff_lt has hcs] at hac,
    filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 hac)],
    rintros x hx âŸ¨hax, hxcâŸ©,
    exact ((h_mono.lt_iff_lt hx hcs).2 hxc).trans_le hcb }
end

/-- If `f` is a function monotonically increasing function on a right neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(f a, b)`, `b > f a`, then `f` is
continuous at `a` from the right.

The assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo (f a) b` cannot be replaced by the weaker
assumption `hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b` we use for strictly monotone functions
because otherwise the function `ceil : â„ â†’ â„¤` would be a counter-example at `a = 0`. -/
lemma continuous_at_right_of_mono_incr_on_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“[Ici a] a)
  (hfs : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo (f a) b) :
  continuous_within_at f (Ici a) a :=
begin
  have ha : a âˆˆ Ici a := left_mem_Ici,
  have has : a âˆˆ s := mem_of_mem_nhds_within ha hs,
  refine tendsto_order.2 âŸ¨Î» b hb, _, Î» b hb, _âŸ©,
  { filter_upwards [hs, self_mem_nhds_within],
    intros x hxs hxa,
    exact hb.trans_le (h_mono _ has _ hxs hxa) },
  { rcases hfs b hb with âŸ¨c, hcs, hac, hcbâŸ©,
    have : a < c, from not_le.1 (Î» h, hac.not_le $ h_mono _ hcs _ has h),
    filter_upwards [hs, Ico_mem_nhds_within_Ici (left_mem_Ico.2 this)],
    rintros x hx âŸ¨hax, hxcâŸ©,
    exact (h_mono _ hx _ hcs hxc.le).trans_lt hcb }
end

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a right
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a right
neighborhood of `f a`, then `f` is continuous at `a` from the right. -/
lemma continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y)
  (hs : s âˆˆ ğ“[Ici a] a) (hfs : closure (f '' s) âˆˆ ğ“[Ici (f a)] (f a)) :
  continuous_within_at f (Ici a) a :=
begin
  refine continuous_at_right_of_mono_incr_on_of_exists_between h_mono hs (Î» b hb, _),
  rcases (mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset hb).1 hfs with âŸ¨b', âŸ¨hab', hbb'âŸ©, hb'âŸ©,
  rcases exists_between hab' with âŸ¨c', hc'âŸ©,
  rcases mem_closure_iff.1 (hb' âŸ¨hc'.1.le, hc'.2âŸ©) (Ioo (f a) b') is_open_Ioo hc'
    with âŸ¨_, hc, âŸ¨c, hcs, rflâŸ©âŸ©,
  exact âŸ¨c, hcs, hc.1, hc.2.trans_le hbb'âŸ©
end

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a right
neighborhood of `a` and the image of this neighborhood under `f` is a right neighborhood of `f a`,
then `f` is continuous at `a` from the right. -/
lemma continuous_at_right_of_mono_incr_on_of_image_mem_nhds_within [densely_ordered Î²] {f : Î± â†’ Î²}
  {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“[Ici a] a)
  (hfs : f '' s âˆˆ ğ“[Ici (f a)] (f a)) :
  continuous_within_at f (Ici a) a :=
continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono hs $
  mem_sets_of_superset hfs subset_closure

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
right neighborhood of `a` and the closure of the image of this neighborhood under `f` is a right
neighborhood of `f a`, then `f` is continuous at `a` from the right. -/
lemma strict_mono_incr_on.continuous_at_right_of_closure_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Ici a] a)
  (hfs : closure (f '' s) âˆˆ ğ“[Ici (f a)] (f a)) :
  continuous_within_at f (Ici a) a :=
continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within
  (Î» x hx y hy, (h_mono.le_iff_le hx hy).2) hs hfs

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
right neighborhood of `a` and the image of this neighborhood under `f` is a right neighborhood of
`f a`, then `f` is continuous at `a` from the right. -/
lemma strict_mono_incr_on.continuous_at_right_of_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Ici a] a)
  (hfs : f '' s âˆˆ ğ“[Ici (f a)] (f a)) :
  continuous_within_at f (Ici a) a :=
h_mono.continuous_at_right_of_closure_image_mem_nhds_within hs
  (mem_sets_of_superset hfs subset_closure)

/-- If a function `f` is strictly monotonically increasing on a right neighborhood of `a` and the
image of this neighborhood under `f` includes `Ioi (f a)`, then `f` is continuous at `a` from the
right. -/
lemma strict_mono_incr_on.continuous_at_right_of_surj_on {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Ici a] a) (hfs : surj_on f s (Ioi (f a))) :
  continuous_within_at f (Ici a) a :=
h_mono.continuous_at_right_of_exists_between hs $ Î» b hb, let âŸ¨c, hcs, hcbâŸ© := hfs hb in
âŸ¨c, hcs, hcb.symm â–¸ hb, hcb.leâŸ©

/-- If `f` is a function strictly monotonically increasing on a left neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `[b, f a)`, `b < f a`, then `f` is
continuous at `a` from the left.

The assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` is required because otherwise the
function `f : â„ â†’ â„` given by `f x = if x < 0 then x else x + 1` would be a counter-example at
`a = 0`. -/
lemma strict_mono_incr_on.continuous_at_left_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Iic a] a)
  (hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)) :
  continuous_within_at f (Iic a) a :=
h_mono.dual.continuous_at_right_of_exists_between hs $
  Î» b hb, let âŸ¨c, hcs, hcb, hcaâŸ© := hfs b hb in âŸ¨c, hcs, hca, hcbâŸ©

/-- If `f` is a function monotonically increasing function on a left neighborhood of `a` and the
image of this neighborhood under `f` meets every interval `(b, f a)`, `b < f a`, then `f` is
continuous at `a` from the left.

The assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo b (f a)` cannot be replaced by the weaker
assumption `hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)` we use for strictly monotone functions
because otherwise the function `floor : â„ â†’ â„¤` would be a counter-example at `a = 0`. -/
lemma continuous_at_left_of_mono_incr_on_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“[Iic a] a)
  (hfs : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo b (f a)) :
  continuous_within_at f (Iic a) a :=
@continuous_at_right_of_mono_incr_on_of_exists_between (order_dual Î±) (order_dual Î²) _ _ _ _ _ _
  f s a (Î» x hx y hy, h_mono y hy x hx) hs $
  Î» b hb, let âŸ¨c, hcs, hcb, hcaâŸ© := hfs b hb in âŸ¨c, hcs, hca, hcbâŸ©

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a left
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a left
neighborhood of `f a`, then `f` is continuous at `a` from the left -/
lemma continuous_at_left_of_mono_incr_on_of_closure_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y)
  (hs : s âˆˆ ğ“[Iic a] a) (hfs : closure (f '' s) âˆˆ ğ“[Iic (f a)] (f a)) :
  continuous_within_at f (Iic a) a :=
@continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within (order_dual Î±) (order_dual Î²)
  _ _ _ _ _ _ _ f s a (Î» x hx y hy, h_mono y hy x hx) hs hfs

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a left
neighborhood of `a` and the image of this neighborhood under `f` is a left neighborhood of `f a`,
then `f` is continuous at `a` from the left. -/
lemma continuous_at_left_of_mono_incr_on_of_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y)
  (hs : s âˆˆ ğ“[Iic a] a) (hfs : f '' s âˆˆ ğ“[Iic (f a)] (f a)) :
  continuous_within_at f (Iic a) a :=
continuous_at_left_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono hs
  (mem_sets_of_superset hfs subset_closure)

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
left neighborhood of `a` and the closure of the image of this neighborhood under `f` is a left
neighborhood of `f a`, then `f` is continuous at `a` from the left. -/
lemma strict_mono_incr_on.continuous_at_left_of_closure_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Iic a] a)
  (hfs : closure (f '' s) âˆˆ ğ“[Iic (f a)] (f a)) :
  continuous_within_at f (Iic a) a :=
h_mono.dual.continuous_at_right_of_closure_image_mem_nhds_within hs hfs

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
left neighborhood of `a` and the image of this neighborhood under `f` is a left neighborhood of
`f a`, then `f` is continuous at `a` from the left. -/
lemma strict_mono_incr_on.continuous_at_left_of_image_mem_nhds_within [densely_ordered Î²]
  {f : Î± â†’ Î²} {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Iic a] a)
  (hfs : f '' s âˆˆ ğ“[Iic (f a)] (f a)) :
  continuous_within_at f (Iic a) a :=
h_mono.dual.continuous_at_right_of_image_mem_nhds_within hs hfs

/-- If a function `f` is strictly monotonically increasing on a left neighborhood of `a` and the
image of this neighborhood under `f` includes `Iio (f a)`, then `f` is continuous at `a` from the
left. -/
lemma strict_mono_incr_on.continuous_at_left_of_surj_on {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“[Iic a] a) (hfs : surj_on f s (Iio (f a))) :
  continuous_within_at f (Iic a) a :=
h_mono.dual.continuous_at_right_of_surj_on hs hfs

/-- If a function `f` is strictly monotonically increasing on a neighborhood of `a` and the image of
this neighborhood under `f` meets every interval `[b, f a)`, `b < f a`, and every interval
`(f a, b]`, `b > f a`, then `f` is continuous at `a`. -/
lemma strict_mono_incr_on.continuous_at_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“ a)
  (hfs_l : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ico b (f a)) (hfs_r : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioc (f a) b) :
  continuous_at f a :=
continuous_at_iff_continuous_left_right.2
  âŸ¨h_mono.continuous_at_left_of_exists_between (mem_nhds_within_of_mem_nhds hs) hfs_l,
   h_mono.continuous_at_right_of_exists_between (mem_nhds_within_of_mem_nhds hs) hfs_râŸ©

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
neighborhood of `a` and the closure of the image of this neighborhood under `f` is a neighborhood of
`f a`, then `f` is continuous at `a`. -/
lemma strict_mono_incr_on.continuous_at_of_closure_image_mem_nhds [densely_ordered Î²] {f : Î± â†’ Î²}
  {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“ a)
  (hfs : closure (f '' s) âˆˆ ğ“ (f a)) :
  continuous_at f a :=
continuous_at_iff_continuous_left_right.2
  âŸ¨h_mono.continuous_at_left_of_closure_image_mem_nhds_within (mem_nhds_within_of_mem_nhds hs)
     (mem_nhds_within_of_mem_nhds hfs),
   h_mono.continuous_at_right_of_closure_image_mem_nhds_within (mem_nhds_within_of_mem_nhds hs)
     (mem_nhds_within_of_mem_nhds hfs)âŸ©

/-- If a function `f` with a densely ordered codomain is strictly monotonically increasing on a
neighborhood of `a` and the image of this set under `f` is a neighborhood of `f a`, then `f` is
continuous at `a`. -/
lemma strict_mono_incr_on.continuous_at_of_image_mem_nhds [densely_ordered Î²] {f : Î± â†’ Î²}
  {s : set Î±} {a : Î±} (h_mono : strict_mono_incr_on f s) (hs : s âˆˆ ğ“ a) (hfs : f '' s âˆˆ ğ“ (f a)) :
  continuous_at f a :=
h_mono.continuous_at_of_closure_image_mem_nhds hs (mem_sets_of_superset hfs subset_closure)

/-- If `f` is a function monotonically increasing function on a neighborhood of `a` and the image of
this neighborhood under `f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a,
b)`, `b > f a`, then `f` is continuous at `a`. -/
lemma continuous_at_of_mono_incr_on_of_exists_between {f : Î± â†’ Î²} {s : set Î±} {a : Î±}
  (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“ a)
  (hfs_l : âˆ€ b < f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo b (f a)) (hfs_r : âˆ€ b > f a, âˆƒ c âˆˆ s, f c âˆˆ Ioo (f a) b) :
  continuous_at f a :=
continuous_at_iff_continuous_left_right.2
  âŸ¨continuous_at_left_of_mono_incr_on_of_exists_between h_mono
     (mem_nhds_within_of_mem_nhds hs) hfs_l,
   continuous_at_right_of_mono_incr_on_of_exists_between h_mono
     (mem_nhds_within_of_mem_nhds hs) hfs_râŸ©

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a neighborhood
of `a` and the closure of the image of this neighborhood under `f` is a neighborhood of `f a`, then
`f` is continuous at `a`. -/
lemma continuous_at_of_mono_incr_on_of_closure_image_mem_nhds [densely_ordered Î²] {f : Î± â†’ Î²}
  {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“ a)
  (hfs : closure (f '' s) âˆˆ ğ“ (f a)) :
  continuous_at f a :=
continuous_at_iff_continuous_left_right.2
  âŸ¨continuous_at_left_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono
     (mem_nhds_within_of_mem_nhds hs) (mem_nhds_within_of_mem_nhds hfs),
   continuous_at_right_of_mono_incr_on_of_closure_image_mem_nhds_within h_mono
     (mem_nhds_within_of_mem_nhds hs) (mem_nhds_within_of_mem_nhds hfs)âŸ©

/-- If a function `f` with a densely ordered codomain is monotonically increasing on a neighborhood
of `a` and the image of this neighborhood under `f` is a neighborhood of `f a`, then `f` is
continuous at `a`. -/
lemma continuous_at_of_mono_incr_on_of_image_mem_nhds [densely_ordered Î²] {f : Î± â†’ Î²}
  {s : set Î±} {a : Î±} (h_mono : âˆ€ (x âˆˆ s) (y âˆˆ s), x â‰¤ y â†’ f x â‰¤ f y) (hs : s âˆˆ ğ“ a)
  (hfs : f '' s âˆˆ ğ“ (f a)) :
  continuous_at f a :=
continuous_at_of_mono_incr_on_of_closure_image_mem_nhds h_mono hs
  (mem_sets_of_superset hfs subset_closure)

/-- A monotone function with densely ordered codomain and a dense range is continuous. -/
lemma monotone.continuous_of_dense_range [densely_ordered Î²] {f : Î± â†’ Î²}
  (h_mono : monotone f) (h_dense : dense_range f) :
  continuous f :=
continuous_iff_continuous_at.mpr $ Î» a,
  continuous_at_of_mono_incr_on_of_closure_image_mem_nhds (Î» x hx y hy hxy, h_mono hxy)
    univ_mem_sets $ by simp only [image_univ, h_dense.closure_eq, univ_mem_sets]

/-- A monotone surjective function with a densely ordered codomain is surjective. -/
lemma monotone.continuous_of_surjective [densely_ordered Î²] {f : Î± â†’ Î²} (h_mono : monotone f)
  (h_surj : function.surjective f) :
  continuous f :=
h_mono.continuous_of_dense_range h_surj.dense_range

end linear_order

/-!
### Continuity of order isomorphisms

In this section we prove that an `order_iso` is continuous, hence it is a `homeomorph`. We prove
this for an `order_iso` between to partial orders with order topology.
-/

namespace order_iso

variables [partial_order Î±] [partial_order Î²] [topological_space Î±] [topological_space Î²]
  [order_topology Î±] [order_topology Î²]

protected lemma continuous (e : Î± â‰ƒo Î²) : continuous e :=
begin
  rw [â€¹order_topology Î²â€º.topology_eq_generate_intervals],
  refine continuous_generated_from (Î» s hs, _),
  rcases hs with âŸ¨a, rfl|rflâŸ©,
  { rw e.preimage_Ioi, apply is_open_lt' },
  { rw e.preimage_Iio, apply is_open_gt' }
end

/-- An order isomorphism between two linear order `order_topology` spaces is a homeomorphism. -/
def to_homeomorph (e : Î± â‰ƒo Î²) : Î± â‰ƒâ‚œ Î² :=
{ continuous_to_fun := e.continuous,
  continuous_inv_fun := e.symm.continuous,
  .. e }

@[simp] lemma coe_to_homeomorph (e : Î± â‰ƒo Î²) : â‡‘e.to_homeomorph = e := rfl
@[simp] lemma coe_to_homeomorph_symm (e : Î± â‰ƒo Î²) : â‡‘e.to_homeomorph.symm = e.symm := rfl

end order_iso
