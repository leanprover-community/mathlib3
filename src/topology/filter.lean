/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import order.filter.lift
import topology.separation
import data.set.intervals.monotone

/-!
# Topology on the set of filters on a type

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file introduce topology on `filter Î±`. It is generated by the sets
`set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`, `s : set Î±`. A set `s : set (filter Î±)` is open if and
only if it is a union of a family of these basic open sets, see `filter.is_open_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `ğ“ : X â†’ filter X` is a topology inducing map.

* In particular, it is a continuous map, so `ğ“ âˆ˜ f` tends to `ğ“ (ğ“ a)` whenever `f` tends to `ğ“ a`.

* If `X` is an ordered topological space with order topology and no max element, then `ğ“ âˆ˜ f` tends
  to `ğ“ filter.at_top` whenever `f` tends to `filter.at_top`.

* It turns `filter X` into a Tâ‚€ space and the order on `filter X` is the dual of the
  `specialization_order (filter X)`.

## Tags

filter, topological space
-/

open set filter topological_space
open_locale filter topology

variables {Î¹ : Sort*} {Î± Î² X Y : Type*}

namespace filter

/-- Topology on `filter Î±` is generated by the sets `set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`,
`s : set Î±`. A set `s : set (filter Î±)` is open if and only if it is a union of a family of these
basic open sets, see `filter.is_open_iff`. -/
instance : topological_space (filter Î±) := generate_from $ range $ Iic âˆ˜ ğ“Ÿ

lemma is_open_Iic_principal {s : set Î±} : is_open (Iic (ğ“Ÿ s)) :=
generate_open.basic _ (mem_range_self _)

lemma is_open_set_of_mem {s : set Î±} : is_open {l : filter Î± | s âˆˆ l} :=
by simpa only [Iic_principal] using is_open_Iic_principal

lemma is_topological_basis_Iic_principal :
  is_topological_basis (range (Iic âˆ˜ ğ“Ÿ : set Î± â†’ set (filter Î±))) :=
{ exists_subset_inter :=
    begin
      rintro _ âŸ¨s, rflâŸ© _ âŸ¨t, rflâŸ© l hl,
      exact âŸ¨Iic (ğ“Ÿ s) âˆ© Iic (ğ“Ÿ t), âŸ¨s âˆ© t, by simpâŸ©, hl, subset.rflâŸ©
    end,
  sUnion_eq := sUnion_eq_univ_iff.2 $ Î» l, âŸ¨Iic âŠ¤, âŸ¨univ, congr_arg Iic principal_univâŸ©, le_topâŸ©,
  eq_generate_from := rfl }

lemma is_open_iff {s : set (filter Î±)} :
  is_open s â†” âˆƒ T : set (set Î±), s = â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t) :=
is_topological_basis_Iic_principal.open_iff_eq_sUnion.trans $
  by simp only [exists_subset_range_iff, sUnion_image]

lemma nhds_eq (l : filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=
nhds_generate_from.trans $ by simp only [mem_set_of_eq, and_comm (l âˆˆ _), infi_and, infi_range,
  filter.lift', filter.lift, (âˆ˜), mem_Iic, le_principal_iff]

lemma nhds_eq' (l : filter Î±) : ğ“ l = l.lift' (Î» s, {l' | s âˆˆ l'}) :=
by simpa only [(âˆ˜), Iic_principal] using nhds_eq l

protected lemma tendsto_nhds {la : filter Î±} {lb : filter Î²} {f : Î± â†’ filter Î²} :
  tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a :=
by simp only [nhds_eq', tendsto_lift', mem_set_of_eq]

lemma has_basis.nhds {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : has_basis l p s) :
  has_basis (ğ“ l) p (Î» i, Iic (ğ“Ÿ (s i))) :=
by { rw nhds_eq, exact h.lift' monotone_principal.Iic }

/-- Neighborhoods of a countably generated filter is a countably generated filter. -/
instance {l : filter Î±} [is_countably_generated l] : is_countably_generated (ğ“ l) :=
let âŸ¨b, hbâŸ© := l.exists_antitone_basis in has_countable_basis.is_countably_generated $
  âŸ¨hb.nhds, set.to_countable _âŸ©

lemma has_basis.nhds' {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : has_basis l p s) :
  has_basis (ğ“ l) p (Î» i, {l' | s i âˆˆ l'}) :=
by simpa only [Iic_principal] using h.nhds

lemma mem_nhds_iff {l : filter Î±} {S : set (filter Î±)} :
  S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=
l.basis_sets.nhds.mem_iff

lemma mem_nhds_iff' {l : filter Î±} {S : set (filter Î±)} :
  S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=
l.basis_sets.nhds'.mem_iff

@[simp] lemma nhds_bot : ğ“ (âŠ¥ : filter Î±) = pure âŠ¥ :=
by simp [nhds_eq, lift'_bot monotone_principal.Iic]

@[simp] lemma nhds_top : ğ“ (âŠ¤ : filter Î±) = âŠ¤ := by simp [nhds_eq]

@[simp] lemma nhds_principal (s : set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=
(has_basis_principal s).nhds.eq_of_same_basis (has_basis_principal _)

@[simp] lemma nhds_pure (x : Î±) : ğ“ (pure x : filter Î±) = ğ“Ÿ {âŠ¥, pure x} :=
by rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]

@[simp] lemma nhds_infi (f : Î¹ â†’ filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) :=
by { simp only [nhds_eq], apply lift'_infi_of_map_univ; simp }

@[simp] lemma nhds_inf (lâ‚ lâ‚‚ : filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ :=
by simpa only [infi_bool_eq] using nhds_infi (Î» b, cond b lâ‚ lâ‚‚)

lemma monotone_nhds : monotone (ğ“ : filter Î± â†’ filter (filter Î±)) :=
monotone.of_map_inf nhds_inf

lemma Inter_nhds (l : filter Î±) : â‹‚â‚€ {s | s âˆˆ ğ“ l} = Iic l :=
by simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff,
  â† set_of_forall, â† filter.le_def]

@[simp] lemma nhds_mono {lâ‚ lâ‚‚ : filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=
begin
  refine âŸ¨Î» h, _, Î» h, monotone_nhds hâŸ©,
  rw [â† Iic_subset_Iic, â† Inter_nhds, â† Inter_nhds],
  exact sInter_subset_sInter h
end

protected lemma mem_interior {s : set (filter Î±)} {l : filter Î±} :
  l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s :=
by rw [mem_interior_iff_mem_nhds, mem_nhds_iff]

protected lemma mem_closure {s : set (filter Î±)} {l : filter Î±} :
  l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' :=
by simp only [closure_eq_compl_interior_compl, filter.mem_interior, mem_compl_iff, not_exists,
  not_forall, not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic, le_principal_iff]

@[simp] protected lemma closure_singleton (l : filter Î±) : closure {l} = Ici l :=
by { ext l', simp [filter.mem_closure, filter.le_def] }

@[simp] lemma specializes_iff_le {lâ‚ lâ‚‚ : filter Î±} : lâ‚ â¤³ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=
by simp only [specializes_iff_closure_subset, filter.closure_singleton, Ici_subset_Ici]

instance : t0_space (filter Î±) :=
âŸ¨Î» x y h, (specializes_iff_le.1 h.specializes).antisymm (specializes_iff_le.1 h.symm.specializes)âŸ©

lemma nhds_at_top [preorder Î±] : ğ“ at_top = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) :=
by simp only [at_top, nhds_infi, nhds_principal]

protected lemma tendsto_nhds_at_top_iff [preorder Î²] {l : filter Î±} {f : Î± â†’ filter Î²} :
  tendsto f l (ğ“ at_top) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a :=
by simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]

lemma nhds_at_bot [preorder Î±] : ğ“ at_bot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) := @nhds_at_top Î±áµ’áµˆ _

protected lemma tendsto_nhds_at_bot_iff [preorder Î²] {l : filter Î±} {f : Î± â†’ filter Î²} :
  tendsto f l (ğ“ at_bot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=
@filter.tendsto_nhds_at_top_iff Î± Î²áµ’áµˆ _ _ _

variables [topological_space X]

lemma nhds_nhds (x : X) :
  ğ“ (ğ“ x) = â¨… (s : set X) (hs : is_open s) (hx : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) :=
by simp only [(nhds_basis_opens x).nhds.eq_binfi, infi_and, @infi_comm _ (_ âˆˆ _)]

lemma inducing_nhds : inducing (ğ“ : X â†’ filter X) :=
inducing_iff_nhds.2 $ Î» x, (nhds_def' _).trans $
  by simp only [nhds_nhds, comap_infi, comap_principal, Iic_principal, preimage_set_of_eq,
    â† mem_interior_iff_mem_nhds, set_of_mem_eq, is_open.interior_eq] { contextual := tt }

@[continuity] lemma continuous_nhds : continuous (ğ“ : X â†’ filter X) := inducing_nhds.continuous

protected lemma tendsto.nhds {f : Î± â†’ X} {l : filter Î±} {x : X} (h : tendsto f l (ğ“ x)) :
  tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=
(continuous_nhds.tendsto _).comp h

end filter

variables [topological_space X] [topological_space Y] {f : X â†’ Y} {x : X} {s : set X}

lemma continuous_within_at.nhds (h : continuous_within_at f s x) :
  continuous_within_at (ğ“ âˆ˜ f) s x :=
h.nhds

lemma continuous_at.nhds (h : continuous_at f x) : continuous_at (ğ“ âˆ˜ f) x := h.nhds
lemma continuous_on.nhds (h : continuous_on f s) : continuous_on (ğ“ âˆ˜ f) s := Î» x hx, (h x hx).nhds
lemma continuous.nhds (h : continuous f) : continuous (ğ“ âˆ˜ f) := filter.continuous_nhds.comp h
