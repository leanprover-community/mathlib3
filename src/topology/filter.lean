/-
Copyright (c) 2022 Yury Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov
-/
import order.filter.lift
import topology.continuous_on
import data.set.intervals.monotone

/-!
# Topology on the set of filters on a type

In this file introduce topology on `filter Î±`. It is generated by the sets
`set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`, `s : set Î±`. A set `s : set (filter Î±)` is open if and
only if it is a union of a family of these basic open sets, see `filter.is_open_iff`.

This topology has the following important properties.

* If `X` is a topological space, then the map `ğ“ : X â†’ filter X` is an inducing map.

* In particular, it is a continuous map, so `ğ“ âˆ˜ f` tends to `ğ“ (ğ“ a)` whenever `f` tends to `ğ“ a`.

* If `X` is an ordered topological space with order topology and no max element, then `ğ“ âˆ˜ f` tends
  to `ğ“ filter.at_top` whenever `f` tends to `filter.at_top`.

## Tags

filter, topological space
-/

open set filter topological_space
open_locale filter topological_space

variables {Î¹ : Sort*} {Î± Î² X Y : Type*}

namespace filter

/-- Topology on `filter Î±` is generated by the sets `set.Iic (ğ“Ÿ s) = {l : filter Î± | s âˆˆ l}`,
`s : set Î±`. A set `s : set (filter Î±)` is open if and only if it is a union of a family of these
basic open sets, see `filter.is_open_iff`. -/
instance : topological_space (filter Î±) := generate_from $ range $ Iic âˆ˜ ğ“Ÿ

lemma is_open_Iic_principal {s : set Î±} : is_open (Iic (ğ“Ÿ s)) :=
generate_open.basic _ (mem_range_self _)

lemma is_open_set_of_mem {s : set Î±} : is_open {l : filter Î± | s âˆˆ l} :=
by simpa only [Iic_principal] using is_open_Iic_principal

lemma is_open_iff {s : set (filter Î±)} :
  is_open s â†” âˆƒ T : set (set Î±), (â‹ƒ t âˆˆ T, Iic (ğ“Ÿ t)) = s :=
begin
  split,
  { intro h, induction h,
    case basic : t ht
    { rcases ht with âŸ¨t, rflâŸ©,
      exact âŸ¨{t}, bUnion_singleton _ _âŸ© },
    case univ
    { exact âŸ¨univ, Unionâ‚‚_eq_univ_iff.2 $ Î» l, âŸ¨univ, mem_univ _, le_principal_iff.2 univ_memâŸ©âŸ© },
    case inter : s t hs' ht' hs ht
    { clear hs' ht', rcases âŸ¨hs, htâŸ© with âŸ¨âŸ¨s, rflâŸ©, t, rflâŸ©,
      refine âŸ¨image2 (âˆ©) s t, _âŸ©,
      simp only [image2_eq_Union, bUnion_Union, bUnion_singleton, inter_Union, Union_inter,
        Iic_inter_Iic, inf_principal] },
    case sUnion : S hS' hS
    { choose! T hT using hS,
      use â‹ƒ t âˆˆ S, T t,
      simp [hT, sUnion_eq_bUnion] { contextual := tt } } },
  { rintro âŸ¨T, rflâŸ©,
    exact is_open_bUnion (Î» t ht, is_open_Iic_principal) }
end

lemma nhds_eq (l : filter Î±) : ğ“ l = l.lift' (Iic âˆ˜ ğ“Ÿ) :=
nhds_generate_from.trans $ by simp only [mem_set_of_eq, and_comm (l âˆˆ _), infi_and, infi_range,
  filter.lift', filter.lift, (âˆ˜), mem_Iic, le_principal_iff]

lemma nhds_eq' (l : filter Î±) : ğ“ l = l.lift' (Î» s, {l' | s âˆˆ l'}) :=
by simpa only [(âˆ˜), Iic_principal] using nhds_eq l

protected lemma tendsto_nhds {la : filter Î±} {lb : filter Î²} {f : Î± â†’ filter Î²} :
  tendsto f la (ğ“ lb) â†” âˆ€ s âˆˆ lb, âˆ€á¶  a in la, s âˆˆ f a :=
by simp only [nhds_eq', tendsto_lift', mem_set_of_eq]

lemma has_basis.nhds {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : has_basis l p s) :
  has_basis (ğ“ l) p (Î» i, Iic (ğ“Ÿ (s i))) :=
by { rw nhds_eq, exact h.lift' monotone_principal.Iic }

lemma has_basis.nhds' {l : filter Î±} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set Î±} (h : has_basis l p s) :
  has_basis (ğ“ l) p (Î» i, {l' | s i âˆˆ l'}) :=
by simpa only [Iic_principal] using h.nhds

lemma mem_nhds_iff {l : filter Î±} {S : set (filter Î±)} :
  S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† S :=
l.basis_sets.nhds.mem_iff

lemma mem_nhds_iff' {l : filter Î±} {S : set (filter Î±)} :
  S âˆˆ ğ“ l â†” âˆƒ t âˆˆ l, âˆ€ â¦ƒl' : filter Î±â¦„, t âˆˆ l' â†’ l' âˆˆ S :=
l.basis_sets.nhds'.mem_iff

@[simp] lemma nhds_bot : ğ“ (âŠ¥ : filter Î±) = pure âŠ¥ :=
by simp [nhds_eq, lift'_bot monotone_principal.Iic]

@[simp] lemma nhds_top : ğ“ (âŠ¤ : filter Î±) = âŠ¤ := by simp [nhds_eq]

@[simp] lemma nhds_principal (s : set Î±) : ğ“ (ğ“Ÿ s) = ğ“Ÿ (Iic (ğ“Ÿ s)) :=
(has_basis_principal s).nhds.eq_of_same_basis (has_basis_principal _)

@[simp] lemma nhds_pure (x : Î±) : ğ“ (pure x : filter Î±) = ğ“Ÿ {âŠ¥, pure x} :=
by rw [â† principal_singleton, nhds_principal, principal_singleton, Iic_pure]

@[simp] lemma nhds_infi (f : Î¹ â†’ filter Î±) : ğ“ (â¨… i, f i) = â¨… i, ğ“ (f i) :=
by { simp only [nhds_eq], apply lift'_infi_of_map_univ; simp }

@[simp] lemma nhds_inf (lâ‚ lâ‚‚ : filter Î±) : ğ“ (lâ‚ âŠ“ lâ‚‚) = ğ“ lâ‚ âŠ“ ğ“ lâ‚‚ :=
by simpa only [infi_bool_eq] using nhds_infi (Î» b, cond b lâ‚ lâ‚‚)

lemma monotone_nhds : monotone (ğ“ : filter Î± â†’ filter (filter Î±)) :=
monotone.of_map_inf nhds_inf

lemma Inter_nhds (l : filter Î±) : â‹‚â‚€ {s | s âˆˆ ğ“ l} = Iic l :=
by simp only [nhds_eq, sInter_lift'_sets monotone_principal.Iic, Iic, le_principal_iff,
  â† set_of_forall, â† filter.le_def]

@[simp] lemma nhds_mono {lâ‚ lâ‚‚ : filter Î±} : ğ“ lâ‚ â‰¤ ğ“ lâ‚‚ â†” lâ‚ â‰¤ lâ‚‚ :=
begin
  refine âŸ¨Î» h, _, Î» h, monotone_nhds hâŸ©,
  rw [â† Iic_subset_Iic, â† Inter_nhds, â† Inter_nhds],
  exact sInter_subset_sInter h
end

protected lemma mem_interior {s : set (filter Î±)} {l : filter Î±} :
  l âˆˆ interior s â†” âˆƒ t âˆˆ l, Iic (ğ“Ÿ t) âŠ† s :=
begin
  refine mem_interior.trans âŸ¨_, _âŸ©,
  { simp only [is_open_iff],
    rintro âŸ¨_, hTs, âŸ¨T, rflâŸ©, hTâŸ©,
    simp only [Unionâ‚‚_subset_iff, mem_Unionâ‚‚] at hTs hT,
    rcases hT with âŸ¨t, htT, htâŸ©,
    exact âŸ¨t, ht (mem_principal_self _), Î» l' hl', hTs t htT hl'âŸ© },
  { rintro âŸ¨t, htl, htâŸ©,
    exact âŸ¨_, ht, is_open_Iic_principal, le_principal_iff.2 htlâŸ© }
end

protected lemma mem_closure {s : set (filter Î±)} {l : filter Î±} :
  l âˆˆ closure s â†” âˆ€ t âˆˆ l, âˆƒ l' âˆˆ s, t âˆˆ l' :=
by simp only [closure_eq_compl_interior_compl, filter.mem_interior, mem_compl_iff, not_exists,
  not_forall, not_not, exists_prop, not_and, and_comm, subset_def, mem_Iic, le_principal_iff]

@[simp] protected lemma closure_singleton (l : filter Î±) : closure {l} = Ici l :=
by { ext l', simp [filter.mem_closure, filter.le_def] }

lemma nhds_at_top [preorder Î±] : ğ“ at_top = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Ici x))) :=
by simp only [at_top, nhds_infi, nhds_principal]

protected lemma tendsto_nhds_at_top [preorder Î²] {l : filter Î±} {f : Î± â†’ filter Î²} :
  tendsto f l (ğ“ at_top) â†” âˆ€ y, âˆ€á¶  a in l, Ici y âˆˆ f a :=
by simp only [nhds_at_top, tendsto_infi, tendsto_principal, mem_Iic, le_principal_iff]

lemma nhds_at_bot [preorder Î±] : ğ“ at_bot = â¨… x : Î±, ğ“Ÿ (Iic (ğ“Ÿ (Iic x))) := @nhds_at_top Î±áµ’áµˆ _

protected lemma tendsto_nhds_at_bot [preorder Î²] {l : filter Î±} {f : Î± â†’ filter Î²} :
  tendsto f l (ğ“ at_bot) â†” âˆ€ y, âˆ€á¶  a in l, Iic y âˆˆ f a :=
@filter.tendsto_nhds_at_top Î± Î²áµ’áµˆ _ _ _

variables [topological_space X]

lemma nhds_nhds (x : X) :
  ğ“ (ğ“ x) = â¨… (s : set X) (hs : is_open s) (hx : x âˆˆ s), ğ“Ÿ (Iic (ğ“Ÿ s)) :=
by simp only [nhds_def' x, nhds_infi, nhds_principal]

lemma inducing_nhds : inducing (ğ“ : X â†’ filter X) :=
begin
  refine âŸ¨eq_of_nhds_eq_nhds $ Î» x, (nhds_def' _).trans _âŸ©,
  simp only [nhds_induced, nhds_nhds, comap_infi, comap_principal, Iic_principal, set_of_mem_eq,
    preimage_set_of_eq, â† mem_interior_iff_mem_nhds, is_open.interior_eq] { contextual := tt }
end

@[continuity] lemma continuous_nhds  : continuous (ğ“ : X â†’ filter X) := inducing_nhds.continuous

lemma tendsto.nhds {f : Î± â†’ X} {l : filter Î±} {x : X} (h : tendsto f l (ğ“ x)) :
  tendsto (ğ“ âˆ˜ f) l (ğ“ (ğ“ x)) :=
(continuous_nhds.tendsto _).comp h

end filter

variables [topological_space X] [topological_space Y] {f : X â†’ Y} {x : X} {s : set X}

lemma continuous_within_at.nhds (h : continuous_within_at f s x) :
  continuous_within_at (ğ“ âˆ˜ f) s x :=
h.nhds

lemma continuous_at.nhds (h : continuous_at f x) : continuous_at (ğ“ âˆ˜ f) x := h.nhds
lemma continuous_on.nhds (h : continuous_on f s) : continuous_on (ğ“ âˆ˜ f) s := Î» x hx, (h x hx).nhds
lemma continuous.nhds (h : continuous f) : continuous (ğ“ âˆ˜ f) := filter.continuous_nhds.comp h
