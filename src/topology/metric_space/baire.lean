/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import analysis.specific_limits.basic
import order.filter.countable_Inter
import topology.G_delta
import topology.sets.compacts

/-!
# Baire theorem

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a GŒ¥ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense GŒ¥ sets is a dense GŒ¥ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

We also define the filter `residual Œ±` generated by dense `GŒ¥` sets and prove that this filter
has the countable intersection property.
-/

noncomputable theory

open_locale classical topology filter ennreal

open filter encodable set topological_space

variables {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*} {Œπ : Type*}

section Baire_theorem

open emetric ennreal

/-- The property `baire_space Œ±` means that the topological space `Œ±` has the Baire property:
any countable intersection of open dense subsets is dense.
Formulated here when the source space is ‚Ñï (and subsumed below by `dense_Inter_of_open` working
with any encodable source space).-/
class baire_space (Œ± : Type*) [topological_space Œ±] : Prop :=
(baire_property : ‚àÄ f : ‚Ñï ‚Üí set Œ±, (‚àÄ n, is_open (f n)) ‚Üí (‚àÄ n, dense (f n)) ‚Üí dense (‚ãÇn, f n))

/-- Baire theorems asserts that various topological spaces have the Baire property.
Two versions of these theorems are given.
The first states that complete pseudo_emetric spaces are Baire. -/
@[priority 100]
instance baire_category_theorem_emetric_complete [pseudo_emetric_space Œ±] [complete_space Œ±] :
  baire_space Œ± :=
begin
  refine ‚ü®Œª f ho hd, _‚ü©,
  let B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := Œªn, 1/2^n,
  have Bpos : ‚àÄn, 0 < B n,
  { intro n,
    simp only [B, one_div, one_mul, ennreal.inv_pos],
    exact pow_ne_top two_ne_top },
  /- Translate the density assumption into two functions `center` and `radius` associating
  to any n, x, Œ¥, Œ¥pos a center and a positive radius such that
  `closed_ball center radius` is included both in `f n` and in `closed_ball x Œ¥`.
  We can also require `radius ‚â§ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : ‚àÄn x Œ¥, Œ¥ ‚â† 0 ‚Üí ‚àÉy r, 0 < r ‚àß r ‚â§ B (n+1) ‚àß closed_ball y r ‚äÜ (closed_ball x Œ¥) ‚à© f n,
  { assume n x Œ¥ Œ¥pos,
    have : x ‚àà closure (f n) := hd n x,
    rcases emetric.mem_closure_iff.1 this (Œ¥/2) (ennreal.half_pos Œ¥pos) with ‚ü®y, ys, xy‚ü©,
    rw edist_comm at xy,
    obtain ‚ü®r, rpos, hr‚ü© : ‚àÉ r > 0, closed_ball y r ‚äÜ f n :=
      nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys),
    refine ‚ü®y, min (min (Œ¥/2) r) (B (n+1)), _, _, Œªz hz, ‚ü®_, _‚ü©‚ü©,
    show 0 < min (min (Œ¥ / 2) r) (B (n+1)),
      from lt_min (lt_min (ennreal.half_pos Œ¥pos) rpos) (Bpos (n+1)),
    show min (min (Œ¥ / 2) r) (B (n+1)) ‚â§ B (n+1), from min_le_right _ _,
    show z ‚àà closed_ball x Œ¥, from calc
      edist z x ‚â§ edist z y + edist y x : edist_triangle _ _ _
      ... ‚â§ (min (min (Œ¥ / 2) r) (B (n+1))) + (Œ¥/2) : add_le_add hz (le_of_lt xy)
      ... ‚â§ Œ¥/2 + Œ¥/2 : add_le_add (le_trans (min_le_left _ _) (min_le_left _ _)) le_rfl
      ... = Œ¥ : ennreal.add_halves Œ¥,
    show z ‚àà f n, from hr (calc
      edist z y ‚â§ min (min (Œ¥ / 2) r) (B (n+1)) : hz
      ... ‚â§ r : le_trans (min_le_left _ _) (min_le_right _ _)) },
  choose! center radius Hpos HB Hball using this,
  refine Œª x, (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 (Œª Œµ Œµpos, _),
  /- `Œµ` is positive. We have to find a point in the ball of radius `Œµ` around `x` belonging to all
  `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball
  `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that
  `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
  limit which belongs to all the `f n`. -/
  let F : ‚Ñï ‚Üí (Œ± √ó ‚Ñù‚â•0‚àû) := Œªn, nat.rec_on n (prod.mk x (min Œµ (B 0)))
                              (Œªn p, prod.mk (center n p.1 p.2) (radius n p.1 p.2)),
  let c : ‚Ñï ‚Üí Œ± := Œªn, (F n).1,
  let r : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := Œªn, (F n).2,
  have rpos : ‚àÄ n, 0 < r n,
  { assume n,
    induction n with n hn,
    exact lt_min Œµpos (Bpos 0),
    exact Hpos n (c n) (r n) hn.ne' },
  have r0 : ‚àÄ n, r n ‚â† 0 := Œª n, (rpos n).ne',
  have rB : ‚àÄn, r n ‚â§ B n,
  { assume n,
    induction n with n hn,
    exact min_le_right _ _,
    exact HB n (c n) (r n) (r0 n) },
  have incl : ‚àÄn, closed_ball (c (n+1)) (r (n+1)) ‚äÜ (closed_ball (c n) (r n)) ‚à© (f n) :=
    Œª n, Hball n (c n) (r n) (r0 n),
  have cdist : ‚àÄn, edist (c n) (c (n+1)) ‚â§ B n,
  { assume n,
    rw edist_comm,
    have A : c (n+1) ‚àà closed_ball (c (n+1)) (r (n+1)) := mem_closed_ball_self,
    have I := calc
      closed_ball (c (n+1)) (r (n+1)) ‚äÜ closed_ball (c n) (r n) :
        subset.trans (incl n) (inter_subset_left _ _)
      ... ‚äÜ closed_ball (c n) (B n) : closed_ball_subset_closed_ball (rB n),
    exact I A },
  have : cauchy_seq c :=
    cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist,
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchy_seq_tendsto_of_complete this with ‚ü®y, ylim‚ü©,
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x Œµ`.
  use y,
  simp only [exists_prop, set.mem_Inter],
  have I : ‚àÄn, ‚àÄm ‚â• n, closed_ball (c m) (r m) ‚äÜ closed_ball (c n) (r n),
  { assume n,
    refine nat.le_induction _ (Œªm hnm h, _),
    { exact subset.refl _ },
    { exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h) }},
  have yball : ‚àÄn, y ‚àà closed_ball (c n) (r n),
  { assume n,
    refine is_closed_ball.mem_of_tendsto ylim _,
    refine (filter.eventually_ge_at_top n).mono (Œª m hm, _),
    exact I n m hm mem_closed_ball_self },
  split,
  show ‚àÄn, y ‚àà f n,
  { assume n,
    have : closed_ball (c (n+1)) (r (n+1)) ‚äÜ f n := subset.trans (incl n) (inter_subset_right _ _),
    exact this (yball (n+1)) },
  show edist y x ‚â§ Œµ, from le_trans (yball 0) (min_le_left _ _),
end

/-- The second theorem states that locally compact spaces are Baire. -/
@[priority 100]
instance baire_category_theorem_locally_compact [topological_space Œ±] [t2_space Œ±]
  [locally_compact_space Œ±] :
  baire_space Œ± :=
begin
  constructor,
  intros f ho hd,
  /- To prove that an intersection of open dense subsets is dense, prove that its intersection
  with any open neighbourhood `U` is dense. Define recursively a decreasing sequence `K` of
  compact neighbourhoods: start with some compact neighbourhood inside `U`, then at each step,
  take its interior, intersect with `f n`, then choose a compact neighbourhood inside the
  intersection.-/
  apply dense_iff_inter_open.2,
  intros U U_open U_nonempty,
  rcases exists_positive_compacts_subset U_open U_nonempty with ‚ü®K‚ÇÄ, hK‚ÇÄ‚ü©,
  have : ‚àÄ n (K : positive_compacts Œ±), ‚àÉ K' : positive_compacts Œ±, ‚ÜëK' ‚äÜ f n ‚à© interior K,
  { refine Œª n K, exists_positive_compacts_subset ((ho n).inter is_open_interior) _,
    rw inter_comm,
    exact (hd n).inter_open_nonempty _ is_open_interior K.interior_nonempty },
  choose K_next hK_next,
  let K : ‚Ñï ‚Üí positive_compacts Œ± := Œª n, nat.rec_on n K‚ÇÄ K_next,
  /- This is a decreasing sequence of positive compacts contained in suitable open sets `f n`.-/
  have hK_decreasing : ‚àÄ (n : ‚Ñï), ‚Üë(K (n + 1)) ‚äÜ f n ‚à© K n,
    from Œª n, (hK_next n (K n)).trans $ inter_subset_inter_right _ interior_subset,
  /- Prove that ÃÄ`‚ãÇ n : ‚Ñï, K n` is inside `U ‚à© ‚ãÇ n : ‚Ñï, (f n)`. -/
  have hK_subset : (‚ãÇ n, K n : set Œ±) ‚äÜ U ‚à© (‚ãÇ n, f n),
  { intros x hx,
    simp only [mem_inter_iff, mem_Inter] at hx ‚ä¢,
    exact ‚ü®hK‚ÇÄ $ hx 0, Œª n, (hK_decreasing n (hx (n + 1))).1‚ü© },
  /- Prove that `‚ãÇ n : ‚Ñï, K n` is not empty, as an intersection of a decreasing sequence
  of nonempty compact subsets.-/
  have hK_nonempty : (‚ãÇ n, K n : set Œ±).nonempty,
    from is_compact.nonempty_Inter_of_sequence_nonempty_compact_closed _
      (Œª n, (hK_decreasing n).trans (inter_subset_right _ _))
      (Œª n, (K n).nonempty) (K 0).is_compact (Œª n, (K n).is_compact.is_closed),
  exact hK_nonempty.mono hK_subset
end

variables [topological_space Œ±] [baire_space Œ±]

/-- Definition of a Baire space. -/
theorem dense_Inter_of_open_nat {f : ‚Ñï ‚Üí set Œ±} (ho : ‚àÄ n, is_open (f n)) (hd : ‚àÄ n, dense (f n)) :
  dense (‚ãÇ n, f n) :=
baire_space.baire_property f ho hd

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_open {S : set (set Œ±)} (ho : ‚àÄs‚ààS, is_open s) (hS : S.countable)
  (hd : ‚àÄs‚ààS, dense s) : dense (‚ãÇ‚ÇÄS) :=
begin
  cases S.eq_empty_or_nonempty with h h,
  { simp [h] },
  { rcases hS.exists_eq_range h with ‚ü®f, hf‚ü©,
    have F : ‚àÄn, f n ‚àà S := Œªn, by rw hf; exact mem_range_self _,
    rw [hf, sInter_range],
    exact dense_Inter_of_open_nat (Œªn, ho _ (F n)) (Œªn, hd _ (F n)) }
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs‚ààS, is_open (f s))
  (hS : S.countable) (hd : ‚àÄs‚ààS, dense (f s)) : dense (‚ãÇs‚ààS, f s) :=
begin
  rw ‚Üê sInter_image,
  apply dense_sInter_of_open,
  { rwa ball_image_iff },
  { exact hS.image _ },
  { rwa ball_image_iff }
end

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs, is_open (f s))
  (hd : ‚àÄs, dense (f s)) : dense (‚ãÇs, f s) :=
begin
  rw ‚Üê sInter_range,
  apply dense_sInter_of_open,
  { rwa forall_range_iff },
  { exact countable_range _ },
  { rwa forall_range_iff }
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with ‚ãÇ‚ÇÄ. -/
theorem dense_sInter_of_GŒ¥ {S : set (set Œ±)} (ho : ‚àÄs‚ààS, is_GŒ¥ s) (hS : S.countable)
  (hd : ‚àÄs‚ààS, dense s) : dense (‚ãÇ‚ÇÄS) :=
begin
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hTo hTc hsT using ho,
  have : ‚ãÇ‚ÇÄ S = ‚ãÇ‚ÇÄ (‚ãÉ s ‚àà S, T s ‚Äπ_‚Ä∫), -- := (sInter_bUnion (Œªs hs, (hT s hs).2.2)).symm,
    by simp only [sInter_Union, (hsT _ _).symm, ‚Üê sInter_eq_bInter],
  rw this,
  refine dense_sInter_of_open _ (hS.bUnion hTc) _;
    simp only [mem_Union]; rintro t ‚ü®s, hs, tTs‚ü©,
  show is_open t, from hTo s hs t tTs,
  show dense t,
  { intro x,
    have := hd s hs x,
    rw hsT s hs at this,
    exact closure_mono (sInter_subset_of_mem tTs) this }
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_GŒ¥ [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (ho : ‚àÄs, is_GŒ¥ (f s))
  (hd : ‚àÄs, dense (f s)) : dense (‚ãÇs, f s) :=
begin
  rw ‚Üê sInter_range,
  exact dense_sInter_of_GŒ¥ (forall_range_iff.2 ‚Äπ_‚Ä∫) (countable_range _) (forall_range_iff.2 ‚Äπ_‚Ä∫)
end

/-- Baire theorem: a countable intersection of dense GŒ¥ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_GŒ¥ {S : set Œ≤} {f : Œ† x ‚àà S, set Œ±} (ho : ‚àÄs‚ààS, is_GŒ¥ (f s ‚Äπ_‚Ä∫))
  (hS : S.countable) (hd : ‚àÄs‚ààS, dense (f s ‚Äπ_‚Ä∫)) : dense (‚ãÇs‚ààS, f s ‚Äπ_‚Ä∫) :=
begin
  rw bInter_eq_Inter,
  haveI := hS.to_encodable,
  exact dense_Inter_of_GŒ¥ (Œª s, ho s s.2) (Œª s, hd s s.2)
end

/-- Baire theorem: the intersection of two dense GŒ¥ sets is dense. -/
theorem dense.inter_of_GŒ¥ {s t : set Œ±} (hs : is_GŒ¥ s) (ht : is_GŒ¥ t) (hsc : dense s)
  (htc : dense t) :
  dense (s ‚à© t) :=
begin
  rw [inter_eq_Inter],
  apply dense_Inter_of_GŒ¥; simp [bool.forall_bool, *]
end

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `GŒ¥` set. -/
lemma eventually_residual {p : Œ± ‚Üí Prop} :
  (‚àÄ·∂† x in residual Œ±, p x) ‚Üî ‚àÉ (t : set Œ±), is_GŒ¥ t ‚àß dense t ‚àß ‚àÄ x ‚àà t, p x :=
calc (‚àÄ·∂† x in residual Œ±, p x) ‚Üî
  ‚àÄ·∂† x in ‚®Ö (t : set Œ±) (ht : is_GŒ¥ t ‚àß dense t), ùìü t, p x :
    by simp only [residual, infi_and]
... ‚Üî ‚àÉ (t : set Œ±) (ht : is_GŒ¥ t ‚àß dense t), ‚àÄ·∂† x in ùìü t, p x : mem_binfi_of_directed
    (Œª t‚ÇÅ h‚ÇÅ t‚ÇÇ h‚ÇÇ, ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, ‚ü®h‚ÇÅ.1.inter h‚ÇÇ.1, dense.inter_of_GŒ¥ h‚ÇÅ.1 h‚ÇÇ.1 h‚ÇÅ.2 h‚ÇÇ.2‚ü©, by simp‚ü©)
    ‚ü®univ, is_GŒ¥_univ, dense_univ‚ü©
... ‚Üî _ : by simp [and_assoc]

/-- A set is residual (comeagre) if and only if it includes a dense `GŒ¥` set. -/
lemma mem_residual {s : set Œ±} :
  s ‚àà residual Œ± ‚Üî ‚àÉ t ‚äÜ s, is_GŒ¥ t ‚àß dense t :=
(@eventually_residual Œ± _ _ (Œª x, x ‚àà s)).trans $ exists_congr $
Œª t, by rw [exists_prop, and_comm (t ‚äÜ s), subset_def, and_assoc]

lemma dense_of_mem_residual {s : set Œ±} (hs : s ‚àà residual Œ±) :
  dense s :=
let ‚ü®t, hts, _, hd‚ü© := mem_residual.1 hs in hd.mono hts

instance : countable_Inter_filter (residual Œ±) :=
‚ü®begin
  intros S hSc hS,
  simp only [mem_residual] at *,
  choose T hTs hT using hS,
  refine ‚ü®‚ãÇ s ‚àà S, T s ‚Äπ_‚Ä∫, _, _, _‚ü©,
  { rw [sInter_eq_bInter],
    exact Inter‚ÇÇ_mono hTs },
  { exact is_GŒ¥_bInter hSc (Œª s hs, (hT s hs).1) },
  { exact dense_bInter_of_GŒ¥ (Œª s hs, (hT s hs).1) hSc (Œª s hs, (hT s hs).2) }
end‚ü©

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with `‚ãÉ`. -/
lemma is_GŒ¥.dense_Union_interior_of_closed [encodable Œπ] {s : set Œ±} (hs : is_GŒ¥ s)
  (hd : dense s) {f : Œπ ‚Üí set Œ±} (hc : ‚àÄ i, is_closed (f i)) (hU : s ‚äÜ ‚ãÉ i, f i) :
  dense (‚ãÉ i, interior (f i)) :=
begin
  let g := Œª i, (frontier (f i))·∂ú,
  have hgo : ‚àÄ i, is_open (g i), from Œª i, is_closed_frontier.is_open_compl,
  have hgd : dense (‚ãÇ i, g i),
  { refine dense_Inter_of_open hgo (Œª i x, _),
    rw [closure_compl, interior_frontier (hc _)],
    exact id },
  refine (hd.inter_of_GŒ¥ hs (is_GŒ¥_Inter $ Œª i, (hgo i).is_GŒ¥) hgd).mono _,
  rintro x ‚ü®hxs, hxg‚ü©,
  rw [mem_Inter] at hxg,
  rcases mem_Union.1 (hU hxs) with ‚ü®i, hi‚ü©,
  exact mem_Union.2 ‚ü®i, self_diff_frontier (f i) ‚ñ∏ ‚ü®hi, hxg _‚ü©‚ü©,
end

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with a union over a countable set in any type. -/
lemma is_GŒ¥.dense_bUnion_interior_of_closed {t : set Œπ} {s : set Œ±} (hs : is_GŒ¥ s)
  (hd : dense s) (ht : t.countable) {f : Œπ ‚Üí set Œ±} (hc : ‚àÄ i ‚àà t, is_closed (f i))
  (hU : s ‚äÜ ‚ãÉ i ‚àà t, f i) :
  dense (‚ãÉ i ‚àà t, interior (f i)) :=
begin
  haveI := ht.to_encodable,
  simp only [bUnion_eq_Union, set_coe.forall'] at *,
  exact hs.dense_Union_interior_of_closed hd hc hU
end

/-- If a countable family of closed sets cover a dense `GŒ¥` set, then the union of their interiors
is dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
lemma is_GŒ¥.dense_sUnion_interior_of_closed {T : set (set Œ±)} {s : set Œ±} (hs : is_GŒ¥ s)
  (hd : dense s) (hc : T.countable) (hc' : ‚àÄ t ‚àà T, is_closed t) (hU : s ‚äÜ ‚ãÉ‚ÇÄ T) :
  dense (‚ãÉ t ‚àà T, interior t) :=
hs.dense_bUnion_interior_of_closed hd hc hc' $ by rwa [‚Üê sUnion_eq_bUnion]

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : set Œ≤} {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄs‚ààS, is_closed (f s))
  (hS : S.countable) (hU : (‚ãÉs‚ààS, f s) = univ) : dense (‚ãÉs‚ààS, interior (f s)) :=
is_GŒ¥_univ.dense_bUnion_interior_of_closed dense_univ hS hc hU.ge

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `‚ãÉ‚ÇÄ`. -/
theorem dense_sUnion_interior_of_closed {S : set (set Œ±)} (hc : ‚àÄs‚ààS, is_closed s)
  (hS : S.countable) (hU : (‚ãÉ‚ÇÄ S) = univ) : dense (‚ãÉs‚ààS, interior s) :=
is_GŒ¥_univ.dense_sUnion_interior_of_closed dense_univ hS hc hU.ge

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±} (hc : ‚àÄs, is_closed (f s))
  (hU : (‚ãÉs, f s) = univ) : dense (‚ãÉs, interior (f s)) :=
is_GŒ¥_univ.dense_Union_interior_of_closed dense_univ hc hU.ge

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed [nonempty Œ±] [encodable Œ≤] {f : Œ≤ ‚Üí set Œ±}
  (hc : ‚àÄs, is_closed (f s)) (hU : (‚ãÉs, f s) = univ) :
  ‚àÉs, (interior $ f s).nonempty :=
by simpa using (dense_Union_interior_of_closed hc hU).nonempty

end Baire_theorem
