/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro
-/
import topology.tactic

/-!
# Ordering on topologies and (co)induced topologies

Topologies on a fixed type `Œ±` are ordered, by reverse inclusion.
That is, for topologies `t‚ÇÅ` and `t‚ÇÇ` on `Œ±`, we write `t‚ÇÅ ‚â§ t‚ÇÇ`
if every set open in `t‚ÇÇ` is also open in `t‚ÇÅ`.
(One also calls `t‚ÇÅ` finer than `t‚ÇÇ`, and `t‚ÇÇ` coarser than `t‚ÇÅ`.)

Any function `f : Œ± ‚Üí Œ≤` induces
       `induced f : topological_space Œ≤ ‚Üí topological_space Œ±`
and  `coinduced f : topological_space Œ± ‚Üí topological_space Œ≤`.
Continuity, the ordering on topologies and (co)induced topologies are
related as follows:
* The identity map (Œ±, t‚ÇÅ) ‚Üí (Œ±, t‚ÇÇ) is continuous iff t‚ÇÅ ‚â§ t‚ÇÇ.
* A map f : (Œ±, t) ‚Üí (Œ≤, u) is continuous
    iff             t ‚â§ induced f u   (`continuous_iff_le_induced`)
    iff coinduced f t ‚â§ u             (`continuous_iff_coinduced_le`).

Topologies on Œ± form a complete lattice, with ‚ä• the discrete topology
and ‚ä§ the indiscrete topology.

For a function f : Œ± ‚Üí Œ≤, (coinduced f, induced f) is a Galois connection
between topologies on Œ± and topologies on Œ≤.

## Implementation notes

There is a Galois insertion between topologies on Œ± (with the inclusion ordering)
and all collections of sets in Œ±. The complete lattice structure on topologies
on Œ± is defined as the reverse of the one obtained via this Galois insertion.

## Tags

finer, coarser, induced topology, coinduced topology

-/

open set filter function
open_locale classical topological_space filter

universes u v w x

variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} {Œπ : Sort w}

namespace topological_space

/-!
### Complete lattice structure

In this section we define a `complete_lattice` structure on `topological_space Œ±`. Topologies are
ordered by inverse inclusion: `t‚ÇÅ ‚â§ t‚ÇÇ` if every set open in `t‚ÇÇ` is open in `t‚ÇÅ`. The topology `‚ä•`
is the discrete topology (i.e., all sets are open) and `‚ä§` is the indiscrete topology (i.e., only
`‚àÖ` and `set.univ` are open).

We also prove some lemmas about `Sup`, `‚®Ü`, and `‚äî` in this lattice.
 -/

instance : complete_semilattice_Sup (topological_space Œ±) :=
{ le := Œª t‚ÇÅ t‚ÇÇ, t‚ÇÇ.is_open ‚â§ t‚ÇÅ.is_open,
  Sup := Œª T,
    { is_open := Œª s, ‚àÄ t ‚àà T, (t : topological_space Œ±).is_open s,
      is_open_univ := Œª t _, t.is_open_univ,
      is_open_inter := Œª s‚ÇÅ s‚ÇÇ h‚ÇÅ h‚ÇÇ t ht, t.is_open_inter _ _ (h‚ÇÅ t ht) (h‚ÇÇ t ht),
      is_open_sUnion := Œª S hS t ht, t.is_open_sUnion _ (Œª s hs, hS _ hs _ ht) },
  le_Sup := Œª S t ht s hs, hs t ht,
  Sup_le := Œª S t ht s hs t' ht', ht _ ht' _ hs,
  .. partial_order.lift (Œª t : topological_space Œ±, order_dual.to_dual t.is_open)
    (Œª _ _, topological_space_eq) }

/-- Topologies on `Œ±` form a complete lattice, with `‚ä•` the discrete topology
  and `‚ä§` the indiscrete topology. The infimum of a collection of topologies
  is the topology generated by all their open sets, while the supremem is the
  topology whose open sets are those sets open in every member of the collection. -/
instance : complete_lattice (topological_space Œ±) :=
{ bot := ‚ü®Œª _, true, trivial, Œª _ _ _ _, trivial, Œª _ _, trivial‚ü©,
  bot_le := Œª _ _ _, trivial,
  sup := Œª t‚ÇÅ t‚ÇÇ,
  { is_open := t‚ÇÅ.is_open ‚äì t‚ÇÇ.is_open,
    is_open_univ := ‚ü®t‚ÇÅ.is_open_univ, t‚ÇÇ.is_open_univ‚ü©,
    is_open_inter := Œª s‚ÇÅ s‚ÇÇ h‚ÇÅ h‚ÇÇ,
      ‚ü®t‚ÇÅ.is_open_inter _ _ h‚ÇÅ.1 h‚ÇÇ.1, t‚ÇÇ.is_open_inter _ _ h‚ÇÅ.2 h‚ÇÇ.2‚ü©,
    is_open_sUnion := Œª S hS,
      ‚ü®t‚ÇÅ.is_open_sUnion _ (Œª s hs, (hS s hs).1), t‚ÇÇ.is_open_sUnion _ (Œª s hs, (hS s hs).2)‚ü©},
  le_sup_left := Œª t‚ÇÅ t‚ÇÇ s hs, hs.1,
  le_sup_right := Œª t‚ÇÅ t‚ÇÇ s hs, hs.2,
  sup_le := Œª t‚ÇÅ t‚ÇÇ t‚ÇÉ h‚ÇÅ h‚ÇÇ s hs, ‚ü®h‚ÇÅ s hs, h‚ÇÇ s hs‚ü©,
  top :=
    { is_open := Œª s, s = ‚àÖ ‚à® s = univ,
      is_open_univ := or.inr rfl,
      is_open_inter := by rintro s‚ÇÅ s‚ÇÇ (rfl|rfl) (rfl|rfl); simp,
      is_open_sUnion := Œª S hS, (eq_empty_or_nonempty _).imp id $ Œª Hne,
        let ‚ü®s, hs, hne‚ü© := nonempty_sUnion.1 Hne in sUnion_eq_univ_iff.2 $
        Œª x, ‚ü®s, hs, ((hS s hs).resolve_left hne.ne_empty).symm ‚ñ∏ mem_univ x‚ü© },
  le_top := by { rintro t s (rfl|rfl), exacts [@is_open_empty _ t, t.is_open_univ] },
  .. complete_lattice_of_complete_semilattice_Sup (topological_space Œ±) }

instance inhabited_topological_space : inhabited (topological_space Œ±) := ‚ü®‚ä§‚ü©

lemma le_def {a b : topological_space Œ±} : a ‚â§ b ‚Üî (‚àÄ s, b.is_open s ‚Üí a.is_open s) := iff.rfl

lemma is_open_Sup {s : set Œ±} {T : set (topological_space Œ±)} :
  @is_open _ (Sup T) s ‚Üî ‚àÄ t ‚àà T, @is_open _ t s := iff.rfl

lemma is_closed_Sup {s : set Œ±} {T : set (topological_space Œ±)} :
  @is_closed _ (Sup T) s ‚Üî ‚àÄ t ‚àà T, @is_closed _ t s :=
by simp only [‚Üê is_open_compl_iff, is_open_Sup]

lemma is_open_supr {Œπ} {s : set Œ±} {t : Œπ ‚Üí topological_space Œ±} :
  @is_open _ (‚®Ü i, t i) s ‚Üî ‚àÄ i, @is_open _ (t i) s :=
by simp only [supr, is_open_Sup, forall_range_iff]

lemma is_closed_supr {Œπ} {s : set Œ±} {t : Œπ ‚Üí topological_space Œ±} :
  @is_closed _ (‚®Ü i, t i) s ‚Üî ‚àÄ i, @is_closed _ (t i) s :=
by simp only [‚Üê is_open_compl_iff, is_open_supr]

lemma is_open_sup {s : set Œ±} {t‚ÇÅ t‚ÇÇ : topological_space Œ±} :
  @is_open Œ± (t‚ÇÅ ‚äî t‚ÇÇ) s ‚Üî @is_open Œ± t‚ÇÅ s ‚àß @is_open Œ± t‚ÇÇ s :=
iff.rfl

lemma is_closed_sup {s : set Œ±} {t‚ÇÅ t‚ÇÇ : topological_space Œ±} :
  @is_closed Œ± (t‚ÇÅ ‚äî t‚ÇÇ) s ‚Üî @is_closed Œ± t‚ÇÅ s ‚àß @is_closed Œ± t‚ÇÇ s :=
by simp only [‚Üê is_open_compl_iff, is_open_sup]

end topological_space

/-!
### Discrete topology

In this section we introduce a typeclass `discrete_topology` saying that the topology on `Œ±` is
equal (but may be not definitionally equal) to `‚ä•`. -/

/-- A topological space is discrete if every set is open, that is,
  its topology equals the discrete topology `‚ä•`. -/
class discrete_topology (Œ± : Type*) [t : topological_space Œ±] : Prop :=
(eq_bot [] : t = ‚ä•)

@[priority 100]
instance discrete_topology_bot (Œ± : Type*) : @discrete_topology Œ± ‚ä• :=
{ eq_bot := rfl }

@[simp] lemma is_open_discrete [topological_space Œ±] [discrete_topology Œ±] (s : set Œ±) :
  is_open s :=
(discrete_topology.eq_bot Œ±).symm ‚ñ∏ trivial

@[simp] lemma is_closed_discrete [topological_space Œ±] [discrete_topology Œ±] (s : set Œ±) :
  is_closed s :=
is_open_compl_iff.1 $ (discrete_topology.eq_bot Œ±).symm ‚ñ∏ trivial

lemma continuous_of_discrete_topology [topological_space Œ±] [discrete_topology Œ±]
  [topological_space Œ≤] {f : Œ± ‚Üí Œ≤} : continuous f :=
continuous_def.2 $ Œªs hs, is_open_discrete _

lemma nhds_bot (Œ± : Type*) : (@nhds Œ± ‚ä•) = pure :=
begin
  refine le_antisymm _ (@pure_le_nhds Œ± ‚ä•),
  assume a s hs,
  exact @is_open.mem_nhds Œ± ‚ä• a s trivial hs
end

lemma nhds_discrete (Œ± : Type*) [topological_space Œ±] [discrete_topology Œ±] : (@nhds Œ± _) = pure :=
(discrete_topology.eq_bot Œ±).symm ‚ñ∏ nhds_bot Œ±

lemma eq_bot_of_singletons_open {t : topological_space Œ±} (h : ‚àÄ x, t.is_open {x}) : t = ‚ä• :=
bot_unique $ Œª s hs, bUnion_of_singleton s ‚ñ∏ is_open_bUnion (Œª x _, h x)

lemma discrete_topology_of_singletons_open [topological_space Œ±] (h : ‚àÄ x, is_open ({x} : set Œ±)) :
  discrete_topology Œ± :=
‚ü®eq_bot_of_singletons_open h‚ü©

lemma forall_open_iff_discrete {X : Type*} [topological_space X] :
  (‚àÄ s : set X, is_open s) ‚Üî discrete_topology X :=
‚ü®Œª h, ‚ü®by { ext U , show is_open U ‚Üî true, simp [h U] }‚ü©, Œª a, @is_open_discrete _ _ a‚ü©

lemma singletons_open_iff_discrete {X : Type*} [topological_space X] :
  (‚àÄ a : X, is_open ({a} : set X)) ‚Üî discrete_topology X :=
‚ü®discrete_topology_of_singletons_open, Œª a _, @is_open_discrete _ _ a _‚ü©

/-!
### Discrete topology instances

In this section we equip some spaces (`empty`, `pempty`, `punit`, `bool`, `‚Ñï`, `‚Ñ§`) with the
discrete topology. We also prove that any topology on a `subsingleton` is the discrete topoloty.
-/

section discrete_instances

@[priority 100]
instance subsingleton.unique_topological_space [subsingleton Œ±] :
  unique (topological_space Œ±) :=
{ default := ‚ä•,
  uniq := Œª t, eq_bot_of_singletons_open $ Œª x, subsingleton.set_cases
    (@is_open_empty _ t) (@is_open_univ _ t) ({x} : set Œ±) }

@[priority 100]
instance subsingleton.discrete_topology [t : topological_space Œ±] [subsingleton Œ±] :
  discrete_topology Œ± :=
‚ü®unique.eq_default t‚ü©

instance : topological_space empty := ‚ä•
instance : discrete_topology empty := ‚ü®rfl‚ü©
instance : topological_space pempty := ‚ä•
instance : discrete_topology pempty := ‚ü®rfl‚ü©
instance : topological_space punit := ‚ä•
instance : discrete_topology punit := ‚ü®rfl‚ü©
instance : topological_space bool := ‚ä•
instance : discrete_topology bool := ‚ü®rfl‚ü©
instance : topological_space ‚Ñï := ‚ä•
instance : discrete_topology ‚Ñï := ‚ü®rfl‚ü©
instance : topological_space ‚Ñ§ := ‚ä•
instance : discrete_topology ‚Ñ§ := ‚ü®rfl‚ü©

end discrete_instances

/-!
### Topology generated from a subbasic

Given a set of sets `g`, `topological_space.generate_from g` is the greatest topology (the least one
in the sense of inclusion) such that all sets from `g` are open.
-/

namespace topological_space

/-- The open sets of the greateast topology (least in the sense of inclusion) containing a
collection of basic sets. -/
inductive generate_open (g : set (set Œ±)) : set Œ± ‚Üí Prop
| basic  : ‚àÄs‚ààg, generate_open s
| univ   : generate_open univ
| inter  : ‚àÄs t, generate_open s ‚Üí generate_open t ‚Üí generate_open (s ‚à© t)
| sUnion : ‚àÄk, (‚àÄs‚ààk, generate_open s) ‚Üí generate_open (‚ãÉ‚ÇÄ k)

/-- The greatest topological space structure (the least in the sense of inclusion)
such that all sets from `g : set (set Œ±)` are open. -/
def generate_from (g : set (set Œ±)) : topological_space Œ± :=
{ is_open        := generate_open g,
  is_open_univ   := generate_open.univ,
  is_open_inter  := generate_open.inter,
  is_open_sUnion := generate_open.sUnion }

/-- `topological_space.generate_from` and `topological_space.is_open` form an order-reversing
Galois insertion. We formulate it using `order_dual`. -/
lemma gc_generate_from (Œ± : Type*) :
  galois_connection (order_dual.to_dual ‚àò @generate_from Œ±)
    (Œª t, {s | @is_open _ (order_dual.of_dual t) s}) :=
begin
  refine Œª g t, ‚ü®Œª ht o ho, ht _ (generate_open.basic o ho), Œª ht s hs, _‚ü©,
  induction hs,
  case basic : s hs { exact ht hs },
  case univ { exact t.is_open_univ },
  case inter : s‚ÇÅ s‚ÇÇ h‚ÇÅ' h‚ÇÇ' h‚ÇÅ h‚ÇÇ { exact t.is_open_inter _ _ h‚ÇÅ h‚ÇÇ },
  case sUnion : S hS' hS { exact t.is_open_sUnion S hS }
end

/-- Characteristic property of `topological_space.generate_from`. -/
lemma is_greatest_generate_from (g : set (set Œ±)) :
  is_greatest {t : topological_space Œ± | ‚àÄ s ‚àà g, @is_open _ t s} (generate_from g) :=
(gc_generate_from Œ±).is_least_l

lemma generate_from_eq_Sup (g : set (set Œ±)) :
  generate_from g = Sup {t : topological_space Œ± | ‚àÄ s ‚àà g, @is_open _ t s} :=
(is_greatest_generate_from g).is_lub.Sup_eq.symm

lemma le_generate_from_iff {g : set (set Œ±)} {t : topological_space Œ±} :
  t ‚â§ generate_from g ‚Üî ‚àÄ s ‚àà g, @is_open Œ± t s :=
gc_generate_from Œ± _ _

alias le_generate_from_iff ‚Üî _ topological_space.le_generate_from

/-- `topological_space.generate_from` and `topological_space.is_open` form an order-reversing
Galois insertion. We formulate it using `order_dual`. -/
lemma gi_generate_from (Œ± : Type*) :
  galois_insertion (order_dual.to_dual ‚àò @generate_from Œ±)
    (Œª t, {s | @is_open _ (order_dual.of_dual t) s}) :=
(gc_generate_from Œ±).to_galois_insertion $ Œª t, (is_greatest_generate_from _).1

@[mono] lemma generate_from_anti {g‚ÇÅ g‚ÇÇ : set (set Œ±)} (h : g‚ÇÅ ‚äÜ g‚ÇÇ) :
  topological_space.generate_from g‚ÇÇ ‚â§ topological_space.generate_from g‚ÇÅ :=
(gc_generate_from _).monotone_l h

lemma generate_from_set_of_is_open (t : topological_space Œ±) :
  topological_space.generate_from {s | t.is_open s} = t :=
(gi_generate_from Œ±).l_u_eq t

lemma left_inverse_generate_from :
  function.left_inverse topological_space.generate_from
    (Œª t : topological_space Œ±, {s | t.is_open s}) :=
(gi_generate_from Œ±).left_inverse_l_u

lemma generate_from_surjective :
  function.surjective (topological_space.generate_from : set (set Œ±) ‚Üí topological_space Œ±) :=
(gi_generate_from Œ±).l_surjective

lemma set_of_is_open_injective :
  function.injective (Œª t : topological_space Œ±, {s | t.is_open s}) :=
(gi_generate_from Œ±).u_injective

lemma generate_from_union (a‚ÇÅ a‚ÇÇ : set (set Œ±)) :
  generate_from (a‚ÇÅ ‚à™ a‚ÇÇ) = generate_from a‚ÇÅ ‚äì generate_from a‚ÇÇ :=
(gc_generate_from Œ±).l_sup

lemma generate_from_Union {f : Œπ ‚Üí set (set Œ±)} :
  generate_from (‚ãÉ i, f i) = (‚®Ö i, generate_from (f i)) :=
(gc_generate_from Œ±).l_supr

lemma generate_from_sUnion {S : set (set (set Œ±))} :
  generate_from (‚ãÉ‚ÇÄ S) = (‚®Ö s ‚àà S, generate_from s) :=
(gc_generate_from Œ±).l_Sup

lemma generate_from_union_is_open (a b : topological_space Œ±) :
  topological_space.generate_from ({s | a.is_open s} ‚à™ {s | b.is_open s}) = a ‚äì b :=
(gi_generate_from Œ±).l_sup_u a b

lemma generate_from_Union_is_open (f : Œπ ‚Üí topological_space Œ±) :
  topological_space.generate_from (‚ãÉ i, {s | (f i).is_open s}) = ‚®Ö i, (f i) :=
(gi_generate_from Œ±).l_supr_u f

lemma generate_from_inter_is_open (a b : topological_space Œ±) :
  topological_space.generate_from ({s | a.is_open s} ‚à© {s | b.is_open s}) = a ‚äî b :=
(gi_generate_from Œ±).l_inf_u a b

lemma generate_from_Inter_is_open (f : Œπ ‚Üí topological_space Œ±) :
  topological_space.generate_from (‚ãÇ i, {s | (f i).is_open s}) = ‚®Ü i, (f i) :=
(gi_generate_from Œ±).l_infi_u f

end topological_space

/-- `g : set (set Œ±)` is a topological subbasis of `Œ±` if the topology on `Œ±` is the -/
def is_topological_subbasis [topological_space Œ±] (g : set (set Œ±)) : Prop :=
‚Äπtopological_space Œ±‚Ä∫ = topological_space.generate_from g

lemma is_topological_subbasis_opens [topological_space Œ±] :
  is_topological_subbasis {s : set Œ± | is_open s} :=
(topological_space.generate_from_set_of_is_open _).symm

lemma is_topological_subbasis_generate_from (g : set (set Œ±)) :
  @is_topological_subbasis Œ± (topological_space.generate_from g) g := refl _

namespace is_topological_subbasis

variables [topological_space Œ±] {g : set (set Œ±)}
open topological_space

protected lemma eq (h : is_topological_subbasis g) : ‚Äπtopological_space Œ±‚Ä∫ = generate_from g := h

lemma is_open_iff (h : is_topological_subbasis g) {s : set Œ±} :
  is_open s ‚Üî generate_open g s :=
by { rw [h.eq], refl }

lemma is_open_of_mem (h : is_topological_subbasis g) {s : set Œ±} (hs : s ‚àà g) :
  is_open s :=
h.is_open_iff.2 $ generate_open.basic s hs

lemma nhds_eq (h : is_topological_subbasis g) (a : Œ±) :
  ùìù a = ‚®Ö (s : set Œ±) (ha : a ‚àà s) (hs : s ‚àà g), ùìü s :=
begin
  simp only [nhds_def, le_antisymm_iff, le_infi_iff, mem_set_of_eq, and_imp],
  refine ‚ü®Œª s ha hg, infi_le_of_le s $ infi_le _ ‚ü®ha, h.is_open_of_mem hg‚ü©, Œª s ha hs, _‚ü©,
  rw h.is_open_iff at hs, induction hs,
  case basic : s hs { exact binfi_le_of_le s ha (infi_le _ hs) },
  case univ { simp only [principal_univ, le_top] },
  case inter : s t hs' ht' hs ht { rw ‚Üê inf_principal, exact le_inf (hs ha.1) (ht ha.2) },
  case sUnion : S ihS' ihS { rcases ha with ‚ü®s, hsS, ha‚ü©,
    exact (ihS s hsS ha).trans (principal_mono.2 $ subset_sUnion_of_mem hsS) }
end

lemma tendsto_nhds (h : is_topological_subbasis g) {l : filter Œ≤} {f : Œ≤ ‚Üí Œ±} {a : Œ±} :
  tendsto f l (ùìù a) ‚Üî ‚àÄ s, a ‚àà s ‚Üí s ‚àà g ‚Üí ‚àÄ·∂† x in l, f x ‚àà s :=
by simp only [h.nhds_eq, tendsto_infi, tendsto_principal]

lemma continuous_iff [topological_space Œ≤] (h : is_topological_subbasis g) {f : Œ≤ ‚Üí Œ±} :
  continuous f ‚Üî ‚àÄ s ‚àà g, is_open (f ‚Åª¬π' s) :=
begin
  simp only [continuous_iff_continuous_at, continuous_at, h.tendsto_nhds, is_open_iff_mem_nhds],
  exact ‚ü®Œª H s hs a ha, H a s ha hs, Œª H a s ha hs, H s hs a ha‚ü©
end

end is_topological_subbasis

/-!
### Construct a topology from its `nhds` filter

Given a family of filters `n : Œ± ‚Üí filter Œ±`, `topological_space.mk_of_nhds` is the least topology
`t` (the greatest one in the sense of inclusion) such that `n a ‚â§ @nhds Œ± t a` for all `a`. In this
section we define `topological_space.mk_of_nhds`, prove that this function forms a Galois insertion
with `nhds Œ±`, and deduce some corollaries from this fact.
-/

namespace topological_space

/-- Construct a topology on `Œ±` given the filter of neighborhoods of each point of `Œ±`. In general,
`topological_space.mk_of_nhds n` is the least topology `t` (the greatest one in the sense of
inclusion) such that `n ‚â§ @nhds Œ± t`. -/
def mk_of_nhds (n : Œ± ‚Üí filter Œ±) : topological_space Œ± :=
{ is_open        := Œª s, ‚àÄ a ‚àà s, s ‚àà n a,
  is_open_univ   := assume x h, univ_mem,
  is_open_inter  := assume s t hs ht x ‚ü®hxs, hxt‚ü©, inter_mem (hs x hxs) (ht x hxt),
  is_open_sUnion := assume s hs a ‚ü®x, hx, hxa‚ü©,
    mem_of_superset (hs x hx _ hxa) (set.subset_sUnion_of_mem hx) }

lemma _root_.gc_nhds (Œ± : Type*) : galois_connection mk_of_nhds (@nhds Œ±) :=
Œª n t, ‚ü®Œª hle x, (@nhds_basis_opens Œ± t x).ge_iff.2 $ Œª s hs, hle s hs.2 x hs.1,
    Œª hle s hs a ha, hle _ $ @is_open.mem_nhds Œ± t _ _ hs ha‚ü©

lemma _root_.gi_nhds (Œ± : Type*) : galois_insertion mk_of_nhds (@nhds Œ±) :=
(gc_nhds Œ±).to_galois_insertion $ Œª t s, (@is_open_iff_mem_nhds Œ± t s).2

@[simp] lemma mk_of_nhds_nhds {t : topological_space Œ±} :
  topological_space.mk_of_nhds (@nhds Œ± t) = t :=
(gi_nhds Œ±).l_u_eq t

lemma le_nhds_mk_of_nhds (n : Œ± ‚Üí filter Œ±) : n ‚â§ @nhds Œ± (topological_space.mk_of_nhds n) :=
(gc_nhds Œ±).le_u_l n

lemma is_least_mk_of_nhds (n : Œ± ‚Üí filter Œ±) :
  is_least {t : topological_space Œ± | n ‚â§ @nhds Œ± t} (topological_space.mk_of_nhds n) :=
(gc_nhds Œ±).is_least_l

lemma nhds_mk_of_nhds (n : Œ± ‚Üí filter Œ±) (a : Œ±)
  (h‚ÇÄ : pure ‚â§ n) (h‚ÇÅ : ‚àÄ{a s}, s ‚àà n a ‚Üí ‚àÉ t ‚àà n a, t ‚äÜ s ‚àß ‚àÄa' ‚àà t, s ‚àà n a') :
  @nhds Œ± (topological_space.mk_of_nhds n) = n :=
begin
  refine le_antisymm (Œª a s hs, _) (le_nhds_mk_of_nhds n),
  letI := topological_space.mk_of_nhds n,
  have h‚ÇÄ : {b | s ‚àà n b} ‚äÜ s := assume b hb, mem_pure.1 $ h‚ÇÄ b hb,
  have h‚ÇÅ : {b | s ‚àà n b} ‚àà ùìù a,
  { refine is_open.mem_nhds (assume b (hb : s ‚àà n b), _) hs,
    rcases h‚ÇÅ hb with ‚ü®t, ht, hts, h‚ü©,
    exact mem_of_superset ht h },
  exact mem_of_superset h‚ÇÅ h‚ÇÄ
end

end topological_space

section gi_nhds

lemma nhds_le_nhds_iff {t‚ÇÅ t‚ÇÇ : topological_space Œ±} :
  @nhds Œ± t‚ÇÅ ‚â§ @nhds Œ± t‚ÇÇ ‚Üî t‚ÇÅ ‚â§ t‚ÇÇ :=
(gi_nhds Œ±).u_le_u_iff

alias nhds_le_nhds_iff ‚Üî le_of_nhds_le_nhds _

lemma injective_nhds : injective (@nhds Œ±) := (gi_nhds Œ±).u_injective

lemma nhds_mono {t‚ÇÅ t‚ÇÇ : topological_space Œ±} (h : t‚ÇÅ ‚â§ t‚ÇÇ) :
  @nhds Œ± t‚ÇÅ ‚â§ @nhds Œ± t‚ÇÇ :=
(gc_nhds Œ±).monotone_u h

lemma nhds_infi' {t : Œπ ‚Üí topological_space Œ±} :
  @nhds Œ± (infi t) = (‚®Ö i, @nhds Œ± (t i)) := (gc_nhds Œ±).u_infi

lemma nhds_infi {t : Œπ ‚Üí topological_space Œ±} {a : Œ±} :
  @nhds Œ± (infi t) a = (‚®Ö i, @nhds Œ± (t i) a) :=
by rw [nhds_infi', infi_apply]

lemma nhds_Inf' {s : set (topological_space Œ±)} :
  @nhds Œ± (Inf s) = (‚®Öt‚ààs, @nhds Œ± t) := (gc_nhds Œ±).u_Inf

lemma nhds_inf' {t‚ÇÅ t‚ÇÇ : topological_space Œ±} :
  @nhds Œ± (t‚ÇÅ ‚äì t‚ÇÇ) = @nhds Œ± t‚ÇÅ ‚äì @nhds Œ± t‚ÇÇ := (gc_nhds Œ±).u_inf

lemma nhds_inf {t‚ÇÅ t‚ÇÇ : topological_space Œ±} {a : Œ±} :
  @nhds Œ± (t‚ÇÅ ‚äì t‚ÇÇ) a = @nhds Œ± t‚ÇÅ a ‚äì @nhds Œ± t‚ÇÇ a :=
congr_fun (gc_nhds Œ±).u_inf a

lemma nhds_top' : @nhds Œ± ‚ä§ = ‚ä§ := (gc_nhds Œ±).u_top

lemma nhds_top {a : Œ±} : @nhds Œ± ‚ä§ a = ‚ä§ :=
congr_fun (gc_nhds Œ±).u_top a

end gi_nhds

section induced_coinduced

/-- Given `f : Œ± ‚Üí Œ≤` and a topology on `Œ≤`, the induced topology on `Œ±` is the collection of
  sets that are preimages of some open set in `Œ≤`. This is the coarsest topology that
  makes `f` continuous. -/
def topological_space.induced {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (t : topological_space Œ≤) :
  topological_space Œ± :=
{ is_open        := Œª s, ‚àÉ s', t.is_open s' ‚àß f ‚Åª¬π' s' = s,
  is_open_univ   := ‚ü®univ, t.is_open_univ, preimage_univ‚ü©,
  is_open_inter  := by rintro s‚ÇÅ s‚ÇÇ ‚ü®s'‚ÇÅ, hs‚ÇÅ, rfl‚ü© ‚ü®s'‚ÇÇ, hs‚ÇÇ, rfl‚ü©;
    exact ‚ü®s'‚ÇÅ ‚à© s'‚ÇÇ, t.is_open_inter _ _ hs‚ÇÅ hs‚ÇÇ, preimage_inter‚ü©,
  is_open_sUnion := assume S h,
  begin
    resetI, choose g hgo hg using h,
    use ‚ãÉ (s : set Œ±) (hs : s ‚àà S), g s hs,
    simp only [sUnion_eq_bUnion, preimage_Union, hg],
    exact ‚ü®is_open_Union $ Œª s, is_open_Union $ Œª hs, hgo _ _, rfl‚ü©,
  end }

lemma is_open_induced_iff [t : topological_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} :
  @is_open Œ± (t.induced f) s ‚Üî (‚àÉt, is_open t ‚àß f ‚Åª¬π' t = s) :=
iff.rfl

lemma is_open_induced_iff' [t : topological_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} :
  (t.induced f).is_open s ‚Üî (‚àÉt, is_open t ‚àß f ‚Åª¬π' t = s) :=
iff.rfl

lemma is_closed_induced_iff [t : topological_space Œ≤] {s : set Œ±} {f : Œ± ‚Üí Œ≤} :
  @is_closed Œ± (t.induced f) s ‚Üî (‚àÉt, is_closed t ‚àß f ‚Åª¬π' t = s) :=
begin
  simp only [‚Üê is_open_compl_iff, is_open_induced_iff],
  exact ‚ü®Œª ‚ü®t, ht, heq‚ü©, ‚ü®t·∂ú, by rwa compl_compl, by simp [preimage_compl, heq, compl_compl]‚ü©,
         Œª ‚ü®t, ht, heq‚ü©, ‚ü®t·∂ú, ht, by simp only [preimage_compl, heq.symm]‚ü©‚ü©
end

/-- Given `f : Œ± ‚Üí Œ≤` and a topology on `Œ±`, the coinduced topology on `Œ≤` is defined
  such that `s:set Œ≤` is open if the preimage of `s` is open. This is the finest topology that
  makes `f` continuous. -/
def topological_space.coinduced {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (t : topological_space Œ±) :
  topological_space Œ≤ :=
{ is_open        := Œªs, t.is_open (f ‚Åª¬π' s),
  is_open_univ   := by rw preimage_univ; exact t.is_open_univ,
  is_open_inter  := assume s‚ÇÅ s‚ÇÇ h‚ÇÅ h‚ÇÇ, by rw preimage_inter; exact t.is_open_inter _ _ h‚ÇÅ h‚ÇÇ,
  is_open_sUnion := assume s h, by rw [preimage_sUnion]; exact (@is_open_Union _ _ t _ $ assume i,
    show is_open (‚ãÉ (H : i ‚àà s), f ‚Åª¬π' i), from
      @is_open_Union _ _ t _ $ assume hi, h i hi) }

lemma is_open_coinduced {t : topological_space Œ±} {s : set Œ≤} {f : Œ± ‚Üí Œ≤} :
  @is_open Œ≤ (topological_space.coinduced f t) s ‚Üî is_open (f ‚Åª¬π' s) :=
iff.rfl

lemma preimage_nhds_coinduced [topological_space Œ±] {œÄ : Œ± ‚Üí Œ≤} {s : set Œ≤}
  {a : Œ±} (hs : s ‚àà @nhds Œ≤ (topological_space.coinduced œÄ ‚Äπ_‚Ä∫) (œÄ a)) : œÄ ‚Åª¬π' s ‚àà ùìù a :=
begin
  letI := topological_space.coinduced œÄ ‚Äπ_‚Ä∫,
  rcases mem_nhds_iff.mp hs with ‚ü®V, hVs, V_op, mem_V‚ü©,
  exact mem_nhds_iff.mpr ‚ü®œÄ ‚Åª¬π' V, set.preimage_mono hVs, V_op, mem_V‚ü©
end

variables {t tŒ± t‚ÇÅ t‚ÇÇ : topological_space Œ±} {tŒ≤ : topological_space Œ≤} {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ±}

local notation `cont` := @continuous _ _

lemma topological_space.coinduced_le_iff_le_induced :
  tŒ±.coinduced f ‚â§ tŒ≤ ‚Üî tŒ± ‚â§ tŒ≤.induced f :=
‚ü®Œª h s ‚ü®t, ht, hst‚ü©, hst ‚ñ∏ h _ ht, Œª h s hs, h _ ‚ü®s, hs, rfl‚ü©‚ü©

lemma continuous_iff_coinduced_le : cont tŒ± tŒ≤ f ‚Üî tŒ±.coinduced f ‚â§ tŒ≤ := continuous_def

lemma continuous_iff_le_induced : cont tŒ± tŒ≤ f ‚Üî tŒ± ‚â§ tŒ≤.induced f :=
continuous_iff_coinduced_le.trans topological_space.coinduced_le_iff_le_induced

alias continuous_iff_coinduced_le ‚Üî continuous.coinduced_le _
alias continuous_iff_le_induced ‚Üî continuous.le_induced _

namespace topological_space

lemma gc_coinduced_induced (f : Œ± ‚Üí Œ≤) :
  galois_connection (topological_space.coinduced f) (topological_space.induced f) :=
assume f g, coinduced_le_iff_le_induced

@[mono] lemma induced_mono (h : t‚ÇÅ ‚â§ t‚ÇÇ) : t‚ÇÅ.induced g ‚â§ t‚ÇÇ.induced g :=
(gc_coinduced_induced g).monotone_u h

@[mono] lemma coinduced_mono (h : t‚ÇÅ ‚â§ t‚ÇÇ) : t‚ÇÅ.coinduced f ‚â§ t‚ÇÇ.coinduced f :=
(gc_coinduced_induced f).monotone_l h

@[simp] lemma induced_top : (‚ä§ : topological_space Œ±).induced g = ‚ä§ :=
(gc_coinduced_induced g).u_top

@[simp] lemma induced_inf : (t‚ÇÅ ‚äì t‚ÇÇ).induced g = t‚ÇÅ.induced g ‚äì t‚ÇÇ.induced g :=
(gc_coinduced_induced g).u_inf

@[simp] lemma induced_infi {t : Œπ ‚Üí topological_space Œ±} :
  (‚®Öi, t i).induced g = (‚®Öi, (t i).induced g) :=
(gc_coinduced_induced g).u_infi

@[simp] lemma coinduced_bot : (‚ä• : topological_space Œ±).coinduced f = ‚ä• :=
(gc_coinduced_induced f).l_bot

@[simp] lemma coinduced_sup : (t‚ÇÅ ‚äî t‚ÇÇ).coinduced f = t‚ÇÅ.coinduced f ‚äî t‚ÇÇ.coinduced f :=
(gc_coinduced_induced f).l_sup

@[simp] lemma coinduced_supr {t : Œπ ‚Üí topological_space Œ±} :
  (‚®Üi, t i).coinduced f = (‚®Üi, (t i).coinduced f) :=
(gc_coinduced_induced f).l_supr

@[simp] lemma induced_id {t : topological_space Œ±} : t.induced id = t :=
topological_space_eq $ funext $ assume s, propext $
  ‚ü®assume ‚ü®s', hs, h‚ü©, h ‚ñ∏ hs, assume hs, ‚ü®s, hs, rfl‚ü©‚ü©

@[simp] lemma coinduced_id {t : topological_space Œ±} : t.coinduced id = t :=
topological_space_eq rfl

lemma induced_compose {tŒ≥ : topological_space Œ≥}
  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} : (tŒ≥.induced g).induced f = tŒ≥.induced (g ‚àò f) :=
topological_space_eq $ funext $ assume s, propext $
  ‚ü®assume ‚ü®s', ‚ü®s, hs, h‚ÇÇ‚ü©, h‚ÇÅ‚ü©, h‚ÇÅ ‚ñ∏ h‚ÇÇ ‚ñ∏ ‚ü®s, hs, rfl‚ü©,
    assume ‚ü®s, hs, h‚ü©, ‚ü®preimage g s, ‚ü®s, hs, rfl‚ü©, h ‚ñ∏ rfl‚ü©‚ü©

lemma induced_const {t : topological_space Œ±} {x : Œ±} :
  t.induced (Œª y : Œ≤, x) = ‚ä§ :=
top_unique (@continuous_const Œ≤ Œ± ‚ä§ t x).le_induced

lemma coinduced_compose {tŒ± : topological_space Œ±}
  {f : Œ± ‚Üí Œ≤} {g : Œ≤ ‚Üí Œ≥} : (tŒ±.coinduced f).coinduced g = tŒ±.coinduced (g ‚àò f) :=
topological_space_eq rfl

lemma induced_generate_from_eq {b : set (set Œ≤)} {f : Œ± ‚Üí Œ≤} :
  (generate_from b).induced f = topological_space.generate_from (preimage f '' b) :=
le_antisymm
  (le_generate_from $ ball_image_iff.2 $ assume s hs, ‚ü®s, generate_open.basic _ hs, rfl‚ü©)
  (coinduced_le_iff_le_induced.1 $ le_generate_from $ assume s hs,
    generate_open.basic _ $ mem_image_of_mem _ hs)

lemma le_induced_generate_from {Œ± Œ≤} [t : topological_space Œ±] {b : set (set Œ≤)}
  {f : Œ± ‚Üí Œ≤} (h : ‚àÄ (a : set Œ≤), a ‚àà b ‚Üí is_open (f ‚Åª¬π' a)) : t ‚â§ induced f (generate_from b) :=
begin
  rw induced_generate_from_eq,
  apply le_generate_from,
  simp only [mem_image, and_imp, forall_apply_eq_imp_iff‚ÇÇ, exists_imp_distrib],
  exact h,
end

theorem is_open_induced_iff {s : set Œ±} :
  @is_open _ (induced f tŒ≤) s ‚Üî s ‚àà preimage f '' {s | is_open s} :=
iff.rfl

theorem is_open_induced {s : set Œ≤} (h : is_open s) : (induced f tŒ≤).is_open (f ‚Åª¬π' s) :=
‚ü®s, h, rfl‚ü©

/-! ### ùìù in the induced topology -/

theorem mem_nhds_induced [T : topological_space Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ≤) (s : set Œ≤) :
  s ‚àà @nhds Œ≤ (topological_space.induced f T) a ‚Üî ‚àÉ u ‚àà ùìù (f a), f ‚Åª¬π' u ‚äÜ s :=
begin
  simp only [mem_nhds_iff, is_open_induced_iff, exists_prop, set.mem_set_of_eq],
  split,
  { rintros ‚ü®u, usub, ‚ü®v, openv, ueq‚ü©, au‚ü©,
    exact ‚ü®v, ‚ü®v, set.subset.refl v, openv, by rwa ‚Üêueq at au‚ü©, by rw ueq; exact usub‚ü© },
  rintros ‚ü®u, ‚ü®v, vsubu, openv, amem‚ü©, finvsub‚ü©,
  exact ‚ü®f ‚Åª¬π' v, set.subset.trans (set.preimage_mono vsubu) finvsub, ‚ü®‚ü®v, openv, rfl‚ü©, amem‚ü©‚ü©
end

theorem nhds_induced [T : topological_space Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ≤) :
  @nhds Œ≤ (topological_space.induced f T) a = comap f (ùìù (f a)) :=
by { ext s, rw [mem_nhds_induced, mem_comap] }

lemma induced_iff_nhds_eq [tŒ± : topological_space Œ±] [tŒ≤ : topological_space Œ≤] (f : Œ≤ ‚Üí Œ±) :
  tŒ≤ = tŒ±.induced f ‚Üî ‚àÄ b, ùìù b = comap f (ùìù $ f b) :=
‚ü®Œª h a, h.symm ‚ñ∏ nhds_induced f a, Œª h, injective_nhds $ funext $ Œª x, by rw [h, nhds_induced]‚ü©

lemma map_nhds_induced_eq (a : Œ±) : map f (@nhds Œ± (induced f tŒ≤) a) = ùìù[range f] (f a) :=
by rw [nhds_induced, filter.map_comap, nhds_within]

theorem map_nhds_induced_of_surjective [T : topological_space Œ±]
    {f : Œ≤ ‚Üí Œ±} (hf : function.surjective f) (a : Œ≤) :
  map f (@nhds Œ≤ (topological_space.induced f T) a) = ùìù (f a) :=
by rw [nhds_induced, map_comap_of_surjective hf]

lemma map_nhds_induced_of_mem {a : Œ±} (h : range f ‚àà ùìù (f a)) :
  map f (@nhds Œ± (induced f tŒ≤) a) = ùìù (f a) :=
by rw [nhds_induced, filter.map_comap_of_mem h]

lemma closure_induced [t : topological_space Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : set Œ±} :
  a ‚àà @closure Œ± (topological_space.induced f t) s ‚Üî f a ‚àà closure (f '' s) :=
by simp only [mem_closure_iff_frequently, nhds_induced, frequently_comap, mem_image, and_comm]

end topological_space

end induced_coinduced

/-!
### Sierpinski topology on `Prop`

In this section we equip `Prop` with the Sierpinski topology: the open sets are `‚àÖ`, `set.univ`, and
`{true}`. 
-/

section sierpinski

open topological_space

/-- Topology with a single nontrivial open set. Same as `topological_space.generate_from {s‚ÇÄ}`
but has nicer defeq properties for `is_open`. -/
protected def topological_space.singleton (s‚ÇÄ : set Œ±) : topological_space Œ± :=
{ is_open := Œª s, s = ‚àÖ ‚à® s = univ ‚à® s = s‚ÇÄ,
  is_open_univ := or.inr (or.inl rfl),
  is_open_inter := by rintro s t (rfl|rfl|rfl) (rfl|rfl|rfl); simp,
  is_open_sUnion := Œª S hS,
    begin
      by_cases he : ‚àÄ s ‚àà S, s = ‚àÖ,
      { exact or.inl (sUnion_eq_empty.2 he) },
      { push_neg at he, right,
        by_cases hu : ‚àÉ s ‚àà S, s = univ,
        { rcases hu with ‚ü®s, hs, rfl‚ü©,
          exact or.inl (eq_univ_of_univ_subset $ subset_sUnion_of_mem hs) },
        { push_neg at hu, right,
          replace hu : ‚àÄ s ‚àà S, s = ‚àÖ ‚à® s = s‚ÇÄ,
            from Œª s hs, (hS s hs).imp id (Œª h, h.resolve_left (hu s hs)),
          rcases he with ‚ü®t, ht, hne‚ü©, obtain rfl : t = s‚ÇÄ, from (hu t ht).resolve_left hne,
          have : is_greatest S t, from ‚ü®ht, Œª s hs, (hu s hs).elim (Œª he, he.symm ‚ñ∏ bot_le) eq.le‚ü©,
          exact this.is_lub.Sup_eq } }
    end }

lemma is_topological_subbasis_singleton (s : set Œ±) :
  @is_topological_subbasis Œ± (topological_space.singleton s) {s} :=
begin
  refine le_antisymm (le_generate_from $ Œª t (ht : t = s), or.inr $ or.inr ht) _,
  rintro t (rfl|rfl|rfl),
  exacts [@is_open_empty _ (_ : _), @is_open_univ _ (_ : _), generate_open.basic _ rfl]
end

instance sierpinski_space : topological_space Prop :=
topological_space.singleton {true}

@[simp] lemma is_open_Prop {s : set Prop} : is_open s ‚Üî s = ‚àÖ ‚à® s = univ ‚à® s = {true} := iff.rfl

lemma is_open_singleton_true : is_open ({true} : set Prop) := or.inr (or.inr rfl)

variables [topological_space Œ±]

lemma continuous_Prop {p : Œ± ‚Üí Prop} : continuous p ‚Üî is_open {x | p x} :=
(is_topological_subbasis_singleton {true}).continuous_iff.trans $ by simp [preimage]

lemma is_open_iff_continuous_mem {s : set Œ±} : is_open s ‚Üî continuous (Œª x, x ‚àà s) :=
continuous_Prop.symm

alias is_open_iff_continuous_mem ‚Üî is_open.continuous_mem _

end sierpinski

/-!
### More on continuity and (co)induced topologies
-/

section constructions
open topological_space

local notation `cont` := @continuous _ _
local notation `tspace` := topological_space

variables {f : Œ± ‚Üí Œ≤}

@[continuity]
lemma continuous_induced_dom {t : tspace Œ≤} : cont (induced f t) t f :=
by { rw continuous_def, assume s h, exact ‚ü®_, h, rfl‚ü© }

lemma continuous_induced_rng {g : Œ≥ ‚Üí Œ±} {t‚ÇÇ : tspace Œ≤} {t‚ÇÅ : tspace Œ≥}
  (h : cont t‚ÇÅ t‚ÇÇ (f ‚àò g)) : cont t‚ÇÅ (induced f t‚ÇÇ) g :=
begin
  rw continuous_def,
  rintros s ‚ü®t, ht, rfl‚ü©,
  simpa using continuous_def.1 h t ht,
end

lemma continuous_induced_rng' [topological_space Œ±] [topological_space Œ≤] [topological_space Œ≥]
  {g : Œ≥ ‚Üí Œ±} (f : Œ± ‚Üí Œ≤) (H : ‚Äπtopological_space Œ±‚Ä∫ = ‚Äπtopological_space Œ≤‚Ä∫.induced f)
  (h : continuous (f ‚àò g)) : continuous g :=
H.symm ‚ñ∏ continuous_induced_rng h

lemma continuous_coinduced_rng {t : tspace Œ±} : cont t (coinduced f t) f :=
by { rw continuous_def, assume s h, exact h }

lemma continuous_coinduced_dom {g : Œ≤ ‚Üí Œ≥} {t‚ÇÅ : tspace Œ±} {t‚ÇÇ : tspace Œ≥}
  (h : cont t‚ÇÅ t‚ÇÇ (g ‚àò f)) : cont (coinduced f t‚ÇÅ) t‚ÇÇ g :=
begin
  rw continuous_def at h ‚ä¢,
  assume s hs,
  exact h _ hs
end

lemma continuous_le_dom {t‚ÇÅ t‚ÇÇ : tspace Œ±} {t‚ÇÉ : tspace Œ≤}
  (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÅ) (h‚ÇÇ : cont t‚ÇÅ t‚ÇÉ f) : cont t‚ÇÇ t‚ÇÉ f :=
begin
  rw continuous_def at h‚ÇÇ ‚ä¢,
  assume s h,
  exact h‚ÇÅ _ (h‚ÇÇ s h)
end

lemma continuous_le_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ t‚ÇÉ : tspace Œ≤}
  (h‚ÇÅ : t‚ÇÇ ‚â§ t‚ÇÉ) (h‚ÇÇ : cont t‚ÇÅ t‚ÇÇ f) : cont t‚ÇÅ t‚ÇÉ f :=
begin
  rw continuous_def at h‚ÇÇ ‚ä¢,
  assume s h,
  exact h‚ÇÇ s (h‚ÇÅ s h)
end

lemma continuous_sup_dom {t‚ÇÅ t‚ÇÇ : tspace Œ±} {t‚ÇÉ : tspace Œ≤}
  (h‚ÇÅ : cont t‚ÇÅ t‚ÇÉ f) (h‚ÇÇ : cont t‚ÇÇ t‚ÇÉ f) : cont (t‚ÇÅ ‚äî t‚ÇÇ) t‚ÇÉ f :=
begin
  rw continuous_def at h‚ÇÅ h‚ÇÇ ‚ä¢,
  assume s h,
  exact ‚ü®h‚ÇÅ s h, h‚ÇÇ s h‚ü©
end

lemma continuous_sup_rng_left {t‚ÇÅ : tspace Œ±} {t‚ÇÉ t‚ÇÇ : tspace Œ≤} :
  cont t‚ÇÅ t‚ÇÇ f ‚Üí cont t‚ÇÅ (t‚ÇÇ ‚äî t‚ÇÉ) f :=
continuous_le_rng le_sup_left

lemma continuous_sup_rng_right {t‚ÇÅ : tspace Œ±} {t‚ÇÉ t‚ÇÇ : tspace Œ≤} :
  cont t‚ÇÅ t‚ÇÉ f ‚Üí cont t‚ÇÅ (t‚ÇÇ ‚äî t‚ÇÉ) f :=
continuous_le_rng le_sup_right

lemma continuous_Sup_dom {t‚ÇÅ : set (tspace Œ±)} {t‚ÇÇ : tspace Œ≤}
  (h : ‚àÄt‚ààt‚ÇÅ, cont t t‚ÇÇ f) : cont (Sup t‚ÇÅ) t‚ÇÇ f :=
continuous_iff_le_induced.2 $ Sup_le $ assume t ht, continuous_iff_le_induced.1 $ h t ht

lemma continuous_Sup_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ : set (tspace Œ≤)} {t : tspace Œ≤}
  (h‚ÇÅ : t ‚àà t‚ÇÇ) (hf : cont t‚ÇÅ t f) : cont t‚ÇÅ (Sup t‚ÇÇ) f :=
continuous_iff_coinduced_le.2 $ le_Sup_of_le h‚ÇÅ $ continuous_iff_coinduced_le.1 hf

lemma continuous_supr_dom {t‚ÇÅ : Œπ ‚Üí tspace Œ±} {t‚ÇÇ : tspace Œ≤}
  (h : ‚àÄi, cont (t‚ÇÅ i) t‚ÇÇ f) : cont (supr t‚ÇÅ) t‚ÇÇ f :=
continuous_Sup_dom $ assume t ‚ü®i, (t_eq : t‚ÇÅ i = t)‚ü©, t_eq ‚ñ∏ h i

lemma continuous_supr_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ : Œπ ‚Üí tspace Œ≤} {i : Œπ}
  (h : cont t‚ÇÅ (t‚ÇÇ i) f) : cont t‚ÇÅ (supr t‚ÇÇ) f :=
continuous_Sup_rng ‚ü®i, rfl‚ü© h

lemma continuous_inf_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ t‚ÇÉ : tspace Œ≤}
  (h‚ÇÅ : cont t‚ÇÅ t‚ÇÇ f) (h‚ÇÇ : cont t‚ÇÅ t‚ÇÉ f) : cont t‚ÇÅ (t‚ÇÇ ‚äì t‚ÇÉ) f :=
continuous_iff_coinduced_le.2 $ le_inf
  (continuous_iff_coinduced_le.1 h‚ÇÅ)
  (continuous_iff_coinduced_le.1 h‚ÇÇ)

lemma continuous_inf_dom_left {t‚ÇÅ t‚ÇÇ : tspace Œ±} {t‚ÇÉ : tspace Œ≤} :
  cont t‚ÇÅ t‚ÇÉ f ‚Üí cont (t‚ÇÅ ‚äì t‚ÇÇ) t‚ÇÉ f :=
continuous_le_dom inf_le_left

lemma continuous_inf_dom_right {t‚ÇÅ t‚ÇÇ : tspace Œ±} {t‚ÇÉ : tspace Œ≤} :
  cont t‚ÇÇ t‚ÇÉ f ‚Üí cont (t‚ÇÅ ‚äì t‚ÇÇ) t‚ÇÉ f :=
continuous_le_dom inf_le_right

lemma continuous_Inf_dom {t‚ÇÅ : set (tspace Œ±)} {t‚ÇÇ : tspace Œ≤} {t : tspace Œ±} (h‚ÇÅ : t ‚àà t‚ÇÅ) :
  cont t t‚ÇÇ f ‚Üí cont (Inf t‚ÇÅ) t‚ÇÇ f :=
continuous_le_dom $ Inf_le h‚ÇÅ

lemma continuous_Inf_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ : set (tspace Œ≤)}
  (h : ‚àÄt‚ààt‚ÇÇ, cont t‚ÇÅ t f) : cont t‚ÇÅ (Inf t‚ÇÇ) f :=
continuous_iff_coinduced_le.2 $ le_Inf $ assume b hb, continuous_iff_coinduced_le.1 $ h b hb

lemma continuous_infi_dom {t‚ÇÅ : Œπ ‚Üí tspace Œ±} {t‚ÇÇ : tspace Œ≤} {i : Œπ} :
  cont (t‚ÇÅ i) t‚ÇÇ f ‚Üí cont (infi t‚ÇÅ) t‚ÇÇ f :=
continuous_le_dom $ infi_le _ _

lemma continuous_infi_rng {t‚ÇÅ : tspace Œ±} {t‚ÇÇ : Œπ ‚Üí tspace Œ≤}
  (h : ‚àÄi, cont t‚ÇÅ (t‚ÇÇ i) f) : cont t‚ÇÅ (infi t‚ÇÇ) f :=
continuous_iff_coinduced_le.2 $ le_infi $ assume i, continuous_iff_coinduced_le.1 $ h i

@[continuity] lemma continuous_bot {t : tspace Œ≤} : cont ‚ä• t f :=
continuous_iff_le_induced.2 $ bot_le

@[continuity] lemma continuous_top {t : tspace Œ±} : cont t ‚ä§ f :=
continuous_iff_coinduced_le.2 $ le_top

end constructions
