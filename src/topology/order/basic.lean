/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Yury Kudryashov
-/
import data.set.intervals.pi
import data.set.pointwise.interval
import order.filter.interval
import topology.support
import topology.algebra.order.left_right

/-!
# Theory of topology on ordered spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

## Main definitions

The order topology on an ordered space is the topology generated by all open intervals (or
equivalently by those of the form `(-‚àû, a)` and `(b, +‚àû)`). We define it as `preorder.topology Œ±`.
However, we do *not* register it as an instance (as many existing ordered types already have
topologies, which would be equal but not definitionally equal to `preorder.topology Œ±`). Instead,
we introduce a class `order_topology Œ±` (which is a `Prop`, also known as a mixin) saying that on
the type `Œ±` having already a topological space structure and a preorder structure, the topological
structure is equal to the order topology.

We also introduce another (mixin) class `order_closed_topology Œ±` saying that the set of points
`(x, y)` with `x ‚â§ y` is closed in the product space. This is automatically satisfied on a linear
order with the order topology.

We prove many basic properties of such topologies.

## Main statements

This file contains the proofs of the following facts. For exact requirements
(`order_closed_topology` vs `order_topology`, `preorder` vs `partial_order` vs `linear_order` etc)
see their statements.

### Open / closed sets

* `is_open_lt` : if `f` and `g` are continuous functions, then `{x | f x < g x}` is open;
* `is_open_Iio`, `is_open_Ioi`, `is_open_Ioo` : open intervals are open;
* `is_closed_le` : if `f` and `g` are continuous functions, then `{x | f x ‚â§ g x}` is closed;
* `is_closed_Iic`, `is_closed_Ici`, `is_closed_Icc` : closed intervals are closed;
* `frontier_le_subset_eq`, `frontier_lt_subset_eq` : frontiers of both `{x | f x ‚â§ g x}`
  and `{x | f x < g x}` are included by `{x | f x = g x}`;
* `exists_Ioc_subset_of_mem_nhds`, `exists_Ico_subset_of_mem_nhds` : if `x < y`, then any
  neighborhood of `x` includes an interval `[x, z)` for some `z ‚àà (x, y]`, and any neighborhood
  of `y` includes an interval `(z, y]` for some `z ‚àà [x, y)`.

### Convergence and inequalities

* `le_of_tendsto_of_tendsto` : if `f` converges to `a`, `g` converges to `b`, and eventually
  `f x ‚â§ g x`, then `a ‚â§ b`
* `le_of_tendsto`, `ge_of_tendsto` : if `f` converges to `a` and eventually `f x ‚â§ b`
  (resp., `b ‚â§ f x`), then `a ‚â§ b` (resp., `b ‚â§ a); we also provide primed versions
  that assume the inequalities to hold for all `x`.

### Min, max, `Sup` and `Inf`

* `continuous.min`, `continuous.max`: pointwise `min`/`max` of two continuous functions is
  continuous.
* `tendsto.min`, `tendsto.max` : if `f` tends to `a` and `g` tends to `b`, then their pointwise
  `min`/`max` tend to `min a b` and `max a b`, respectively.
* `tendsto_of_tendsto_of_tendsto_of_le_of_le` : theorem known as squeeze theorem,
  sandwich theorem, theorem of Carabinieri, and two policemen (and a drunk) theorem; if `g` and `h`
  both converge to `a`, and eventually `g x ‚â§ f x ‚â§ h x`, then `f` converges to `a`.

## Implementation notes

We do _not_ register the order topology as an instance on a preorder (or even on a linear order).
Indeed, on many such spaces, a topology has already been constructed in a different way (think
of the discrete spaces `‚Ñï` or `‚Ñ§`, or `‚Ñù` that could inherit a topology as the completion of `‚Ñö`),
and is in general not defeq to the one generated by the intervals. We make it available as a
definition `preorder.topology Œ±` though, that can be registered as an instance when necessary, or
for specific types.
-/

open set filter topological_space
open function
open order_dual (to_dual of_dual)
open_locale topology classical filter

universes u v w
variables {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w}

/-- A topology on a set which is both a topological space and a preorder is _order-closed_ if the
set of points `(x, y)` with `x ‚â§ y` is closed in the product space. We introduce this as a mixin.
This property is satisfied for the order topology on a linear order, but it can be satisfied more
generally, and suffices to derive many interesting properties relating order and topology. -/
class order_closed_topology (Œ± : Type*) [topological_space Œ±] [preorder Œ±] : Prop :=
(is_closed_le' : is_closed {p : Œ± √ó Œ± | p.1 ‚â§ p.2})

instance [topological_space Œ±] [h : first_countable_topology Œ±] : first_countable_topology Œ±·µí·µà := h

instance [topological_space Œ±] [h : second_countable_topology Œ±] : second_countable_topology Œ±·µí·µà :=
h

lemma dense.order_dual [topological_space Œ±] {s : set Œ±} (hs : dense s) :
  dense (order_dual.of_dual ‚Åª¬π' s) := hs

section order_closed_topology

section preorder
variables [topological_space Œ±] [preorder Œ±] [t : order_closed_topology Œ±]
include t

namespace subtype

instance {p : Œ± ‚Üí Prop} : order_closed_topology (subtype p) :=
have this : continuous (Œª (p : (subtype p) √ó (subtype p)), ((p.fst : Œ±), (p.snd : Œ±))) :=
  (continuous_subtype_coe.comp continuous_fst).prod_mk
  (continuous_subtype_coe.comp continuous_snd),
order_closed_topology.mk (t.is_closed_le'.preimage this)

end subtype

lemma is_closed_le_prod : is_closed {p : Œ± √ó Œ± | p.1 ‚â§ p.2} :=
t.is_closed_le'

lemma is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_closed {b | f b ‚â§ g b} :=
continuous_iff_is_closed.mp (hf.prod_mk hg) _ is_closed_le_prod

lemma is_closed_le' (a : Œ±) : is_closed {b | b ‚â§ a} :=
is_closed_le continuous_id continuous_const

lemma is_closed_Iic {a : Œ±} : is_closed (Iic a) :=
is_closed_le' a

lemma is_closed_ge' (a : Œ±) : is_closed {b | a ‚â§ b} :=
is_closed_le continuous_const continuous_id

lemma is_closed_Ici {a : Œ±} : is_closed (Ici a) :=
is_closed_ge' a

instance : order_closed_topology Œ±·µí·µà :=
‚ü®(@order_closed_topology.is_closed_le' Œ± _ _ _).preimage continuous_swap‚ü©

lemma is_closed_Icc {a b : Œ±} : is_closed (Icc a b) :=
is_closed.inter is_closed_Ici is_closed_Iic

@[simp] lemma closure_Icc (a b : Œ±) : closure (Icc a b) = Icc a b :=
is_closed_Icc.closure_eq

@[simp] lemma closure_Iic (a : Œ±) : closure (Iic a) = Iic a :=
is_closed_Iic.closure_eq

@[simp] lemma closure_Ici (a : Œ±) : closure (Ici a) = Ici a :=
is_closed_Ici.closure_eq

lemma le_of_tendsto_of_tendsto {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : f ‚â§·∂†[b] g) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
have tendsto (Œªb, (f b, g b)) b (ùìù (a‚ÇÅ, a‚ÇÇ)),
  by rw [nhds_prod_eq]; exact hf.prod_mk hg,
show (a‚ÇÅ, a‚ÇÇ) ‚àà {p:Œ±√óŒ± | p.1 ‚â§ p.2},
  from t.is_closed_le'.mem_of_tendsto this h

alias le_of_tendsto_of_tendsto ‚Üê tendsto_le_of_eventually_le

lemma le_of_tendsto_of_tendsto' {f g : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} [ne_bot b]
  (hf : tendsto f b (ùìù a‚ÇÅ)) (hg : tendsto g b (ùìù a‚ÇÇ)) (h : ‚àÄ x, f x ‚â§ g x) :
  a‚ÇÅ ‚â§ a‚ÇÇ :=
le_of_tendsto_of_tendsto hf hg (eventually_of_forall h)

lemma le_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto_of_tendsto lim tendsto_const_nhds h

lemma le_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤}
  [ne_bot x] (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, f c ‚â§ b) : a ‚â§ b :=
le_of_tendsto lim (eventually_of_forall h)

lemma ge_of_tendsto {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ·∂† c in x, b ‚â§ f c) : b ‚â§ a :=
le_of_tendsto_of_tendsto tendsto_const_nhds lim h

lemma ge_of_tendsto' {f : Œ≤ ‚Üí Œ±} {a b : Œ±} {x : filter Œ≤} [ne_bot x]
  (lim : tendsto f x (ùìù a)) (h : ‚àÄ c, b ‚â§ f c) : b ‚â§ a :=
ge_of_tendsto lim (eventually_of_forall h)

@[simp]
lemma closure_le_eq [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  closure {b | f b ‚â§ g b} = {b | f b ‚â§ g b} :=
(is_closed_le hf hg).closure_eq

lemma closure_lt_subset_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f)
  (hg : continuous g) :
  closure {b | f b < g b} ‚äÜ {b | f b ‚â§ g b} :=
closure_minimal (Œª x, le_of_lt) $ is_closed_le hf hg

lemma continuous_within_at.closure_le [topological_space Œ≤]
 {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} {x : Œ≤} (hx : x ‚àà closure s)
 (hf : continuous_within_at f s x)
 (hg : continuous_within_at g s x)
 (h : ‚àÄ y ‚àà s, f y ‚â§ g y) : f x ‚â§ g x :=
show (f x, g x) ‚àà {p : Œ± √ó Œ± | p.1 ‚â§ p.2},
from order_closed_topology.is_closed_le'.closure_subset ((hf.prod hg).mem_closure hx h)

/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,
then the set `{x ‚àà s | f x ‚â§ g x}` is a closed set. -/
lemma is_closed.is_closed_le [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (hs : is_closed s)
  (hf : continuous_on f s) (hg : continuous_on g s) :
  is_closed {x ‚àà s | f x ‚â§ g x} :=
(hf.prod hg).preimage_closed_of_closed hs order_closed_topology.is_closed_le'

lemma le_on_closure [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} {s : set Œ≤} (h : ‚àÄ x ‚àà s, f x ‚â§ g x)
  (hf : continuous_on f (closure s)) (hg : continuous_on g (closure s)) ‚¶Éx‚¶Ñ (hx : x ‚àà closure s) :
  f x ‚â§ g x :=
have s ‚äÜ {y ‚àà closure s | f y ‚â§ g y}, from Œª y hy, ‚ü®subset_closure hy, h y hy‚ü©,
(closure_minimal this (is_closed_closure.is_closed_le hf hg) hx).2

lemma is_closed.epigraph [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ≤}
  (hs : is_closed s) (hf : continuous_on f s) :
  is_closed {p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß f p.1 ‚â§ p.2} :=
(hs.preimage continuous_fst).is_closed_le (hf.comp continuous_on_fst subset.rfl) continuous_on_snd

lemma is_closed.hypograph [topological_space Œ≤] {f : Œ≤ ‚Üí Œ±} {s : set Œ≤}
  (hs : is_closed s) (hf : continuous_on f s) :
  is_closed {p : Œ≤ √ó Œ± | p.1 ‚àà s ‚àß p.2 ‚â§ f p.1} :=
(hs.preimage continuous_fst).is_closed_le continuous_on_snd (hf.comp continuous_on_fst subset.rfl)

omit t

lemma nhds_within_Ici_ne_bot {a b : Œ±} (H‚ÇÇ : a ‚â§ b) :
  ne_bot (ùìù[Ici a] b) :=
nhds_within_ne_bot_of_mem H‚ÇÇ

@[instance] lemma nhds_within_Ici_self_ne_bot (a : Œ±) :
  ne_bot (ùìù[‚â•] a) :=
nhds_within_Ici_ne_bot (le_refl a)

lemma nhds_within_Iic_ne_bot {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Iic b] a) :=
nhds_within_ne_bot_of_mem H

@[instance] lemma nhds_within_Iic_self_ne_bot (a : Œ±) :
  ne_bot (ùìù[‚â§] a) :=
nhds_within_Iic_ne_bot (le_refl a)

end preorder

section partial_order
variables [topological_space Œ±] [partial_order Œ±] [t : order_closed_topology Œ±]
include t

@[priority 90] -- see Note [lower instance priority]
instance order_closed_topology.to_t2_space : t2_space Œ± :=
t2_iff_is_closed_diagonal.2 $ by simpa only [diagonal, le_antisymm_iff] using
  t.is_closed_le'.inter (is_closed_le continuous_snd continuous_fst)

end partial_order

section linear_order
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±]

lemma is_open_lt_prod : is_open {p : Œ± √ó Œ± | p.1 < p.2} :=
by { simp_rw [‚Üê is_closed_compl_iff, compl_set_of, not_lt],
     exact is_closed_le continuous_snd continuous_fst }

lemma is_open_lt [topological_space Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : continuous f) (hg : continuous g) :
  is_open {b | f b < g b} :=
by simp [lt_iff_not_ge, -not_le]; exact (is_closed_le hg hf).is_open_compl

variables {a b : Œ±}

lemma is_open_Iio : is_open (Iio a) :=
is_open_lt continuous_id continuous_const

lemma is_open_Ioi : is_open (Ioi a) :=
is_open_lt continuous_const continuous_id

lemma is_open_Ioo : is_open (Ioo a b) :=
is_open.inter is_open_Ioi is_open_Iio

@[simp] lemma interior_Ioi : interior (Ioi a) = Ioi a :=
is_open_Ioi.interior_eq

@[simp] lemma interior_Iio : interior (Iio a) = Iio a :=
is_open_Iio.interior_eq

@[simp] lemma interior_Ioo : interior (Ioo a b) = Ioo a b :=
is_open_Ioo.interior_eq

lemma Ioo_subset_closure_interior : Ioo a b ‚äÜ closure (interior (Ioo a b)) :=
by simp only [interior_Ioo, subset_closure]

lemma Iio_mem_nhds {a b : Œ±} (h : a < b) : Iio b ‚àà ùìù a :=
is_open.mem_nhds is_open_Iio h

lemma Ioi_mem_nhds {a b : Œ±} (h : a < b) : Ioi a ‚àà ùìù b :=
is_open.mem_nhds is_open_Ioi h

lemma Iic_mem_nhds {a b : Œ±} (h : a < b) : Iic b ‚àà ùìù a :=
mem_of_superset (Iio_mem_nhds h) Iio_subset_Iic_self

lemma Ici_mem_nhds {a b : Œ±} (h : a < b) : Ici a ‚àà ùìù b :=
mem_of_superset (Ioi_mem_nhds h) Ioi_subset_Ici_self

lemma Ioo_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioo a b ‚àà ùìù x :=
is_open.mem_nhds is_open_Ioo ‚ü®ha, hb‚ü©

lemma Ioc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ioc a b ‚àà ùìù x :=
mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ioc_self

lemma Ico_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Ico a b ‚àà ùìù x :=
mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Ico_self

lemma Icc_mem_nhds {a b x : Œ±} (ha : a < x) (hb : x < b) : Icc a b ‚àà ùìù x :=
mem_of_superset (Ioo_mem_nhds ha hb) Ioo_subset_Icc_self

lemma eventually_lt_of_tendsto_lt {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : v < u)
  (h : filter.tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, f a < u :=
tendsto_nhds.1 h (< u) is_open_Iio hv

lemma eventually_gt_of_tendsto_gt {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : u < v)
  (h : filter.tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, u < f a :=
tendsto_nhds.1 h (> u) is_open_Ioi hv

lemma eventually_le_of_tendsto_lt {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : v < u)
  (h : tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, f a ‚â§ u :=
(eventually_lt_of_tendsto_lt hv h).mono (Œª v, le_of_lt)

lemma eventually_ge_of_tendsto_gt {l : filter Œ≥} {f : Œ≥ ‚Üí Œ±} {u v : Œ±} (hv : u < v)
  (h : tendsto f l (ùìù v)) : ‚àÄ·∂† a in l, u ‚â§ f a :=
(eventually_gt_of_tendsto_gt hv h).mono (Œª v, le_of_lt)

variables [topological_space Œ≥]
/-!
### Neighborhoods to the left and to the right on an `order_closed_topology`

Limits to the left and to the right of real functions are defined in terms of neighborhoods to
the left and to the right, either open or closed, i.e., members of `ùìù[>] a` and
`ùìù[‚â•] a` on the right, and similarly on the left. Here we simply prove that all
right-neighborhoods of a point are equal, and we'll prove later other useful characterizations which
require the stronger hypothesis `order_topology Œ±` -/

/-!
#### Right neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioo a c ‚àà ùìù[>] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by rw [inter_comm, Ioi_inter_Iio]; exact Ioo_subset_Ioo_left H.1‚ü©

lemma Ioc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ioc a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Ico_self

lemma Icc_mem_nhds_within_Ioi {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[>] b :=
mem_of_superset (Ioo_mem_nhds_within_Ioi H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] a = ùìù[>] a :=
le_antisymm (nhds_within_mono _ Ioc_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioc_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Ioi {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] a = ùìù[>] a :=
le_antisymm (nhds_within_mono _ Ioo_subset_Ioi_self) $
  nhds_within_le_of_mem $ Ioo_mem_nhds_within_Ioi $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Ioc_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Ioi h]

@[simp]
lemma continuous_within_at_Ioo_iff_Ioi [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioo a b) a ‚Üî continuous_within_at f (Ioi a) a :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Ioi h]

/-!
#### Left neighborhoods, point excluded
-/

lemma Ioo_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioo a c ‚àà ùìù[<] b :=
by simpa only [dual_Ioo] using Ioo_mem_nhds_within_Ioi
  (show to_dual b ‚àà Ico (to_dual c) (to_dual a), from H.symm)

lemma Ico_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ico a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Ioc_self

lemma Icc_mem_nhds_within_Iio {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[<] b :=
mem_of_superset (Ioo_mem_nhds_within_Iio H) Ioo_subset_Icc_self

@[simp] lemma nhds_within_Ico_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] b = ùìù[<] b :=
by simpa only [dual_Ioc] using nhds_within_Ioc_eq_nhds_within_Ioi h.dual

@[simp] lemma nhds_within_Ioo_eq_nhds_within_Iio {a b : Œ±} (h : a < b) :
  ùìù[Ioo a b] b = ùìù[<] b :=
by simpa only [dual_Ioo] using nhds_within_Ioo_eq_nhds_within_Ioi h.dual

@[simp] lemma continuous_within_at_Ico_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  continuous_within_at f (Ico a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Iio h]

@[simp] lemma continuous_within_at_Ioo_iff_Iio {a b : Œ±} {f : Œ± ‚Üí Œ≥} (h : a < b) :
  continuous_within_at f (Ioo a b) b ‚Üî continuous_within_at f (Iio b) b :=
by simp only [continuous_within_at, nhds_within_Ioo_eq_nhds_within_Iio h]

/-!
#### Right neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[‚â•] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H

lemma Ioc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioc a c ‚àà ùìù[‚â•] b :=
mem_of_superset (Ioo_mem_nhds_within_Ici H) Ioo_subset_Ioc_self

lemma Ico_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Ico a c ‚àà ùìù[‚â•] b :=
mem_nhds_within.2 ‚ü®Iio c, is_open_Iio, H.2,
  by simp only [inter_comm, Ici_inter_Iio, Ico_subset_Ico_left H.1]‚ü©

lemma Icc_mem_nhds_within_Ici {a b c : Œ±} (H : b ‚àà Ico a c) :
  Icc a c ‚àà ùìù[‚â•] b :=
mem_of_superset (Ico_mem_nhds_within_Ici H) Ico_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] a = ùìù[‚â•] a :=
le_antisymm (nhds_within_mono _ Icc_subset_Ici_self) $
  nhds_within_le_of_mem $ Icc_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp] lemma nhds_within_Ico_eq_nhds_within_Ici {a b : Œ±} (h : a < b) :
  ùìù[Ico a b] a = ùìù[‚â•] a :=
le_antisymm (nhds_within_mono _ (Œª x, and.left)) $
  nhds_within_le_of_mem $ Ico_mem_nhds_within_Ici $ left_mem_Ico.2 h

@[simp]
lemma continuous_within_at_Icc_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Ici h]

@[simp]
lemma continuous_within_at_Ico_iff_Ici [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ico a b) a ‚Üî continuous_within_at f (Ici a) a :=
by simp only [continuous_within_at, nhds_within_Ico_eq_nhds_within_Ici h]

/-!
#### Left neighborhoods, point included
-/

lemma Ioo_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ioo a c ‚àà ùìù[‚â§] b :=
mem_nhds_within_of_mem_nhds $ is_open.mem_nhds is_open_Ioo H

lemma Ico_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioo a c) :
  Ico a c ‚àà ùìù[‚â§] b :=
mem_of_superset (Ioo_mem_nhds_within_Iic H) Ioo_subset_Ico_self

lemma Ioc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Ioc a c ‚àà ùìù[‚â§] b :=
by simpa only [dual_Ico] using Ico_mem_nhds_within_Ici
  (show to_dual b ‚àà Ico (to_dual c) (to_dual a), from H.symm)

lemma Icc_mem_nhds_within_Iic {a b c : Œ±} (H : b ‚àà Ioc a c) :
  Icc a c ‚àà ùìù[‚â§] b :=
mem_of_superset (Ioc_mem_nhds_within_Iic H) Ioc_subset_Icc_self

@[simp] lemma nhds_within_Icc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Icc a b] b = ùìù[‚â§] b :=
by simpa only [dual_Icc] using nhds_within_Icc_eq_nhds_within_Ici h.dual

@[simp] lemma nhds_within_Ioc_eq_nhds_within_Iic {a b : Œ±} (h : a < b) :
  ùìù[Ioc a b] b = ùìù[‚â§] b :=
by simpa only [dual_Ico] using nhds_within_Ico_eq_nhds_within_Ici h.dual

@[simp]
lemma continuous_within_at_Icc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Icc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Icc_eq_nhds_within_Iic h]

@[simp]
lemma continuous_within_at_Ioc_iff_Iic [topological_space Œ≤] {a b : Œ±} {f : Œ± ‚Üí Œ≤} (h : a < b) :
  continuous_within_at f (Ioc a b) b ‚Üî continuous_within_at f (Iic b) b :=
by simp only [continuous_within_at, nhds_within_Ioc_eq_nhds_within_Iic h]

end linear_order

section linear_order
variables [topological_space Œ±] [linear_order Œ±] [order_closed_topology Œ±] {f g : Œ≤ ‚Üí Œ±}

section
variables [topological_space Œ≤]

lemma lt_subset_interior_le (hf : continuous f) (hg : continuous g) :
  {b | f b < g b} ‚äÜ interior {b | f b ‚â§ g b} :=
interior_maximal (Œª p, le_of_lt) $ is_open_lt hf hg

lemma frontier_le_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b ‚â§ g b} ‚äÜ {b | f b = g b} :=
begin
  rw [frontier_eq_closure_inter_closure, closure_le_eq hf hg],
  rintros b ‚ü®hb‚ÇÅ, hb‚ÇÇ‚ü©,
  refine le_antisymm hb‚ÇÅ (closure_lt_subset_le hg hf _),
  convert hb‚ÇÇ using 2, simp only [not_le.symm], refl
end

lemma frontier_Iic_subset (a : Œ±) : frontier (Iic a) ‚äÜ {a} :=
frontier_le_subset_eq (@continuous_id Œ± _) continuous_const

lemma frontier_Ici_subset (a : Œ±) : frontier (Ici a) ‚äÜ {a} := @frontier_Iic_subset Œ±·µí·µà _ _ _ _

lemma frontier_lt_subset_eq (hf : continuous f) (hg : continuous g) :
  frontier {b | f b < g b} ‚äÜ {b | f b = g b} :=
by rw ‚Üê frontier_compl;
   convert frontier_le_subset_eq hg hf; simp [ext_iff, eq_comm]

lemma continuous_if_le [topological_space Œ≥] [Œ† x, decidable (f x ‚â§ g x)]
  {f' g' : Œ≤ ‚Üí Œ≥} (hf : continuous f) (hg : continuous g)
  (hf' : continuous_on f' {x | f x ‚â§ g x}) (hg' : continuous_on g' {x | g x ‚â§ f x})
  (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
  continuous (Œª x, if f x ‚â§ g x then f' x else g' x) :=
begin
  refine continuous_if (Œª a ha, hfg _ (frontier_le_subset_eq hf hg ha)) _ (hg'.mono _),
  { rwa [(is_closed_le hf hg).closure_eq] },
  { simp only [not_le], exact closure_lt_subset_le hg hf }
end

lemma continuous.if_le [topological_space Œ≥] [Œ† x, decidable (f x ‚â§ g x)] {f' g' : Œ≤ ‚Üí Œ≥}
  (hf' : continuous f') (hg' : continuous g') (hf : continuous f) (hg : continuous g)
  (hfg : ‚àÄ x, f x = g x ‚Üí f' x = g' x) :
  continuous (Œª x, if f x ‚â§ g x then f' x else g' x) :=
continuous_if_le hf hg hf'.continuous_on hg'.continuous_on hfg

lemma tendsto.eventually_lt {l : filter Œ≥} {f g : Œ≥ ‚Üí Œ±} {y z : Œ±}
  (hf : tendsto f l (ùìù y)) (hg : tendsto g l (ùìù z)) (hyz : y < z) : ‚àÄ·∂† x in l, f x < g x :=
begin
  by_cases h : y ‚ãñ z,
  { filter_upwards [hf (Iio_mem_nhds hyz), hg (Ioi_mem_nhds hyz)],
    rw [h.Iio_eq],
    exact Œª x hfx hgx, lt_of_le_of_lt hfx hgx },
  { obtain ‚ü®w, hyw, hwz‚ü© := (not_covby_iff hyz).mp h,
    filter_upwards [hf (Iio_mem_nhds hyw), hg (Ioi_mem_nhds hwz)],
    exact Œª x, lt_trans },
end

lemma continuous_at.eventually_lt {x‚ÇÄ : Œ≤} (hf : continuous_at f x‚ÇÄ)
  (hg : continuous_at g x‚ÇÄ) (hfg : f x‚ÇÄ < g x‚ÇÄ) : ‚àÄ·∂† x in ùìù x‚ÇÄ, f x < g x :=
tendsto.eventually_lt hf hg hfg

@[continuity] lemma continuous.min (hf : continuous f) (hg : continuous g) :
  continuous (Œªb, min (f b) (g b)) :=
by { simp only [min_def], exact hf.if_le hg hf hg (Œª x, id) }

@[continuity] lemma continuous.max (hf : continuous f) (hg : continuous g) :
  continuous (Œªb, max (f b) (g b)) :=
@continuous.min Œ±·µí·µà _ _ _ _ _ _ _ hf hg

end

lemma continuous_min : continuous (Œª p : Œ± √ó Œ±, min p.1 p.2) := continuous_fst.min continuous_snd

lemma continuous_max : continuous (Œª p : Œ± √ó Œ±, max p.1 p.2) := continuous_fst.max continuous_snd

lemma filter.tendsto.max {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, max (f b) (g b)) b (ùìù (max a‚ÇÅ a‚ÇÇ)) :=
(continuous_max.tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)

lemma filter.tendsto.min {b : filter Œ≤} {a‚ÇÅ a‚ÇÇ : Œ±} (hf : tendsto f b (ùìù a‚ÇÅ))
  (hg : tendsto g b (ùìù a‚ÇÇ)) :
  tendsto (Œªb, min (f b) (g b)) b (ùìù (min a‚ÇÅ a‚ÇÇ)) :=
(continuous_min.tendsto (a‚ÇÅ, a‚ÇÇ)).comp (hf.prod_mk_nhds hg)

lemma filter.tendsto.max_right {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù a)) :
  tendsto (Œª i, max a (f i)) l (ùìù a) :=
by { convert ((continuous_max.comp (@continuous.prod.mk Œ± Œ± _ _ a)).tendsto a).comp h, simp, }

lemma filter.tendsto.max_left {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù a)) :
  tendsto (Œª i, max (f i) a) l (ùìù a) :=
by { simp_rw max_comm _ a, exact h.max_right, }

lemma filter.tendsto_nhds_max_right {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù[>] a)) :
  tendsto (Œª i, max a (f i)) l (ùìù[>] a) :=
begin
  obtain ‚ü®h‚ÇÅ : tendsto f l (ùìù a), h‚ÇÇ : ‚àÄ·∂† i in l, f i ‚àà Ioi a‚ü© := tendsto_nhds_within_iff.mp h,
  exact tendsto_nhds_within_iff.mpr ‚ü®h‚ÇÅ.max_right, h‚ÇÇ.mono $ Œª i hi, lt_max_of_lt_right hi‚ü©,
end

lemma filter.tendsto_nhds_max_left {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù[>] a)) :
  tendsto (Œª i, max (f i) a) l (ùìù[>] a) :=
by { simp_rw max_comm _ a, exact filter.tendsto_nhds_max_right h, }

lemma filter.tendsto.min_right {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù a)) :
  tendsto (Œª i, min a (f i)) l (ùìù a) :=
@filter.tendsto.max_right Œ±·µí·µà Œ≤ _ _ _ f l a h

lemma filter.tendsto.min_left {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù a)) :
  tendsto (Œª i, min (f i) a) l (ùìù a) :=
@filter.tendsto.max_left Œ±·µí·µà Œ≤ _ _ _ f l a h

lemma filter.tendsto_nhds_min_right {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù[<] a)) :
  tendsto (Œª i, min a (f i)) l (ùìù[<] a) :=
@filter.tendsto_nhds_max_right Œ±·µí·µà Œ≤ _ _ _ f l a h

lemma filter.tendsto_nhds_min_left {l : filter Œ≤} {a : Œ±} (h : tendsto f l (ùìù[<] a)) :
  tendsto (Œª i, min (f i) a) l (ùìù[<] a) :=
@filter.tendsto_nhds_max_left Œ±·µí·µà Œ≤ _ _ _ f l a h

lemma dense.exists_lt [no_min_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, y < x :=
hs.exists_mem_open is_open_Iio (exists_lt x)

lemma dense.exists_gt [no_max_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, x < y :=
hs.order_dual.exists_lt x

lemma dense.exists_le [no_min_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, y ‚â§ x :=
(hs.exists_lt x).imp $ Œª y hy, ‚ü®hy.fst, hy.snd.le‚ü©

lemma dense.exists_ge [no_max_order Œ±] {s : set Œ±} (hs : dense s) (x : Œ±) : ‚àÉ y ‚àà s, x ‚â§ y :=
hs.order_dual.exists_le x

lemma dense.exists_le' {s : set Œ±} (hs : dense s) (hbot : ‚àÄ x, is_bot x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ y ‚àà s, y ‚â§ x :=
begin
  by_cases hx : is_bot x,
  { exact ‚ü®x, hbot x hx, le_rfl‚ü© },
  { simp only [is_bot, not_forall, not_le] at hx,
    rcases hs.exists_mem_open is_open_Iio hx with ‚ü®y, hys, hy : y < x‚ü©,
    exact ‚ü®y, hys, hy.le‚ü© }
end

lemma dense.exists_ge' {s : set Œ±} (hs : dense s) (htop : ‚àÄ x, is_top x ‚Üí x ‚àà s) (x : Œ±) :
  ‚àÉ y ‚àà s, x ‚â§ y :=
hs.order_dual.exists_le' htop x

lemma dense.exists_between [densely_ordered Œ±] {s : set Œ±} (hs : dense s) {x y : Œ±} (h : x < y) :
  ‚àÉ z ‚àà s, z ‚àà Ioo x y :=
hs.exists_mem_open is_open_Ioo (nonempty_Ioo.2 h)

variables [nonempty Œ±] [topological_space Œ≤]

/-- A compact set is bounded below -/
lemma is_compact.bdd_below {s : set Œ±} (hs : is_compact s) : bdd_below s :=
begin
  by_contra H,
  rcases hs.elim_finite_subcover_image (Œª x (_ : x ‚àà s), @is_open_Ioi _ _ _ _ x) _
    with ‚ü®t, st, ft, ht‚ü©,
  { refine H (ft.bdd_below.imp $ Œª C hC y hy, _),
    rcases mem_Union‚ÇÇ.1 (ht hy) with ‚ü®x, hx, xy‚ü©,
    exact le_trans (hC hx) (le_of_lt xy) },
  { refine Œª x hx, mem_Union‚ÇÇ.2 (not_imp_comm.1 _ H),
    exact Œª h, ‚ü®x, Œª y hy, le_of_not_lt (h.imp $ Œª ys, ‚ü®_, hy, ys‚ü©)‚ü© }
end

/-- A compact set is bounded above -/
lemma is_compact.bdd_above {s : set Œ±} (hs : is_compact s) : bdd_above s :=
@is_compact.bdd_below Œ±·µí·µà _ _ _ _ _ hs

/-- A continuous function is bounded below on a compact set. -/
lemma is_compact.bdd_below_image {f : Œ≤ ‚Üí Œ±} {K : set Œ≤}
  (hK : is_compact K) (hf : continuous_on f K) : bdd_below (f '' K) :=
(hK.image_of_continuous_on hf).bdd_below

/-- A continuous function is bounded above on a compact set. -/
lemma is_compact.bdd_above_image {f : Œ≤ ‚Üí Œ±} {K : set Œ≤}
  (hK : is_compact K) (hf : continuous_on f K) : bdd_above (f '' K) :=
@is_compact.bdd_below_image Œ±·µí·µà _ _ _ _ _ _ _ _ hK hf

/-- A continuous function with compact support is bounded below. -/
@[to_additive /-" A continuous function with compact support is bounded below. "-/]
lemma continuous.bdd_below_range_of_has_compact_mul_support [has_one Œ±] {f : Œ≤ ‚Üí Œ±}
  (hf : continuous f) (h : has_compact_mul_support f) : bdd_below (range f) :=
(h.is_compact_range hf).bdd_below

/-- A continuous function with compact support is bounded above. -/
@[to_additive /-" A continuous function with compact support is bounded above. "-/]
lemma continuous.bdd_above_range_of_has_compact_mul_support [has_one Œ±]
  {f : Œ≤ ‚Üí Œ±} (hf : continuous f) (h : has_compact_mul_support f) :
  bdd_above (range f) :=
@continuous.bdd_below_range_of_has_compact_mul_support Œ±·µí·µà _ _ _ _ _ _ _ _ hf h

end linear_order

end order_closed_topology

instance [preorder Œ±] [topological_space Œ±] [order_closed_topology Œ±]
  [preorder Œ≤] [topological_space Œ≤] [order_closed_topology Œ≤] :
  order_closed_topology (Œ± √ó Œ≤) :=
‚ü®(is_closed_le (continuous_fst.comp continuous_fst) (continuous_fst.comp continuous_snd)).inter
  (is_closed_le (continuous_snd.comp continuous_fst) (continuous_snd.comp continuous_snd))‚ü©

instance {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} [Œ† i, preorder (Œ± i)] [Œ† i, topological_space (Œ± i)]
  [Œ† i, order_closed_topology (Œ± i)] : order_closed_topology (Œ† i, Œ± i) :=
begin
  constructor,
  simp only [pi.le_def, set_of_forall],
  exact is_closed_Inter (Œª i, is_closed_le ((continuous_apply i).comp continuous_fst)
    ((continuous_apply i).comp continuous_snd))
end

instance pi.order_closed_topology' [preorder Œ≤] [topological_space Œ≤]
  [order_closed_topology Œ≤] : order_closed_topology (Œ± ‚Üí Œ≤) :=
pi.order_closed_topology

/-- The order topology on an ordered type is the topology generated by open intervals. We register
it on a preorder, but it is mostly interesting in linear orders, where it is also order-closed.
We define it as a mixin. If you want to introduce the order topology on a preorder, use
`preorder.topology`. -/
class order_topology (Œ± : Type*) [t : topological_space Œ±] [preorder Œ±] : Prop :=
(topology_eq_generate_intervals : t = generate_from {s | ‚àÉ a, s = Ioi a ‚à® s = Iio a})

/-- (Order) topology on a partial order `Œ±` generated by the subbase of open intervals
`(a, ‚àû) = { x ‚à£ a < x }, (-‚àû , b) = {x ‚à£ x < b}` for all `a, b` in `Œ±`. We do not register it as an
instance as many ordered sets are already endowed with the same topology, most often in a non-defeq
way though. Register as a local instance when necessary. -/
def preorder.topology (Œ± : Type*) [preorder Œ±] : topological_space Œ± :=
generate_from {s : set Œ± | ‚àÉ (a : Œ±), s = {b : Œ± | a < b} ‚à® s = {b : Œ± | b < a}}

section order_topology

section preorder

variables [topological_space Œ±] [preorder Œ±] [t : order_topology Œ±]
include t

instance : order_topology Œ±·µí·µà :=
‚ü®by convert @order_topology.topology_eq_generate_intervals Œ± _ _ _;
  conv in (_ ‚à® _) { rw or.comm }; refl‚ü©

lemma is_open_iff_generate_intervals {s : set Œ±} :
  is_open s ‚Üî generate_open {s | ‚àÉ a, s = Ioi a ‚à® s = Iio a} s :=
by rw [t.topology_eq_generate_intervals]; refl

lemma is_open_lt' (a : Œ±) : is_open {b : Œ± | a < b} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inl rfl‚ü©

lemma is_open_gt' (a : Œ±) : is_open {b : Œ± | b < a} :=
by rw [@is_open_iff_generate_intervals Œ± _ _ t]; exact generate_open.basic _ ‚ü®a, or.inr rfl‚ü©

lemma lt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a < x :=
is_open.mem_nhds (is_open_lt' _) h

lemma le_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù b, a ‚â§ x :=
(ùìù b).sets_of_superset (lt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma gt_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
is_open.mem_nhds (is_open_gt' _) h

lemma ge_mem_nhds {a b : Œ±} (h : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
(ùìù a).sets_of_superset (gt_mem_nhds h) $ assume b hb, le_of_lt hb

lemma nhds_eq_order (a : Œ±) :
  ùìù a = (‚®Ö b ‚àà Iio a, ùìü (Ioi b)) ‚äì (‚®Ö b ‚àà Ioi a, ùìü (Iio b)) :=
by rw [t.topology_eq_generate_intervals, nhds_generate_from];
from le_antisymm
  (le_inf
    (le_infi‚ÇÇ $ assume b hb, infi_le_of_le {c : Œ± | b < c} $ infi_le _ ‚ü®hb, b, or.inl rfl‚ü©)
    (le_infi‚ÇÇ $ assume b hb, infi_le_of_le {c : Œ± | c < b} $ infi_le _ ‚ü®hb, b, or.inr rfl‚ü©))
  (le_infi $ assume s, le_infi $ assume ‚ü®ha, b, hs‚ü©,
    match s, ha, hs with
    | _, h, (or.inl rfl) := inf_le_of_left_le $ infi_le_of_le b $ infi_le _ h
    | _, h, (or.inr rfl) := inf_le_of_right_le $ infi_le_of_le b $ infi_le _ h
    end)

lemma tendsto_order {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤} :
  tendsto f x (ùìù a) ‚Üî (‚àÄ a' < a, ‚àÄ·∂† b in x, a' < f b) ‚àß (‚àÄ a' > a, ‚àÄ·∂† b in x, f b < a') :=
by simp [nhds_eq_order a, tendsto_inf, tendsto_infi, tendsto_principal]

instance tendsto_Icc_class_nhds (a : Œ±) : tendsto_Ixx_class Icc (ùìù a) (ùìù a) :=
begin
  simp only [nhds_eq_order, infi_subtype'],
  refine ((has_basis_infi_principal_finite _).inf
    (has_basis_infi_principal_finite _)).tendsto_Ixx_class (Œª s hs, _),
  refine ((ord_connected_bInter _).inter (ord_connected_bInter _)).out; intros _ _,
  exacts [ord_connected_Ioi, ord_connected_Iio]
end

instance tendsto_Ico_class_nhds (a : Œ±) : tendsto_Ixx_class Ico (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ico_subset_Icc_self)

instance tendsto_Ioc_class_nhds (a : Œ±) : tendsto_Ixx_class Ioc (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioc_subset_Icc_self)

instance tendsto_Ioo_class_nhds (a : Œ±) : tendsto_Ixx_class Ioo (ùìù a) (ùìù a) :=
tendsto_Ixx_class_of_subset (Œª _ _, Ioo_subset_Icc_self)

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold eventually for the filter. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a))
  (hgf : ‚àÄ·∂† b in b, g b ‚â§ f b) (hfh : ‚àÄ·∂† b in b, f b ‚â§ h b) :
  tendsto f b (ùìù a) :=
(hg.Icc hh).of_small_sets $ hgf.and hfh

/-- **Squeeze theorem** (also known as **sandwich theorem**). This version assumes that inequalities
hold everywhere. -/
lemma tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : Œ≤ ‚Üí Œ±} {b : filter Œ≤} {a : Œ±}
  (hg : tendsto g b (ùìù a)) (hh : tendsto h b (ùìù a)) (hgf : g ‚â§ f) (hfh : f ‚â§ h) :
  tendsto f b (ùìù a) :=
tendsto_of_tendsto_of_tendsto_of_le_of_le' hg hh
  (eventually_of_forall hgf) (eventually_of_forall hfh)

lemma nhds_order_unbounded {a : Œ±} (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) :
  ùìù a = (‚®Öl (h‚ÇÇ : l < a) u (h‚ÇÇ : a < u), ùìü (Ioo l u)) :=
have ‚àÉ u, u ‚àà Ioi a, from hu, have ‚àÉ l, l ‚àà Iio a, from hl,
by { simp only [nhds_eq_order, inf_binfi, binfi_inf, *, inf_principal, Ioi_inter_Iio], refl }

lemma tendsto_order_unbounded {f : Œ≤ ‚Üí Œ±} {a : Œ±} {x : filter Œ≤}
  (hu : ‚àÉu, a < u) (hl : ‚àÉl, l < a) (h : ‚àÄl u, l < a ‚Üí a < u ‚Üí ‚àÄ·∂† b in x, l < f b ‚àß f b < u) :
  tendsto f x (ùìù a) :=
by rw [nhds_order_unbounded hu hl];
from (tendsto_infi.2 $ assume l, tendsto_infi.2 $ assume hl,
  tendsto_infi.2 $ assume u, tendsto_infi.2 $ assume hu, tendsto_principal.2 $ h l u hl hu)

end preorder

instance tendsto_Ixx_nhds_within {Œ± : Type*} [preorder Œ±] [topological_space Œ±]
  (a : Œ±) {s t : set Œ±} {Ixx}
  [tendsto_Ixx_class Ixx (ùìù a) (ùìù a)] [tendsto_Ixx_class Ixx (ùìü s) (ùìü t)]:
  tendsto_Ixx_class Ixx (ùìù[s] a) (ùìù[t] a) :=
filter.tendsto_Ixx_class_inf

instance tendsto_Icc_class_nhds_pi {Œπ : Type*} {Œ± : Œπ ‚Üí Type*}
  [Œ† i, preorder (Œ± i)] [Œ† i, topological_space (Œ± i)] [‚àÄ i, order_topology (Œ± i)]
  (f : Œ† i, Œ± i) :
  tendsto_Ixx_class Icc (ùìù f) (ùìù f) :=
begin
  constructor,
  conv in ((ùìù f).small_sets) { rw [nhds_pi, filter.pi] },
  simp only [small_sets_infi, small_sets_comap, tendsto_infi, tendsto_lift', (‚àò), mem_powerset_iff],
  intros i s hs,
  have : tendsto (Œª g : Œ† i, Œ± i, g i) (ùìù f) (ùìù (f i)) := ((continuous_apply i).tendsto f),
  refine (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _,
  exact Œª p hp g hg, hp ‚ü®hg.1 _, hg.2 _‚ü©
end

theorem induced_order_topology' {Œ± : Type u} {Œ≤ : Type v}
  [preorder Œ±] [ta : topological_space Œ≤] [preorder Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H‚ÇÅ : ‚àÄ {a x}, x < f a ‚Üí ‚àÉ b < a, x ‚â§ f b)
  (H‚ÇÇ : ‚àÄ {a x}, f a < x ‚Üí ‚àÉ b > a, f b ‚â§ x) :
  @order_topology _ (induced f ta) _ :=
begin
  letI := induced f ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (f a)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { exact mem_comap.2 ‚ü®{x | f b < x},
        mem_inf_of_left $ mem_infi_of_mem _ $ mem_infi_of_mem (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© },
    { exact mem_comap.2 ‚ü®{x | x < f b},
        mem_inf_of_right $ mem_infi_of_mem _ $ mem_infi_of_mem (hf.2 ab) $ mem_principal_self _,
        Œª x, hf.1‚ü© } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _; refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _); simp,
    { rcases H‚ÇÅ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inl rfl‚ü© (mem_principal.2 _)),
      exact Œª c hc, lt_of_le_of_lt xb (hf.2 hc) },
    { rcases H‚ÇÇ h with ‚ü®b, ab, xb‚ü©,
      refine mem_infi_of_mem _ (mem_infi_of_mem ‚ü®ab, b, or.inr rfl‚ü© (mem_principal.2 _)),
      exact Œª c hc, lt_of_lt_of_le (hf.2 hc) xb } },
end

theorem induced_order_topology {Œ± : Type u} {Œ≤ : Type v}
  [preorder Œ±] [ta : topological_space Œ≤] [preorder Œ≤] [order_topology Œ≤]
  (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, f x < f y ‚Üî x < y)
  (H : ‚àÄ {x y}, x < y ‚Üí ‚àÉ a, x < f a ‚àß f a < y) :
  @order_topology _ (induced f ta) _ :=
induced_order_topology' f @hf
  (Œª a x xa, let ‚ü®b, xb, ba‚ü© := H xa in ‚ü®b, hf.1 ba, le_of_lt xb‚ü©)
  (Œª a x ax, let ‚ü®b, ab, bx‚ü© := H ax in ‚ü®b, hf.1 ab, le_of_lt bx‚ü©)

/-- On an `ord_connected` subset of a linear order, the order topology for the restriction of the
order is the same as the restriction to the subset of the order topology. -/
instance order_topology_of_ord_connected {Œ± : Type u}
  [ta : topological_space Œ±] [linear_order Œ±] [order_topology Œ±]
  {t : set Œ±} [ht : ord_connected t] :
  order_topology t :=
begin
  letI := induced (coe : t ‚Üí Œ±) ta,
  refine ‚ü®eq_of_nhds_eq_nhds (Œª a, _)‚ü©,
  rw [nhds_induced, nhds_generate_from, nhds_eq_order (a : Œ±)],
  apply le_antisymm,
  { refine le_infi (Œª s, le_infi $ Œª hs, le_principal_iff.2 _),
    rcases hs with ‚ü®ab, b, rfl|rfl‚ü©,
    { refine ‚ü®Ioi b, _, Œª _, id‚ü©,
      refine mem_inf_of_left (mem_infi_of_mem b _),
      exact mem_infi_of_mem ab (mem_principal_self (Ioi ‚Üëb)) },
    { refine ‚ü®Iio b, _, Œª _, id‚ü©,
      refine mem_inf_of_right (mem_infi_of_mem b _),
      exact mem_infi_of_mem ab (mem_principal_self (Iio b)) } },
  { rw [‚Üê map_le_iff_le_comap],
    refine le_inf _ _,
    { refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _),
      by_cases hx : x ‚àà t,
      { refine mem_infi_of_mem (Ioi ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inl rfl‚ü©‚ü© _),
        exact Œª _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map'],
      convert univ_sets _,
      suffices hx' : ‚àÄ (y : t), ‚Üëy ‚àà Ioi x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Œª hx, ht.out y.2 a.2 ‚ü®le_of_not_gt hx, le_of_lt h‚ü© },
    { refine le_infi (Œª x, le_infi $ Œª h, le_principal_iff.2 _),
      by_cases hx : x ‚àà t,
      { refine mem_infi_of_mem (Iio ‚ü®x, hx‚ü©) (mem_infi_of_mem ‚ü®h, ‚ü®‚ü®x, hx‚ü©, or.inr rfl‚ü©‚ü© _),
        exact Œª _, id },
      simp only [set_coe.exists, mem_set_of_eq, mem_map'],
      convert univ_sets _,
      suffices hx' : ‚àÄ (y : t), ‚Üëy ‚àà Iio x,
      { simp [hx'] },
      intros y,
      revert hx,
      contrapose!,
      -- here we use the `ord_connected` hypothesis
      exact Œª hx, ht.out a.2 y.2 ‚ü®le_of_lt h, le_of_not_gt hx‚ü© } }
end

lemma nhds_within_Ici_eq'' [topological_space Œ±] [preorder Œ±] [order_topology Œ±] (a : Œ±) :
  ùìù[‚â•] a = (‚®Ö u (hu : a < u), ùìü (Iio u)) ‚äì ùìü (Ici a) :=
begin
  rw [nhds_within, nhds_eq_order],
  refine le_antisymm (inf_le_inf_right _ inf_le_right) (le_inf (le_inf _ inf_le_left) inf_le_right),
  exact inf_le_right.trans (le_infi‚ÇÇ $ Œª l hl, principal_mono.2 $ Ici_subset_Ioi.2 hl)
end

lemma nhds_within_Iic_eq'' [topological_space Œ±] [preorder Œ±] [order_topology Œ±] (a : Œ±) :
  ùìù[‚â§] a = (‚®Ö l < a, ùìü (Ioi l)) ‚äì ùìü (Iic a) :=
nhds_within_Ici_eq'' (to_dual a)

lemma nhds_within_Ici_eq' [topological_space Œ±] [preorder Œ±] [order_topology Œ±] {a : Œ±}
  (ha : ‚àÉ u, a < u) :
  ùìù[‚â•] a = ‚®Ö u (hu : a < u), ùìü (Ico a u) :=
by simp only [nhds_within_Ici_eq'', binfi_inf ha, inf_principal, Iio_inter_Ici]

lemma nhds_within_Iic_eq' [topological_space Œ±] [preorder Œ±] [order_topology Œ±] {a : Œ±}
  (ha : ‚àÉ l, l < a) :
  ùìù[‚â§] a = ‚®Ö l < a, ùìü (Ioc l a) :=
by simp only [nhds_within_Iic_eq'', binfi_inf ha, inf_principal, Ioi_inter_Iic]

lemma nhds_within_Ici_basis' [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a : Œ±}
  (ha : ‚àÉ u, a < u) : (ùìù[‚â•] a).has_basis (Œª u, a < u) (Œª u, Ico a u) :=
(nhds_within_Ici_eq' ha).symm ‚ñ∏ has_basis_binfi_principal (Œª b hb c hc,
  ‚ü®min b c, lt_min hb hc, Ico_subset_Ico_right (min_le_left _ _),
    Ico_subset_Ico_right (min_le_right _ _)‚ü©) ha

lemma nhds_within_Iic_basis' [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] {a : Œ±}
  (ha : ‚àÉ l, l < a) : (ùìù[‚â§] a).has_basis (Œª l, l < a) (Œª l, Ioc l a) :=
by { convert @nhds_within_Ici_basis' Œ±·µí·µà _ _ _ (to_dual a) ha,
     exact funext (Œª x, (@dual_Ico _ _ _ _).symm) }

lemma nhds_within_Ici_basis [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]
  [no_max_order Œ±] (a : Œ±) : (ùìù[‚â•] a).has_basis (Œª u, a < u) (Œª u, Ico a u) :=
nhds_within_Ici_basis' (exists_gt a)

lemma nhds_within_Iic_basis [topological_space Œ±] [linear_order Œ±] [order_topology Œ±]
  [no_min_order Œ±] (a : Œ±) : (ùìù[‚â§] a).has_basis (Œª l, l < a) (Œª l, Ioc l a) :=
nhds_within_Iic_basis' (exists_lt a)

lemma nhds_top_order [topological_space Œ±] [preorder Œ±] [order_top Œ±] [order_topology Œ±] :
  ùìù (‚ä§:Œ±) = (‚®Öl (h‚ÇÇ : l < ‚ä§), ùìü (Ioi l)) :=
by simp [nhds_eq_order (‚ä§:Œ±)]

lemma nhds_bot_order [topological_space Œ±] [preorder Œ±] [order_bot Œ±] [order_topology Œ±] :
  ùìù (‚ä•:Œ±) = (‚®Öl (h‚ÇÇ : ‚ä• < l), ùìü (Iio l)) :=
by simp [nhds_eq_order (‚ä•:Œ±)]

lemma nhds_top_basis [topological_space Œ±] [linear_order Œ±] [order_top Œ±] [order_topology Œ±]
  [nontrivial Œ±] :
  (ùìù ‚ä§).has_basis (Œª a : Œ±, a < ‚ä§) (Œª a : Œ±, Ioi a) :=
have ‚àÉ x : Œ±, x < ‚ä§, from (exists_ne ‚ä§).imp $ Œª x hx, hx.lt_top,
by simpa only [Iic_top, nhds_within_univ, Ioc_top] using nhds_within_Iic_basis' this

lemma nhds_bot_basis [topological_space Œ±] [linear_order Œ±] [order_bot Œ±] [order_topology Œ±]
  [nontrivial Œ±] :
  (ùìù ‚ä•).has_basis (Œª a : Œ±, ‚ä• < a) (Œª a : Œ±, Iio a) :=
@nhds_top_basis Œ±·µí·µà _ _ _ _ _

lemma nhds_top_basis_Ici [topological_space Œ±] [linear_order Œ±] [order_top Œ±] [order_topology Œ±]
  [nontrivial Œ±] [densely_ordered Œ±] :
  (ùìù ‚ä§).has_basis (Œª a : Œ±, a < ‚ä§) Ici :=
nhds_top_basis.to_has_basis
  (Œª a ha, let ‚ü®b, hab, hb‚ü© := exists_between ha in ‚ü®b, hb, Ici_subset_Ioi.mpr hab‚ü©)
  (Œª a ha, ‚ü®a, ha, Ioi_subset_Ici_self‚ü©)

lemma nhds_bot_basis_Iic [topological_space Œ±] [linear_order Œ±] [order_bot Œ±] [order_topology Œ±]
  [nontrivial Œ±] [densely_ordered Œ±] :
  (ùìù ‚ä•).has_basis (Œª a : Œ±, ‚ä• < a) Iic :=
@nhds_top_basis_Ici Œ±·µí·µà _ _ _ _ _ _

lemma tendsto_nhds_top_mono [topological_space Œ≤] [preorder Œ≤] [order_top Œ≤] [order_topology Œ≤]
  {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä§)) (hg : f ‚â§·∂†[l] g) :
  tendsto g l (ùìù ‚ä§) :=
begin
  simp only [nhds_top_order, tendsto_infi, tendsto_principal] at hf ‚ä¢,
  intros x hx,
  filter_upwards [hf x hx, hg] with _ using lt_of_lt_of_le,
end

lemma tendsto_nhds_bot_mono [topological_space Œ≤] [preorder Œ≤] [order_bot Œ≤] [order_topology Œ≤]
  {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä•)) (hg : g ‚â§·∂†[l] f) :
  tendsto g l (ùìù ‚ä•) :=
@tendsto_nhds_top_mono Œ± Œ≤·µí·µà _ _ _ _ _ _ _ hf hg

lemma tendsto_nhds_top_mono' [topological_space Œ≤] [preorder Œ≤] [order_top Œ≤]
  [order_topology Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä§)) (hg : f ‚â§ g) :
  tendsto g l (ùìù ‚ä§) :=
tendsto_nhds_top_mono hf (eventually_of_forall hg)

lemma tendsto_nhds_bot_mono' [topological_space Œ≤] [preorder Œ≤] [order_bot Œ≤]
  [order_topology Œ≤] {l : filter Œ±} {f g : Œ± ‚Üí Œ≤} (hf : tendsto f l (ùìù ‚ä•)) (hg : g ‚â§ f) :
  tendsto g l (ùìù ‚ä•) :=
tendsto_nhds_bot_mono hf (eventually_of_forall hg)

section linear_order
variables [topological_space Œ±] [linear_order Œ±]

section order_closed_topology
variables [order_closed_topology Œ±] {a b : Œ±}

lemma eventually_le_nhds (hab : a < b) : ‚àÄ·∂† x in ùìù a, x ‚â§ b :=
eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Iio b, Iio_subset_Iic_self, is_open_Iio, hab‚ü©)

lemma eventually_lt_nhds (hab : a < b) : ‚àÄ·∂† x in ùìù a, x < b :=
eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Iio b, rfl.subset, is_open_Iio, hab‚ü©)

lemma eventually_ge_nhds (hab : b < a) : ‚àÄ·∂† x in ùìù a, b ‚â§ x :=
eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Ioi b, Ioi_subset_Ici_self, is_open_Ioi, hab‚ü©)

lemma eventually_gt_nhds (hab : b < a) : ‚àÄ·∂† x in ùìù a, b < x :=
eventually_iff.mpr (mem_nhds_iff.mpr ‚ü®Ioi b, rfl.subset, is_open_Ioi, hab‚ü©)

end order_closed_topology

section order_topology
variables [order_topology Œ±]

lemma order_separated {a‚ÇÅ a‚ÇÇ : Œ±} (h : a‚ÇÅ < a‚ÇÇ) :
  ‚àÉu v : set Œ±, is_open u ‚àß is_open v ‚àß a‚ÇÅ ‚àà u ‚àß a‚ÇÇ ‚àà v ‚àß (‚àÄb‚ÇÅ‚ààu, ‚àÄb‚ÇÇ‚ààv, b‚ÇÅ < b‚ÇÇ) :=
match dense_or_discrete a‚ÇÅ a‚ÇÇ with
| or.inl ‚ü®a, ha‚ÇÅ, ha‚ÇÇ‚ü© := ‚ü®{a' | a' < a}, {a' | a < a'}, is_open_gt' a, is_open_lt' a, ha‚ÇÅ, ha‚ÇÇ,
    assume b‚ÇÅ h‚ÇÅ b‚ÇÇ h‚ÇÇ, lt_trans h‚ÇÅ h‚ÇÇ‚ü©
| or.inr ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© := ‚ü®{a | a < a‚ÇÇ}, {a | a‚ÇÅ < a}, is_open_gt' a‚ÇÇ, is_open_lt' a‚ÇÅ, h, h,
    assume b‚ÇÅ hb‚ÇÅ b‚ÇÇ hb‚ÇÇ,
    calc b‚ÇÅ ‚â§ a‚ÇÅ : h‚ÇÇ _ hb‚ÇÅ
      ... < a‚ÇÇ : h
      ... ‚â§ b‚ÇÇ : h‚ÇÅ _ hb‚ÇÇ‚ü©
end

@[priority 100] -- see Note [lower instance priority]
instance order_topology.to_order_closed_topology : order_closed_topology Œ± :=
{ is_closed_le' :=
    is_open_compl_iff.1 $ is_open_prod_iff.mpr $ assume a‚ÇÅ a‚ÇÇ (h : ¬¨ a‚ÇÅ ‚â§ a‚ÇÇ),
      have h : a‚ÇÇ < a‚ÇÅ, from lt_of_not_ge h,
      let ‚ü®u, v, hu, hv, ha‚ÇÅ, ha‚ÇÇ, h‚ü© := order_separated h in
      ‚ü®v, u, hv, hu, ha‚ÇÇ, ha‚ÇÅ, assume ‚ü®b‚ÇÅ, b‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©, not_le_of_gt $ h b‚ÇÇ h‚ÇÇ b‚ÇÅ h‚ÇÅ‚ü© }

lemma exists_Ioc_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ l, l < a) :
  ‚àÉ l < a, Ioc l a ‚äÜ s :=
(nhds_within_Iic_basis' h).mem_iff.mp (nhds_within_le_nhds hs)

lemma exists_Ioc_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {l : Œ±} (hl : l < a) :
  ‚àÉ l' ‚àà Ico l a, Ioc l' a ‚äÜ s :=
let ‚ü®l', hl'a, hl's‚ü© := exists_Ioc_subset_of_mem_nhds hs ‚ü®l, hl‚ü©
in ‚ü®max l l', ‚ü®le_max_left _ _, max_lt hl hl'a‚ü©,
  (Ioc_subset_Ioc_left $ le_max_right _ _).trans hl's‚ü©

lemma exists_Ico_subset_of_mem_nhds' {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) {u : Œ±} (hu : a < u) :
  ‚àÉ u' ‚àà Ioc a u, Ico a u' ‚äÜ s :=
by simpa only [order_dual.exists, exists_prop, dual_Ico, dual_Ioc]
  using exists_Ioc_subset_of_mem_nhds' (show of_dual ‚Åª¬π' s ‚àà ùìù (to_dual a), from hs) hu.dual

lemma exists_Ico_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) (h : ‚àÉ u, a < u) :
  ‚àÉ u (_ : a < u), Ico a u ‚äÜ s :=
let ‚ü®l', hl'‚ü© := h, ‚ü®l, hl‚ü© := exists_Ico_subset_of_mem_nhds' hs hl' in ‚ü®l, hl.fst.1, hl.snd‚ü©

lemma exists_Icc_mem_subset_of_mem_nhds_within_Ici {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù[‚â•] a) :
  ‚àÉ b (_ : a ‚â§ b), Icc a b ‚àà ùìù[‚â•] a ‚àß Icc a b ‚äÜ s :=
begin
  rcases (em (is_max a)).imp_right not_is_max_iff.mp with ha|ha,
  { use a, simpa [ha.Ici_eq] using hs },
  { rcases (nhds_within_Ici_basis' ha).mem_iff.mp hs with ‚ü®b, hab, hbs‚ü©,
    rcases eq_empty_or_nonempty (Ioo a b) with H|‚ü®c, hac, hcb‚ü©,
    { have : Ico a b = Icc a a,
      { rw [‚Üê Icc_union_Ioo_eq_Ico le_rfl hab, H, union_empty] },
      exact ‚ü®a, le_rfl, this ‚ñ∏ ‚ü®Ico_mem_nhds_within_Ici $ left_mem_Ico.2 hab, hbs‚ü©‚ü© },
    { refine ‚ü®c, hac.le, Icc_mem_nhds_within_Ici $ left_mem_Ico.mpr hac, _‚ü©,
      exact (Icc_subset_Ico_right hcb).trans hbs } }
end

lemma exists_Icc_mem_subset_of_mem_nhds_within_Iic {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù[‚â§] a) :
  ‚àÉ b ‚â§ a, Icc b a ‚àà ùìù[‚â§] a ‚àß Icc b a ‚äÜ s :=
by simpa only [dual_Icc, to_dual.surjective.exists]
  using @exists_Icc_mem_subset_of_mem_nhds_within_Ici Œ±·µí·µà _ _ _ (to_dual a) _ hs

lemma exists_Icc_mem_subset_of_mem_nhds {a : Œ±} {s : set Œ±} (hs : s ‚àà ùìù a) :
  ‚àÉ b c, a ‚àà Icc b c ‚àß Icc b c ‚àà ùìù a ‚àß Icc b c ‚äÜ s :=
begin
  rcases exists_Icc_mem_subset_of_mem_nhds_within_Iic (nhds_within_le_nhds hs)
    with ‚ü®b, hba, hb_nhds, hbs‚ü©,
  rcases exists_Icc_mem_subset_of_mem_nhds_within_Ici (nhds_within_le_nhds hs)
    with ‚ü®c, hac, hc_nhds, hcs‚ü©,
  refine ‚ü®b, c, ‚ü®hba, hac‚ü©, _‚ü©,
  rw [‚Üê Icc_union_Icc_eq_Icc hba hac, ‚Üê nhds_left_sup_nhds_right],
  exact ‚ü®union_mem_sup hb_nhds hc_nhds, union_subset hbs hcs‚ü©
end

lemma is_open.exists_Ioo_subset [nontrivial Œ±] {s : set Œ±} (hs : is_open s) (h : s.nonempty) :
  ‚àÉ a b, a < b ‚àß Ioo a b ‚äÜ s :=
begin
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, x ‚àà s := h,
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y ‚â† x := exists_ne x,
  rcases lt_trichotomy x y with H|rfl|H,
  { obtain ‚ü®u, xu, hu‚ü© : ‚àÉ (u : Œ±) (hu : x < u), Ico x u ‚äÜ s :=
      exists_Ico_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©,
    exact ‚ü®x, u, xu, Ioo_subset_Ico_self.trans hu‚ü© },
  { exact (hy rfl).elim },
  { obtain ‚ü®l, lx, hl‚ü© : ‚àÉ (l : Œ±) (hl : l < x), Ioc l x ‚äÜ s :=
      exists_Ioc_subset_of_mem_nhds (hs.mem_nhds hx) ‚ü®y, H‚ü©,
    exact ‚ü®l, x, lx, Ioo_subset_Ioc_self.trans hl‚ü© }
end

lemma dense_of_exists_between [nontrivial Œ±] {s : set Œ±}
  (h : ‚àÄ ‚¶Éa b‚¶Ñ, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b) : dense s :=
begin
  apply dense_iff_inter_open.2 (Œª U U_open U_nonempty, _),
  obtain ‚ü®a, b, hab, H‚ü© : ‚àÉ (a b : Œ±), a < b ‚àß Ioo a b ‚äÜ U := U_open.exists_Ioo_subset U_nonempty,
  obtain ‚ü®x, xs, hx‚ü© : ‚àÉ (x : Œ±) (H : x ‚àà s), a < x ‚àß x < b := h hab,
  exact ‚ü®x, ‚ü®H hx, xs‚ü©‚ü©
end

/-- A set in a nontrivial densely linear ordered type is dense in the sense of topology if and only
if for any `a < b` there exists `c ‚àà s`, `a < c < b`. Each implication requires less typeclass
assumptions. -/
lemma dense_iff_exists_between [densely_ordered Œ±] [nontrivial Œ±] {s : set Œ±} :
  dense s ‚Üî ‚àÄ a b, a < b ‚Üí ‚àÉ c ‚àà s, a < c ‚àß c < b :=
‚ü®Œª h a b hab, h.exists_between hab, dense_of_exists_between‚ü©

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`,
provided `a` is neither a bottom element nor a top element. -/
lemma mem_nhds_iff_exists_Ioo_subset' {a : Œ±} {s : set Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
begin
  split,
  { assume h,
    rcases exists_Ico_subset_of_mem_nhds h hu with ‚ü®u, au, hu‚ü©,
    rcases exists_Ioc_subset_of_mem_nhds h hl with ‚ü®l, la, hl‚ü©,
    exact ‚ü®l, u, ‚ü®la, au‚ü©, Ioc_union_Ico_eq_Ioo la au ‚ñ∏ union_subset hl hu‚ü© },
  { rintros ‚ü®l, u, ha, h‚ü©,
    apply mem_of_superset (Ioo_mem_nhds ha.1 ha.2) h }
end

/-- A set is a neighborhood of `a` if and only if it contains an interval `(l, u)` containing `a`.
-/
lemma mem_nhds_iff_exists_Ioo_subset [no_max_order Œ±] [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù a ‚Üî ‚àÉl u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ s :=
mem_nhds_iff_exists_Ioo_subset' (exists_lt a) (exists_gt a)

lemma nhds_basis_Ioo' {a : Œ±} (hl : ‚àÉ l, l < a) (hu : ‚àÉ u, a < u) :
  (ùìù a).has_basis (Œª b : Œ± √ó Œ±, b.1 < a ‚àß a < b.2) (Œª b, Ioo b.1 b.2) :=
‚ü®Œª s, (mem_nhds_iff_exists_Ioo_subset' hl hu).trans $ by simp‚ü©

lemma nhds_basis_Ioo [no_max_order Œ±] [no_min_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª b : Œ± √ó Œ±, b.1 < a ‚àß a < b.2) (Œª b, Ioo b.1 b.2) :=
nhds_basis_Ioo' (exists_lt a) (exists_gt a)

lemma filter.eventually.exists_Ioo_subset [no_max_order Œ±] [no_min_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop}
  (hp : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ l u, a ‚àà Ioo l u ‚àß Ioo l u ‚äÜ {x | p x} :=
mem_nhds_iff_exists_Ioo_subset.1 hp

/-- The set of points which are isolated on the right is countable when the space is
second-countable. -/
lemma countable_of_isolated_right [second_countable_topology Œ±] :
  set.countable {x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ} :=
begin
  nontriviality Œ±,
  let s := {x : Œ± | ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ},
  have : ‚àÄ x ‚àà s, ‚àÉ y, x < y ‚àß Ioo x y = ‚àÖ := Œª x, id,
  choose! y hy h'y using this,
  have Hy : ‚àÄ x z, x ‚àà s ‚Üí z < y x ‚Üí z ‚â§ x,
  { assume x z xs hz,
    have A : Ioo x (y x) = ‚àÖ := h'y _ xs,
    contrapose! A,
    exact nonempty.ne_empty ‚ü®z, A, hz‚ü© },
  suffices H : ‚àÄ (a : set Œ±), is_open a ‚Üí set.countable {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a},
  { have : s ‚äÜ ‚ãÉ (a ‚àà countable_basis Œ±), {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a},
    { assume x hx,
      rcases (is_basis_countable_basis Œ±).exists_mem_of_ne (hy x hx).ne with ‚ü®a, ab, xa, ya‚ü©,
      simp only [mem_set_of_eq, mem_Union],
      exact ‚ü®a, ab, hx, xa, ya‚ü© },
    apply countable.mono this,
    refine countable.bUnion (countable_countable_basis Œ±) (Œª a ha, H _ _),
    exact is_open_of_mem_countable_basis ha },
  assume a ha,
  suffices H : set.countable {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)},
  { have : {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a} ‚äÜ
      {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)} ‚à™ {x | is_bot x},
    { assume x hx,
      by_cases h'x : is_bot x,
      { simp only [h'x, mem_set_of_eq, mem_union, not_true, and_false, false_or] },
      { simpa only [h'x, hx.2.1, hx.2.2, mem_set_of_eq, mem_union,
          not_false_iff, and_true, or_false] using hx.left } },
    exact countable.mono this (H.union (subsingleton_is_bot Œ±).countable) },
  let t := {x | x ‚àà s ‚àß x ‚àà a ‚àß y x ‚àâ a ‚àß ¬¨(is_bot x)},
  have : ‚àÄ x ‚àà t, ‚àÉ z < x, Ioc z x ‚äÜ a,
  { assume x hx,
    apply exists_Ioc_subset_of_mem_nhds (ha.mem_nhds hx.2.1),
    simpa only [is_bot, not_forall, not_le] using hx.right.right.right },
  choose! z hz h'z using this,
  have : pairwise_disjoint t (Œª x, Ioc (z x) x),
  { assume x xt x' x't hxx',
    rcases lt_or_gt_of_ne hxx' with h'|h',
    { refine disjoint_left.2 (Œª u ux ux', xt.2.2.1 _),
      refine h'z x' x't ‚ü®ux'.1.trans_le (ux.2.trans (hy x xt.1).le), _‚ü©,
      by_contra' H,
      exact false.elim (lt_irrefl _ ((Hy _ _ xt.1 H).trans_lt h')) },
    { refine disjoint_left.2 (Œª u ux ux', x't.2.2.1 _),
      refine h'z x xt ‚ü®ux.1.trans_le (ux'.2.trans (hy x' x't.1).le), _‚ü©,
      by_contra' H,
      exact false.elim (lt_irrefl _ ((Hy _ _ x't.1 H).trans_lt h')) } },
  refine this.countable_of_is_open (Œª x hx, _) (Œª x hx, ‚ü®x, hz x hx, le_rfl‚ü©),
  suffices H : Ioc (z x) x = Ioo (z x) (y x),
  { rw H, exact is_open_Ioo },
  exact subset.antisymm (Ioc_subset_Ioo_right (hy x hx.1)) (Œª u hu, ‚ü®hu.1, Hy _ _ hx.1 hu.2‚ü©),
end

/-- The set of points which are isolated on the left is countable when the space is
second-countable. -/
lemma countable_of_isolated_left [second_countable_topology Œ±] :
  set.countable {x : Œ± | ‚àÉ y, y < x ‚àß Ioo y x = ‚àÖ} :=
begin
  convert @countable_of_isolated_right Œ±·µí·µà _ _ _ _,
  have : ‚àÄ (x y : Œ±), Ioo x y = {z | z < y ‚àß x < z},
  { simp_rw [and_comm, Ioo], simp only [eq_self_iff_true, forall_2_true_iff] },
  simp_rw [this],
  refl
end

/-- Consider a disjoint family of intervals `(x, y)` with `x < y` in a second-countable space.
Then the family is countable.
This is not a straightforward consequence of second-countability as some of these intervals might be
empty (but in fact this can happen only for countably many of them). -/
lemma set.pairwise_disjoint.countable_of_Ioo [second_countable_topology Œ±]
  {y : Œ± ‚Üí Œ±} {s : set Œ±} (h : pairwise_disjoint s (Œª x, Ioo x (y x))) (h' : ‚àÄ x ‚àà s, x < y x) :
  s.countable :=
begin
  let t := {x | x ‚àà s ‚àß (Ioo x (y x)).nonempty},
  have t_count : t.countable,
  { have : t ‚äÜ s := Œª x hx, hx.1,
    exact (h.subset this).countable_of_is_open (Œª x hx, is_open_Ioo) (Œª x hx, hx.2) },
  have : s ‚äÜ t ‚à™ {x : Œ± | ‚àÉ x', x < x' ‚àß Ioo x x' = ‚àÖ},
  { assume x hx,
    by_cases h'x : (Ioo x (y x)).nonempty,
    { exact or.inl ‚ü®hx, h'x‚ü© },
    { exact or.inr ‚ü®y x, h' x hx, not_nonempty_iff_eq_empty.1 h'x‚ü© } },
  exact countable.mono this (t_count.union countable_of_isolated_right),
end

section pi

/-!
### Intervals in `Œ† i, œÄ i` belong to `ùìù x`

For each lemma `pi_Ixx_mem_nhds` we add a non-dependent version `pi_Ixx_mem_nhds'` because
sometimes Lean fails to unify different instances while trying to apply the dependent version to,
e.g., `Œπ ‚Üí ‚Ñù`.
-/

variables {Œπ : Type*} {œÄ : Œπ ‚Üí Type*} [finite Œπ] [Œ† i, linear_order (œÄ i)]
  [Œ† i, topological_space (œÄ i)] [‚àÄ i, order_topology (œÄ i)] {a b x : Œ† i, œÄ i} {a' b' x' : Œπ ‚Üí Œ±}

lemma pi_Iic_mem_nhds (ha : ‚àÄ i, x i < a i) : Iic a ‚àà ùìù x :=
pi_univ_Iic a ‚ñ∏ set_pi_mem_nhds (set.to_finite _) (Œª i _, Iic_mem_nhds (ha _))

lemma pi_Iic_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iic a' ‚àà ùìù x' :=
pi_Iic_mem_nhds ha

lemma pi_Ici_mem_nhds (ha : ‚àÄ i, a i < x i) : Ici a ‚àà ùìù x :=
pi_univ_Ici a ‚ñ∏ set_pi_mem_nhds (set.to_finite _) (Œª i _, Ici_mem_nhds (ha _))

lemma pi_Ici_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ici a' ‚àà ùìù x' :=
pi_Ici_mem_nhds ha

lemma pi_Icc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Icc a b ‚àà ùìù x :=
pi_univ_Icc a b ‚ñ∏ set_pi_mem_nhds finite_univ (Œª i _, Icc_mem_nhds (ha _) (hb _))

lemma pi_Icc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Icc a' b' ‚àà ùìù x' :=
pi_Icc_mem_nhds ha hb

variables [nonempty Œπ]

lemma pi_Iio_mem_nhds (ha : ‚àÄ i, x i < a i) : Iio a ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (set.to_finite _) (Œª i _, _))
    (pi_univ_Iio_subset a),
  exact Iio_mem_nhds (ha i)
end

lemma pi_Iio_mem_nhds' (ha : ‚àÄ i, x' i < a' i) : Iio a' ‚àà ùìù x' :=
pi_Iio_mem_nhds ha

lemma pi_Ioi_mem_nhds (ha : ‚àÄ i, a i < x i) : Ioi a ‚àà ùìù x :=
@pi_Iio_mem_nhds Œπ (Œª i, (œÄ i)·µí·µà) _ _ _ _ _ _ _ ha

lemma pi_Ioi_mem_nhds' (ha : ‚àÄ i, a' i < x' i) : Ioi a' ‚àà ùìù x' :=
pi_Ioi_mem_nhds ha

lemma pi_Ioc_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioc a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (set.to_finite _) (Œª i _, _))
    (pi_univ_Ioc_subset a b),
  exact Ioc_mem_nhds (ha i) (hb i)
end

lemma pi_Ioc_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioc a' b' ‚àà ùìù x' :=
pi_Ioc_mem_nhds ha hb

lemma pi_Ico_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ico a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (set.to_finite _) (Œª i _, _))
    (pi_univ_Ico_subset a b),
  exact Ico_mem_nhds (ha i) (hb i)
end

lemma pi_Ico_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ico a' b' ‚àà ùìù x' :=
pi_Ico_mem_nhds ha hb

lemma pi_Ioo_mem_nhds (ha : ‚àÄ i, a i < x i) (hb : ‚àÄ i, x i < b i) : Ioo a b ‚àà ùìù x :=
begin
  refine mem_of_superset (set_pi_mem_nhds (set.to_finite _) (Œª i _, _))
    (pi_univ_Ioo_subset a b),
  exact Ioo_mem_nhds (ha i) (hb i)
end

lemma pi_Ioo_mem_nhds' (ha : ‚àÄ i, a' i < x' i) (hb : ‚àÄ i, x' i < b' i) : Ioo a' b' ‚àà ùìù x' :=
pi_Ioo_mem_nhds ha hb

end pi

lemma disjoint_nhds_at_top [no_max_order Œ±] (x : Œ±) :
  disjoint (ùìù x) at_top :=
begin
  rcases exists_gt x with ‚ü®y, hy : x < y‚ü©,
  refine disjoint_of_disjoint_of_mem _ (Iio_mem_nhds hy) (mem_at_top y),
  exact disjoint_left.mpr (Œª z, not_le.2)
end

@[simp] lemma inf_nhds_at_top [no_max_order Œ±] (x : Œ±) :
  ùìù x ‚äì at_top = ‚ä• :=
disjoint_iff.1 (disjoint_nhds_at_top x)

lemma disjoint_nhds_at_bot [no_min_order Œ±] (x : Œ±) : disjoint (ùìù x) at_bot :=
@disjoint_nhds_at_top Œ±·µí·µà _ _ _ _ x

@[simp] lemma inf_nhds_at_bot [no_min_order Œ±] (x : Œ±) : ùìù x ‚äì at_bot = ‚ä• :=
@inf_nhds_at_top Œ±·µí·µà _ _ _ _ x

lemma not_tendsto_nhds_of_tendsto_at_top [no_max_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_top) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_top x).symm

lemma not_tendsto_at_top_of_tendsto_nhds [no_max_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨  tendsto f F at_top :=
hf.not_tendsto (disjoint_nhds_at_top x)

lemma not_tendsto_nhds_of_tendsto_at_bot [no_min_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} (hf : tendsto f F at_bot) (x : Œ±) :
  ¬¨ tendsto f F (ùìù x) :=
hf.not_tendsto (disjoint_nhds_at_bot x).symm

lemma not_tendsto_at_bot_of_tendsto_nhds [no_min_order Œ±]
  {F : filter Œ≤} [ne_bot F] {f : Œ≤ ‚Üí Œ±} {x : Œ±} (hf : tendsto f F (ùìù x)) :
  ¬¨ tendsto f F at_bot :=
hf.not_tendsto (disjoint_nhds_at_bot x)

/-!
### Neighborhoods to the left and to the right on an `order_topology`

We've seen some properties of left and right neighborhood of a point in an `order_closed_topology`.
In an `order_topology`, such neighborhoods can be characterized as the sets containing suitable
intervals to the right or to the left of `a`. We give now these characterizations. -/

-- NB: If you extend the list, append to the end please to avoid breaking the API
/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `(a, +‚àû)`
1. `s` is a neighborhood of `a` within `(a, b]`
2. `s` is a neighborhood of `a` within `(a, b)`
3. `s` includes `(a, u)` for some `u ‚àà (a, b]`
4. `s` includes `(a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ioi {a b : Œ±} (hab : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[>] a, -- 0 : `s` is a neighborhood of `a` within `(a, +‚àû)`
    s ‚àà ùìù[Ioc a b] a,   -- 1 : `s` is a neighborhood of `a` within `(a, b]`
    s ‚àà ùìù[Ioo a b] a,   -- 2 : `s` is a neighborhood of `a` within `(a, b)`
    ‚àÉ u ‚àà Ioc a b, Ioo a u ‚äÜ s,    -- 3 : `s` includes `(a, u)` for some `u ‚àà (a, b]`
    ‚àÉ u ‚àà Ioi a, Ioo a u ‚äÜ s] :=   -- 4 : `s` includes `(a, u)` for some `u > a`
begin
  tfae_have : 1 ‚Üî 2, by rw [nhds_within_Ioc_eq_nhds_within_Ioi hab],
  tfae_have : 1 ‚Üî 3, by rw [nhds_within_Ioo_eq_nhds_within_Ioi hab],
  tfae_have : 4 ‚Üí 5, from Œª ‚ü®u, umem, hu‚ü©, ‚ü®u, umem.1, hu‚ü©,
  tfae_have : 5 ‚Üí 1,
  { rintros ‚ü®u, hau, hu‚ü©,
    exact mem_of_superset (Ioo_mem_nhds_within_Ioi ‚ü®le_refl a, hau‚ü©) hu },
  tfae_have : 1 ‚Üí 4,
  { assume h,
    rcases mem_nhds_within_iff_exists_mem_nhds_inter.1 h with ‚ü®v, va, hv‚ü©,
    rcases exists_Ico_subset_of_mem_nhds' va hab with ‚ü®u, au, hu‚ü©,
    refine ‚ü®u, au, Œªx hx, _‚ü©,
    refine hv ‚ü®hu ‚ü®le_of_lt hx.1, hx.2‚ü©, _‚ü©,
    exact hx.1 },
  tfae_finish
end

lemma mem_nhds_within_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioc a u', Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 3

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
(tfae_mem_nhds_within_Ioi hu' s).out 0 4

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioo_subset [no_max_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioo a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := exists_gt a in mem_nhds_within_Ioi_iff_exists_Ioo_subset' hu'

/-- A set is a neighborhood of `a` within `(a, +‚àû)` if and only if it contains an interval `(a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ioi_iff_exists_Ioc_subset [no_max_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[>] a ‚Üî ‚àÉu ‚àà Ioi a, Ioc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ioi_iff_exists_Ioo_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases exists_between au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ioo_subset_Ioc_self as‚ü© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b)`
1. `s` is a neighborhood of `b` within `[a, b)`
2. `s` is a neighborhood of `b` within `(a, b)`
3. `s` includes `(l, b)` for some `l ‚àà [a, b)`
4. `s` includes `(l, b)` for some `l < b` -/
lemma tfae_mem_nhds_within_Iio {a b : Œ±} (h : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[<] b, -- 0 : `s` is a neighborhood of `b` within `(-‚àû, b)`
    s ‚àà ùìù[Ico a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b)`
    s ‚àà ùìù[Ioo a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b)`
    ‚àÉ l ‚àà Ico a b, Ioo l b ‚äÜ s,    -- 3 : `s` includes `(l, b)` for some `l ‚àà [a, b)`
    ‚àÉ l ‚àà Iio b, Ioo l b ‚äÜ s] :=   -- 4 : `s` includes `(l, b)` for some `l < b`
by simpa only [exists_prop, order_dual.exists, dual_Ioi, dual_Ioc, dual_Ioo]
    using tfae_mem_nhds_within_Ioi h.dual (of_dual ‚Åª¬π' s)

lemma mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Ico l' a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 3

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
(tfae_mem_nhds_within_Iio hl' s).out 0 4

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `(l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ioo_subset [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ioo l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := exists_lt a in mem_nhds_within_Iio_iff_exists_Ioo_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a)` if and only if it contains an interval `[l, a)`
with `l < a`. -/
lemma mem_nhds_within_Iio_iff_exists_Ico_subset [no_min_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[<] a ‚Üî ‚àÉl ‚àà Iio a, Ico l a ‚äÜ s :=
begin
  have : of_dual ‚Åª¬π' s ‚àà ùìù[>] (to_dual a) ‚Üî _ :=
    mem_nhds_within_Ioi_iff_exists_Ioc_subset,
  simpa only [order_dual.exists, exists_prop, dual_Ioc] using this,
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `a` within `[a, +‚àû)`
1. `s` is a neighborhood of `a` within `[a, b]`
2. `s` is a neighborhood of `a` within `[a, b)`
3. `s` includes `[a, u)` for some `u ‚àà (a, b]`
4. `s` includes `[a, u)` for some `u > a` -/
lemma tfae_mem_nhds_within_Ici {a b : Œ±} (hab : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[‚â•] a, -- 0 : `s` is a neighborhood of `a` within `[a, +‚àû)`
    s ‚àà ùìù[Icc a b] a,   -- 1 : `s` is a neighborhood of `a` within `[a, b]`
    s ‚àà ùìù[Ico a b] a,   -- 2 : `s` is a neighborhood of `a` within `[a, b)`
    ‚àÉ u ‚àà Ioc a b, Ico a u ‚äÜ s,    -- 3 : `s` includes `[a, u)` for some `u ‚àà (a, b]`
    ‚àÉ u ‚àà Ioi a, Ico a u ‚äÜ s] :=   -- 4 : `s` includes `[a, u)` for some `u > a`
begin
  tfae_have : 1 ‚Üî 2, by rw [nhds_within_Icc_eq_nhds_within_Ici hab],
  tfae_have : 1 ‚Üî 3, by rw [nhds_within_Ico_eq_nhds_within_Ici hab],
  tfae_have : 1 ‚Üî 5, from (nhds_within_Ici_basis' ‚ü®b, hab‚ü©).mem_iff,
  tfae_have : 4 ‚Üí 5, from Œª ‚ü®u, umem, hu‚ü©, ‚ü®u, umem.1, hu‚ü©,
  tfae_have : 5 ‚Üí 4,
  { rintro ‚ü®u, hua, hus‚ü©,
    exact ‚ü®min u b, ‚ü®lt_min hua hab, min_le_right _ _‚ü©,
      (Ico_subset_Ico_right $ min_le_left _ _).trans hus‚ü©, },
  tfae_finish
end

lemma mem_nhds_within_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioc a u', Ico a u ‚äÜ s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u < u'`, provided `a` is not a top element. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset' {a u' : Œ±} {s : set Œ±} (hu' : a < u') :
  s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
(tfae_mem_nhds_within_Ici hu' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u)`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Ico_subset [no_max_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[‚â•] a ‚Üî ‚àÉu ‚àà Ioi a, Ico a u ‚äÜ s :=
let ‚ü®u', hu'‚ü© := exists_gt a in mem_nhds_within_Ici_iff_exists_Ico_subset' hu'

lemma nhds_within_Ici_basis_Ico [no_max_order Œ±] (a : Œ±) :
  (ùìù[‚â•] a).has_basis (Œª u, a < u) (Ico a) :=
‚ü®Œª s, mem_nhds_within_Ici_iff_exists_Ico_subset‚ü©

/-- A set is a neighborhood of `a` within `[a, +‚àû)` if and only if it contains an interval `[a, u]`
with `a < u`. -/
lemma mem_nhds_within_Ici_iff_exists_Icc_subset [no_max_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â•] a ‚Üî ‚àÉ u, a < u ‚àß Icc a u ‚äÜ s :=
begin
  rw mem_nhds_within_Ici_iff_exists_Ico_subset,
  split,
  { rintros ‚ü®u, au, as‚ü©,
    rcases exists_between au with ‚ü®v, hv‚ü©,
    exact ‚ü®v, hv.1, Œªx hx, as ‚ü®hx.1, lt_of_le_of_lt hx.2 hv.2‚ü©‚ü© },
  { rintros ‚ü®u, au, as‚ü©,
    exact ‚ü®u, au, subset.trans Ico_subset_Icc_self as‚ü© }
end

/-- The following statements are equivalent:

0. `s` is a neighborhood of `b` within `(-‚àû, b]`
1. `s` is a neighborhood of `b` within `[a, b]`
2. `s` is a neighborhood of `b` within `(a, b]`
3. `s` includes `(l, b]` for some `l ‚àà [a, b)`
4. `s` includes `(l, b]` for some `l < b` -/
lemma tfae_mem_nhds_within_Iic {a b : Œ±} (h : a < b) (s : set Œ±) :
  tfae [s ‚àà ùìù[‚â§] b, -- 0 : `s` is a neighborhood of `b` within `(-‚àû, b]`
    s ‚àà ùìù[Icc a b] b,   -- 1 : `s` is a neighborhood of `b` within `[a, b]`
    s ‚àà ùìù[Ioc a b] b,   -- 2 : `s` is a neighborhood of `b` within `(a, b]`
    ‚àÉ l ‚àà Ico a b, Ioc l b ‚äÜ s,    -- 3 : `s` includes `(l, b]` for some `l ‚àà [a, b)`
    ‚àÉ l ‚àà Iio b, Ioc l b ‚äÜ s] :=   -- 4 : `s` includes `(l, b]` for some `l < b`
by simpa only [exists_prop, order_dual.exists, dual_Ici, dual_Ioc, dual_Icc, dual_Ico]
    using tfae_mem_nhds_within_Ici h.dual (of_dual ‚Åª¬π' s)

lemma mem_nhds_within_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Ico l' a, Ioc l a ‚äÜ s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 3 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`, provided `a` is not a bottom element. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset' {a l' : Œ±} {s : set Œ±} (hl' : l' < a) :
  s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
(tfae_mem_nhds_within_Iic hl' s).out 0 4 (by norm_num) (by norm_num)

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `(l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Ioc_subset [no_min_order Œ±] {a : Œ±} {s : set Œ±} :
  s ‚àà ùìù[‚â§] a ‚Üî ‚àÉl ‚àà Iio a, Ioc l a ‚äÜ s :=
let ‚ü®l', hl'‚ü© := exists_lt a in mem_nhds_within_Iic_iff_exists_Ioc_subset' hl'

/-- A set is a neighborhood of `a` within `(-‚àû, a]` if and only if it contains an interval `[l, a]`
with `l < a`. -/
lemma mem_nhds_within_Iic_iff_exists_Icc_subset [no_min_order Œ±] [densely_ordered Œ±]
  {a : Œ±} {s : set Œ±} : s ‚àà ùìù[‚â§] a ‚Üî ‚àÉ l, l < a ‚àß Icc l a ‚äÜ s :=
begin
  convert @mem_nhds_within_Ici_iff_exists_Icc_subset Œ±·µí·µà _ _ _ _ _ _ _,
  simp_rw (show ‚àÄ u : Œ±·µí·µà, @Icc Œ±·µí·µà _ a u = @Icc Œ± _ u a, from Œª u, dual_Icc),
  refl,
end

end order_topology

end linear_order

section linear_ordered_add_comm_group

variables [topological_space Œ±] [linear_ordered_add_comm_group Œ±] [order_topology Œ±]
variables {l : filter Œ≤} {f g : Œ≤ ‚Üí Œ±}

lemma nhds_eq_infi_abs_sub (a : Œ±) : ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r}) :=
begin
  simp only [le_antisymm_iff, nhds_eq_order, le_inf_iff, le_infi_iff, le_principal_iff, mem_Ioi,
    mem_Iio, abs_sub_lt_iff, @sub_lt_iff_lt_add _ _ _ _ _ _ a, @sub_lt_comm _ _ _ _ a, set_of_and],
  refine ‚ü®_, _, _‚ü©,
  { intros Œµ Œµ0,
    exact inter_mem_inf
      (mem_infi_of_mem (a - Œµ) $ mem_infi_of_mem (sub_lt_self a Œµ0) (mem_principal_self _))
      (mem_infi_of_mem (Œµ + a) $ mem_infi_of_mem (by simpa) (mem_principal_self _)) },
  { intros b hb,
    exact mem_infi_of_mem (a - b) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Ioi])) },
  { intros b hb,
    exact mem_infi_of_mem (b - a) (mem_infi_of_mem (sub_pos.2 hb) (by simp [Iio])) }
end

lemma order_topology_of_nhds_abs {Œ± : Type*} [topological_space Œ±] [linear_ordered_add_comm_group Œ±]
  (h_nhds : ‚àÄa:Œ±, ùìù a = (‚®Ör>0, ùìü {b | |a - b| < r})) : order_topology Œ± :=
begin
  refine ‚ü®eq_of_nhds_eq_nhds $ Œª a, _‚ü©,
  rw [h_nhds],
  letI := preorder.topology Œ±, letI : order_topology Œ± := ‚ü®rfl‚ü©,
  exact (nhds_eq_infi_abs_sub a).symm
end

lemma linear_ordered_add_comm_group.tendsto_nhds {x : filter Œ≤} {a : Œ±} :
  tendsto f x (ùìù a) ‚Üî ‚àÄ Œµ > (0 : Œ±), ‚àÄ·∂† b in x, |f b - a| < Œµ :=
by simp [nhds_eq_infi_abs_sub, abs_sub_comm a]

lemma eventually_abs_sub_lt (a : Œ±) {Œµ : Œ±} (hŒµ : 0 < Œµ) : ‚àÄ·∂† x in ùìù a, |x - a| < Œµ :=
(nhds_eq_infi_abs_sub a).symm ‚ñ∏ mem_infi_of_mem Œµ
  (mem_infi_of_mem hŒµ $ by simp only [abs_sub_comm, mem_principal_self])

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_top` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.add_at_top {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_top) :
  tendsto (Œª x, f x + g x) l at_top :=
begin
  nontriviality Œ±,
  obtain ‚ü®C', hC'‚ü© : ‚àÉ C', C' < C := exists_lt C,
  refine tendsto_at_top_add_left_of_le' _ C' _ hg,
  exact (hf.eventually (lt_mem_nhds hC')).mono (Œª x, le_of_lt)
end

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to `C`
and `g` tends to `at_bot` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.add_at_bot {C : Œ±} (hf : tendsto f l (ùìù C)) (hg : tendsto g l at_bot) :
  tendsto (Œª x, f x + g x) l at_bot :=
@filter.tendsto.add_at_top Œ±·µí·µà _ _ _ _ _ _ _ _ hf hg

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_top` and `g` tends to `C` then `f + g` tends to `at_top`. -/
lemma filter.tendsto.at_top_add {C : Œ±} (hf : tendsto f l at_top) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_top :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_top hf }

/-- In a linearly ordered additive commutative group with the order topology, if `f` tends to
`at_bot` and `g` tends to `C` then `f + g` tends to `at_bot`. -/
lemma filter.tendsto.at_bot_add {C : Œ±} (hf : tendsto f l at_bot) (hg : tendsto g l (ùìù C)) :
  tendsto (Œª x, f x + g x) l at_bot :=
by { conv in (_ + _) { rw add_comm }, exact hg.add_at_bot hf }

lemma nhds_basis_Ioo_pos [no_min_order Œ±] [no_max_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, Ioo (a-Œµ) (a+Œµ)) :=
‚ü®begin
  refine Œª t, (nhds_basis_Ioo a).mem_iff.trans ‚ü®_, _‚ü©,
  { rintros ‚ü®‚ü®l, u‚ü©, ‚ü®hl : l < a, hu : a < u‚ü©, h' : Ioo l u ‚äÜ t‚ü©,
    refine ‚ü®min (a-l) (u-a), by apply lt_min; rwa sub_pos, _‚ü©,
    rintros x ‚ü®hx, hx'‚ü©,
    apply h',
    rw [sub_lt_comm, lt_min_iff, sub_lt_sub_iff_left] at hx,
    rw [‚Üê sub_lt_iff_lt_add', lt_min_iff, sub_lt_sub_iff_right] at hx',
    exact ‚ü®hx.1, hx'.2‚ü© },
  { rintros ‚ü®Œµ, Œµ_pos, h‚ü©,
    exact ‚ü®(a-Œµ, a+Œµ), by simp [Œµ_pos], h‚ü© },
end‚ü©

lemma nhds_basis_abs_sub_lt [no_min_order Œ±] [no_max_order Œ±] (a : Œ±) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, {b | |b - a| < Œµ}) :=
begin
  convert nhds_basis_Ioo_pos a,
  { ext Œµ,
    change |x - a| < Œµ ‚Üî a - Œµ < x ‚àß x < a + Œµ,
    simp [abs_lt, sub_lt_iff_lt_add, add_comm Œµ a, add_comm x Œµ] }
end

variable (Œ±)

lemma nhds_basis_zero_abs_sub_lt [no_min_order Œ±] [no_max_order Œ±] :
  (ùìù (0 : Œ±)).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ) (Œª Œµ, {b | |b| < Œµ}) :=
by simpa using nhds_basis_abs_sub_lt (0 : Œ±)

variable {Œ±}

/-- If `a` is positive we can form a basis from only nonnegative `Ioo` intervals -/
lemma nhds_basis_Ioo_pos_of_pos [no_min_order Œ±] [no_max_order Œ±]
  {a : Œ±} (ha : 0 < a) :
  (ùìù a).has_basis (Œª Œµ : Œ±, (0 : Œ±) < Œµ ‚àß Œµ ‚â§ a) (Œª Œµ, Ioo (a-Œµ) (a+Œµ)) :=
‚ü® Œª t, (nhds_basis_Ioo_pos a).mem_iff.trans
  ‚ü®Œª h, let ‚ü®i, hi, hit‚ü© := h in
    ‚ü®min i a, ‚ü®lt_min hi ha, min_le_right i a‚ü©, trans (Ioo_subset_Ioo
    (sub_le_sub_left (min_le_left i a) a) (add_le_add_left (min_le_left i a) a)) hit‚ü©,
  Œª h, let ‚ü®i, hi, hit‚ü© := h in ‚ü®i, hi.1, hit‚ü© ‚ü© ‚ü©

end linear_ordered_add_comm_group

lemma preimage_neg [add_group Œ±] : preimage (has_neg.neg : Œ± ‚Üí Œ±) = image (has_neg.neg : Œ± ‚Üí Œ±) :=
(image_eq_preimage_of_inverse neg_neg neg_neg).symm

lemma filter.map_neg_eq_comap_neg [add_group Œ±] :
  map (has_neg.neg : Œ± ‚Üí Œ±) = comap (has_neg.neg : Œ± ‚Üí Œ±) :=
funext $ assume f, map_eq_comap_of_inverse (funext neg_neg) (funext neg_neg)

section order_topology

variables [topological_space Œ±] [topological_space Œ≤]
  [linear_order Œ±] [linear_order Œ≤] [order_topology Œ±] [order_topology Œ≤]

lemma is_lub.frequently_mem {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù[‚â§] a, x ‚àà s :=
begin
  rcases hs with ‚ü®a', ha'‚ü©,
  intro h,
  rcases (ha.1 ha').eq_or_lt with (rfl|ha'a),
  { exact h.self_of_nhds_within le_rfl ha' },
  { rcases (mem_nhds_within_Iic_iff_exists_Ioc_subset' ha'a).1 h
      with ‚ü®b, hba, hb‚ü©,
    rcases ha.exists_between hba with ‚ü®b', hb's, hb'‚ü©,
    exact hb hb' hb's },
end

lemma is_lub.frequently_nhds_mem {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù a, x ‚àà s :=
(ha.frequently_mem hs).filter_mono inf_le_left

lemma is_glb.frequently_mem {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù[‚â•] a, x ‚àà s :=
@is_lub.frequently_mem Œ±·µí·µà _ _ _ _ _ ha hs

lemma is_glb.frequently_nhds_mem {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  ‚àÉ·∂† x in ùìù a, x ‚àà s :=
(ha.frequently_mem hs).filter_mono inf_le_left

lemma is_lub.mem_closure {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  a ‚àà closure s :=
(ha.frequently_nhds_mem hs).mem_closure

lemma is_glb.mem_closure {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty) :
  a ‚àà closure s :=
(ha.frequently_nhds_mem hs).mem_closure

lemma is_lub.nhds_within_ne_bot {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty) :
  ne_bot (ùìù[s] a) :=
mem_closure_iff_nhds_within_ne_bot.1 (ha.mem_closure hs)

lemma is_glb.nhds_within_ne_bot : ‚àÄ {a : Œ±} {s : set Œ±}, is_glb s a ‚Üí s.nonempty ‚Üí
  ne_bot (ùìù[s] a) :=
@is_lub.nhds_within_ne_bot Œ±·µí·µà _ _ _

lemma is_lub_of_mem_nhds {s : set Œ±} {a : Œ±} {f : filter Œ±}
  (hsa : a ‚àà upper_bounds s) (hsf : s ‚àà f) [ne_bot (f ‚äì ùìù a)] : is_lub s a :=
‚ü®hsa, assume b hb,
  not_lt.1 $ assume hba,
  have s ‚à© {a | b < a} ‚àà f ‚äì ùìù a,
    from inter_mem_inf hsf (is_open.mem_nhds (is_open_lt' _) hba),
  let ‚ü®x, ‚ü®hxs, hxb‚ü©‚ü© := filter.nonempty_of_mem this in
  have b < b, from lt_of_lt_of_le hxb $ hb hxs,
  lt_irrefl b this‚ü©

lemma is_lub_of_mem_closure {s : set Œ±} {a : Œ±} (hsa : a ‚àà upper_bounds s) (hsf : a ‚àà closure s) :
  is_lub s a :=
begin
  rw [mem_closure_iff_cluster_pt, cluster_pt, inf_comm] at hsf,
  haveI : (ùìü s ‚äì ùìù a).ne_bot := hsf,
  exact is_lub_of_mem_nhds hsa (mem_principal_self s),
end

lemma is_glb_of_mem_nhds : ‚àÄ {s : set Œ±} {a : Œ±} {f : filter Œ±},
  a ‚àà lower_bounds s ‚Üí s ‚àà f ‚Üí ne_bot (f ‚äì ùìù a) ‚Üí is_glb s a :=
@is_lub_of_mem_nhds Œ±·µí·µà _ _ _

lemma is_glb_of_mem_closure {s : set Œ±} {a : Œ±} (hsa : a ‚àà lower_bounds s) (hsf : a ‚àà closure s) :
  is_glb s a :=
@is_lub_of_mem_closure Œ±·µí·µà _ _ _ s a hsa hsf

lemma is_lub.mem_upper_bounds_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : monotone_on f s) (ha : is_lub s a)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upper_bounds (f '' s) :=
begin
  rintro _ ‚ü®x, hx, rfl‚ü©,
  replace ha := ha.inter_Ici_of_mem hx,
  haveI := ha.nhds_within_ne_bot ‚ü®x, hx, le_rfl‚ü©,
  refine ge_of_tendsto (hb.mono_left (nhds_within_mono _ (inter_subset_left s (Ici x)))) _,
  exact mem_of_superset self_mem_nhds_within (Œª y hy, hf hx hy.1 hy.2)
end

-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as `x : Œ±`
-- tends to infinity, rather than tending to a point `x` in `Œ±`, see `is_lub_of_tendsto_at_top`
lemma is_lub.is_lub_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : monotone_on f s) (ha : is_lub s a) (hs : s.nonempty)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : is_lub (f '' s) b :=
begin
  haveI := ha.nhds_within_ne_bot hs,
  exact ‚ü®ha.mem_upper_bounds_of_tendsto hf hb, Œª b' hb', le_of_tendsto hb
    (mem_of_superset self_mem_nhds_within $ Œª x hx, hb' $ mem_image_of_mem _ hx)‚ü©
end

lemma is_glb.mem_lower_bounds_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : monotone_on f s) (ha : is_glb s a)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lower_bounds (f '' s) :=
@is_lub.mem_upper_bounds_of_tendsto Œ±·µí·µà Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf.dual ha hb

-- For a version of this theorem in which the convergence considered on the domain `Œ±` is as
-- `x : Œ±` tends to negative infinity, rather than tending to a point `x` in `Œ±`, see
-- `is_glb_of_tendsto_at_bot`
lemma is_glb.is_glb_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : monotone_on f s) : is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub.is_lub_of_tendsto Œ±·µí·µà Œ≥·µí·µà _ _ _ _ _ _ f s a b hf.dual

lemma is_lub.mem_lower_bounds_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : antitone_on f s) (ha : is_lub s a)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà lower_bounds (f '' s) :=
@is_lub.mem_upper_bounds_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf ha hb

lemma is_lub.is_glb_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] : ‚àÄ {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥},
  (antitone_on f s) ‚Üí is_lub s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_glb (f '' s) b :=
@is_lub.is_lub_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _

lemma is_glb.mem_upper_bounds_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥}
  (hf : antitone_on f s) (ha : is_glb s a)
  (hb : tendsto f (ùìù[s] a) (ùìù b)) : b ‚àà upper_bounds (f '' s) :=
@is_glb.mem_lower_bounds_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _ _ _ _ _ hf ha hb

lemma is_glb.is_lub_of_tendsto [preorder Œ≥] [topological_space Œ≥]
  [order_closed_topology Œ≥] : ‚àÄ {f : Œ± ‚Üí Œ≥} {s : set Œ±} {a : Œ±} {b : Œ≥},
  (antitone_on f s) ‚Üí is_glb s a ‚Üí s.nonempty ‚Üí
  tendsto f (ùìù[s] a) (ùìù b) ‚Üí is_lub (f '' s) b :=
@is_glb.is_glb_of_tendsto Œ± Œ≥·µí·µà _ _ _ _ _ _

lemma is_lub.mem_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_lub s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
sc.closure_subset $ ha.mem_closure hs

alias is_lub.mem_of_is_closed ‚Üê is_closed.is_lub_mem

lemma is_glb.mem_of_is_closed {a : Œ±} {s : set Œ±} (ha : is_glb s a) (hs : s.nonempty)
  (sc : is_closed s) : a ‚àà s :=
sc.closure_subset $ ha.mem_closure hs

alias is_glb.mem_of_is_closed ‚Üê is_closed.is_glb_mem

/-!
### Existence of sequences tending to Inf or Sup of a given set
-/

lemma is_lub.exists_seq_strict_mono_tendsto_of_not_mem {t : set Œ±} {x : Œ±}
  [is_countably_generated (ùìù x)] (htx : is_lub t x) (not_mem : x ‚àâ t) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
begin
  rcases ht with ‚ü®l, hl‚ü©,
  have hl : l < x,
   from (htx.1 hl).eq_or_lt.resolve_left (Œª h,  (not_mem $ h ‚ñ∏ hl).elim),
  obtain ‚ü®s, hs‚ü© : ‚àÉ s : ‚Ñï ‚Üí set Œ±, (ùìù x).has_basis (Œª (_x : ‚Ñï), true) s :=
    let ‚ü®s, hs‚ü© := (ùìù x).exists_antitone_basis in ‚ü®s, hs.to_has_basis‚ü©,
  have : ‚àÄ n k, k < x ‚Üí ‚àÉ y, Icc y x ‚äÜ s n ‚àß k < y ‚àß y < x ‚àß y ‚àà t,
  { assume n k hk,
    obtain ‚ü®L, hL, h‚ü© : ‚àÉ (L : Œ±) (hL : L ‚àà Ico k x), Ioc L x ‚äÜ s n :=
      exists_Ioc_subset_of_mem_nhds' (hs.mem_of_mem trivial) hk,
    obtain ‚ü®y, hy‚ü© : ‚àÉ (y : Œ±), L < y ‚àß y < x ‚àß y ‚àà t,
    { rcases htx.exists_between' not_mem hL.2 with ‚ü®y, yt, hy‚ü©,
      refine ‚ü®y, hy.1, hy.2, yt‚ü© },
    exact ‚ü®y, Œª z hz, h ‚ü®hy.1.trans_le hz.1, hz.2‚ü©, hL.1.trans_lt hy.1, hy.2‚ü© },
  choose! f hf using this,
  let u : ‚Ñï ‚Üí Œ± := Œª n, nat.rec_on n (f 0 l) (Œª n h, f n.succ h),
  have I : ‚àÄ n, u n < x,
  { assume n,
    induction n with n IH,
    { exact (hf 0 l hl).2.2.1 },
    { exact (hf n.succ _ IH).2.2.1 } },
  have S : strict_mono u := strict_mono_nat_of_lt_succ (Œª n, (hf n.succ _ (I n)).2.1),
  refine ‚ü®u, S, I, hs.tendsto_right_iff.2 (Œª n _, _), (Œª n, _)‚ü©,
  { simp only [ge_iff_le, eventually_at_top],
    refine ‚ü®n, Œª p hp, _‚ü©,
    have up : u p ‚àà Icc (u n) x := ‚ü®S.monotone hp, (I p).le‚ü©,
    have : Icc (u n) x ‚äÜ s n,
      by { cases n, { exact (hf 0 l hl).1 }, { exact (hf n.succ (u n) (I n)).1 } },
    exact this up },
  { cases n,
    { exact (hf 0 l hl).2.2.2 },
    { exact (hf n.succ _ (I n)).2.2.2 } }
end

lemma is_lub.exists_seq_monotone_tendsto {t : set Œ±} {x : Œ±} [is_countably_generated (ùìù x)]
  (htx : is_lub t x) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, monotone u ‚àß (‚àÄ n, u n ‚â§ x) ‚àß tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
begin
  by_cases h : x ‚àà t,
  { exact ‚ü®Œª n, x, monotone_const, Œª n, le_rfl, tendsto_const_nhds, Œª n, h‚ü© },
  { rcases htx.exists_seq_strict_mono_tendsto_of_not_mem h ht  with ‚ü®u, hu‚ü©,
    exact ‚ü®u, hu.1.monotone, Œª n, (hu.2.1 n).le, hu.2.2‚ü© }
end

lemma exists_seq_strict_mono_tendsto' {Œ± : Type*} [linear_order Œ±] [topological_space Œ±]
  [densely_ordered Œ±] [order_topology Œ±]
  [first_countable_topology Œ±] {x y : Œ±} (hy : y < x) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n ‚àà Ioo y x) ‚àß tendsto u at_top (ùìù x) :=
begin
  have hx : x ‚àâ Ioo y x := Œª h, (lt_irrefl x h.2).elim,
  have ht : set.nonempty (Ioo y x) := nonempty_Ioo.2 hy,
  rcases (is_lub_Ioo hy).exists_seq_strict_mono_tendsto_of_not_mem hx ht with ‚ü®u, hu‚ü©,
  exact ‚ü®u, hu.1, hu.2.2.symm‚ü©
end

lemma exists_seq_strict_mono_tendsto [densely_ordered Œ±] [no_min_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù x) :=
begin
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, y < x := exists_lt x,
  rcases exists_seq_strict_mono_tendsto' hy with ‚ü®u, hu_mono, hu_mem, hux‚ü©,
  exact ‚ü®u, hu_mono, Œª n, (hu_mem n).2, hux‚ü©
end

lemma exists_seq_strict_mono_tendsto_nhds_within [densely_ordered Œ±] [no_min_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_mono u ‚àß (‚àÄ n, u n < x) ‚àß tendsto u at_top (ùìù[<] x) :=
let ‚ü®u, hu, hx, h‚ü© := exists_seq_strict_mono_tendsto x in ‚ü®u, hu, hx,
  tendsto_nhds_within_mono_right (range_subset_iff.2 hx) $ tendsto_nhds_within_range.2 h‚ü©

lemma exists_seq_tendsto_Sup {Œ± : Type*} [conditionally_complete_linear_order Œ±]
  [topological_space Œ±] [order_topology Œ±] [first_countable_topology Œ±]
  {S : set Œ±} (hS : S.nonempty) (hS' : bdd_above S) :
  ‚àÉ (u : ‚Ñï ‚Üí Œ±), monotone u ‚àß tendsto u at_top (ùìù (Sup S)) ‚àß (‚àÄ n, u n ‚àà S) :=
begin
  rcases (is_lub_cSup hS hS').exists_seq_monotone_tendsto hS with ‚ü®u, hu‚ü©,
  exact ‚ü®u, hu.1, hu.2.2‚ü©,
end

lemma is_glb.exists_seq_strict_anti_tendsto_of_not_mem {t : set Œ±} {x : Œ±}
  [is_countably_generated (ùìù x)] (htx : is_glb t x) (not_mem : x ‚àâ t) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, x < u n) ‚àß
                        tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
@is_lub.exists_seq_strict_mono_tendsto_of_not_mem Œ±·µí·µà _ _ _ t x _ htx not_mem ht

lemma is_glb.exists_seq_antitone_tendsto {t : set Œ±} {x : Œ±} [is_countably_generated (ùìù x)]
  (htx : is_glb t x) (ht : t.nonempty) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, antitone u ‚àß (‚àÄ n, x ‚â§ u n) ‚àß
                        tendsto u at_top (ùìù x) ‚àß (‚àÄ n, u n ‚àà t) :=
@is_lub.exists_seq_monotone_tendsto Œ±·µí·µà _ _ _ t x _ htx ht

lemma exists_seq_strict_anti_tendsto' [densely_ordered Œ±]
  [first_countable_topology Œ±] {x y : Œ±} (hy : x < y) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, u n ‚àà Ioo x y) ‚àß tendsto u at_top (ùìù x) :=
by simpa only [dual_Ioo] using exists_seq_strict_mono_tendsto' (order_dual.to_dual_lt_to_dual.2 hy)

lemma exists_seq_strict_anti_tendsto [densely_ordered Œ±] [no_max_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù x) :=
@exists_seq_strict_mono_tendsto Œ±·µí·µà _ _ _ _ _ _ x

lemma exists_seq_strict_anti_tendsto_nhds_within [densely_ordered Œ±] [no_max_order Œ±]
  [first_countable_topology Œ±] (x : Œ±) :
  ‚àÉ u : ‚Ñï ‚Üí Œ±, strict_anti u ‚àß (‚àÄ n, x < u n) ‚àß tendsto u at_top (ùìù[>] x) :=
@exists_seq_strict_mono_tendsto_nhds_within Œ±·µí·µà _ _ _ _ _ _ _

lemma exists_seq_strict_anti_strict_mono_tendsto [densely_ordered Œ±] [first_countable_topology Œ±]
  {x y : Œ±} (h : x < y) :
  ‚àÉ (u v : ‚Ñï ‚Üí Œ±), strict_anti u ‚àß strict_mono v ‚àß (‚àÄ k, u k ‚àà Ioo x y) ‚àß (‚àÄ l, v l ‚àà Ioo x y) ‚àß
    (‚àÄ k l, u k < v l) ‚àß tendsto u at_top (ùìù x) ‚àß tendsto v at_top (ùìù y) :=
begin
  rcases exists_seq_strict_anti_tendsto' h with ‚ü®u, hu_anti, hu_mem, hux‚ü©,
  rcases exists_seq_strict_mono_tendsto' (hu_mem 0).2 with ‚ü®v, hv_mono, hv_mem, hvy‚ü©,
  exact ‚ü®u, v, hu_anti, hv_mono, hu_mem, Œª l, ‚ü®(hu_mem 0).1.trans (hv_mem l).1, (hv_mem l).2‚ü©,
    Œª k l, (hu_anti.antitone (zero_le k)).trans_lt (hv_mem l).1, hux, hvy‚ü©
end

lemma exists_seq_tendsto_Inf {Œ± : Type*} [conditionally_complete_linear_order Œ±]
  [topological_space Œ±] [order_topology Œ±] [first_countable_topology Œ±]
  {S : set Œ±} (hS : S.nonempty) (hS' : bdd_below S) :
  ‚àÉ (u : ‚Ñï ‚Üí Œ±), antitone u ‚àß tendsto u at_top (ùìù (Inf S)) ‚àß (‚àÄ n, u n ‚àà S) :=
@exists_seq_tendsto_Sup Œ±·µí·µà _ _ _ _ S hS hS'

end order_topology

section densely_ordered

variables [topological_space Œ±] [linear_order Œ±] [order_topology Œ±] [densely_ordered Œ±]
{a b : Œ±} {s : set Œ±}

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`, unless `a` is a top
element. -/
lemma closure_Ioi' {a : Œ±} (h : (Ioi a).nonempty) :
  closure (Ioi a) = Ici a :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioi_subset_Ici_self is_closed_Ici },
  { rw [‚Üê diff_subset_closure_iff, Ici_diff_Ioi_same, singleton_subset_iff],
    exact is_glb_Ioi.mem_closure h }
end

/-- The closure of the interval `(a, +‚àû)` is the closed interval `[a, +‚àû)`. -/
@[simp] lemma closure_Ioi (a : Œ±) [no_max_order Œ±] :
  closure (Ioi a) = Ici a :=
closure_Ioi' nonempty_Ioi

/-- The closure of the interval `(-‚àû, a)` is the closed interval `(-‚àû, a]`, unless `a` is a bottom
element. -/
lemma closure_Iio' (h : (Iio a).nonempty) : closure (Iio a) = Iic a := @closure_Ioi' Œ±·µí·µà _ _ _ _ _ h

/-- The closure of the interval `(-‚àû, a)` is the interval `(-‚àû, a]`. -/
@[simp] lemma closure_Iio (a : Œ±) [no_min_order Œ±] :
  closure (Iio a) = Iic a :=
closure_Iio' nonempty_Iio

/-- The closure of the open interval `(a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioo {a b : Œ±} (hab : a ‚â† b) :
  closure (Ioo a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioo_subset_Icc_self is_closed_Icc },
  { cases hab.lt_or_lt with hab hab,
    { rw [‚Üê diff_subset_closure_iff, Icc_diff_Ioo_same hab.le],
      have hab' : (Ioo a b).nonempty, from nonempty_Ioo.2 hab,
      simp only [insert_subset, singleton_subset_iff],
      exact ‚ü®(is_glb_Ioo hab).mem_closure hab', (is_lub_Ioo hab).mem_closure hab'‚ü© },
    { rw Icc_eq_empty_of_lt hab, exact empty_subset _ } }
end

/-- The closure of the interval `(a, b]` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ioc {a b : Œ±} (hab : a ‚â† b) :
  closure (Ioc a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ioc_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ioc_self),
    rw closure_Ioo hab }
end

/-- The closure of the interval `[a, b)` is the closed interval `[a, b]`. -/
@[simp] lemma closure_Ico {a b : Œ±} (hab : a ‚â† b) :
  closure (Ico a b) = Icc a b :=
begin
  apply subset.antisymm,
  { exact closure_minimal Ico_subset_Icc_self is_closed_Icc },
  { apply subset.trans _ (closure_mono Ioo_subset_Ico_self),
    rw closure_Ioo hab }
end

@[simp] lemma interior_Ici' {a : Œ±} (ha : (Iio a).nonempty) : interior (Ici a) = Ioi a :=
by rw [‚Üê compl_Iio, interior_compl, closure_Iio' ha, compl_Iic]

lemma interior_Ici [no_min_order Œ±] {a : Œ±} : interior (Ici a) = Ioi a :=
interior_Ici' nonempty_Iio

@[simp] lemma interior_Iic' {a : Œ±} (ha : (Ioi a).nonempty) : interior (Iic a) = Iio a :=
@interior_Ici' Œ±·µí·µà _ _ _ _ _ ha

lemma interior_Iic [no_max_order Œ±] {a : Œ±} : interior (Iic a) = Iio a :=
interior_Iic' nonempty_Ioi

@[simp] lemma interior_Icc [no_min_order Œ±] [no_max_order Œ±] {a b : Œ±}:
  interior (Icc a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iic, interior_inter, interior_Ici, interior_Iic, Ioi_inter_Iio]

@[simp] lemma interior_Ico [no_min_order Œ±] {a b : Œ±} : interior (Ico a b) = Ioo a b :=
by rw [‚Üê Ici_inter_Iio, interior_inter, interior_Ici, interior_Iio, Ioi_inter_Iio]

@[simp] lemma interior_Ioc [no_max_order Œ±] {a b : Œ±} : interior (Ioc a b) = Ioo a b :=
by rw [‚Üê Ioi_inter_Iic, interior_inter, interior_Ioi, interior_Iic, Ioi_inter_Iio]

lemma closure_interior_Icc {a b : Œ±} (h : a ‚â† b) : closure (interior (Icc a b)) = Icc a b :=
(closure_minimal interior_subset is_closed_Icc).antisymm $
calc Icc a b = closure (Ioo a b) : (closure_Ioo h).symm
... ‚äÜ closure (interior (Icc a b)) : closure_mono (interior_maximal Ioo_subset_Icc_self is_open_Ioo)

lemma Ioc_subset_closure_interior (a b : Œ±) : Ioc a b ‚äÜ closure (interior (Ioc a b)) :=
begin
  rcases eq_or_ne a b with rfl|h,
  { simp },
  { calc Ioc a b ‚äÜ Icc a b : Ioc_subset_Icc_self
    ... = closure (Ioo a b) : (closure_Ioo h).symm
    ... ‚äÜ closure (interior (Ioc a b)) :
      closure_mono (interior_maximal Ioo_subset_Ioc_self is_open_Ioo) }
end

lemma Ico_subset_closure_interior (a b : Œ±) : Ico a b ‚äÜ closure (interior (Ico a b)) :=
by simpa only [dual_Ioc]
  using Ioc_subset_closure_interior (order_dual.to_dual b) (order_dual.to_dual a)

@[simp] lemma frontier_Ici' {a : Œ±} (ha : (Iio a).nonempty) : frontier (Ici a) = {a} :=
by simp [frontier, ha]

lemma frontier_Ici [no_min_order Œ±] {a : Œ±} : frontier (Ici a) = {a} :=
frontier_Ici' nonempty_Iio

@[simp] lemma frontier_Iic' {a : Œ±} (ha : (Ioi a).nonempty) : frontier (Iic a) = {a} :=
by simp [frontier, ha]

lemma frontier_Iic [no_max_order Œ±] {a : Œ±} : frontier (Iic a) = {a} :=
frontier_Iic' nonempty_Ioi

@[simp] lemma frontier_Ioi' {a : Œ±} (ha : (Ioi a).nonempty) : frontier (Ioi a) = {a} :=
by simp [frontier, closure_Ioi' ha, Iic_diff_Iio, Icc_self]

lemma frontier_Ioi [no_max_order Œ±] {a : Œ±} : frontier (Ioi a) = {a} :=
frontier_Ioi' nonempty_Ioi

@[simp] lemma frontier_Iio' {a : Œ±} (ha : (Iio a).nonempty) : frontier (Iio a) = {a} :=
by simp [frontier, closure_Iio' ha, Iic_diff_Iio, Icc_self]

lemma frontier_Iio [no_min_order Œ±] {a : Œ±} : frontier (Iio a) = {a} :=
frontier_Iio' nonempty_Iio

@[simp] lemma frontier_Icc [no_min_order Œ±] [no_max_order Œ±] {a b : Œ±} (h : a ‚â§ b) :
  frontier (Icc a b) = {a, b} :=
by simp [frontier, h, Icc_diff_Ioo_same]

@[simp] lemma frontier_Ioo {a b : Œ±} (h : a < b) : frontier (Ioo a b) = {a, b} :=
by rw [frontier, closure_Ioo h.ne, interior_Ioo, Icc_diff_Ioo_same h.le]

@[simp] lemma frontier_Ico [no_min_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ico a b) = {a, b} :=
by rw [frontier, closure_Ico h.ne, interior_Ico, Icc_diff_Ioo_same h.le]

@[simp] lemma frontier_Ioc [no_max_order Œ±] {a b : Œ±} (h : a < b) : frontier (Ioc a b) = {a, b} :=
by rw [frontier, closure_Ioc h.ne, interior_Ioc, Icc_diff_Ioo_same h.le]

lemma nhds_within_Ioi_ne_bot' {a b : Œ±} (H‚ÇÅ : (Ioi a).nonempty) (H‚ÇÇ : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by rwa [closure_Ioi' H‚ÇÅ]

lemma nhds_within_Ioi_ne_bot [no_max_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Ioi a] b) :=
nhds_within_Ioi_ne_bot' nonempty_Ioi H

lemma nhds_within_Ioi_self_ne_bot' {a : Œ±} (H : (Ioi a).nonempty) :
  ne_bot (ùìù[>] a) :=
nhds_within_Ioi_ne_bot' H (le_refl a)

@[instance]
lemma nhds_within_Ioi_self_ne_bot [no_max_order Œ±] (a : Œ±) :
  ne_bot (ùìù[>] a) :=
nhds_within_Ioi_ne_bot (le_refl a)

lemma filter.eventually.exists_gt [no_max_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ b > a, p b :=
by simpa only [exists_prop, gt_iff_lt, and_comm]
  using ((h.filter_mono (@nhds_within_le_nhds _ _ a (Ioi a))).and self_mem_nhds_within).exists

lemma nhds_within_Iio_ne_bot' {b c : Œ±} (H‚ÇÅ : (Iio c).nonempty) (H‚ÇÇ : b ‚â§ c) :
  ne_bot (ùìù[Iio c] b) :=
mem_closure_iff_nhds_within_ne_bot.1 $ by rwa closure_Iio' H‚ÇÅ

lemma nhds_within_Iio_ne_bot [no_min_order Œ±] {a b : Œ±} (H : a ‚â§ b) :
  ne_bot (ùìù[Iio b] a) :=
nhds_within_Iio_ne_bot' nonempty_Iio H

lemma nhds_within_Iio_self_ne_bot' {b : Œ±} (H : (Iio b).nonempty) :
  ne_bot (ùìù[<] b) :=
nhds_within_Iio_ne_bot' H (le_refl b)

@[instance]
lemma nhds_within_Iio_self_ne_bot [no_min_order Œ±] (a : Œ±) :
  ne_bot (ùìù[<] a) :=
nhds_within_Iio_ne_bot (le_refl a)

lemma filter.eventually.exists_lt [no_min_order Œ±] {a : Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in ùìù a, p x) :
  ‚àÉ b < a, p b :=
@filter.eventually.exists_gt Œ±·µí·µà _ _ _ _ _ _ _ h

lemma right_nhds_within_Ico_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ico a b] b) :=
(is_lub_Ico H).nhds_within_ne_bot (nonempty_Ico.2 H)

lemma left_nhds_within_Ioc_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioc a b] a) :=
(is_glb_Ioc H).nhds_within_ne_bot (nonempty_Ioc.2 H)

lemma left_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] a) :=
(is_glb_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

lemma right_nhds_within_Ioo_ne_bot {a b : Œ±} (H : a < b) : ne_bot (ùìù[Ioo a b] b) :=
(is_lub_Ioo H).nhds_within_ne_bot (nonempty_Ioo.2 H)

lemma comap_coe_nhds_within_Iio_of_Ioo_subset (hb : s ‚äÜ Iio b)
  (hs : s.nonempty ‚Üí ‚àÉ a < b, Ioo a b ‚äÜ s) :
  comap (coe : s ‚Üí Œ±) (ùìù[<] b) = at_top :=
begin
  nontriviality,
  haveI : nonempty s := nontrivial_iff_nonempty.1 ‚Äπ_‚Ä∫,
  rcases hs (nonempty_subtype.1 ‚Äπ_‚Ä∫) with ‚ü®a, h, hs‚ü©,
  ext u, split,
  { rintros ‚ü®t, ht, hts‚ü©,
    obtain ‚ü®x, ‚ü®hxa : a ‚â§ x, hxb : x < b‚ü©, hxt : Ioo x b ‚äÜ t‚ü© :=
      (mem_nhds_within_Iio_iff_exists_mem_Ico_Ioo_subset h).mp ht,
    obtain ‚ü®y, hxy, hyb‚ü© := exists_between hxb,
    refine mem_of_superset (mem_at_top ‚ü®y, hs ‚ü®hxa.trans_lt hxy, hyb‚ü©‚ü©) _,
    rintros ‚ü®z, hzs‚ü© (hyz : y ‚â§ z),
    refine hts (hxt ‚ü®hxy.trans_le _, hb _‚ü©); assumption },
  { intros hu,
    obtain ‚ü®x : s, hx : ‚àÄ z, x ‚â§ z ‚Üí z ‚àà u‚ü© := mem_at_top_sets.1 hu,
    exact ‚ü®Ioo x b, Ioo_mem_nhds_within_Iio (right_mem_Ioc.2 $ hb x.2), Œª z hz, hx _ hz.1.le‚ü© }
end

lemma comap_coe_nhds_within_Ioi_of_Ioo_subset (ha : s ‚äÜ Ioi a)
  (hs : s.nonempty ‚Üí ‚àÉ b > a, Ioo a b ‚äÜ s) :
  comap (coe : s ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Iio_of_Ioo_subset
  (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a), from ha)
  (Œª h, by simpa only [order_dual.exists, dual_Ioo] using hs h)

lemma map_coe_at_top_of_Ioo_subset (hb : s ‚äÜ Iio b)
  (hs : ‚àÄ a' < b, ‚àÉ a < b, Ioo a b ‚äÜ s) :
  map (coe : s ‚Üí Œ±) at_top = ùìù[<] b :=
begin
  rcases eq_empty_or_nonempty (Iio b) with (hb'|‚ü®a, ha‚ü©),
  { rw [filter_eq_bot_of_is_empty at_top, filter.map_bot, hb', nhds_within_empty],
    exact ‚ü®Œª x, hb'.subset (hb x.2)‚ü© },
  { rw [‚Üê comap_coe_nhds_within_Iio_of_Ioo_subset hb (Œª _, hs a ha), map_comap_of_mem],
    rw subtype.range_coe,
    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' ha).2 (hs a ha) },
end

lemma map_coe_at_bot_of_Ioo_subset (ha : s ‚äÜ Ioi a)
  (hs : ‚àÄ b' > a, ‚àÉ b > a, Ioo a b ‚äÜ s) :
  map (coe : s ‚Üí Œ±) at_bot = (ùìù[>] a) :=
begin
  -- the elaborator gets stuck without `(... : _)`
  refine (map_coe_at_top_of_Ioo_subset
    (show of_dual ‚Åª¬π' s ‚äÜ Iio (to_dual a), from ha) (Œª b' hb', _) : _),
  simpa only [order_dual.exists, dual_Ioo] using hs b' hb',
end

/-- The `at_top` filter for an open interval `Ioo a b` comes from the left-neighbourhoods filter at
the right endpoint in the ambient order. -/
lemma comap_coe_Ioo_nhds_within_Iio (a b : Œ±) :
  comap (coe : Ioo a b ‚Üí Œ±) (ùìù[<] b) = at_top :=
comap_coe_nhds_within_Iio_of_Ioo_subset Ioo_subset_Iio_self $
  Œª h, ‚ü®a, nonempty_Ioo.1 h, subset.refl _‚ü©

/-- The `at_bot` filter for an open interval `Ioo a b` comes from the right-neighbourhoods filter at
the left endpoint in the ambient order. -/
lemma comap_coe_Ioo_nhds_within_Ioi (a b : Œ±) :
  comap (coe : Ioo a b ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset Ioo_subset_Ioi_self $
  Œª h, ‚ü®b, nonempty_Ioo.1 h, subset.refl _‚ü©

lemma comap_coe_Ioi_nhds_within_Ioi (a : Œ±) : comap (coe : Ioi a ‚Üí Œ±) (ùìù[>] a) = at_bot :=
comap_coe_nhds_within_Ioi_of_Ioo_subset (subset.refl _) $
  Œª ‚ü®x, hx‚ü©, ‚ü®x, hx, Ioo_subset_Ioi_self‚ü©

lemma comap_coe_Iio_nhds_within_Iio (a : Œ±) :
  comap (coe : Iio a ‚Üí Œ±) (ùìù[<] a) = at_top :=
@comap_coe_Ioi_nhds_within_Ioi Œ±·µí·µà _ _ _ _ a

@[simp] lemma map_coe_Ioo_at_top {a b : Œ±} (h : a < b) :
  map (coe : Ioo a b ‚Üí Œ±) at_top = ùìù[<] b :=
map_coe_at_top_of_Ioo_subset Ioo_subset_Iio_self $ Œª _ _, ‚ü®_, h, subset.refl _‚ü©

@[simp] lemma map_coe_Ioo_at_bot {a b : Œ±} (h : a < b) :
  map (coe : Ioo a b ‚Üí Œ±) at_bot = ùìù[>] a :=
map_coe_at_bot_of_Ioo_subset Ioo_subset_Ioi_self $ Œª _ _, ‚ü®_, h, subset.refl _‚ü©

@[simp] lemma map_coe_Ioi_at_bot (a : Œ±) :
  map (coe : Ioi a ‚Üí Œ±) at_bot = ùìù[>] a :=
map_coe_at_bot_of_Ioo_subset (subset.refl _) $ Œª b hb, ‚ü®b, hb, Ioo_subset_Ioi_self‚ü©

@[simp] lemma map_coe_Iio_at_top (a : Œ±) :
  map (coe : Iio a ‚Üí Œ±) at_top = ùìù[<] a :=
@map_coe_Ioi_at_bot Œ±·µí·µà _ _ _ _ _

variables {l : filter Œ≤} {f : Œ± ‚Üí Œ≤}

@[simp] lemma tendsto_comp_coe_Ioo_at_top (h : a < b) :
  tendsto (Œª x : Ioo a b, f x) at_top l ‚Üî tendsto f (ùìù[<] b) l :=
by rw [‚Üê map_coe_Ioo_at_top h, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ioo_at_bot (h : a < b) :
  tendsto (Œª x : Ioo a b, f x) at_bot l ‚Üî tendsto f (ùìù[>] a) l :=
by rw [‚Üê map_coe_Ioo_at_bot h, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Ioi_at_bot :
  tendsto (Œª x : Ioi a, f x) at_bot l ‚Üî tendsto f (ùìù[>] a) l :=
by rw [‚Üê map_coe_Ioi_at_bot, tendsto_map'_iff]

@[simp] lemma tendsto_comp_coe_Iio_at_top :
  tendsto (Œª x : Iio a, f x) at_top l ‚Üî tendsto f (ùìù[<] a) l :=
by rw [‚Üê map_coe_Iio_at_top, tendsto_map'_iff]

@[simp] lemma tendsto_Ioo_at_top {f : Œ≤ ‚Üí Ioo a b} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[<] b) :=
by rw [‚Üê comap_coe_Ioo_nhds_within_Iio, tendsto_comap_iff]

@[simp] lemma tendsto_Ioo_at_bot {f : Œ≤ ‚Üí Ioo a b} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[>] a) :=
by rw [‚Üê comap_coe_Ioo_nhds_within_Ioi, tendsto_comap_iff]

@[simp] lemma tendsto_Ioi_at_bot {f : Œ≤ ‚Üí Ioi a} :
  tendsto f l at_bot ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[>] a) :=
by rw [‚Üê comap_coe_Ioi_nhds_within_Ioi, tendsto_comap_iff]

@[simp] lemma tendsto_Iio_at_top {f : Œ≤ ‚Üí Iio a} :
  tendsto f l at_top ‚Üî tendsto (Œª x, (f x : Œ±)) l (ùìù[<] a) :=
by rw [‚Üê comap_coe_Iio_nhds_within_Iio, tendsto_comap_iff]

instance (x : Œ±) [nontrivial Œ±] : ne_bot (ùìù[‚â†] x) :=
begin
  apply forall_mem_nonempty_iff_ne_bot.1 (Œª s hs, _),
  obtain ‚ü®u, u_open, xu, us‚ü© : ‚àÉ (u : set Œ±), is_open u ‚àß x ‚àà u ‚àß u ‚à© {x}·∂ú ‚äÜ s :=
    mem_nhds_within.1 hs,
  obtain ‚ü®a, b, a_lt_b, hab‚ü© : ‚àÉ (a b : Œ±), a < b ‚àß Ioo a b ‚äÜ u := u_open.exists_Ioo_subset ‚ü®x, xu‚ü©,
  obtain ‚ü®y, hy‚ü© : ‚àÉ y, a < y ‚àß y < b := exists_between a_lt_b,
  rcases ne_or_eq x y with xy|rfl,
  { exact ‚ü®y, us ‚ü®hab hy, xy.symm‚ü©‚ü© },
  obtain ‚ü®z, hz‚ü© : ‚àÉ z, a < z ‚àß z < x := exists_between hy.1,
  exact ‚ü®z, us ‚ü®hab ‚ü®hz.1, hz.2.trans hy.2‚ü©, hz.2.ne‚ü©‚ü©,
end

/-- Let `s` be a dense set in a nontrivial dense linear order `Œ±`. If `s` is a
separable space (e.g., if `Œ±` has a second countable topology), then there exists a countable
dense subset `t ‚äÜ s` such that `t` does not contain bottom/top elements of `Œ±`. -/
lemma dense.exists_countable_dense_subset_no_bot_top [nontrivial Œ±]
  {s : set Œ±} [separable_space s] (hs : dense s) :
  ‚àÉ t ‚äÜ s, t.countable ‚àß dense t ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àâ t) ‚àß (‚àÄ x, is_top x ‚Üí x ‚àâ t) :=
begin
  rcases hs.exists_countable_dense_subset with ‚ü®t, hts, htc, htd‚ü©,
  refine ‚ü®t \ ({x | is_bot x} ‚à™ {x | is_top x}), _, _, _, _, _‚ü©,
  { exact (diff_subset _ _).trans hts },
  { exact htc.mono (diff_subset _ _) },
  { exact htd.diff_finite ((subsingleton_is_bot Œ±).finite.union (subsingleton_is_top Œ±).finite) },
  { assume x hx, simp [hx] },
  { assume x hx, simp [hx] }
end

variable (Œ±)
/-- If `Œ±` is a nontrivial separable dense linear order, then there exists a
countable dense set `s : set Œ±` that contains neither top nor bottom elements of `Œ±`.
For a dense set containing both bot and top elements, see
`exists_countable_dense_bot_top`. -/
lemma exists_countable_dense_no_bot_top [separable_space Œ±] [nontrivial Œ±] :
  ‚àÉ s : set Œ±, s.countable ‚àß dense s ‚àß (‚àÄ x, is_bot x ‚Üí x ‚àâ s) ‚àß (‚àÄ x, is_top x ‚Üí x ‚àâ s) :=
by simpa using dense_univ.exists_countable_dense_subset_no_bot_top

end densely_ordered

section complete_linear_order

variables [complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [complete_linear_order Œ≤] [topological_space Œ≤] [order_closed_topology Œ≤] [nonempty Œ≥]

lemma Sup_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Sup s ‚àà closure s :=
(is_lub_Sup s).mem_closure hs

lemma Inf_mem_closure {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) :
  Inf s ‚àà closure s :=
(is_glb_Inf s).mem_closure hs

lemma is_closed.Sup_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Sup s ‚àà s :=
(is_lub_Sup s).mem_of_is_closed hs hc

lemma is_closed.Inf_mem {Œ± : Type u} [topological_space Œ±] [complete_linear_order Œ±]
  [order_topology Œ±] {s : set Œ±} (hs : s.nonempty) (hc : is_closed s) :
  Inf s ‚àà s :=
(is_glb_Inf s).mem_of_is_closed hs hc

/-- A monotone function continuous at the supremum of a nonempty set sends this supremum to
the supremum of the image of this set. -/
lemma monotone.map_Sup_of_continuous_at' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Sup s) = Sup (f '' s) :=
--This is a particular case of the more general is_lub.is_lub_of_tendsto
((is_lub_Sup _).is_lub_of_tendsto (Œª x hx y hy xy, Mf xy) hs $
  Cf.mono_left inf_le_left).Sup_eq.symm

/-- A monotone function `f` sending `bot` to `bot` and continuous at the supremum of a set sends
this supremum to the supremum of the image of this set. -/
lemma monotone.map_Sup_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (Sup s) = Sup (f '' s) :=
begin
  cases s.eq_empty_or_nonempty with h h,
  { simp [h, fbot] },
  { exact Mf.map_Sup_of_continuous_at' Cf h }
end

/-- A monotone function continuous at the indexed supremum over a nonempty `Sort` sends this indexed
supremum to the indexed supremum of the composition. -/
lemma monotone.map_supr_of_continuous_at' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, Mf.map_Sup_of_continuous_at' Cf (range_nonempty g), ‚Üê range_comp, supr]

/-- If a monotone function sending `bot` to `bot` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
lemma monotone.map_supr_of_continuous_at {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Mf : monotone f) (fbot : f ‚ä• = ‚ä•) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, Mf.map_Sup_of_continuous_at Cf fbot, ‚Üê range_comp, supr]

/-- A monotone function continuous at the infimum of a nonempty set sends this infimum to
the infimum of the image of this set. -/
lemma monotone.map_Inf_of_continuous_at' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (hs : s.nonempty) :
  f (Inf s) = Inf (f '' s) :=
@monotone.map_Sup_of_continuous_at' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual hs

/-- A monotone function `f` sending `top` to `top` and continuous at the infimum of a set sends
this infimum to the infimum of the image of this set. -/
lemma monotone.map_Inf_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (Inf s) = Inf (f '' s) :=
@monotone.map_Sup_of_continuous_at Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual ftop

/-- A monotone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed infimum of the composition. -/
lemma monotone.map_infi_of_continuous_at' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@monotone.map_supr_of_continuous_at' Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ _ f g Cf Mf.dual

/-- If a monotone function sending `top` to `top` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed infimum of the composition. -/
lemma monotone.map_infi_of_continuous_at {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Mf : monotone f) (ftop : f ‚ä§ = ‚ä§) :
  f (infi g) = infi (f ‚àò g) :=
@monotone.map_supr_of_continuous_at Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ Œπ f g Cf Mf.dual ftop

/-- An antitone function continuous at the supremum of a nonempty set sends this supremum to
the infimum of the image of this set. -/
lemma antitone.map_Sup_of_continuous_at' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Af : antitone f) (hs : s.nonempty) :
  f (Sup s) = Inf (f '' s) :=
monotone.map_Sup_of_continuous_at'
  (show continuous_at (order_dual.to_dual ‚àò f) (Sup s), from Cf) Af hs

/-- An antitone function `f` sending `bot` to `top` and continuous at the supremum of a set sends
this supremum to the infimum of the image of this set. -/
lemma antitone.map_Sup_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Af : antitone f) (fbot : f ‚ä• = ‚ä§) :
  f (Sup s) = Inf (f '' s) :=
monotone.map_Sup_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (Sup s), from Cf) Af fbot

/-- An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this
indexed supremum to the indexed infimum of the composition. -/
lemma antitone.map_supr_of_continuous_at' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Af : antitone f) :
  f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
monotone.map_supr_of_continuous_at'
  (show continuous_at (order_dual.to_dual ‚àò f) (supr g), from Cf) Af

/-- An antitone function sending `bot` to `top` is continuous at the indexed supremum over
a `Sort`, then it sends this indexed supremum to the indexed supremum of the composition. -/
lemma antitone.map_supr_of_continuous_at {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (supr g)) (Af : antitone f) (fbot : f ‚ä• = ‚ä§) :
  f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
monotone.map_supr_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (supr g), from Cf) Af fbot

/-- An antitone function continuous at the infimum of a nonempty set sends this infimum to
the supremum of the image of this set. -/
lemma antitone.map_Inf_of_continuous_at' {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Af : antitone f) (hs : s.nonempty) :
  f (Inf s) = Sup (f '' s) :=
monotone.map_Inf_of_continuous_at'
  (show continuous_at (order_dual.to_dual ‚àò f) (Inf s), from Cf) Af hs

/-- An antitone function `f` sending `top` to `bot` and continuous at the infimum of a set sends
this infimum to the supremum of the image of this set. -/
lemma antitone.map_Inf_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Af : antitone f) (ftop : f ‚ä§ = ‚ä•) :
  f (Inf s) = Sup (f '' s) :=
monotone.map_Inf_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (Inf s), from Cf) Af ftop

/-- An antitone function continuous at the indexed infimum over a nonempty `Sort` sends this indexed
infimum to the indexed supremum of the composition. -/
lemma antitone.map_infi_of_continuous_at' {Œπ : Sort*} [nonempty Œπ] {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Af : antitone f) :
  f (‚®Ö i, g i) = ‚®Ü i, f (g i) :=
monotone.map_infi_of_continuous_at'
  (show continuous_at (order_dual.to_dual ‚àò f) (infi g), from Cf) Af

/-- If an antitone function sending `top` to `bot` is continuous at the indexed infimum over
a `Sort`, then it sends this indexed infimum to the indexed supremum of the composition. -/
lemma antitone.map_infi_of_continuous_at {Œπ : Sort*} {f : Œ± ‚Üí Œ≤} {g : Œπ ‚Üí Œ±}
  (Cf : continuous_at f (infi g)) (Af : antitone f) (ftop : f ‚ä§ = ‚ä•) :
  f (infi g) = supr (f ‚àò g) :=
monotone.map_infi_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (infi g), from Cf) Af ftop

end complete_linear_order

section conditionally_complete_linear_order

variables [conditionally_complete_linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_closed_topology Œ≤]
  [nonempty Œ≥]

lemma cSup_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_above s) : Sup s ‚àà closure s :=
(is_lub_cSup hs B).mem_closure hs

lemma cInf_mem_closure {s : set Œ±} (hs : s.nonempty) (B : bdd_below s) : Inf s ‚àà closure s :=
(is_glb_cInf hs B).mem_closure hs

lemma is_closed.cSup_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_above s) :
  Sup s ‚àà s :=
(is_lub_cSup hs B).mem_of_is_closed hs hc

lemma is_closed.cInf_mem {s : set Œ±} (hc : is_closed s) (hs : s.nonempty) (B : bdd_below s) :
  Inf s ‚àà s :=
(is_glb_cInf hs B).mem_of_is_closed hs hc

/-- If a monotone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the supremum of the image of `s`. -/
lemma monotone.map_cSup_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_above s) :
  f (Sup s) = Sup (f '' s) :=
begin
  refine ((is_lub_cSup (ne.image f) (Mf.map_bdd_above H)).unique _).symm,
  refine (is_lub_cSup ne H).is_lub_of_tendsto (Œªx hx y hy xy, Mf xy)  ne _,
  exact Cf.mono_left inf_le_left
end

/-- If a monotone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the supremum of the composition. -/
lemma monotone.map_csupr_of_continuous_at {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ü i, g i)) (Mf : monotone f) (H : bdd_above (range g)) :
  f (‚®Ü i, g i) = ‚®Ü i, f (g i) :=
by rw [supr, Mf.map_cSup_of_continuous_at Cf (range_nonempty _) H, ‚Üê range_comp, supr]

/-- If a monotone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the infimum of the image of `s`. -/
lemma monotone.map_cInf_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Mf : monotone f) (ne : s.nonempty) (H : bdd_below s) :
  f (Inf s) = Inf (f '' s) :=
@monotone.map_cSup_of_continuous_at Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f s Cf Mf.dual ne H

/-- A continuous monotone function sends indexed infimum to indexed infimum in conditionally
complete linear order, under a boundedness assumption. -/
lemma monotone.map_cinfi_of_continuous_at {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ö i, g i)) (Mf : monotone f) (H : bdd_below (range g)) :
  f (‚®Ö i, g i) = ‚®Ö i, f (g i) :=
@monotone.map_csupr_of_continuous_at Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ _ _ _ _ Cf Mf.dual H

/-- If an antitone function is continuous at the supremum of a nonempty bounded above set `s`,
then it sends this supremum to the infimum of the image of `s`. -/
lemma antitone.map_cSup_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Sup s))
  (Af : antitone f) (ne : s.nonempty) (H : bdd_above s) :
  f (Sup s) = Inf (f '' s) :=
monotone.map_cSup_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (Sup s), from Cf) Af ne H

/-- If an antitone function is continuous at the indexed supremum of a bounded function on
a nonempty `Sort`, then it sends this supremum to the infimum of the composition. -/
lemma antitone.map_csupr_of_continuous_at {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ü i, g i)) (Af : antitone f) (H : bdd_above (range g)) :
  f (‚®Ü i, g i) = ‚®Ö i, f (g i) :=
monotone.map_csupr_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (‚®Ü i, g i), from Cf) Af H

/-- If an antitone function is continuous at the infimum of a nonempty bounded below set `s`,
then it sends this infimum to the supremum of the image of `s`. -/
lemma antitone.map_cInf_of_continuous_at {f : Œ± ‚Üí Œ≤} {s : set Œ±} (Cf : continuous_at f (Inf s))
  (Af : antitone f) (ne : s.nonempty) (H : bdd_below s) :
  f (Inf s) = Sup (f '' s) :=
monotone.map_cInf_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (Inf s), from Cf) Af ne H

/-- A continuous antitone function sends indexed infimum to indexed supremum in conditionally
complete linear order, under a boundedness assumption. -/
lemma antitone.map_cinfi_of_continuous_at {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ±}
  (Cf : continuous_at f (‚®Ö i, g i)) (Af : antitone f) (H : bdd_below (range g)) :
  f (‚®Ö i, g i) = ‚®Ü i, f (g i) :=
monotone.map_cinfi_of_continuous_at
  (show continuous_at (order_dual.to_dual ‚àò f) (‚®Ö i, g i), from Cf) Af H

/-- A monotone map has a limit to the left of any point `x`, equal to `Sup (f '' (Iio x))`. -/
lemma monotone.tendsto_nhds_within_Iio {Œ± Œ≤ : Type*}
  [linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤]
  {f : Œ± ‚Üí Œ≤} (Mf : monotone f) (x : Œ±) :
  tendsto f (ùìù[<] x) (ùìù (Sup (f '' (Iio x)))) :=
begin
  rcases eq_empty_or_nonempty (Iio x) with h|h, { simp [h] },
  refine tendsto_order.2 ‚ü®Œª l hl, _, Œª m hm, _‚ü©,
  { obtain ‚ü®z, zx, lz‚ü© : ‚àÉ (a : Œ±), a < x ‚àß l < f a,
      by simpa only [mem_image, exists_prop, exists_exists_and_eq_and]
        using exists_lt_of_lt_cSup (nonempty_image_iff.2 h) hl,
    exact (mem_nhds_within_Iio_iff_exists_Ioo_subset' zx).2
      ‚ü®z, zx, Œª y hy, lz.trans_le (Mf (hy.1.le))‚ü© },
  { filter_upwards [self_mem_nhds_within] with _ hy,
    apply lt_of_le_of_lt _ hm,
    exact le_cSup (Mf.map_bdd_above bdd_above_Iio) (mem_image_of_mem _ hy), },
end

/-- A monotone map has a limit to the right of any point `x`, equal to `Inf (f '' (Ioi x))`. -/
lemma monotone.tendsto_nhds_within_Ioi {Œ± Œ≤ : Type*}
  [linear_order Œ±] [topological_space Œ±] [order_topology Œ±]
  [conditionally_complete_linear_order Œ≤] [topological_space Œ≤] [order_topology Œ≤]
  {f : Œ± ‚Üí Œ≤} (Mf : monotone f) (x : Œ±) :
  tendsto f (ùìù[>] x) (ùìù (Inf (f '' (Ioi x)))) :=
@monotone.tendsto_nhds_within_Iio Œ±·µí·µà Œ≤·µí·µà _ _ _ _ _ _ f Mf.dual x

end conditionally_complete_linear_order

section nhds_with_pos

section linear_ordered_add_comm_group

variables [linear_order Œ±] [has_zero Œ±] [topological_space Œ±] [order_topology Œ±]

lemma eventually_nhds_within_pos_mem_Ioo {Œµ : Œ±} (h : 0 < Œµ) :
  ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioo 0 Œµ :=
Ioo_mem_nhds_within_Ioi (left_mem_Ico.2 h)

lemma eventually_nhds_within_pos_mem_Ioc {Œµ : Œ±} (h : 0 < Œµ) :
  ‚àÄ·∂† x in ùìù[>] 0, x ‚àà Ioc 0 Œµ :=
Ioc_mem_nhds_within_Ioi (left_mem_Ico.2 h)

end linear_ordered_add_comm_group

end nhds_with_pos

end order_topology
