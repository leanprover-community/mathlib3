/-
Copyright (c) 2022 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import logic.equiv.defs
import order.upper_lower
import topology.algebra.constructions
import topology.order.lattice
import topology.separation

/-!
# Lower topology

This file introduces the lower topology on a preorder. It is shown that the lower topology on a
partial order is T₀ and the complements of the upper closures of finite subsets form a basis.

## References

* [Gierz et al, A Compendium of Continuous Lattices][GierzEtAl1980]

## Tags

lower topology, preorder
-/

universe u

variable (α : Type u)

open set topological_space

/--
Type synonym for a preorder equipped with the lower topology
-/
def with_lower_topology := α

instance [p : preorder α] : preorder (with_lower_topology α) := p

@[simp] lemma mem_set_of_eq' {x : set (with_lower_topology α)} {p : set α → Prop} :
  x ∈ {y | p y} = p x := rfl

@[simp] lemma mem_set_of_eq'' {x : set α} {p : set (with_lower_topology α) → Prop} :
  x ∈ {y | p y} = p x := rfl

instance [preorder α] : topological_space (with_lower_topology α) :=
  generate_from {s | ∃ a, (Ici a)ᶜ = s}

namespace with_lower_topology

variable {α}

/-- `to_lower` is the identity function to the `with_lower_topology` of a type.  -/
@[pattern] def to_lower : α ≃ with_lower_topology α := equiv.refl _

/-- `of_lower` is the identity function from the `with_lower_topology` of a type.  -/
@[pattern] def of_lower : with_lower_topology α ≃ α := equiv.refl _

@[simp] lemma to_with_lower_topology_symm_eq : (@to_lower α).symm = @of_lower α := rfl
@[simp] lemma of_with_lower_topology_symm_eq : (@of_lower α).symm = @to_lower α := rfl
@[simp] lemma to_lower_of_lower (a : with_lower_topology α) : to_lower (of_lower a) = a := rfl
@[simp] lemma of_lower_to_lower (a : α) : of_lower (to_lower a) = a := rfl
@[simp] lemma to_lower_inj {a b : α} : to_lower a = to_lower b ↔ a = b := iff.rfl
@[simp] lemma of_lower_inj {a b : with_lower_topology α} : of_lower a = of_lower b ↔ a = b :=
iff.rfl

/-- A recursor for `with_lower_topology`. Use as `induction x using with_lower_topology.rec`. -/
protected def rec {β : with_lower_topology α → Sort*}
  (h : Π a, β (to_lower a)) : Π a, β a := λ a, h (of_lower a)

end with_lower_topology

/--
The lower topology is the topology generated by the complements of the closed intervals to infinity.
-/
class lower_topology (α : Type u) [t : topological_space α] [preorder α] : Prop :=
(topology_eq_lower_topology : t = generate_from {s | ∃ a, (Ici a)ᶜ = s})

instance [preorder α] : lower_topology (with_lower_topology α) :=
{ topology_eq_lower_topology := rfl, }

namespace lower_topology

variable {α}

/--
The complements of the upper closures of finite subsets are a collection of lower sets
which form a basis for the lower topology.
-/
def lower_basis (α : Type u) [preorder α] :=
{s : set α | ∃ (F : set α), F.finite ∧ ↑(upper_closure F).compl = s}

section preorder

variable {α}

variables [preorder α] [topological_space α] [t : lower_topology α]

include t

lemma is_open_iff_generate_Ici_comp {s : set α} :
  is_open s ↔ generate_open {s | ∃a, (Ici a)ᶜ = s} s := by rw [t.topology_eq_lower_topology]; refl

/--
Left-closed right-infinite intervals [a,∞) are closed in the lower topology.
-/
lemma is_closed_Ici (a : α) : is_closed (Ici a) :=
is_open_compl_iff.1 begin
  rw is_open_iff_generate_Ici_comp,
  fconstructor,
  rw mem_set_of_eq,
  use a,
end

/--
The upper closure of a finite subset is closed in the lower topology.
-/
lemma is_closed_upper_closure (F : set α) (h : F.finite) :
  is_closed (upper_closure F : set α) :=
begin
  simp only [← upper_set.infi_Ici, upper_set.coe_infi],
  exact is_closed_bUnion h (λ a h₁, is_closed_Ici a),
end

/--
Every subset open in the lower topology is a lower set.
-/
lemma is_lower_set_of_is_open {s : set α} (h : is_open s) : is_lower_set s :=
begin
  rw is_open_iff_generate_Ici_comp at h,
  induction h,
  case generate_open.basic : u h { obtain ⟨a, rfl⟩ := h, exact (is_upper_set_Ici a).compl },
  case univ : { exact is_lower_set_univ },
  case inter : u v hu1 hv1 hu2 hv2 { exact hu2.inter hv2 },
  case sUnion : _ _ ih { exact is_lower_set_sUnion ih },
end

lemma is_upper_set_of_is_closed {s : set α} (h : is_closed s) :
  is_upper_set s := is_lower_set_compl.1 $ is_lower_set_of_is_open h.is_open_compl

/--
The closure of a singleton {a} in the lower topology is the left-closed right-infinite interval
[a,∞).
-/
@[simp] lemma closure_singleton (a : α) : closure {a} = Ici a :=
subset_antisymm (closure_minimal (λ b h, h.ge) $ is_closed_Ici a) $
  (is_upper_set_of_is_closed is_closed_closure).Ici_subset (subset_closure rfl)

protected lemma is_topological_basis :
  is_topological_basis (lower_basis α) :=
begin
  convert is_topological_basis_of_subbasis t.topology_eq_lower_topology,
  simp_rw [lower_basis, upper_set.coe_compl, coe_upper_closure, compl_set_of],
  push_neg, simp_rw set_of_forall,
  ext s, split,
  { rintro ⟨F, hF, rfl⟩,
    refine ⟨(λ a, (Ici a)ᶜ) '' F, ⟨hF.image _, image_subset_iff.2 $ λ _ _, ⟨_, rfl⟩⟩, _⟩,
    rw sInter_image, refl },
  { rintro ⟨F, ⟨hF, hs⟩, rfl⟩,
    haveI := hF.to_subtype,
    rw [subset_def, subtype.forall'] at hs,
    choose f he using hs,
    refine ⟨_, finite_range f, set.ext $ λ a, _⟩,
    simp_rw [bInter_range, Inter_subtype, ←compl_set_of, Ici_def, he, mem_Inter₂],
    refl },
end

end preorder

section partial_order

variables {α} [partial_order α] [topological_space α] [t : lower_topology α]

include t

/--
The lower topology on a partial order is T₀.
-/
@[priority 90] -- see Note [lower instance priority]
instance : t0_space α :=
begin
  rw t0_space_iff_inseparable,
  intros x y h,
  rw [inseparable_iff_closure_eq, closure_singleton, closure_singleton] at h,
  rw subset_antisymm_iff at h,
  rw le_antisymm_iff,
  split,
  { rw ← Ici_subset_Ici, apply h.2, },
  { rw ← Ici_subset_Ici, apply h.1, }
end

end partial_order

end lower_topology

section prod

universes v

variable (β : Type v)

@[simp] lemma of_lower_to_lower_prod_to_lower : (with_lower_topology.of_lower.trans
  (with_lower_topology.to_lower.prod_congr with_lower_topology.to_lower)) = @equiv.refl (α × β) :=
begin
  ext,
  { rw [equiv.coe_trans, function.comp_app, equiv.prod_congr_apply, prod_map, equiv.coe_refl,
      id.def], exact rfl, },
  { rw [equiv.coe_trans, function.comp_app, equiv.prod_congr_apply, prod_map, equiv.coe_refl,
      id.def], exact rfl, }
end

-- Why doesn't equiv.refl_symm work?
@[simp] lemma refl_symm : (equiv.refl (α × β)).symm = @equiv.refl (α × β) := rfl

section partial_order

variables [partial_order α] [partial_order β] [topological_space α] [s : lower_topology α]
  [topological_space β] [t : lower_topology β]

include s t

lemma prod_basis_is_topological_basis :
  is_topological_basis
  (image2 prod (lower_topology.lower_basis α) (lower_topology.lower_basis β)) :=
is_topological_basis.prod lower_topology.is_topological_basis lower_topology.is_topological_basis

instance [order_bot α] [order_bot β] : lower_topology (α × β) :=
{ topology_eq_lower_topology :=
  begin
    rw le_antisymm_iff,
    split,
    { apply le_generate_from,
    intros,
    simp only [prod.exists, mem_set_of_eq] at H,
    cases H with a,
    cases H_h with b,
    rw [← H_h_h, ← upper_set.coe_Ici, is_open_compl_iff, upper_set.prod_Ici],
    apply is_closed.inter,
    { apply is_closed.prod is_closed_univ,
      rw upper_set.coe_Ici,
      apply lower_topology.is_closed_Ici, },
    { apply is_closed.prod, rw upper_set.coe_Ici,
      apply lower_topology.is_closed_Ici,
      apply is_closed_univ, } },
    { rw (prod_basis_is_topological_basis α β).eq_generate_from,
      apply le_generate_from,
      intros U hU,
      simp only [mem_image2, exists_and_distrib_left] at hU,
      cases hU with V,
      cases hU_h with hV,
      cases hU_h_right with W,
      cases hU_h_right_h with hW hUVW,
      rw ← hUVW,
      rw [lower_topology.lower_basis, mem_set_of_eq] at hV,
      cases hV with F₁,
      rw [lower_topology.lower_basis, mem_set_of_eq] at hW,
      cases hW with F₂,
      rw [← hV_h.2, ← hW_h.2, ← lower_set.coe_prod, upper_closure_compl_prod_upper_closure_compl,
        lower_set.coe_inf],
      apply is_open.inter,
      { rw [upper_set.coe_compl, is_open_compl_iff, upper_closure_prod, upper_closure_univ,
          ← upper_set.Ici_bot, ← upper_closure_singleton, ← upper_closure_prod],
        convert lower_topology.is_closed_upper_closure _ _,
        sorry,
        apply set.finite.prod (finite_singleton ⊥) hW_h.1, },
      { rw  [upper_set.coe_compl, is_open_compl_iff, upper_closure_prod, upper_closure_univ,
          ← upper_set.Ici_bot, ← upper_closure_singleton, ← upper_closure_prod],
        convert lower_topology.is_closed_upper_closure _ _,
        sorry,
       apply set.finite.prod hV_h.1 (finite_singleton ⊥), }, },
  end }

/--
The lower topology of the partially ordered space α × β is homeomorphic to the product topology of
the lower topology of the partially ordered space α with the lower topology of the partially ordered
space β
-/
def lower_topology_prod_hom [order_bot α] [order_bot β] :
  with_lower_topology (α × β) ≃ₜ (α × β) :=
{ continuous_to_fun :=
  begin
    simp only [of_lower_to_lower_prod_to_lower, equiv.to_fun_as_coe, equiv.coe_refl],
    convert continuous_id,
    rw (prod.lower_topology α β).topology_eq_lower_topology,
    exact rfl,
  end,
  continuous_inv_fun :=
  begin
    simp only [of_lower_to_lower_prod_to_lower, equiv.inv_fun_as_coe, refl_symm, equiv.coe_refl],
    convert continuous_id,
    rw (prod.lower_topology α β).topology_eq_lower_topology,
    exact rfl,
  end,
  ..with_lower_topology.of_lower.trans (with_lower_topology.to_lower.prod_congr
    with_lower_topology.to_lower) }

end partial_order

section complete_lattice

variables {α} {β}

variables [complete_lattice α] [complete_lattice β]

lemma inf_hom_monotone (f : Inf_hom α β) :
monotone f := order_hom_class.mono f

variables  [topological_space α] [s : lower_topology α]
  [topological_space β] [t : lower_topology β]

include s t

lemma inf_hom_continuous (f : Inf_hom α β) :
  continuous f :=
begin
  sorry,
/-
  have e2: ∀ (s : set β), s ∈ (lower_topology.lower_basis β) → is_open (f ⁻¹' s) :=
  begin
  intros s hs,
  rw lower_topology.lower_basis at hs,
  rw mem_set_of_eq at hs,
  cases hs with a,
  cases hs_h,
  rw ← hs_h_right,
  rw ← is_closed_compl_iff,
  rw upper_set.coe_compl,
  rw preimage_compl,
  rw compl_compl,
  let p :=  Inf (f ⁻¹' Ici a),
  have e1: f ⁻¹' Ici a = Ici p :=
  begin
    rw subset_antisymm_iff,
    split,
    { intros x hx,
      rw mem_Ici,
      exact Inf_le hx, },
    { intros x hx,
      simp only [mem_preimage, mem_Ici],
      rw mem_Ici at hx,
      have p_def: p = Inf (f ⁻¹' Ici a) := rfl,
      have e1: a ≤ f(p) := begin
        rw p_def,
        simp only [map_Inf, ge_iff_le, le_Inf_iff, mem_image, mem_preimage, mem_Ici,
          forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, imp_self, forall_const],
      end,
      apply le_trans e1 (inf_hom_monotone f hx), },
  end,
  rw e1,
  exact with_lower_topology.is_closed_Ici p
  end,

  convert continuous_generated_from e2,

-/
end

end complete_lattice

end prod

section complete_lattice

variable [complete_lattice α]

/--
The inf map `(a,b) → a ⊓ b` as an Inf_hom.
-/
def inf_Inf_hom : Inf_hom (α × α) α :=
{ to_fun := λ (p : α × α), (p.fst ⊓ p.snd : α),
  map_Inf' := λ s, begin
    rw le_antisymm_iff,
    split,
    { simp only [le_Inf_iff, mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂,
        le_inf_iff],
      intros a ha,
      split,
      { exact inf_le_of_left_le (monotone_fst (Inf_le ha)), },
      { exact inf_le_of_right_le (monotone_snd (Inf_le ha)), }, },
    { rw Inf_le_iff,
      intros b hb,
      rw mem_lower_bounds at hb,
      simp only
        [mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂, le_inf_iff] at hb,
      have h₂ : (b,b) ≤ Inf s :=
      begin
        rw le_Inf_iff,
        exact hb,
      end,
      rw le_inf_iff,
      apply h₂, }
  end, }

variables [topological_space α] [s : lower_topology α]

include s

lemma lower_topology.continuous_inf: continuous (inf_Inf_hom α) :=
inf_hom_continuous (inf_Inf_hom α)

@[priority 90] -- see Note [lower instance priority]
instance lower_topology.has_continuous_inf : has_continuous_inf α :=
{ continuous_inf := lower_topology.continuous_inf α, }

end complete_lattice
