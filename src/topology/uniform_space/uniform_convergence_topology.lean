/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import topology.uniform_space.uniform_convergence
import topology.uniform_space.pi

/-!
# Topology and uniform structure of uniform convergence

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±` (in the `uniform_convergence` namespace)
- uniform convergence on a specified family `ğ”–` of sets of `Î±`
  (in the `uniform_convergence_on` namespace), also called `ğ”–`-convergence

Usual examples of the second construction include :
- the topology of compact convergence, when `ğ”–` is the set of compacts of `Î±`
- the strong topology on the dual of a TVS `E`, when `ğ”–` is the set of Von Neuman bounded subsets
  of `E`
- the weak-* topology on the dual of a TVS `E`, when `ğ”–` is the set of singletons of `E`.

## Main definitions

* `uniform_convergence.gen` : basis sets for the uniformity of uniform convergence
* `uniform_convergence.uniform_space` : uniform structure of uniform convergence
* `uniform_convergence_on.uniform_space` : uniform structure of ğ”–-convergence

## Main statements

* `uniform_convergence.uniform_continuous_eval` : evaluation is uniformly continuous
* `uniform_convergence.t2_space` : the topology of uniform convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2.
* `uniform_convergence.tendsto_iff_tendsto_uniformly` : `uniform_convergence.uniform_space` is
  indeed the uniform structure of uniform convergence

* `uniform_convergence_on.uniform_continuous_eval_of_mem` : evaluation at a point contained in a
  set of `ğ”–` is uniformly continuous
* `uniform_convergence.t2_space` : the topology of `ğ”–`-convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2 and `ğ”–` covers `Î±`
* `uniform_convergence_on.tendsto_iff_tendsto_uniformly_on` :
  `uniform_convergence_on.uniform_space` is indeed the uniform structure of `ğ”–`-convergence

## Implementation details

We do not declare these structures as instances, since they would conflict with `Pi.uniform_space`.

## TODO

* Show that the uniform structure of `ğ”–`-convergence is exactly the structure of `ğ”–'`-convergence,
  where `ğ”–'` is the bornology generated by `ğ”–`.
* Add a type synonym for `Î± â†’ Î²` endowed with the structures of uniform convergence

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]

## Tags

uniform convergence
-/


noncomputable theory
open_locale topological_space classical uniformity filter

local attribute [-instance] Pi.uniform_space

open set filter

namespace uniform_convergence

variables (Î± Î² : Type*) {Î³ Î¹ : Type*}
variables {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of uniform convergence -/
protected def gen (V : set (Î² Ã— Î²)) : set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  {uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x, (uv.1 x, uv.2 x) âˆˆ V}

variables [uniform_space Î²]

protected lemma is_basis_gen :
  is_basis (Î» V : set (Î² Ã— Î²), V âˆˆ ğ“¤ Î²) (uniform_convergence.gen Î± Î²) :=
âŸ¨âŸ¨univ, univ_memâŸ©, Î» U V hU hV, âŸ¨U âˆ© V, inter_mem hU hV, Î» uv huv,
  âŸ¨Î» x, (huv x).left, Î» x, (huv x).rightâŸ©âŸ©âŸ©

/-- Filter basis for the uniformity of uniform convergence -/
protected def uniformity_basis : filter_basis ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
(uniform_convergence.is_basis_gen Î± Î²).filter_basis

/-- Core of the uniform structure of uniform convergence -/
protected def uniform_core : uniform_space.core (Î± â†’ Î²) :=
uniform_space.core.mk_of_basis (uniform_convergence.uniformity_basis Î± Î²)
  (Î» U âŸ¨V, hV, hVUâŸ© f, hVU â–¸ Î» x, refl_mem_uniformity hV)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ âŸ¨uniform_convergence.gen Î± Î² (prod.swap â»Â¹' V),
    âŸ¨prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©, Î» uv huv x, huv xâŸ©)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV in
    âŸ¨uniform_convergence.gen Î± Î² W, âŸ¨W, hW, rflâŸ©, Î» uv âŸ¨w, huw, hwvâŸ© x, hWV
      âŸ¨w x, by exact âŸ¨huw x, hwv xâŸ©âŸ©âŸ©)

/-- Uniform structure of uniform convergence -/
protected def uniform_space : uniform_space (Î± â†’ Î²) :=
uniform_space.of_core (uniform_convergence.uniform_core Î± Î²)

protected lemma has_basis_uniformity :
  (@uniformity (Î± â†’ Î²) (uniform_convergence.uniform_space Î± Î²)).has_basis (Î» V, V âˆˆ ğ“¤ Î²)
  (uniform_convergence.gen Î± Î²) :=
(uniform_convergence.is_basis_gen Î± Î²).has_basis

protected lemma has_basis_uniformity_of_basis {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : has_basis (ğ“¤ Î²) p s) :
  (@uniformity (Î± â†’ Î²) (uniform_convergence.uniform_space Î± Î²)).has_basis p
  (Î» i, uniform_convergence.gen Î± Î² (s i)) :=
(uniform_convergence.has_basis_uniformity Î± Î²).to_has_basis
  (Î» U hU, let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU in âŸ¨i, hi, Î» uv huv x, hiU (huv x)âŸ©)
  (Î» i hi, âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©)

/-- Topology of uniform convergence -/
protected def topological_space : topological_space (Î± â†’ Î²) :=
(uniform_convergence.uniform_space Î± Î²).to_topological_space

protected lemma has_basis_nhds_of_basis {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : has_basis (ğ“¤ Î²) p s) :
  (@nhds (Î± â†’ Î²) (uniform_convergence.topological_space Î± Î²) f).has_basis p
  (Î» i, {g | (g, f) âˆˆ uniform_convergence.gen Î± Î² (s i)}) :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence.uniform_space Î± Î²,
  exact nhds_basis_uniformity (uniform_convergence.has_basis_uniformity_of_basis Î± Î² h)
end

protected lemma has_basis_nhds :
  (@nhds (Î± â†’ Î²) (uniform_convergence.topological_space Î± Î²) f).has_basis (Î» V, V âˆˆ ğ“¤ Î²)
  (Î» V, {g | (g, f) âˆˆ uniform_convergence.gen Î± Î² V}) :=
uniform_convergence.has_basis_nhds_of_basis  Î± Î² (filter.basis_sets _)

variables {Î±}

lemma uniform_continuous_eval (x : Î±) : @uniform_continuous _ _
  (uniform_convergence.uniform_space Î± Î²) _ (function.eval x) :=
begin
  change _ â‰¤ _,
  rw [map_le_iff_le_comap,
      (uniform_convergence.has_basis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)],
  exact Î» U hU, âŸ¨U, hU, Î» uv huv, huv xâŸ©
end

variables {Î²}

lemma t2_space [t2_space Î²] : @t2_space _ (uniform_convergence.topological_space Î± Î²) :=
{ t2 :=
  begin
    letI : uniform_space (Î± â†’ Î²) := uniform_convergence.uniform_space Î± Î²,
    letI : topological_space (Î± â†’ Î²) := uniform_convergence.topological_space Î± Î²,
    intros f g h,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext h),
    exact separated_by_continuous (uniform_continuous_eval Î² x).continuous hx
  end }

protected lemma le_Pi : uniform_convergence.uniform_space Î± Î² â‰¤ Pi.uniform_space (Î» _, Î²) :=
begin
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  exact uniform_continuous_eval Î² x
end

protected lemma tendsto_iff_tendsto_uniformly :
  tendsto F p (@nhds _ (uniform_convergence.topological_space Î± Î²) f) â†”
  tendsto_uniformly F f p :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence.uniform_space Î± Î²,
  rw [(uniform_convergence.has_basis_nhds Î± Î²).tendsto_right_iff, tendsto_uniformly],
  split;
  { intros h U hU,
    filter_upwards [h (prod.swap â»Â¹' U) (tendsto_swap_uniformity hU)],
    exact Î» n, id }
end

variable {Î±}

end uniform_convergence

namespace uniform_convergence_on

variables (Î± Î² : Type*) {Î³ Î¹ : Type*} [uniform_space Î²] (ğ”– : set (set Î±))
variables {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

protected def gen (S : set Î±) (V : set (Î² Ã— Î²)) : set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  {uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x âˆˆ S, (uv.1 x, uv.2 x) âˆˆ V}

protected lemma is_basis_gen (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  is_basis (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, uniform_convergence_on.gen Î± Î² SV.1 SV.2) :=
âŸ¨âŸ¨âŸ¨h.some, univâŸ©, âŸ¨h.some_spec, univ_memâŸ©âŸ©, Î» Uâ‚Vâ‚ Uâ‚‚Vâ‚‚ hâ‚ hâ‚‚,
  let âŸ¨Uâ‚ƒ, hâ‚ƒ, hâ‚â‚ƒ, hâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1 in âŸ¨âŸ¨Uâ‚ƒ, Uâ‚Vâ‚.2 âˆ© Uâ‚‚Vâ‚‚.2âŸ©,
  âŸ¨âŸ¨hâ‚ƒ, inter_mem hâ‚.2 hâ‚‚.2âŸ©, Î» uv huv, âŸ¨Î» x hx, (huv x (hâ‚â‚ƒ hx)).1, Î» x hx, (huv x (hâ‚‚â‚ƒ hx)).2âŸ©âŸ©âŸ©âŸ©

/-- Uniform structure of uniform convergence on the sets of `ğ”–`. -/
protected def uniform_space : uniform_space (Î± â†’ Î²) :=
â¨… (s : set Î±) (hs : s âˆˆ ğ”–), uniform_space.comap (Î» f, s.restrict f)
  (uniform_convergence.uniform_space s Î²)

/-- Topology of uniform convergence on the sets of `ğ”–`. -/
protected def topological_space : topological_space (Î± â†’ Î²) :=
(uniform_convergence_on.uniform_space Î± Î² ğ”–).to_topological_space

protected lemma topological_space_eq :
  uniform_convergence_on.topological_space Î± Î² ğ”– = â¨… (s : set Î±) (hs : s âˆˆ ğ”–),
  topological_space.induced (Î» f, s.restrict f) (uniform_convergence.topological_space s Î²) :=
begin
  simp only [uniform_convergence_on.topological_space, to_topological_space_infi,
    to_topological_space_infi, to_topological_space_comap],
  refl
end

protected lemma uniformity_eq_gen (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  @uniformity (Î± â†’ Î²) (uniform_convergence_on.uniform_space Î± Î² ğ”–) =
  (uniform_convergence_on.is_basis_gen Î± Î² ğ”– h h').filter :=
begin
  simp_rw [infi_uniformity', uniformity_comap rfl],
  refine le_antisymm _ _,
  { rw [is_basis.filter_eq_generate, sets_iff_generate],
    rintros uv âŸ¨âŸ¨U, VâŸ©, âŸ¨hU, hVâŸ©, rflâŸ©,
    exact mem_infi_of_mem U (mem_infi_of_mem hU âŸ¨uniform_convergence.gen U Î² V,
      (uniform_convergence.has_basis_uniformity U Î²).mem_of_mem hV, Î» uv huv x hx, huv âŸ¨x, hxâŸ©âŸ©) },
  { refine (le_infi $ Î» S, le_infi $ Î» hS, _),
    rw [â† map_le_iff_le_comap, (uniform_convergence.has_basis_uniformity S Î²).ge_iff],
    exact Î» V hV, âŸ¨uniform_convergence_on.gen Î± Î² S V, âŸ¨âŸ¨S, VâŸ©, âŸ¨âŸ¨hS, hVâŸ©, rflâŸ©âŸ©,
      Î» uv huv x, huv x.1 x.2âŸ© }
end

protected lemma has_basis_uniformity (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  (@uniformity (Î± â†’ Î²) (uniform_convergence_on.uniform_space Î± Î² ğ”–)).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, uniform_convergence_on.gen Î± Î² SV.1 SV.2) :=
begin
  rw uniform_convergence_on.uniformity_eq_gen Î± Î² ğ”– h h',
  exact is_basis.has_basis _
end

protected lemma has_basis_uniformity_of_basis (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (@uniformity (Î± â†’ Î²) (uniform_convergence_on.uniform_space Î± Î² ğ”–)).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”– âˆ§ p Si.2)
    (Î» Si, uniform_convergence_on.gen Î± Î² Si.1 (s Si.2)) :=
(uniform_convergence_on.has_basis_uniformity Î± Î² ğ”– h h').to_has_basis
  (Î» UV hUV, let âŸ¨i, hi, hiVâŸ© := hb.mem_iff.mp hUV.2 in
    âŸ¨âŸ¨UV.1, iâŸ©, âŸ¨hUV.1, hiâŸ©, Î» uv huv x hx, hiV (huv x hx)âŸ©)
  (Î» Si hSi, âŸ¨âŸ¨Si.1, s Si.2âŸ©, âŸ¨hSi.1, hb.mem_of_mem hSi.2âŸ©, subset_refl _âŸ©)

protected lemma has_basis_nhds_of_basis (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (@nhds (Î± â†’ Î²) (uniform_convergence_on.topological_space Î± Î² ğ”–) f).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”– âˆ§ p Si.2)
    (Î» Si, {g | (g, f) âˆˆ uniform_convergence_on.gen Î± Î² Si.1 (s Si.2)}) :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
  exact nhds_basis_uniformity (uniform_convergence_on.has_basis_uniformity_of_basis Î± Î² ğ”– h h' hb)
end

protected lemma has_basis_nhds (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  (@nhds (Î± â†’ Î²) (uniform_convergence_on.topological_space Î± Î² ğ”–) f).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, {g | (g, f) âˆˆ uniform_convergence_on.gen Î± Î² SV.1 SV.2}) :=
uniform_convergence_on.has_basis_nhds_of_basis Î± Î² ğ”– h h' (filter.basis_sets _)

protected lemma uniform_continuous_restrict (h : s âˆˆ ğ”–) :
  @uniform_continuous _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–)
  (uniform_convergence.uniform_space s Î²) s.restrict :=
begin
  change _ â‰¤ _,
  rw [uniform_convergence_on.uniform_space, map_le_iff_le_comap, uniformity, infi_uniformity],
  refine infi_le_of_le s _,
  rw infi_uniformity,
  exact infi_le _ h,
end

protected lemma uniform_space_antitone : antitone (uniform_convergence_on.uniform_space Î± Î²) :=
Î» ğ”–â‚ ğ”–â‚‚ hâ‚â‚‚, infi_le_infi_of_subset hâ‚â‚‚

variables {Î±}

lemma uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :
  @uniform_continuous _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–) _ (function.eval x) :=
begin
  change _ â‰¤ _,
  rw [map_le_iff_le_comap, ((ğ“¤ _).basis_sets.comap _).ge_iff,
      uniform_convergence_on.uniform_space, infi_uniformity'],
  intros U hU,
  refine mem_infi_of_mem s _,
  rw infi_uniformity',
  exact mem_infi_of_mem hs (mem_comap.mpr
    âŸ¨ uniform_convergence.gen s Î² U,
      (uniform_convergence.has_basis_uniformity s Î²).mem_of_mem hU,
      Î» uv huv, huv âŸ¨x, hxsâŸ© âŸ©)
end

variables {Î²}

lemma t2_space_of_covering [t2_space Î²] (h : â‹ƒâ‚€ ğ”– = univ) :
  @t2_space _ (uniform_convergence_on.topological_space Î± Î² ğ”–) :=
{ t2 :=
  begin
    letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
    letI : topological_space (Î± â†’ Î²) := uniform_convergence_on.topological_space Î± Î² ğ”–,
    intros f g hfg,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg),
    obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ true.intro),
    exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ğ”– hxs hs).continuous hx
  end }

protected lemma le_Pi_of_covering (h : â‹ƒâ‚€ ğ”– = univ) :
  uniform_convergence_on.uniform_space Î± Î² ğ”– â‰¤ Pi.uniform_space (Î» _, Î²) :=
begin
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ true.intro),
  exact uniform_continuous_eval_of_mem Î² ğ”– hxs hs
end

protected lemma tendsto_iff_tendsto_uniformly_on :
  tendsto F p (@nhds _ (uniform_convergence_on.topological_space Î± Î² ğ”–) f) â†”
  âˆ€ s âˆˆ ğ”–, tendsto_uniformly_on F f p s :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
  rw [uniform_convergence_on.topological_space_eq, nhds_infi, tendsto_infi],
  refine forall_congr (Î» s, _),
  rw [nhds_infi, tendsto_infi],
  refine forall_congr (Î» hs, _),
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
      uniform_convergence.tendsto_iff_tendsto_uniformly],
  refl
end

end uniform_convergence_on
