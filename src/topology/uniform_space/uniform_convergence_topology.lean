/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import topology.uniform_space.uniform_convergence
import topology.uniform_space.pi
import topology.uniform_space.equiv

/-!
# Topology and uniform structure of uniform convergence

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±`
- uniform convergence on a specified family `ğ”–` of sets of `Î±`, also called `ğ”–`-convergence

Since `Î± â†’ Î²` is already endowed with the topologies and uniform structures of pointwise
convergence, we introduce type aliases `uniform_fun Î± Î²` (denoted `Î± â†’áµ¤ Î²`) and
`uniform_on_fun Î± Î² ğ”–` (denoted `Î± â†’áµ¤[ğ”–] Î²`) and we actually endow *these* with the structures
of uniform and `ğ”–`-convergence respectively.

Usual examples of the second construction include :
- the topology of compact convergence, when `ğ”–` is the set of compacts of `Î±`
- the strong topology on the dual of a topological vector space (TVS) `E`, when `ğ”–` is the set of
  Von Neuman bounded subsets of `E`
- the weak-* topology on the dual of a TVS `E`, when `ğ”–` is the set of singletons of `E`.

This file contains a lot of technical facts, so it is heavily commented, proofs included!

## Main definitions

* `uniform_fun.gen`: basis sets for the uniformity of uniform convergence. These are sets
  of the form `S(V) := {(f, g) | âˆ€ x : Î±, (f x, g x) âˆˆ V}` for some `V : set (Î² Ã— Î²)`
* `uniform_fun.uniform_space`: uniform structure of uniform convergence. This is the
  `uniform_space` on `Î± â†’áµ¤ Î²` whose uniformity is generated by the sets `S(V)` for `V âˆˆ ğ“¤ Î²`.
  We will denote this uniform space as `ğ’°(Î±, Î², uÎ²)`, both in the comments and as a local notation
  in the Lean code, where `uÎ²` is the uniform space structure on `Î²`.
  This is declared as an instance on `Î± â†’áµ¤ Î²`.
* `uniform_on_fun.uniform_space`: uniform structure of `ğ”–`-convergence, where
  `ğ”– : set (set Î±)`. This is the infimum, for `S âˆˆ ğ”–`, of the pullback of `ğ’° S Î²` by the map of
  restriction to `S`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform space structure
  on `Î²`.
  This is declared as an instance on `Î± â†’áµ¤[ğ”–] Î²`.

## Main statements

### Basic properties

* `uniform_fun.uniform_continuous_eval`: evaluation is uniformly continuous on `Î± â†’áµ¤ Î²`.
* `uniform_fun.t2_space`: the topology of uniform convergence on `Î± â†’áµ¤ Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚.
* `uniform_fun.tendsto_iff_tendsto_uniformly`: `ğ’°(Î±, Î², uÎ²)` is
  indeed the uniform structure of uniform convergence
* `uniform_on_fun.uniform_continuous_eval_of_mem`: evaluation at a point contained in a
  set of `ğ”–` is uniformly continuous on `Î± â†’áµ¤[ğ”–] Î²`
* `uniform_on_fun.t2_space_of_covering`: the topology of `ğ”–`-convergence on `Î± â†’áµ¤[ğ”–] Î²` is Tâ‚‚ if
  `Î²` is Tâ‚‚ and `ğ”–` covers `Î±`
* `uniform_on_fun.tendsto_iff_tendsto_uniformly_on`:
  `ğ’±(Î±, Î², ğ”– uÎ²)` is indeed the uniform structure of `ğ”–`-convergence

### Functoriality and compatibility with product of uniform spaces

In order to avoid the need for filter bases as much as possible when using these definitions,
we develop an extensive API for manipulating these structures abstractly. As usual in the topology
section of mathlib, we first state results about the complete lattices of `uniform_space`s on
fixed types, and then we use these to deduce categorical-like results about maps between two
uniform spaces.

We only describe these in the harder case of `ğ”–`-convergence, as the names of the corresponding
results for uniform convergence can easily be guessed.

#### Order statements

* `uniform_on_fun.mono`: let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and
  `ğ”–â‚ ğ”–â‚‚ : set (set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and `ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`.
* `uniform_on_fun.infi_eq`: if `u` is a family of uniform structures on `Î³`, then
  `ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`.
* `uniform_on_fun.comap_eq`: if `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
  `ğ’±(Î±, Î³, ğ”–, comap f u) = comap (Î» g, f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`.

An interesting note about these statements is that they are proved without ever unfolding the basis
definition of the uniform structure of uniform convergence! Instead, we build a
(not very interesting) Galois connection `uniform_convergence.gc` and then rely on the Galois
connection API to do most of the work.

#### Morphism statements (unbundled)

* `uniform_on_fun.postcomp_uniform_continuous`: if `f : Î³ â†’ Î²` is uniformly
  continuous, then `(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous.
* `uniform_on_fun.postcomp_uniform_inducing`: if `f : Î³ â†’ Î²` is a uniform
  inducing, then `(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing.
* `uniform_on_fun.precomp_uniform_continuous`: let `f : Î³ â†’ Î±`, `ğ”– : set (set Î±)`,
  `ğ”— : set (set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`. Then, the function
  `(Î» g, g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.

#### Isomorphism statements (bundled)

* `uniform_on_fun.congr_right`: turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism
  `(Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by post-composing.
* `uniform_on_fun.congr_left`: turn a bijection `e : Î³ â‰ƒ Î±` such that we have both
  `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and `âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism
  `(Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by pre-composing.
* `uniform_on_fun.uniform_equiv_Pi_comm`: the natural bijection between `Î± â†’ Î  i, Î´ i`
  and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform isomorphism between `Î± â†’áµ¤[ğ”–] (Î  i, Î´ i)` and
  `Î  i, Î± â†’áµ¤[ğ”–] Î´ i`.

#### Important use cases

* If `G` is a uniform group, then `Î± â†’áµ¤[ğ”–] G` is a uniform group: since `(/) : G Ã— G â†’ G` is
  uniformly continuous, `uniform_convergence_on.postcomp_uniform_continuous` tells us that
  `((/) âˆ˜ â€”) : (Î± â†’áµ¤[ğ”–] G Ã— G) â†’ (Î± â†’áµ¤[ğ”–] G)` is uniformly continuous. By precomposing with
  `uniform_convergence_on.uniform_equiv_prod_arrow`, this gives that
  `(/) : (Î± â†’áµ¤[ğ”–] G) Ã— (Î± â†’áµ¤[ğ”–] G) â†’ (Î± â†’áµ¤[ğ”–] G)` is also uniformly continuous
* The transpose of a continuous linear map is continuous for the strong topologies: since
  continuous linear maps are uniformly continuous and map bounded sets to bounded sets,
  this is just a special case of `uniform_convergence_on.precomp_uniform_continuous`.

## References

* [N. Bourbaki, *General Topology, Chapter X*][bourbaki1966]

## Tags

uniform convergence
-/

noncomputable theory
open_locale topology classical uniformity filter

open set filter topological_space

section type_alias

/-- The type of functions from `Î±` to `Î²` equipped with the uniform structure and topology of
uniform convergence. We denote it `Î± â†’áµ¤ Î²`. -/
def uniform_fun (Î± Î² : Type*) := Î± â†’ Î²

/-- The type of functions from `Î±` to `Î²` equipped with the uniform structure and topology of
uniform convergence on some family `ğ”–` of subsets of `Î±`. We denote it `Î± â†’áµ¤[ğ”–] Î²`. -/
@[nolint unused_arguments]
def uniform_on_fun (Î± Î² : Type*) (ğ”– : set (set Î±)) := Î± â†’ Î²

localized "notation Î± ` â†’áµ¤ `:25 Î²:0 := uniform_fun Î± Î²" in uniform_convergence
localized "notation Î± ` â†’áµ¤[`:25 ğ”– `] `:0 Î²:0 := uniform_on_fun Î± Î² ğ”–" in uniform_convergence
localized "notation `Î»áµ˜` binders `, ` r:(scoped p, uniform_fun.of_fun p) := r"
  in uniform_convergence
localized "notation `Î»áµ˜[` ğ”– `] ` binders `, ` r:(scoped p, uniform_fun.of_fun p) := r"
  in uniform_convergence

instance {Î± Î²} [nonempty Î²] : nonempty (Î± â†’áµ¤ Î²) := pi.nonempty
instance {Î± Î² ğ”–} [nonempty Î²] : nonempty (Î± â†’áµ¤[ğ”–] Î²) := pi.nonempty

/-- Reinterpret `f : Î± â†’ Î²` as an element of `Î± â†’áµ¤ Î²`. -/
def uniform_fun.of_fun {Î± Î²} : (Î± â†’ Î²) â‰ƒ (Î± â†’áµ¤ Î²) := âŸ¨Î» x, x, Î» x, x, Î» x, rfl, Î» x, rflâŸ©

/-- Reinterpret `f : Î± â†’ Î²` as an element of `Î± â†’áµ¤[ğ”–] Î²`. -/
def uniform_on_fun.of_fun {Î± Î²} (ğ”–) : (Î± â†’ Î²) â‰ƒ (Î± â†’áµ¤[ğ”–] Î²) := âŸ¨Î» x, x, Î» x, x, Î» x, rfl, Î» x, rflâŸ©

/-- Reinterpret `f : Î± â†’áµ¤ Î²` as an element of `Î± â†’ Î²`. -/
def uniform_fun.to_fun {Î± Î²} : (Î± â†’áµ¤ Î²) â‰ƒ (Î± â†’ Î²) := uniform_fun.of_fun.symm

/-- Reinterpret `f : Î± â†’áµ¤[ğ”–] Î²` as an element of `Î± â†’ Î²`. -/
def uniform_on_fun.to_fun {Î± Î²} (ğ”–) : (Î± â†’áµ¤[ğ”–] Î²) â‰ƒ (Î± â†’ Î²) := (uniform_on_fun.of_fun ğ”–).symm

-- Note: we don't declare a `has_coe_to_fun` instance because Lean wouldn't insert it when writing
-- `f x` (because of definitional equality with `Î± â†’ Î²`).

end type_alias

open_locale uniform_convergence

namespace uniform_fun

variables (Î± Î² : Type*) {Î³ Î¹ : Type*}
variables {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of uniform convergence: `gen Î± Î² V` is the set of pairs `(f, g)`
of functions `Î± â†’áµ¤ Î²` such that `âˆ€ x, (f x, g x) âˆˆ V`. -/
protected def gen (V : set (Î² Ã— Î²)) : set ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
  {uv : (Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²) | âˆ€ x, (uv.1 x, uv.2 x) âˆˆ V}

/-- If `ğ“•` is a filter on `Î² Ã— Î²`, then the set of all `uniform_convergence.gen Î± Î² V` for
`V âˆˆ ğ“•` is a filter basis on `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)`. This will only be applied to `ğ“• = ğ“¤ Î²` when
`Î²` is equipped with a `uniform_space` structure, but it is useful to define it for any filter in
order to be able to state that it has a lower adjoint (see `uniform_convergence.gc`). -/
protected lemma is_basis_gen (ğ“‘ : filter $ Î² Ã— Î²) :
  is_basis (Î» V : set (Î² Ã— Î²), V âˆˆ ğ“‘) (uniform_fun.gen Î± Î²) :=
âŸ¨âŸ¨univ, univ_memâŸ©, Î» U V hU hV, âŸ¨U âˆ© V, inter_mem hU hV, Î» uv huv,
  âŸ¨Î» x, (huv x).left, Î» x, (huv x).rightâŸ©âŸ©âŸ©

/-- For `ğ“• : filter (Î² Ã— Î²)`, this is the set of all `uniform_convergence.gen Î± Î² V` for
`V âˆˆ ğ“•` as a bundled `filter_basis` over `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)`. This will only be applied to
`ğ“• = ğ“¤ Î²` when `Î²` is equipped with a `uniform_space` structure, but it is useful to define it for
any filter in order to be able to state that it has a lower adjoint
(see `uniform_convergence.gc`). -/
protected def basis (ğ“• : filter $ Î² Ã— Î²) : filter_basis ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
(uniform_fun.is_basis_gen Î± Î² ğ“•).filter_basis

/-- For `ğ“• : filter (Î² Ã— Î²)`, this is the filter generated by the filter basis
`uniform_convergence.basis Î± Î² ğ“•`. For `ğ“• = ğ“¤ Î²`, this will be the uniformity of uniform
convergence on `Î±`. -/
protected def filter (ğ“• : filter $ Î² Ã— Î²) : filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) :=
(uniform_fun.basis Î± Î² ğ“•).filter

local notation `Î¦` :=
Î» (Î± Î² : Type*) (uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î±), (uvx.1.1 uvx.2, uvx.1.2 uvx.2)

/- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).
The exact definition of the lower adjoint `l` is not interesting; we will only use that it exists
(in `uniform_convergence.mono` and `uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/
local notation `lower_adjoint` :=
Î» ğ“, map (Î¦ Î± Î²) (ğ“ Ã—á¶  âŠ¤)

/-- The function `uniform_convergence.filter Î± Î² : filter (Î² Ã— Î²) â†’ filter ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²))`
has a lower adjoint `l` (in the sense of `galois_connection`). The exact definition of `l` is not
interesting; we will only use that it exists (in `uniform_convergence.mono` and
`uniform_convergence.infi_eq`) and that
`l (filter.map (prod.map f f) ğ“•) = filter.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) (l ğ“•)` for each
`ğ“• : filter (Î³ Ã— Î³)` and `f : Î³ â†’ Î±` (in `uniform_convergence.comap_eq`). -/
protected lemma gc : galois_connection lower_adjoint
  (Î» ğ“•, uniform_fun.filter Î± Î² ğ“•) :=
begin
  intros ğ“ ğ“•,
  symmetry,
  calc ğ“ â‰¤ uniform_fun.filter Î± Î² ğ“•
      â†” (uniform_fun.basis Î± Î² ğ“•).sets âŠ† ğ“.sets :
        by rw [uniform_fun.filter, â† filter_basis.generate, sets_iff_generate]
  ... â†” âˆ€ U âˆˆ ğ“•, uniform_fun.gen Î± Î² U âˆˆ ğ“ : image_subset_iff
  ... â†” âˆ€ U âˆˆ ğ“•, {uv | âˆ€ x, (uv, x) âˆˆ
          {t : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U}} âˆˆ ğ“ : iff.rfl
  ... â†” âˆ€ U âˆˆ ğ“•, {uvx : ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î²)) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U} âˆˆ
          ğ“ Ã—á¶  (âŠ¤ : filter Î±) : forallâ‚‚_congr (Î» U hU, mem_prod_top.symm)
  ... â†” lower_adjoint ğ“ â‰¤ ğ“• : iff.rfl,
end

variables [uniform_space Î²]

/-- Core of the uniform structure of uniform convergence. -/
protected def uniform_core : uniform_space.core (Î± â†’áµ¤ Î²) :=
uniform_space.core.mk_of_basis (uniform_fun.basis Î± Î² (ğ“¤ Î²))
  (Î» U âŸ¨V, hV, hVUâŸ© f, hVU â–¸ Î» x, refl_mem_uniformity hV)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ âŸ¨uniform_fun.gen Î± Î² (prod.swap â»Â¹' V),
    âŸ¨prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©, Î» uv huv x, huv xâŸ©)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV in
    âŸ¨uniform_fun.gen Î± Î² W, âŸ¨W, hW, rflâŸ©, Î» uv âŸ¨w, huw, hwvâŸ© x, hWV
      âŸ¨w x, by exact âŸ¨huw x, hwv xâŸ©âŸ©âŸ©)

/-- Uniform structure of uniform convergence, declared as an instance on `Î± â†’áµ¤ Î²`.
We will denote it `ğ’°(Î±, Î², uÎ²)` in the rest of this file. -/
instance : uniform_space (Î± â†’áµ¤ Î²) :=
uniform_space.of_core (uniform_fun.uniform_core Î± Î²)

/-- Topology of uniform convergence, declared as an instance on `Î± â†’áµ¤ Î²`. -/
instance : topological_space (Î± â†’áµ¤ Î²) := infer_instance

local notation `ğ’°(`Î±`, `Î²`, `u`)` := @uniform_fun.uniform_space Î± Î² u

/-- By definition, the uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}`
for `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected lemma has_basis_uniformity :
  (ğ“¤ (Î± â†’áµ¤ Î²)).has_basis (Î» V, V âˆˆ ğ“¤ Î²)
  (uniform_fun.gen Î± Î²) :=
(uniform_fun.is_basis_gen Î± Î² (ğ“¤ Î²)).has_basis

/-- The uniformity of `Î± â†’áµ¤ Î²` admits the family `{(f, g) | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as
a filter basis, for any basis `ğ“‘` of `ğ“¤ Î²` (in the case `ğ“‘ = (ğ“¤ Î²).as_basis` this is true by
definition). -/
protected lemma has_basis_uniformity_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : (ğ“¤ Î²).has_basis p s) :
  (ğ“¤ (Î± â†’áµ¤ Î²)).has_basis p (uniform_fun.gen Î± Î² âˆ˜ s) :=
(uniform_fun.has_basis_uniformity Î± Î²).to_has_basis
  (Î» U hU, let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU in âŸ¨i, hi, Î» uv huv x, hiU (huv x)âŸ©)
  (Î» i hi, âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©)

/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“‘` as a filter
basis, for any basis `ğ“‘` of `ğ“¤ Î²`. -/
protected lemma has_basis_nhds_of_basis (f) {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : has_basis (ğ“¤ Î²) p s) :
  (ğ“ f).has_basis p (Î» i, {g | (f, g) âˆˆ uniform_fun.gen Î± Î² (s i)}) :=
nhds_basis_uniformity' (uniform_fun.has_basis_uniformity_of_basis Î± Î² h)

/-- For `f : Î± â†’áµ¤ Î²`, `ğ“ f` admits the family `{g | âˆ€ x, (f x, g x) âˆˆ V}` for `V âˆˆ ğ“¤ Î²` as a
filter basis. -/
protected lemma has_basis_nhds (f) :
  (ğ“ f).has_basis (Î» V, V âˆˆ ğ“¤ Î²) (Î» V, {g | (f, g) âˆˆ uniform_fun.gen Î± Î² V}) :=
uniform_fun.has_basis_nhds_of_basis Î± Î² f (filter.basis_sets _)

instance is_countably_generated_uniformity [(ğ“¤ Î²).is_countably_generated] :
  (ğ“¤ $ Î± â†’áµ¤ Î²).is_countably_generated :=
begin
  rcases (ğ“¤ Î²).exists_antitone_basis with âŸ¨s, s_basis, -âŸ©,
  exact filter.has_countable_basis.is_countably_generated
    âŸ¨uniform_fun.has_basis_uniformity_of_basis Î± Î² s_basis, countable_univâŸ©,
end

variables {Î±}

/-- Evaluation at a fixed point is uniformly continuous on `Î± â†’áµ¤ Î²`. -/
lemma uniform_continuous_eval (x : Î±) :
  uniform_continuous (function.eval x âˆ˜ to_fun : (Î± â†’áµ¤ Î²) â†’ Î²) :=
begin
  change _ â‰¤ _,
  rw [map_le_iff_le_comap,
      (uniform_fun.has_basis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)],
  exact Î» U hU, âŸ¨U, hU, Î» uv huv, huv xâŸ©
end

variables {Î²}

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³` and `uâ‚ â‰¤ uâ‚‚`, then
`ğ’°(Î±, Î³, uâ‚) â‰¤ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected lemma mono : monotone (@uniform_fun.uniform_space Î± Î³) :=
Î» uâ‚ uâ‚‚ hu, (uniform_fun.gc Î± Î³).monotone_u hu

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’°(Î±, Î³, (â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i)`. -/
protected lemma infi_eq {u : Î¹ â†’ uniform_space Î³} :
  (ğ’°(Î±, Î³, â¨… i, u i)) = â¨… i, ğ’°(Î±, Î³, u i) :=
begin
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  ext : 1,
  change uniform_fun.filter Î± Î³ (ğ“¤[â¨… i, u i]) = ğ“¤[â¨… i, ğ’°(Î±, Î³, u i)],
  rw [infi_uniformity, infi_uniformity],
  exact (uniform_fun.gc Î± Î³).u_infi
end

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚) = ğ’°(Î±, Î³, uâ‚) âŠ“ ğ’°(Î±, Î³, uâ‚‚)`. -/
protected lemma inf_eq {uâ‚ uâ‚‚ : uniform_space Î³} :
  (ğ’°(Î±, Î³, uâ‚ âŠ“ uâ‚‚)) = (ğ’°(Î±, Î³, uâ‚)) âŠ“ (ğ’°(Î±, Î³, uâ‚‚)) :=
begin
  -- This follows directly from the fact that the upper adjoint in a Galois connection maps
  -- infimas to infimas.
  rw [inf_eq_infi, inf_eq_infi, uniform_fun.infi_eq],
  refine infi_congr (Î» i, _),
  cases i; refl
end

/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’°(Î±, Î³, comap f u) = comap (Î» g, f âˆ˜ g) ğ’°(Î±, Î³, uâ‚)`. -/
protected lemma comap_eq {f : Î³ â†’ Î²} :
  (ğ’°(Î±, Î³, â€¹uniform_space Î²â€º.comap f)) = (ğ’°(Î±, Î², _)).comap ((âˆ˜) f) :=
begin
  letI : uniform_space Î³ := â€¹uniform_space Î²â€º.comap f,
  ext : 1,
  change (uniform_fun.filter Î± Î³ ((ğ“¤ Î²).comap _)) =
    (uniform_fun.filter Î± Î² ((ğ“¤ Î²))).comap _,
  -- We have the following four Galois connection which form a square diagram, and we want
  -- to show that the square of upper adjoints is commutative. The trick then is to use
  -- `galois_connection.u_comm_of_l_comm` to reduce it to commutativity of the lower adjoints,
  -- which is way easier to prove.
  have hâ‚ := filter.gc_map_comap (prod.map ((âˆ˜) f) ((âˆ˜) f)),
  have hâ‚‚ := filter.gc_map_comap (prod.map f f),
  have hâ‚ƒ := uniform_fun.gc Î± Î²,
  have hâ‚„ := uniform_fun.gc Î± Î³,
  refine galois_connection.u_comm_of_l_comm hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ (Î» ğ“, _),
  have : prod.map f f âˆ˜ (Î¦ Î± Î³) =
    (Î¦ Î± Î²) âˆ˜ prod.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) id,
  { ext; refl },
  rw [map_comm this, â† prod_map_map_eq'],
  refl
end

/-- Post-composition by a uniformly continuous function is uniformly continuous on `Î± â†’áµ¤ Î²`.

More precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then `(Î» g, f âˆ˜ g) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)`
is uniformly continuous. -/
protected lemma postcomp_uniform_continuous [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_continuous f):
  uniform_continuous (of_fun âˆ˜ ((âˆ˜) f) âˆ˜ to_fun : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
uniform_continuous_iff.mpr $
calc ğ’°(Î±, Î³, _)
    â‰¤ ğ’°(Î±, Î³, â€¹uniform_space Î²â€º.comap f) :
      uniform_fun.mono (uniform_continuous_iff.mp hf)
... = (ğ’°(Î±, Î², _)).comap ((âˆ˜) f) :
      uniform_fun.comap_eq

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of uniform convergence.

More precisely, if `f : Î³ â†’ Î²` is a uniform inducing, then `(Î» g, f âˆ˜ g) : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)` is
a uniform inducing. -/
protected lemma postcomp_uniform_inducing [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_inducing f):
  uniform_inducing (of_fun âˆ˜ ((âˆ˜) f) âˆ˜ to_fun : (Î± â†’áµ¤ Î³) â†’ (Î± â†’áµ¤ Î²)) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
begin
  split,
  replace hf : (ğ“¤ Î²).comap (prod.map f f) = _ := hf.comap_uniformity,
  change comap (prod.map (of_fun âˆ˜ (âˆ˜) f âˆ˜ to_fun) (of_fun âˆ˜ (âˆ˜) f âˆ˜ to_fun)) _ = _,
  rw [â† uniformity_comap] at âŠ¢ hf,
  congr,
  rw [â† uniform_space_eq hf, uniform_fun.comap_eq],
  refl
end

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism `(Î± â†’áµ¤ Î³) â‰ƒáµ¤ (Î± â†’áµ¤ Î²)` by
post-composing. -/
protected def congr_right [uniform_space Î³] (e : Î³ â‰ƒáµ¤ Î²) :
  (Î± â†’áµ¤ Î³) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) :=
{ uniform_continuous_to_fun :=
    uniform_fun.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_fun.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (Î» a, e.to_equiv) }

/-- Pre-composition by a any function is uniformly continuous for the uniform structures of
uniform convergence.

More precisely, for any `f : Î³ â†’ Î±`, the function `(Î» g, g âˆ˜ f) : (Î± â†’áµ¤ Î²) â†’ (Î³ â†’áµ¤ Î²)` is uniformly
continuous. -/
protected lemma precomp_uniform_continuous {f : Î³ â†’ Î±} :
  uniform_continuous (Î» g : Î± â†’áµ¤ Î², of_fun (g âˆ˜ f)) :=
begin
  -- Here we simply go back to filter bases.
  rw uniform_continuous_iff,
  change ğ“¤ (Î± â†’áµ¤ Î²) â‰¤ (ğ“¤ (Î³ â†’áµ¤ Î²)).comap (prod.map (Î» g : Î± â†’áµ¤ Î², g âˆ˜ f) (Î» g : Î± â†’áµ¤ Î², g âˆ˜ f)),
  rw (uniform_fun.has_basis_uniformity Î± Î²).le_basis_iff
    ((uniform_fun.has_basis_uniformity Î³ Î²).comap _),
  exact Î» U hU, âŸ¨U, hU, Î» uv huv x, huv (f x)âŸ©
end

/-- Turn a bijection `Î³ â‰ƒ Î±` into a uniform isomorphism
`(Î³ â†’áµ¤ Î²) â‰ƒáµ¤ (Î± â†’áµ¤ Î²)` by pre-composing. -/
protected def congr_left (e : Î³ â‰ƒ Î±) :
  (Î³ â†’áµ¤ Î²) â‰ƒáµ¤ (Î± â†’áµ¤ Î²) :=
{ uniform_continuous_to_fun :=
    uniform_fun.precomp_uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_fun.precomp_uniform_continuous,
  .. equiv.arrow_congr e (equiv.refl _) }

/-- The topology of uniform convergence is Tâ‚‚. -/
instance [t2_space Î²] : t2_space (Î± â†’áµ¤ Î²) :=
{ t2 :=
  begin
    intros f g h,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext h),
    exact separated_by_continuous (uniform_continuous_eval Î² x).continuous hx
  end }

/-- The natural map `uniform_fun.to_fun` from `Î± â†’áµ¤ Î²` to `Î± â†’ Î²` is uniformly continuous.

In other words, the uniform structure of uniform convergence is finer than that of pointwise
convergence, aka the product uniform structure. -/
protected lemma uniform_continuous_to_fun : uniform_continuous (to_fun : (Î± â†’áµ¤ Î²) â†’ Î± â†’ Î²) :=
begin
  -- By definition of the product uniform structure, this is just `uniform_continuous_eval`.
  rw uniform_continuous_pi,
  intros x,
  exact uniform_continuous_eval Î² x
end

/-- The topology of uniform convergence indeed gives the same notion of convergence as
`tendsto_uniformly`. -/
protected lemma tendsto_iff_tendsto_uniformly {F : Î¹ â†’ Î± â†’áµ¤ Î²} {f : Î± â†’áµ¤ Î²} :
  tendsto F p (ğ“ f) â†” tendsto_uniformly F f p :=
begin
  rw [(uniform_fun.has_basis_nhds Î± Î² f).tendsto_right_iff, tendsto_uniformly],
  exact iff.rfl,
end

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤ Î² Ã— Î³` and `(Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î³)`. -/
protected def uniform_equiv_prod_arrow [uniform_space Î³] :
  (Î± â†’áµ¤ Î² Ã— Î³) â‰ƒáµ¤ ((Î± â†’áµ¤ Î²) Ã— (Î± â†’áµ¤ Î³)) :=
-- Denote `Ï†` this bijection. We want to show that
-- `comap Ï† (ğ’°(Î±, Î², uÎ²) Ã— ğ’°(Î±, Î³, uÎ³)) = ğ’°(Î±, Î² Ã— Î³, uÎ² Ã— uÎ³)`.
-- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
-- `uniform_convergence.inf_eq` and `uniform_convergence.comap_eq`, which leaves us to check
-- that some square commutes.
(equiv.arrow_prod_equiv_prod_arrow _ _ _).to_uniform_equiv_of_uniform_inducing
begin
  split,
  change comap (prod.map (equiv.arrow_prod_equiv_prod_arrow _ _ _)
    (equiv.arrow_prod_equiv_prod_arrow _ _ _)) _ = _,
  rw â† uniformity_comap,
  congr,
  rw [prod.uniform_space, prod.uniform_space, uniform_space.comap_inf, uniform_fun.inf_eq],
  congr;
  rw [â† uniform_space.comap_comap, uniform_fun.comap_eq];
  refl -- the relevant diagram commutes by definition
end

variables (Î±) (Î´ : Î¹ â†’ Type*) [Î  i, uniform_space (Î´ i)]

/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤ (Î  i, Î´ i)` and `Î  i, Î± â†’áµ¤ Î´ i`. -/
protected def uniform_equiv_Pi_comm : uniform_equiv (Î± â†’áµ¤ Î  i, Î´ i) (Î  i, Î± â†’áµ¤ Î´ i) :=
-- Denote `Ï†` this bijection. We want to show that
-- `comap Ï† (Î  i, ğ’°(Î±, Î´ i, uÎ´ i)) = ğ’°(Î±, (Î  i, Î´ i), (Î  i, uÎ´ i))`.
-- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
-- `uniform_convergence.infi_eq` and `uniform_convergence.comap_eq`, which leaves us to check
-- that some square commutes.
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  (ğ’°(Î±, Î  i, Î´ i, Pi.uniform_space Î´))
  (@Pi.uniform_space Î¹ (Î» i, Î± â†’ Î´ i) (Î» i, ğ’°(Î±, Î´ i, _)))
  (equiv.Pi_comm _)
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw â† uniformity_comap,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_fun.infi_eq],
  refine infi_congr (Î» i, _),
  rw [â† uniform_space.comap_comap, uniform_fun.comap_eq]
  -- Like in the previous lemma, the diagram actually commutes by definition
end

end uniform_fun

namespace uniform_on_fun

variables {Î± Î² : Type*} {Î³ Î¹ : Type*}
variables {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

local notation `ğ’°(`Î±`, `Î²`, `u`)` := @uniform_fun.uniform_space Î± Î² u

/-- Basis sets for the uniformity of `ğ”–`-convergence: for `S : set Î±` and `V : set (Î² Ã— Î²)`,
`gen ğ”– S V` is the set of pairs `(f, g)` of functions `Î± â†’áµ¤[ğ”–] Î²` such that
`âˆ€ x âˆˆ S, (f x, g x) âˆˆ V`. Note that the family `ğ”– : set (set Î±)` is only used to specify which
type alias of `Î± â†’ Î²` to use here. -/
protected def gen (ğ”–) (S : set Î±) (V : set (Î² Ã— Î²)) : set ((Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)) :=
  {uv : (Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²) | âˆ€ x âˆˆ S, (uv.1 x, uv.2 x) âˆˆ V}

/-- For `S : set Î±` and `V : set (Î² Ã— Î²)`, we have
`uniform_on_fun.gen ğ”– S V = (S.restrict Ã— S.restrict) â»Â¹' (uniform_fun.gen S Î² V)`.
This is the crucial fact for proving that the family `uniform_on_fun.gen S V` for `S âˆˆ ğ”–` and
`V âˆˆ ğ“¤ Î²` is indeed a basis for the uniformity `Î± â†’áµ¤[ğ”–] Î²` endowed with `ğ’±(Î±, Î², ğ”–, uÎ²)`
the uniform structure of `ğ”–`-convergence, as defined in `uniform_on_fun.uniform_space`. -/
protected lemma gen_eq_preimage_restrict {ğ”–} (S : set Î±) (V : set (Î² Ã— Î²)) :
  uniform_on_fun.gen ğ”– S V =
  (prod.map S.restrict S.restrict) â»Â¹' (uniform_fun.gen S Î² V) :=
begin
  ext uv,
  exact âŸ¨Î» h âŸ¨x, hxâŸ©, h x hx, Î» h x hx, h âŸ¨x, hxâŸ©âŸ©
end

/-- `uniform_on_fun.gen` is antitone in the first argument and monotone in the second. -/
protected lemma gen_mono {ğ”–} {S S' : set Î±} {V V' : set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :
  uniform_on_fun.gen ğ”– S V âŠ† uniform_on_fun.gen ğ”– S' V' :=
Î» uv h x hx, hV (h x $ hS hx)

/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis on `Î² Ã— Î²`, then the
family `uniform_on_fun.gen ğ”– S V` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` is a filter basis on
`(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î²)`.
We will show in `has_basis_uniformity_of_basis` that, if `ğ“‘` is a basis for `ğ“¤ Î²`, then the
corresponding filter is the uniformity of `Î± â†’áµ¤[ğ”–] Î²`. -/
protected lemma is_basis_gen (ğ”– : set (set Î±)) (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  (ğ“‘ : filter_basis $ Î² Ã— Î²) :
  is_basis (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘)
    (Î» SV, uniform_on_fun.gen ğ”– SV.1 SV.2) :=
âŸ¨h.prod ğ“‘.nonempty, Î» Uâ‚Vâ‚ Uâ‚‚Vâ‚‚ hâ‚ hâ‚‚,
  let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1 in
  let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2 in âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©, âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, Î» uv huv,
    âŸ¨(Î» x hx, (hVâ‚â‚‚â‚ƒ $ huv x $ hUâ‚â‚ƒ hx).1), (Î» x hx, (hVâ‚â‚‚â‚ƒ $ huv x $ hUâ‚‚â‚ƒ hx).2)âŸ©âŸ©âŸ©âŸ©

variables (Î± Î²) [uniform_space Î²] (ğ”– : set (set Î±)) {ğ”— : set (set Î±)}

/-- Uniform structure of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`,
declared as an instance on `Î± â†’áµ¤[ğ”–] Î²`. It is defined as the infimum, for `S âˆˆ ğ”–`, of the pullback
by `S.restrict`, the map of restriction to `S`, of the uniform structure `ğ’°(s, Î², uÎ²)` on
`â†¥S â†’áµ¤ Î²`. We will denote it `ğ’±(Î±, Î², ğ”–, uÎ²)`, where `uÎ²` is the uniform structure on `Î²`. -/
instance : uniform_space (Î± â†’áµ¤[ğ”–] Î²) :=
â¨… (s : set Î±) (hs : s âˆˆ ğ”–), uniform_space.comap s.restrict
  (ğ’°(s, Î², _))

local notation `ğ’±(`Î±`, `Î²`, `ğ”–`, `u`)` := @uniform_on_fun.uniform_space Î± Î² u ğ”–

/-- Topology of `ğ”–`-convergence, i.e uniform convergence on the elements of `ğ”–`, declared as an
instance on `Î± â†’áµ¤[ğ”–] Î²`. -/
instance : topological_space (Î± â†’áµ¤[ğ”–] Î²) :=
(ğ’±(Î±, Î², ğ”–, _)).to_topological_space

/-- The topology of `ğ”–`-convergence is the infimum, for `S âˆˆ ğ”–`, of topology induced by the map
of `S.restrict : (Î± â†’áµ¤[ğ”–] Î²) â†’ (â†¥S â†’áµ¤ Î²)` of restriction to `S`, where `â†¥S â†’áµ¤ Î²` is endowed with
the topology of uniform convergence. -/
protected lemma topological_space_eq :
  uniform_on_fun.topological_space Î± Î² ğ”– = â¨… (s : set Î±) (hs : s âˆˆ ğ”–),
  topological_space.induced s.restrict (uniform_fun.topological_space s Î²) :=
begin
  simp only [uniform_on_fun.topological_space, to_topological_space_infi,
    to_topological_space_infi, to_topological_space_comap],
  refl
end

/-- If `S âˆˆ ğ”–`, then the restriction to `S` is a uniformly continuous map from `Î± â†’áµ¤[ğ”–] Î²` to
`â†¥S â†’áµ¤ Î²`. -/
protected lemma uniform_continuous_restrict (h : s âˆˆ ğ”–) :
  uniform_continuous (uniform_fun.of_fun âˆ˜ (s.restrict : (Î± â†’ Î²) â†’ (s â†’ Î²)) âˆ˜ (to_fun ğ”–)) :=
begin
  change _ â‰¤ _,
  rw [uniform_on_fun.uniform_space, map_le_iff_le_comap, uniformity, infi_uniformity],
  refine infi_le_of_le s _,
  rw infi_uniformity,
  exact infi_le _ h,
end

section generated

/-!
One import fact about the `ğ”–`-convergence uniform structure and topology, is that they
don't change if you replace `ğ”–` by the set `ğ”–'` of all `s : set Î±` which are contained in some
finite union of elements of `ğ”–`. This `ğ”–'` is the smallest ideal (in the sense of
`order.ideal`) containing `ğ”–`, but in this context the litterature (e.g Bourbaki) often uses
"bornology" to mean `order.ideal (set Î±)`. Unfortunately, there is some disagreement on wether
bornologies are required to cover the whole space, and mathlib currently follows this more
restrictive convention, so we cannot use it here (otherwise, the theorem stated above is simply
false). On the other hand, the API for `order.ideal` is rather small and we have basically no facts
about ideals on sets, so it isn't a real option either.

The two long terms solution for that would of course be to either develop a lot more API around
`order.ideal` and `order.pfilter` (and potentially even use them to redefine `filter` and
`bornology`) or remove the covering condition from `bornology`. Each of them require a lot of work
and we don't want to embark in such a project until the port to Lean4 is finished.

So we develop a minimal API, using the facts that (noncovering) bornologies are exactly sets of the
form `{s | sá¶œ âˆˆ F}` for `F : filter Î±`. We define an ad-hoc predicate `generate_same` to express
that two sets of subsets of `Î±` generate the same (noncovering) bornology, and we develop a minimal
API around it to allow for further theory development. **Please do not expand this API further**
as it will be completely refactored to use either `order.ideal` or a modified `bornology`.
-/

variables {Î± Î² ğ”–}

/-- For `ğ”– ğ”— : set (set Î±)`, `generate_same ğ”– ğ”—` expresses the fact that `ğ”–` and `ğ”—` generate the
same *noncovering* bornology on `Î±` (i.e ideal of `set Î±`). We express this by saying that the
pointwise complements of `ğ”–` and `ğ”—` generate the same filter. See `generate_same_iff` for
a more concrete characterization. -/
def generate_same (ğ”– ğ”— : set (set Î±)) : Prop :=
generate (compl â»Â¹' ğ”–) = generate (compl â»Â¹' ğ”—)

/-- For every `ğ”–`, there is a nonempty and directed `ğ”—` which satisfies `generate_same ğ”—`. This
is essentially saying that any *noncovering* bornology admits a basis (in the dual sense of
`filter.has_basis`). We could even ask `ğ”—` to be downwards-closed (i.e a full-blown *noncovering*
bornology), but it's not useful in practice. -/
lemma exists_generate_same_directed (ğ”– : set (set Î±)) :
  âˆƒ ğ”— : set (set Î±), ğ”—.nonempty âˆ§ directed_on (âŠ†) ğ”— âˆ§ generate_same ğ”– ğ”— :=
begin
  -- The proof is simple: the bornology generated by `ğ”–` works.
  -- As usual, we take complements to go back to filters
  refine âŸ¨{s | sá¶œ âˆˆ filter.generate (compl â»Â¹' ğ”–)}, âŸ¨âˆ…, show âˆ…á¶œ âˆˆ _, from _âŸ©,
    directed_on_of_sup_mem (Î» s t hs ht, show (s âˆª t)á¶œ âˆˆ _, from _), _âŸ©,
  { rw compl_empty,
    exact univ_mem },
  { rw compl_union,
    exact inter_mem hs ht },
  { change _ = generate ((compl âˆ˜ compl) â»Â¹' (generate _).sets),
    rw [compl_comp_compl, preimage_id, (gi_generate Î±).l_u_eq] }
end

/-- Concrete characterization of `generate_same`. -/
lemma generate_same_iff {ğ”– ğ”— : set (set Î±)} :
  generate_same ğ”– ğ”— â†”
    (âˆ€ s âˆˆ ğ”–, âˆƒ T âŠ† ğ”—, T.finite âˆ§ s âŠ† â‹ƒâ‚€ T) âˆ§ (âˆ€ t âˆˆ ğ”—, âˆƒ S âŠ† ğ”–, S.finite âˆ§ t âŠ† â‹ƒâ‚€ S) :=
begin
  -- Like above, we go back to filters to apply `mem_generate_iff`.
  -- Eventually, this should be a direct consequence of the dual lemmas for bornologies,
  -- which would make the proof much simpler because we wouldn't have to take care of complements
  symmetry,
  rw [generate_same, and_comm, le_antisymm_iff, sets_iff_generate, sets_iff_generate, subset_def],
  congrm (_ âˆ§ _);
  rw [(@compl_surjective (set Î±) _).forall];
  refine forallâ‚‚_congr (Î» x hx, _);
  rw [filter.mem_sets, mem_generate_iff];
  { split; rintros âŸ¨Y, hYğ”–, hYf, hxYâŸ©,
    { refine âŸ¨compl â»Â¹' Y, preimage_mono hYğ”–, hYf.preimage (compl_injective.inj_on _), _âŸ©,
      rwa [compl_subset_comm, compl_sUnion, â† preimage_compl_eq_image_compl] at hxY },
    { refine âŸ¨compl '' Y, image_subset_iff.mpr hYğ”–, hYf.image _, _âŸ©,
      rwa [â† compl_sInter, compl_subset_compl] } }
end

/-- Key part of proving `uniform_on_fun_filter_generate`: given any uniform structure `u` on
    `Î± â†’ Î²`, the set of all `S : set Î±` for which the restriction map from `(Î± â†’ Î², u)` â†’ `S â†’áµ¤ Î²`
    is uniformly continuous is a *noncovering* bornology on `Î±`.
    As usual, we take complements to express that in terms of filters. -/
def co_converging_sets (u : uniform_space (Î± â†’ Î²)) :
  filter Î± :=
{ sets := {S | @uniform_continuous (Î± â†’ Î²) ((Sá¶œ : set Î±) â†’áµ¤ Î²) u _ (restrict Sá¶œ)},
  univ_sets :=
  begin
    refine uniform_continuous_of_const (Î» u v, _),
    rw compl_univ,
    exact funext (Î» x, x.2.elim)
  end,
  inter_sets :=
  begin
    rintro sâ‚ sâ‚‚ (hâ‚ : tendsto _ _ _) (hâ‚‚ : tendsto _ _ _),
    change tendsto _ _ _,
    rw (uniform_fun.has_basis_uniformity _ Î²).tendsto_right_iff at âŠ¢ hâ‚ hâ‚‚,
    intros U hU,
    filter_upwards [hâ‚ U hU, hâ‚‚ U hU],
    rintros âŸ¨u, vâŸ© hu hv âŸ¨x, hxâŸ©,
    rcases not_and_distrib.mp hx with (hx|hx),
    { exact hu âŸ¨x, hxâŸ© },
    { exact hv âŸ¨x, hxâŸ© }
  end,
  sets_of_superset :=
  begin
    rintro sâ‚ sâ‚‚ (hâ‚ : tendsto _ _ _) hâ‚â‚‚,
    change tendsto _ _ _,
    rw (uniform_fun.has_basis_uniformity _ Î²).tendsto_right_iff at âŠ¢ hâ‚,
    intros U hU,
    have hâ‚‚â‚ : sâ‚‚á¶œ âŠ† sâ‚á¶œ := compl_subset_compl.mpr hâ‚â‚‚,
    filter_upwards [hâ‚ U hU] using Î» uv huv âŸ¨x, hxâŸ©, huv âŸ¨x, hâ‚‚â‚ hxâŸ©
  end }

/-- Replacing `ğ”–` by the *noncovering* bornology generated by `ğ”–` doesn't change the uniform
structure of `ğ”–`-convergence. -/
lemma _root_.uniform_on_fun_filter_generate :
  ğ’±(Î±, Î², {s | sá¶œ âˆˆ filter.generate (compl â»Â¹' ğ”–)}, _) =
  ğ’±(Î±, Î², ğ”–, _) :=
begin
  refine le_antisymm (infi_le_infi_of_subset $ Î» s hs, filter.generate_sets.basic $ by simpa) _,
  calc ğ’±(Î±, Î², ğ”–, _)
      â‰¤ ğ’±(Î±, Î², ğ”–, _) : le_rfl
  ... â‰¤ ğ’±(Î±, Î², {s | sá¶œ âˆˆ co_converging_sets ğ’±(Î±, Î², ğ”–, _)}, _) :
    le_infi (Î» s, le_infi $ Î» hs, by rwa [â† uniform_continuous_iff, â† compl_compl s])
  ... â‰¤ ğ’±(Î±, Î², {s | sá¶œ âˆˆ filter.generate (compl â»Â¹' ğ”–)}, _) :
    infi_le_infi_of_subset (Î» s hs, _),
  suffices : co_converging_sets ğ’±(Î±, Î², ğ”–, _) â‰¤ generate (compl â»Â¹' ğ”–),
  { exact this hs },
  exact sets_iff_generate.mpr (Î» t ht, uniform_on_fun.uniform_continuous_restrict _ _ _ ht)
end

/-- If `ğ”–` and `ğ”—` generate the same *noncovering* bornology (in the sense of
    `uniform_on_fun.generate_same`), then the uniform structures of `ğ”–`-convergence and
    `ğ”—`-convergence are equal. -/
lemma generate_same.uniform_space_eq {ğ”– ğ”— : set (set Î±)} (H : generate_same ğ”– ğ”—) :
  ğ’±(Î±, Î², ğ”–, _) = ğ’±(Î±, Î², ğ”—, _) :=
by rw [â† @uniform_on_fun_filter_generate _ _ _ ğ”–, â† @uniform_on_fun_filter_generate _ _ _ ğ”—,
        (show _ = _, from H)]

end generated

protected lemma has_basis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (hb : has_basis (ğ“¤ Î²) p s) (S : set Î±) :
  (@uniformity (Î± â†’áµ¤[ğ”–] Î²) ((uniform_fun.uniform_space S Î²).comap S.restrict)).has_basis
  p (Î» i, uniform_on_fun.gen ğ”– S (s i)) :=
begin
  simp_rw [uniform_on_fun.gen_eq_preimage_restrict, uniformity_comap],
  exact (uniform_fun.has_basis_uniformity_of_basis S Î² hb).comap _
end

protected lemma has_basis_uniformity_of_basis_auxâ‚‚ (h : directed_on (âŠ†) ğ”–) {p : Î¹ â†’ Prop}
  {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  directed_on ((Î» s : set Î±, (uniform_fun.uniform_space s Î²).comap
    (s.restrict : (Î± â†’áµ¤ Î²) â†’ s â†’áµ¤ Î²)) â»Â¹'o ge) ğ”– :=
h.mono $ Î» s t hst,
  ((uniform_on_fun.has_basis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _).le_basis_iff
    (uniform_on_fun.has_basis_uniformity_of_basis_auxâ‚ Î± Î² ğ”– hb _)).mpr
  (Î» V hV, âŸ¨V, hV, uniform_on_fun.gen_mono hst subset_rflâŸ©)

/-- If `ğ”– : set (set Î±)` is nonempty and directed and `ğ“‘` is a filter basis of `ğ“¤ Î²`, then the
uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and
`V âˆˆ ğ“‘` as a filter basis. -/
protected lemma has_basis_uniformity_of_basis (hğ”–ğ”— : generate_same ğ”– ğ”—) (h : ğ”—.nonempty)
  (h' : directed_on (âŠ†) ğ”—) {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”— âˆ§ p Si.2)
    (Î» Si, uniform_on_fun.gen ğ”– Si.1 (s Si.2)) :=
begin
  rw hğ”–ğ”—.uniform_space_eq,
  simp only [infi_uniformity'],
  exact has_basis_binfi_of_directed h (Î» S, (uniform_on_fun.gen _ S) âˆ˜ s) _
    (Î» S hS, uniform_on_fun.has_basis_uniformity_of_basis_auxâ‚ Î± Î² _ hb S)
    (uniform_on_fun.has_basis_uniformity_of_basis_auxâ‚‚ Î± Î² _ h' hb)
end

/-- If `ğ”– : set (set Î±)` is nonempty and directed, then the uniformity of `Î± â†’áµ¤[ğ”–] Î²` admits the
family `{(f, g) | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected lemma has_basis_uniformity (hğ”–ğ”— : generate_same ğ”– ğ”—) (h : ğ”—.nonempty)
  (h' : directed_on (âŠ†) ğ”—) :
  (ğ“¤ (Î± â†’áµ¤[ğ”–] Î²)).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”— âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, uniform_on_fun.gen ğ”– SV.1 SV.2) :=
uniform_on_fun.has_basis_uniformity_of_basis Î± Î² ğ”– hğ”–ğ”— h h' (ğ“¤ Î²).basis_sets

/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : set (set Î±)` is nonempty and directed, `ğ“ f` admits the
family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“‘` as a filter basis, for any basis
`ğ“‘` of `ğ“¤ Î²`. -/
protected lemma has_basis_nhds_of_basis (f : Î± â†’áµ¤[ğ”–] Î²) (hğ”–ğ”— : generate_same ğ”– ğ”—) (h : ğ”—.nonempty)
  (h' : directed_on (âŠ†) ğ”—) {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (ğ“ f).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”— âˆ§ p Si.2)
    (Î» Si, {g | (g, f) âˆˆ uniform_on_fun.gen ğ”– Si.1 (s Si.2)}) :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_on_fun.uniform_space Î± Î² ğ”–,
  exact nhds_basis_uniformity (uniform_on_fun.has_basis_uniformity_of_basis Î± Î² ğ”– hğ”–ğ”— h h' hb)
end

/-- For `f : Î± â†’áµ¤[ğ”–] Î²`, where `ğ”– : set (set Î±)` is nonempty and directed, `ğ“ f` admits the
family `{g | âˆ€ x âˆˆ S, (f x, g x) âˆˆ V}` for `S âˆˆ ğ”–` and `V âˆˆ ğ“¤ Î²` as a filter basis. -/
protected lemma has_basis_nhds (f : Î± â†’áµ¤[ğ”–] Î²) (hğ”–ğ”— : generate_same ğ”– ğ”—) (h : ğ”—.nonempty)
  (h' : directed_on (âŠ†) ğ”—) :
  (ğ“ f).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”— âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, {g | (g, f) âˆˆ uniform_on_fun.gen ğ”– SV.1 SV.2}) :=
uniform_on_fun.has_basis_nhds_of_basis Î± Î² ğ”– f hğ”–ğ”— h h' (filter.basis_sets _)

protected lemma countably_generated_uniformity (hğ”–ğ”— : generate_same ğ”– ğ”—) (hcount : ğ”—.countable)
  [(ğ“¤ Î²).is_countably_generated] : (ğ“¤ $ Î± â†’áµ¤[ğ”–] Î²).is_countably_generated :=
begin
  rw [hğ”–ğ”—.uniform_space_eq],
  simp_rw [infi_uniformity', uniformity_comap rfl, â† infi_subtype''],
  letI : countable ğ”— := hcount.to_subtype,
  refine @infi.is_countably_generated _ _ _ _ (Î» T, _),
  change (comap _ (ğ“¤ $ (T : set Î±) â†’áµ¤ Î²)).is_countably_generated,
  apply_instance
end

variables {Î±}

/-- Let `uâ‚`, `uâ‚‚` be two uniform structures on `Î³` and `ğ”–â‚ ğ”–â‚‚ : set (set Î±)`. If `uâ‚ â‰¤ uâ‚‚` and
`ğ”–â‚‚ âŠ† ğ”–â‚` then `ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚)`. -/
protected lemma mono â¦ƒuâ‚ uâ‚‚ : uniform_space Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : set (set Î±)â¦„
  (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) :
  ğ’±(Î±, Î³, ğ”–â‚, uâ‚) â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) :=
calc ğ’±(Î±, Î³, ğ”–â‚, uâ‚)
    â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚) : infi_le_infi_of_subset hğ”–
... â‰¤ ğ’±(Î±, Î³, ğ”–â‚‚, uâ‚‚) : infiâ‚‚_mono
        (Î» i hi, uniform_space.comap_mono $ uniform_fun.mono hu)

/-- If `x : Î±` is in some `S âˆˆ ğ”–`, then evaluation at `x` is uniformly continuous on
`Î± â†’áµ¤[ğ”–] Î²`. -/
lemma uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :
  uniform_continuous ((function.eval x : (Î± â†’ Î²) â†’ Î²) âˆ˜ to_fun ğ”–) :=
(uniform_fun.uniform_continuous_eval Î² (âŸ¨x, hxsâŸ© : s)).comp
  (uniform_on_fun.uniform_continuous_restrict Î± Î² ğ”– hs)

variables {Î²} {ğ”–}

/-- If `u` is a family of uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, (â¨… i, u i)) = â¨… i, ğ’±(Î±, Î³, ğ”–, u i)`. -/
protected lemma infi_eq {u : Î¹ â†’ uniform_space Î³} :
  ğ’±(Î±, Î³, ğ”–, â¨… i, u i) =
  â¨… i, ğ’±(Î±, Î³, ğ”–, u i) :=
begin
  simp_rw [uniform_on_fun.uniform_space, uniform_fun.infi_eq, uniform_space.comap_infi],
  rw infi_comm,
  exact infi_congr (Î» s, infi_comm)
end

/-- If `uâ‚` and `uâ‚‚` are two uniform structures on `Î³`, then
`ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) = ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“ ğ’±(Î±, Î³, ğ”–, uâ‚‚)`. -/
protected lemma inf_eq {uâ‚ uâ‚‚ : uniform_space Î³} :
  ğ’±(Î±, Î³, ğ”–, uâ‚ âŠ“ uâ‚‚) =
  ğ’±(Î±, Î³, ğ”–, uâ‚) âŠ“
  ğ’±(Î±, Î³, ğ”–, uâ‚‚) :=
begin
  rw [inf_eq_infi, inf_eq_infi, uniform_on_fun.infi_eq],
  refine infi_congr (Î» i, _),
  cases i; refl
end

/-- If `u` is a uniform structures on `Î²` and `f : Î³ â†’ Î²`, then
`ğ’±(Î±, Î³, ğ”–, comap f u) = comap (Î» g, f âˆ˜ g) ğ’±(Î±, Î³, ğ”–, uâ‚)`. -/
protected lemma comap_eq {f : Î³ â†’ Î²} :
  ğ’±(Î±, Î³, ğ”–, â€¹uniform_space Î²â€º.comap f) =
  ğ’±(Î±, Î², ğ”–, _).comap ((âˆ˜) f) :=
begin
  -- We reduce this to `uniform_convergence.comap_eq` using the fact that `comap` distributes
  -- on `infi`.
  simp_rw [uniform_on_fun.uniform_space, uniform_space.comap_infi,
            uniform_fun.comap_eq, â† uniform_space.comap_comap],
  refl -- by definition, `âˆ€ S âˆˆ ğ”–, (f âˆ˜ â€”) âˆ˜ S.restrict = S.restrict âˆ˜ (f âˆ˜ â€”)`.
end

/-- Post-composition by a uniformly continuous function is uniformly continuous for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : Î³ â†’ Î²` is uniformly continuous, then
`(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is uniformly continuous. -/
protected lemma postcomp_uniform_continuous [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_continuous f):
  uniform_continuous (of_fun ğ”– âˆ˜ (âˆ˜) f âˆ˜ to_fun ğ”–) :=
begin
  -- This is a direct consequence of `uniform_convergence.comap_eq`
  rw uniform_continuous_iff,
  calc ğ’±(Î±, Î³, ğ”–, _)
      â‰¤ ğ’±(Î±, Î³, ğ”–, â€¹uniform_space Î²â€º.comap f) :
        uniform_on_fun.mono (uniform_continuous_iff.mp hf) (subset_rfl)
  ... = ğ’±(Î±, Î², ğ”–, _).comap ((âˆ˜) f) :
        uniform_on_fun.comap_eq
end

/-- Post-composition by a uniform inducing is a uniform inducing for the
uniform structures of `ğ”–`-convergence.

More precisely, if `f : Î³ â†’ Î²` is a uniform inducing, then
`(Î» g, f âˆ˜ g) : (Î± â†’áµ¤[ğ”–] Î³) â†’ (Î± â†’áµ¤[ğ”–] Î²)` is a uniform inducing. -/
protected lemma postcomp_uniform_inducing [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_inducing f):
  uniform_inducing (of_fun ğ”– âˆ˜ (âˆ˜) f âˆ˜ to_fun ğ”–) :=
-- This is a direct consequence of `uniform_convergence.comap_eq`
begin
  split,
  replace hf : (ğ“¤ Î²).comap (prod.map f f) = _ := hf.comap_uniformity,
  change comap (prod.map (of_fun ğ”– âˆ˜ (âˆ˜) f âˆ˜ to_fun ğ”–) (of_fun ğ”– âˆ˜ (âˆ˜) f âˆ˜ to_fun ğ”–)) _ = _,
  rw [â† uniformity_comap] at âŠ¢ hf,
  congr,
  rw [â† uniform_space_eq hf, uniform_on_fun.comap_eq],
  refl
end

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` into a uniform isomorphism `(Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)`
by post-composing. -/
protected def congr_right [uniform_space Î³] (e : Î³ â‰ƒáµ¤ Î²) :
  (Î± â†’áµ¤[ğ”–] Î³) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²) :=
{ uniform_continuous_to_fun :=
    uniform_on_fun.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_on_fun.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (Î» a, e.to_equiv) }

/-- Let `f : Î³ â†’ Î±`, `ğ”– : set (set Î±)`, `ğ”— : set (set Î³)`, and assume that `âˆ€ T âˆˆ ğ”—, f '' T âˆˆ ğ”–`.
Then, the function `(Î» g, g âˆ˜ f) : (Î± â†’áµ¤[ğ”–] Î²) â†’ (Î³ â†’áµ¤[ğ”—] Î²)` is uniformly continuous.

Note that one can easily see that assuming `âˆ€ T âˆˆ ğ”—, âˆƒ S âˆˆ ğ”–, f '' T âŠ† S` would work too, but
we will get this for free when we prove that `ğ’±(Î±, Î², ğ”–, uÎ²) = ğ’±(Î±, Î², ğ”–', uÎ²)` where `ğ”–'` is the
***noncovering*** bornology generated by `ğ”–`. -/
protected lemma precomp_uniform_continuous {ğ”— : set (set Î³)} {f : Î³ â†’ Î±}
  (hf : ğ”— âŠ† (image f) â»Â¹' ğ”–) :
  uniform_continuous (Î» g : Î± â†’áµ¤[ğ”–] Î², of_fun ğ”— (g âˆ˜ f)) :=
begin
  -- Since `comap` distributes on `infi`, it suffices to prove that
  -- `â¨… s âˆˆ ğ”–, comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ â¨… t âˆˆ ğ”—, comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.
  simp_rw [uniform_continuous_iff, uniform_on_fun.uniform_space, uniform_space.comap_infi,
            â† uniform_space.comap_comap],
  -- For any `t âˆˆ ğ”—`, note `s := f '' t âˆˆ ğ”–`.
  -- We will show that `comap s.restrict ğ’°(â†¥s, Î², uÎ²) â‰¤ comap (t.restrict âˆ˜ (â€” âˆ˜ f)) ğ’°(â†¥t, Î², uÎ²)`.
  refine le_infiâ‚‚ (Î» t ht, infi_le_of_le (f '' t) $ infi_le_of_le (hf ht) _),
  -- Let `f'` be the map from `t` to `f '' t` induced by `f`.
  let f' : t â†’ f '' t := (maps_to_image f t).restrict f t (f '' t),
  -- By definition `t.restrict âˆ˜ (â€” âˆ˜ f) = (â€” âˆ˜ f') âˆ˜ (f '' t).restrict`.
  have : t.restrict âˆ˜ (Î» g : Î± â†’áµ¤[ğ”–] Î², of_fun ğ”— (g âˆ˜ f)) =
    (Î» g : (f '' t) â†’ Î², g âˆ˜ f') âˆ˜ (f '' t).restrict := rfl,
  -- Thus, we have to show `comap (f '' t).restrict ğ’°(â†¥(f '' t), Î², uÎ²) â‰¤`
  -- `comap (f '' t).restrict (comap (â€” âˆ˜ f') ğ’°(â†¥t, Î², uÎ²))`.
  rw [this, @uniform_space.comap_comap (Î± â†’áµ¤[ğ”–] Î²) ((f '' t) â†’áµ¤ Î²)],
  -- But this is exactly monotonicity of `comap` applied to
  -- `uniform_convergence.precomp_continuous`.
  refine uniform_space.comap_mono _,
  rw â† uniform_continuous_iff,
  exact uniform_fun.precomp_uniform_continuous
end

/-- Turn a bijection `e : Î³ â‰ƒ Î±` such that we have both `âˆ€ T âˆˆ ğ”—, e '' T âˆˆ ğ”–` and
`âˆ€ S âˆˆ ğ”–, e â»Â¹' S âˆˆ ğ”—` into a uniform isomorphism `(Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²)` by pre-composing. -/
protected def congr_left {ğ”— : set (set Î³)} (e : Î³ â‰ƒ Î±)
  (he : ğ”— âŠ† (image e) â»Â¹' ğ”–) (he' : ğ”– âŠ† (preimage e) â»Â¹' ğ”—) :
  (Î³ â†’áµ¤[ğ”—] Î²) â‰ƒáµ¤ (Î± â†’áµ¤[ğ”–] Î²) :=
{ uniform_continuous_to_fun :=
    uniform_on_fun.precomp_uniform_continuous
    begin
      intros s hs,
      change e.symm '' s âˆˆ ğ”—,
      rw â† preimage_equiv_eq_image_symm,
      exact he' hs
    end,
  uniform_continuous_inv_fun :=
    uniform_on_fun.precomp_uniform_continuous he,
  .. equiv.arrow_congr e (equiv.refl _) }

/-- If `ğ”–` covers `Î±`, then the topology of `ğ”–`-convergence is Tâ‚‚. -/
lemma t2_space_of_covering [t2_space Î²] (h : â‹ƒâ‚€ ğ”– = univ) :
  t2_space (Î± â†’áµ¤[ğ”–] Î²) :=
{ t2 :=
  begin
    intros f g hfg,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg),
    obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ true.intro),
    exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ğ”– hxs hs).continuous hx
  end }

/-- If `ğ”–` covers `Î±`, the natural map `uniform_on_fun.to_fun` from `Î± â†’áµ¤[ğ”–] Î²` to `Î± â†’ Î²` is
uniformly continuous.

In other words, if `ğ”–` covers `Î±`, then the uniform structure of `ğ”–`-convergence is finer than
that of pointwise convergence. -/
protected lemma uniform_continuous_to_fun (h : â‹ƒâ‚€ ğ”– = univ) :
  uniform_continuous (to_fun ğ”– : (Î± â†’áµ¤[ğ”–] Î²) â†’ Î± â†’ Î²) :=
begin
  rw uniform_continuous_pi,
  intros x,
  obtain âŸ¨s : set Î±, hs : s âˆˆ ğ”–, hxs :  x âˆˆ sâŸ© := sUnion_eq_univ_iff.mp h x,
  exact uniform_continuous_eval_of_mem Î² ğ”– hxs hs
end

/-- Convergence in the topology of `ğ”–`-convergence means uniform convergence on `S` (in the sense
of `tendsto_uniformly_on`) for all `S âˆˆ ğ”–`. -/
protected lemma tendsto_iff_tendsto_uniformly_on {F : Î¹ â†’ Î± â†’áµ¤[ğ”–] Î²} {f : Î± â†’áµ¤[ğ”–] Î²} :
  tendsto F p (ğ“ f) â†”
  âˆ€ s âˆˆ ğ”–, tendsto_uniformly_on F f p s :=
begin
  rw [uniform_on_fun.topological_space_eq, nhds_infi, tendsto_infi],
  refine forall_congr (Î» s, _),
  rw [nhds_infi, tendsto_infi],
  refine forall_congr (Î» hs, _),
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
      uniform_fun.tendsto_iff_tendsto_uniformly],
  refl
end

/-- The natural bijection between `Î± â†’ Î² Ã— Î³` and `(Î± â†’ Î²) Ã— (Î± â†’ Î³)`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤[ğ”–] Î² Ã— Î³` and `(Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î³)`. -/
protected def uniform_equiv_prod_arrow [uniform_space Î³] :
  (Î± â†’áµ¤[ğ”–] Î² Ã— Î³) â‰ƒáµ¤ ((Î± â†’áµ¤[ğ”–] Î²) Ã— (Î± â†’áµ¤[ğ”–] Î³)) :=
-- Denote `Ï†` this bijection. We want to show that
-- `comap Ï† (ğ’±(Î±, Î², ğ”–, uÎ²) Ã— ğ’±(Î±, Î³, ğ”–, uÎ³)) = ğ’±(Î±, Î² Ã— Î³, ğ”–, uÎ² Ã— uÎ³)`.
-- But `uÎ² Ã— uÎ³` is defined as `comap fst uÎ² âŠ“ comap snd uÎ³`, so we just have to apply
-- `uniform_convergence_on.inf_eq` and `uniform_convergence_on.comap_eq`, which leaves us to check
-- that some square commutes.
-- We could also deduce this from `uniform_convergence.uniform_equiv_prod_arrow`, but it turns out
-- to be more annoying.
((uniform_on_fun.of_fun ğ”–).symm.trans $ (equiv.arrow_prod_equiv_prod_arrow _ _ _).trans $
  (uniform_on_fun.of_fun ğ”–).prod_congr (uniform_on_fun.of_fun ğ”–))
  .to_uniform_equiv_of_uniform_inducing
begin
  split,
  rw [uniformity_prod, comap_inf, comap_comap, comap_comap, uniform_on_fun.inf_eq, inf_uniformity,
    uniform_on_fun.comap_eq, uniform_on_fun.comap_eq, uniformity_comap, uniformity_comap],
  refl -- the relevant diagram commutes by definition
end

variables (ğ”–) (Î´ : Î¹ â†’ Type*) [Î  i, uniform_space (Î´ i)]

/-- The natural bijection between `Î± â†’ Î  i, Î´ i` and `Î  i, Î± â†’ Î´ i`, upgraded to a uniform
isomorphism between `Î± â†’áµ¤[ğ”–] (Î  i, Î´ i)` and `Î  i, Î± â†’áµ¤[ğ”–] Î´ i`. -/
protected def uniform_equiv_Pi_comm :
  (Î± â†’áµ¤[ğ”–] Î  i, Î´ i) â‰ƒáµ¤ (Î  i, Î± â†’áµ¤[ğ”–] Î´ i)  :=
-- Denote `Ï†` this bijection. We want to show that
-- `comap Ï† (Î  i, ğ’±(Î±, Î´ i, ğ”–, uÎ´ i)) = ğ’±(Î±, (Î  i, Î´ i), ğ”–, (Î  i, uÎ´ i))`.
-- But `Î  i, uÎ´ i` is defined as `â¨… i, comap (eval i) (uÎ´ i)`, so we just have to apply
-- `uniform_convergence_on.infi_eq` and `uniform_convergence_on.comap_eq`, which leaves us to check
-- that some square commutes.
-- We could also deduce this from `uniform_convergence.uniform_equiv_Pi_comm`, but it turns out
-- to be more annoying.
(equiv.Pi_comm _).to_uniform_equiv_of_uniform_inducing
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw â† uniformity_comap,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_on_fun.infi_eq],
  refine infi_congr (Î» i, _),
  rw [â† uniform_space.comap_comap, uniform_on_fun.comap_eq]
  -- Like in the previous lemma, the diagram actually commutes by definition
end

end uniform_on_fun
