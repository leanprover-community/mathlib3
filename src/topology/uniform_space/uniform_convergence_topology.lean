/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import topology.uniform_space.uniform_convergence
import topology.uniform_space.pi
import topology.uniform_space.equiv

/-!
# Topology and uniform structure of uniform convergence

This files endows `Î± â†’ Î²` with the topologies / uniform structures of
- uniform convergence on `Î±` (in the `uniform_convergence` namespace)
- uniform convergence on a specified family `ğ”–` of sets of `Î±`
  (in the `uniform_convergence_on` namespace), also called `ğ”–`-convergence

Usual examples of the second construction include :
- the topology of compact convergence, when `ğ”–` is the set of compacts of `Î±`
- the strong topology on the dual of a TVS `E`, when `ğ”–` is the set of Von Neuman bounded subsets
  of `E`
- the weak-* topology on the dual of a TVS `E`, when `ğ”–` is the set of singletons of `E`.

## Main definitions

* `uniform_convergence.gen` : basis sets for the uniformity of uniform convergence
* `uniform_convergence.uniform_space` : uniform structure of uniform convergence
* `uniform_convergence_on.uniform_space` : uniform structure of ğ”–-convergence

## Main statements

* `uniform_convergence.uniform_continuous_eval`: evaluation is uniformly continuous
* `uniform_convergence.t2_space`: the topology of uniform convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2.
* `uniform_convergence.tendsto_iff_tendsto_uniformly`: `uniform_convergence.uniform_space` is
  indeed the uniform structure of uniform convergence
* `uniform_convergence_on.uniform_continuous_eval_of_mem` : evaluation at a point contained in a
  set of `ğ”–` is uniformly continuous
* `uniform_convergence.t2_space`: the topology of `ğ”–`-convergence on `Î± â†’ Î²` is T2 if
  `Î²` is T2 and `ğ”–` covers `Î±`
* `uniform_convergence_on.tendsto_iff_tendsto_uniformly_on`:
  `uniform_convergence_on.uniform_space` is indeed the uniform structure of `ğ”–`-convergence

## Implementation details

We do not declare these structures as instances, since they would conflict with `Pi.uniform_space`.

## TODO

* Show that the uniform structure of `ğ”–`-convergence is exactly the structure of `ğ”–'`-convergence,
  where `ğ”–'` is the bornology generated by `ğ”–`.
* Add a type synonym for `Î± â†’ Î²` endowed with the structures of uniform convergence?

## References

* [N. Bourbaki, *General Topology, Chapter X*][bourbaki1966]

## Tags

uniform convergence
-/


noncomputable theory
open_locale topological_space classical uniformity filter

local attribute [-instance] Pi.uniform_space
local attribute [-instance] Pi.topological_space

open set filter

namespace uniform_convergence

variables (Î± Î² : Type*) {Î³ Î¹ : Type*}
variables {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of uniform convergence -/
protected def gen (V : set (Î² Ã— Î²)) : set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  {uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x, (uv.1 x, uv.2 x) âˆˆ V}

protected lemma is_basis_gen (ğ“‘ : filter_basis $ Î² Ã— Î²) :
  is_basis (Î» V : set (Î² Ã— Î²), V âˆˆ ğ“‘) (uniform_convergence.gen Î± Î²) :=
âŸ¨ğ“‘.nonempty, Î» U V hU hV, let âŸ¨z, hz, hzUVâŸ© := ğ“‘.inter_sets hU hV in âŸ¨z, hz, Î» uv huv,
  âŸ¨Î» x, inter_subset_left _ _ $ hzUV (huv x), Î» x, inter_subset_right _ _ $ hzUV (huv x)âŸ©âŸ©âŸ©

/-- Filter basis for the uniformity of uniform convergence -/
protected def basis (ğ“‘ : filter_basis $ Î² Ã— Î²) : filter_basis ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
(uniform_convergence.is_basis_gen Î± Î² ğ“‘).filter_basis

/-- Uniformity of uniform convergence -/
protected def filter (ğ“‘ : filter_basis $ Î² Ã— Î²) : filter ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
(uniform_convergence.basis Î± Î² ğ“‘).filter

local notation `Î¦` :=
  Î» (Î± Î² : Type*) (uvx : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î±), (uvx.1.1 uvx.2, uvx.1.2 uvx.2)

/-- This is a lower adjoint to `uniform_convergence.filter` (see `uniform_convergence.gc`).
The exact definition is not really interesting, but this allows us to prove many properties of
the uniform structure of uniform convergence using only results about Galois connections. -/
protected def lower_adjoint (ğ“ : filter $ (Î± â†’ Î²) Ã— (Î± â†’ Î²)) : filter (Î² Ã— Î²) :=
map (Î¦ Î± Î²) (ğ“ Ã—á¶  âŠ¤)

protected lemma gc : galois_connection (uniform_convergence.lower_adjoint Î± Î²)
  (Î» ğ“‘, uniform_convergence.filter Î± Î² ğ“‘.as_basis) :=
begin
  intros ğ“ ğ“‘,
  symmetry,
  calc ğ“ â‰¤ uniform_convergence.filter Î± Î² ğ“‘.as_basis
      â†” (uniform_convergence.basis Î± Î² ğ“‘.as_basis).sets âŠ† ğ“.sets :
        by rw [uniform_convergence.filter, â† filter_basis.generate, sets_iff_generate]
  ... â†” âˆ€ U âˆˆ ğ“‘, uniform_convergence.gen Î± Î² U âˆˆ ğ“ : image_subset_iff
  ... â†” âˆ€ U âˆˆ ğ“‘, {uv | âˆ€ x, (uv, x) âˆˆ
          {t : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î± | (t.1.1 t.2, t.1.2 t.2) âˆˆ U}} âˆˆ ğ“ : iff.rfl
  ... â†” âˆ€ U âˆˆ ğ“‘, {uvx : ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) Ã— Î± | (uvx.1.1 uvx.2, uvx.1.2 uvx.2) âˆˆ U} âˆˆ
          ğ“ Ã—á¶  (âŠ¤ : filter Î±) : forallâ‚‚_congr (Î» U hU, mem_prod_top.symm)
  ... â†” uniform_convergence.lower_adjoint Î± Î² ğ“ â‰¤ ğ“‘ : iff.rfl,
end

variables [uniform_space Î²]

/-- Core of the uniform structure of uniform convergence -/
protected def uniform_core : uniform_space.core (Î± â†’ Î²) :=
uniform_space.core.mk_of_basis (uniform_convergence.basis Î± Î² (ğ“¤ Î²).as_basis)
  (Î» U âŸ¨V, hV, hVUâŸ© f, hVU â–¸ Î» x, refl_mem_uniformity hV)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ âŸ¨uniform_convergence.gen Î± Î² (prod.swap â»Â¹' V),
    âŸ¨prod.swap â»Â¹' V, tendsto_swap_uniformity hV, rflâŸ©, Î» uv huv x, huv xâŸ©)
  (Î» U âŸ¨V, hV, hVUâŸ©, hVU â–¸ let âŸ¨W, hW, hWVâŸ© := comp_mem_uniformity_sets hV in
    âŸ¨uniform_convergence.gen Î± Î² W, âŸ¨W, hW, rflâŸ©, Î» uv âŸ¨w, huw, hwvâŸ© x, hWV
      âŸ¨w x, by exact âŸ¨huw x, hwv xâŸ©âŸ©âŸ©)

/-- Uniform structure of uniform convergence -/
protected def uniform_space : uniform_space (Î± â†’ Î²) :=
uniform_space.of_core (uniform_convergence.uniform_core Î± Î²)

local attribute [instance] uniform_convergence.uniform_space

protected lemma has_basis_uniformity :
  (ğ“¤ (Î± â†’ Î²)).has_basis (Î» V, V âˆˆ ğ“¤ Î²)
  (uniform_convergence.gen Î± Î²) :=
(uniform_convergence.is_basis_gen Î± Î² (ğ“¤ Î²).as_basis).has_basis

protected lemma has_basis_uniformity_of_basis {Î¹ : Sort*} {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : (ğ“¤ Î²).has_basis p s) :
  (ğ“¤ (Î± â†’ Î²)).has_basis p (uniform_convergence.gen Î± Î² âˆ˜ s) :=
(uniform_convergence.has_basis_uniformity Î± Î²).to_has_basis
  (Î» U hU, let âŸ¨i, hi, hiUâŸ© := h.mem_iff.mp hU in âŸ¨i, hi, Î» uv huv x, hiU (huv x)âŸ©)
  (Î» i hi, âŸ¨s i, h.mem_of_mem hi, subset_refl _âŸ©)

/-- Topology of uniform convergence -/
protected def topological_space : topological_space (Î± â†’ Î²) :=
(uniform_convergence.uniform_space Î± Î²).to_topological_space

protected lemma has_basis_nhds_of_basis (f) {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (h : has_basis (ğ“¤ Î²) p s) :
  (ğ“ f).has_basis p (Î» i, {g | (f, g) âˆˆ uniform_convergence.gen Î± Î² (s i)}) :=
nhds_basis_uniformity' (uniform_convergence.has_basis_uniformity_of_basis Î± Î² h)

protected lemma has_basis_nhds (f) :
  (ğ“ f).has_basis (Î» V, V âˆˆ ğ“¤ Î²) (Î» V, {g | (f, g) âˆˆ uniform_convergence.gen Î± Î² V}) :=
uniform_convergence.has_basis_nhds_of_basis Î± Î² f (filter.basis_sets _)

variables {Î±}

lemma uniform_continuous_eval (x : Î±) : uniform_continuous (function.eval x : (Î± â†’ Î²) â†’ Î²) :=
begin
  change _ â‰¤ _,
  rw [map_le_iff_le_comap,
      (uniform_convergence.has_basis_uniformity Î± Î²).le_basis_iff ((ğ“¤ _).basis_sets.comap _)],
  exact Î» U hU, âŸ¨U, hU, Î» uv huv, huv xâŸ©
end

variables {Î²}

protected lemma mono : monotone (@uniform_convergence.uniform_space Î± Î³) :=
Î» uâ‚ uâ‚‚ hu, (uniform_convergence.gc Î± Î³).monotone_u hu

protected lemma infi_eq {u : Î¹ â†’ uniform_space Î³} :
  (@uniform_convergence.uniform_space Î± Î³ (â¨… i, u i)) =
  â¨… i, (@uniform_convergence.uniform_space Î± Î³ (u i)) :=
begin
  ext : 1,
  change uniform_convergence.filter Î± Î³ (@uniformity _ (â¨… i, u i)).as_basis =
    @uniformity _ (â¨… i, (@uniform_convergence.uniform_space Î± Î³ (u i))),
  rw [infi_uniformity', infi_uniformity'],
  exact (uniform_convergence.gc Î± Î³).u_infi
end

protected lemma inf_eq {uâ‚ uâ‚‚ : uniform_space Î³} :
  (@uniform_convergence.uniform_space Î± Î³ (uâ‚ âŠ“ uâ‚‚)) =
  (@uniform_convergence.uniform_space Î± Î³ uâ‚) âŠ“ (@uniform_convergence.uniform_space Î± Î³ uâ‚‚) :=
begin
  rw [inf_eq_infi, inf_eq_infi, uniform_convergence.infi_eq],
  refine infi_congr (Î» i, _),
  cases i; refl
end

protected lemma comap_eq {f : Î³ â†’ Î²} :
  (@uniform_convergence.uniform_space Î± Î³ (â€¹uniform_space Î²â€º.comap f)) =
  (uniform_convergence.uniform_space Î± Î²).comap ((âˆ˜) f) :=
begin
  letI : uniform_space Î³ := â€¹uniform_space Î²â€º.comap f,
  ext : 1,
  change (uniform_convergence.filter Î± Î³ (((ğ“¤ Î²).comap _).as_basis)) =
    (uniform_convergence.filter Î± Î² ((ğ“¤ Î²).as_basis)).comap _,
  have hâ‚ := filter.gc_map_comap (prod.map ((âˆ˜) f) ((âˆ˜) f)),
  have hâ‚‚ := filter.gc_map_comap (prod.map f f),
  have hâ‚ƒ := uniform_convergence.gc Î± Î²,
  have hâ‚„ := uniform_convergence.gc Î± Î³,
  refine galois_connection.u_comm_of_l_comm hâ‚ hâ‚‚ hâ‚ƒ hâ‚„ (Î» ğ“, _),
  have : prod.map f f âˆ˜ (Î¦ Î± Î³) =
    (Î¦ Î± Î²) âˆ˜ prod.map (prod.map ((âˆ˜) f) ((âˆ˜) f)) id,
  { ext; refl },
  rw [uniform_convergence.lower_adjoint, uniform_convergence.lower_adjoint, map_comm this,
      â† prod_map_map_eq'],
  refl
end

protected lemma postcomp_uniform_continuous [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_continuous f):
  uniform_continuous ((âˆ˜) f : (Î± â†’ Î³) â†’ Î± â†’ Î²) :=
uniform_continuous_iff.mpr $
calc uniform_convergence.uniform_space Î± Î³
    â‰¤ @uniform_convergence.uniform_space Î± Î³ (â€¹uniform_space Î²â€º.comap f) :
      uniform_convergence.mono (uniform_continuous_iff.mp hf)
... = (uniform_convergence.uniform_space Î± Î²).comap ((âˆ˜) f) :
      uniform_convergence.comap_eq

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` to a uniform isomorphism `(Î± â†’ Î³) â‰ƒáµ¤ (Î± â†’ Î²)`, with the
uniform structures of uniform convergence, by post-composing. -/
protected def congr_right [uniform_space Î³] (e : Î³ â‰ƒáµ¤ Î²) :
  (Î± â†’ Î³) â‰ƒáµ¤ (Î± â†’ Î²) :=
{ uniform_continuous_to_fun :=
    uniform_convergence.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (Î» a, e.to_equiv) }

protected lemma precomp_uniform_continuous {f : Î³ â†’ Î±} :
  uniform_continuous (Î» g : Î± â†’ Î², g âˆ˜ f) :=
begin
  rw uniform_continuous_iff,
  change ğ“¤ (Î± â†’ Î²) â‰¤ (ğ“¤ (Î³ â†’ Î²)).comap (prod.map (Î» g : Î± â†’ Î², g âˆ˜ f) (Î» g : Î± â†’ Î², g âˆ˜ f)),
  rw (uniform_convergence.has_basis_uniformity Î± Î²).le_basis_iff
    ((uniform_convergence.has_basis_uniformity Î³ Î²).comap _),
  exact Î» U hU, âŸ¨U, hU, Î» uv huv x, huv (f x)âŸ©
end

/-- Turn a bijection `Î³ â‰ƒ Î±` to a uniform isomorphism `(Î³ â†’ Î²) â‰ƒáµ¤ (Î± â†’ Î²)`, with the uniform
structures of uniform convergence, by pre-composing. -/
protected def congr_left (e : Î³ â‰ƒ Î±) :
  (Î³ â†’ Î²) â‰ƒáµ¤ (Î± â†’ Î²) :=
{ uniform_continuous_to_fun :=
    uniform_convergence.precomp_uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence.precomp_uniform_continuous,
  .. equiv.arrow_congr e (equiv.refl _) }

lemma t2_space [t2_space Î²] : t2_space (Î± â†’ Î²) :=
{ t2 :=
  begin
    letI : uniform_space (Î± â†’ Î²) := uniform_convergence.uniform_space Î± Î²,
    letI : topological_space (Î± â†’ Î²) := uniform_convergence.topological_space Î± Î²,
    intros f g h,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext h),
    exact separated_by_continuous (uniform_continuous_eval Î² x).continuous hx
  end }

protected lemma le_Pi : uniform_convergence.uniform_space Î± Î² â‰¤ Pi.uniform_space (Î» _, Î²) :=
begin
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  exact uniform_continuous_eval Î² x
end

protected lemma tendsto_iff_tendsto_uniformly : tendsto F p (ğ“ f) â†” tendsto_uniformly F f p :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence.uniform_space Î± Î²,
  rw [(uniform_convergence.has_basis_nhds Î± Î²).tendsto_right_iff, tendsto_uniformly],
  exact iff.rfl,
end

/-- If `Î± â†’ Î² Ã— Î³`, `Î± â†’ Î²` and `Î± â†’ Î³` are equipped with the uniform structures of uniform
convergence, then the natural bijection between `(Î± â†’ Î² Ã— Î³)` and `((Î± â†’ Î²) Ã— (Î± â†’ Î³))` is a
uniform isomorphism. -/
protected def uniform_equiv_prod_arrow [uniform_space Î³] :
  (Î± â†’ Î² Ã— Î³) â‰ƒáµ¤ ((Î± â†’ Î²) Ã— (Î± â†’ Î³)) :=
(equiv.arrow_prod_equiv_prod_arrow _ _ _).to_uniform_equiv_of_uniform_inducing
begin
  split,
  change comap (prod.map (equiv.arrow_prod_equiv_prod_arrow _ _ _)
    (equiv.arrow_prod_equiv_prod_arrow _ _ _)) _ = _,
  rw â† uniformity_comap rfl,
  congr,
  rw [prod.uniform_space, prod.uniform_space, uniform_space.comap_inf, uniform_convergence.inf_eq],
  congr;
  rw [â† uniform_space.comap_comap, uniform_convergence.comap_eq];
  refl
end

variables (Î±) (Î´ : Î¹ â†’ Type*) [Î  i, uniform_space (Î´ i)]

local attribute [-instance] uniform_convergence.uniform_space

/-- If `Î± â†’ Î  i, Î´ i` and each `Î± â†’ Î´ i` are equipped with the uniform structures of uniform
convergence, then "swapping the arguments" is a uniform isomorphism between `Î± â†’ Î  i, Î´ i` and
`Î  i, Î± â†’ Î´ i`. -/
protected def uniform_equiv_Pi_comm : @uniform_equiv (Î± â†’ Î  i, Î´ i) (Î  i, Î± â†’ Î´ i)
  (@uniform_convergence.uniform_space Î± (Î  i, Î´ i) (Pi.uniform_space Î´))
  (@Pi.uniform_space Î¹ (Î» i, Î± â†’ Î´ i) (Î» i, uniform_convergence.uniform_space Î± (Î´ i))) :=
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  (@uniform_convergence.uniform_space Î± (Î  i, Î´ i) (Pi.uniform_space Î´))
  (@Pi.uniform_space Î¹ (Î» i, Î± â†’ Î´ i) (Î» i, uniform_convergence.uniform_space Î± (Î´ i)))
  (equiv.Pi_comm _)
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw â† uniformity_comap rfl,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_convergence.infi_eq],
  refine infi_congr (Î» i, _),
  rw [â† uniform_space.comap_comap, uniform_convergence.comap_eq]
end

end uniform_convergence

namespace uniform_convergence_on

variables {Î± Î² : Type*} {Î³ Î¹ : Type*}
variables {F : Î¹ â†’ Î± â†’ Î²} {f : Î± â†’ Î²} {s s' : set Î±} {x : Î±} {p : filter Î¹} {g : Î¹ â†’ Î±}

/-- Basis sets for the uniformity of `ğ”–`-convergence -/
protected def gen (S : set Î±) (V : set (Î² Ã— Î²)) : set ((Î± â†’ Î²) Ã— (Î± â†’ Î²)) :=
  {uv : (Î± â†’ Î²) Ã— (Î± â†’ Î²) | âˆ€ x âˆˆ S, (uv.1 x, uv.2 x) âˆˆ V}

protected lemma gen_eq_preimage_restrict (S : set Î±) (V : set (Î² Ã— Î²)) :
  uniform_convergence_on.gen S V =
  (prod.map S.restrict S.restrict) â»Â¹' (uniform_convergence.gen S Î² V) :=
begin
  ext uv,
  exact âŸ¨Î» h âŸ¨x, hxâŸ©, h x hx, Î» h x hx, h âŸ¨x, hxâŸ©âŸ©
end

protected lemma gen_mono {S S' : set Î±} {V V' : set (Î² Ã— Î²)} (hS : S' âŠ† S) (hV : V âŠ† V') :
  uniform_convergence_on.gen S V âŠ† uniform_convergence_on.gen S' V' :=
Î» uv h x hx, hV (h x $ hS hx)

protected lemma is_basis_gen (ğ”– : set (set Î±)) (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  (ğ“‘ : filter_basis $ Î² Ã— Î²) :
  is_basis (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“‘)
    (Î» SV, uniform_convergence_on.gen SV.1 SV.2) :=
âŸ¨h.prod ğ“‘.nonempty, Î» Uâ‚Vâ‚ Uâ‚‚Vâ‚‚ hâ‚ hâ‚‚,
  let âŸ¨Uâ‚ƒ, hUâ‚ƒ, hUâ‚â‚ƒ, hUâ‚‚â‚ƒâŸ© := h' Uâ‚Vâ‚.1 hâ‚.1 Uâ‚‚Vâ‚‚.1 hâ‚‚.1 in
  let âŸ¨Vâ‚ƒ, hVâ‚ƒ, hVâ‚â‚‚â‚ƒâŸ© := ğ“‘.inter_sets hâ‚.2 hâ‚‚.2 in âŸ¨âŸ¨Uâ‚ƒ, Vâ‚ƒâŸ©, âŸ¨âŸ¨hUâ‚ƒ, hVâ‚ƒâŸ©, Î» uv huv,
    âŸ¨(Î» x hx, (hVâ‚â‚‚â‚ƒ $ huv x $ hUâ‚â‚ƒ hx).1), (Î» x hx, (hVâ‚â‚‚â‚ƒ $ huv x $ hUâ‚‚â‚ƒ hx).2)âŸ©âŸ©âŸ©âŸ©

variables (Î± Î²) [uniform_space Î²] (ğ”– : set (set Î±))

/-- Uniform structure of uniform convergence on the sets of `ğ”–`. -/
protected def uniform_space : uniform_space (Î± â†’ Î²) :=
â¨… (s : set Î±) (hs : s âˆˆ ğ”–), uniform_space.comap (Î» f, s.restrict f)
  (uniform_convergence.uniform_space s Î²)

/-- Topology of uniform convergence on the sets of `ğ”–`. -/
protected def topological_space : topological_space (Î± â†’ Î²) :=
(uniform_convergence_on.uniform_space Î± Î² ğ”–).to_topological_space

protected lemma topological_space_eq :
  uniform_convergence_on.topological_space Î± Î² ğ”– = â¨… (s : set Î±) (hs : s âˆˆ ğ”–),
  topological_space.induced (Î» f, s.restrict f) (uniform_convergence.topological_space s Î²) :=
begin
  simp only [uniform_convergence_on.topological_space, to_topological_space_infi,
    to_topological_space_infi, to_topological_space_comap],
  refl
end

private lemma has_basis_uniformity_of_basis_auxâ‚ {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)}
  (hb : has_basis (ğ“¤ Î²) p s) (S : set Î±) :
  (@uniformity (Î± â†’ Î²) ((uniform_convergence.uniform_space S Î²).comap S.restrict)).has_basis
  p (Î» i, uniform_convergence_on.gen S (s i)) :=
begin
  simp_rw [uniform_convergence_on.gen_eq_preimage_restrict, uniformity_comap rfl],
  exact (uniform_convergence.has_basis_uniformity_of_basis S Î² hb).comap _
end

private lemma has_basis_uniformity_of_basis_auxâ‚‚ (h : directed_on (âŠ†) ğ”–) {p : Î¹ â†’ Prop}
  {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  directed_on ((Î» s : set Î±, (uniform_convergence.uniform_space s Î²).comap
    (s.restrict : (Î± â†’ Î²) â†’ s â†’ Î²)) â»Â¹'o ge) ğ”– :=
h.mono $ Î» s t hst,
  ((has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb _).le_basis_iff
    (has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb _)).mpr
  (Î» V hV, âŸ¨V, hV, uniform_convergence_on.gen_mono hst subset_rflâŸ©)

protected lemma has_basis_uniformity_of_basis (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (@uniformity (Î± â†’ Î²) (uniform_convergence_on.uniform_space Î± Î² ğ”–)).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”– âˆ§ p Si.2)
    (Î» Si, uniform_convergence_on.gen Si.1 (s Si.2)) :=
begin
  simp only [infi_uniformity'],
  exact has_basis_binfi_of_directed h (Î» S, (@uniform_convergence_on.gen Î± Î² S) âˆ˜ s) _
    (Î» S hS, has_basis_uniformity_of_basis_auxâ‚ Î± Î² hb S)
    (has_basis_uniformity_of_basis_auxâ‚‚ Î± Î² ğ”– h' hb)
end

protected lemma has_basis_uniformity (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  (@uniformity (Î± â†’ Î²) (uniform_convergence_on.uniform_space Î± Î² ğ”–)).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, uniform_convergence_on.gen SV.1 SV.2) :=
uniform_convergence_on.has_basis_uniformity_of_basis Î± Î² ğ”– h h' (ğ“¤ Î²).basis_sets

protected lemma has_basis_nhds_of_basis (f) (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–)
  {p : Î¹ â†’ Prop} {s : Î¹ â†’ set (Î² Ã— Î²)} (hb : has_basis (ğ“¤ Î²) p s) :
  (@nhds (Î± â†’ Î²) (uniform_convergence_on.topological_space Î± Î² ğ”–) f).has_basis
    (Î» Si : set Î± Ã— Î¹, Si.1 âˆˆ ğ”– âˆ§ p Si.2)
    (Î» Si, {g | (g, f) âˆˆ uniform_convergence_on.gen Si.1 (s Si.2)}) :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
  exact nhds_basis_uniformity (uniform_convergence_on.has_basis_uniformity_of_basis Î± Î² ğ”– h h' hb)
end

protected lemma has_basis_nhds (f) (h : ğ”–.nonempty) (h' : directed_on (âŠ†) ğ”–) :
  (@nhds (Î± â†’ Î²) (uniform_convergence_on.topological_space Î± Î² ğ”–) f).has_basis
    (Î» SV : set Î± Ã— set (Î² Ã— Î²), SV.1 âˆˆ ğ”– âˆ§ SV.2 âˆˆ ğ“¤ Î²)
    (Î» SV, {g | (g, f) âˆˆ uniform_convergence_on.gen SV.1 SV.2}) :=
uniform_convergence_on.has_basis_nhds_of_basis Î± Î² ğ”– f h h' (filter.basis_sets _)

protected lemma uniform_continuous_restrict (h : s âˆˆ ğ”–) :
  @uniform_continuous _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–)
  (uniform_convergence.uniform_space s Î²) s.restrict :=
begin
  change _ â‰¤ _,
  rw [uniform_convergence_on.uniform_space, map_le_iff_le_comap, uniformity, infi_uniformity],
  refine infi_le_of_le s _,
  rw infi_uniformity,
  exact infi_le _ h,
end

variables {Î±}

protected lemma mono â¦ƒuâ‚ uâ‚‚ : uniform_space Î³â¦„ (hu : uâ‚ â‰¤ uâ‚‚) â¦ƒğ”–â‚ ğ”–â‚‚ : set (set Î±)â¦„
  (hğ”– : ğ”–â‚‚ âŠ† ğ”–â‚) :
  @uniform_convergence_on.uniform_space Î± Î³ uâ‚ ğ”–â‚ â‰¤
  @uniform_convergence_on.uniform_space Î± Î³ uâ‚‚ ğ”–â‚‚ :=
calc @uniform_convergence_on.uniform_space Î± Î³ uâ‚ ğ”–â‚
    â‰¤ @uniform_convergence_on.uniform_space Î± Î³ uâ‚ ğ”–â‚‚ : infi_le_infi_of_subset hğ”–
... â‰¤ @uniform_convergence_on.uniform_space Î± Î³ uâ‚‚ ğ”–â‚‚ : infiâ‚‚_mono
        (Î» i hi, uniform_space.comap_mono $ uniform_convergence.mono hu)

lemma uniform_continuous_eval_of_mem {x : Î±} (hxs : x âˆˆ s) (hs : s âˆˆ ğ”–) :
  @uniform_continuous _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–) _ (function.eval x) :=
begin
  change _ â‰¤ _,
  rw [map_le_iff_le_comap, ((ğ“¤ _).basis_sets.comap _).ge_iff,
      uniform_convergence_on.uniform_space, infi_uniformity'],
  intros U hU,
  refine mem_infi_of_mem s _,
  rw infi_uniformity',
  exact mem_infi_of_mem hs (mem_comap.mpr
    âŸ¨ uniform_convergence.gen s Î² U,
      (uniform_convergence.has_basis_uniformity s Î²).mem_of_mem hU,
      Î» uv huv, huv âŸ¨x, hxsâŸ© âŸ©)
end

variables {Î²} {ğ”–}

protected lemma infi_eq {u : Î¹ â†’ uniform_space Î³} :
  (@uniform_convergence_on.uniform_space Î± Î³ (â¨… i, u i) ğ”–) =
  â¨… i, (@uniform_convergence_on.uniform_space Î± Î³ (u i) ğ”–) :=
begin
  simp_rw [uniform_convergence_on.uniform_space, uniform_convergence.infi_eq,
    uniform_space.comap_infi],
  rw infi_comm,
  exact infi_congr (Î» s, infi_comm)
end

protected lemma inf_eq {uâ‚ uâ‚‚ : uniform_space Î³} :
  (@uniform_convergence_on.uniform_space Î± Î³ (uâ‚ âŠ“ uâ‚‚) ğ”–) =
  (@uniform_convergence_on.uniform_space Î± Î³ uâ‚ ğ”–) âŠ“
  (@uniform_convergence_on.uniform_space Î± Î³ uâ‚‚ ğ”–) :=
begin
  rw [inf_eq_infi, inf_eq_infi, uniform_convergence_on.infi_eq],
  refine infi_congr (Î» i, _),
  cases i; refl
end

protected lemma comap_eq {f : Î³ â†’ Î²} :
  (@uniform_convergence_on.uniform_space Î± Î³ (â€¹uniform_space Î²â€º.comap f) ğ”–) =
  (uniform_convergence_on.uniform_space Î± Î² ğ”–).comap ((âˆ˜) f) :=
begin
  simp_rw [uniform_convergence_on.uniform_space, uniform_space.comap_infi,
            uniform_convergence.comap_eq, â† uniform_space.comap_comap],
  refl
end

protected lemma postcomp_uniform_continuous [uniform_space Î³] {f : Î³ â†’ Î²}
  (hf : uniform_continuous f):
  @uniform_continuous (Î± â†’ Î³) (Î± â†’ Î²)
  (uniform_convergence_on.uniform_space Î± Î³ ğ”–) (uniform_convergence_on.uniform_space Î± Î² ğ”–)
  ((âˆ˜) f) :=
begin
  rw uniform_continuous_iff,
  calc uniform_convergence_on.uniform_space Î± Î³ ğ”–
      â‰¤ @uniform_convergence_on.uniform_space Î± Î³ (â€¹uniform_space Î²â€º.comap f) ğ”– :
        uniform_convergence_on.mono (uniform_continuous_iff.mp hf) (subset_rfl)
  ... = (uniform_convergence_on.uniform_space Î± Î² ğ”–).comap ((âˆ˜) f) :
        uniform_convergence_on.comap_eq
end

/-- Turn a uniform isomorphism `Î³ â‰ƒáµ¤ Î²` to a uniform isomorphism `(Î± â†’ Î³) â‰ƒáµ¤ (Î± â†’ Î²)`, with the
uniform structures of `ğ”–`-convergence, by post-composing. -/
protected def congr_right [uniform_space Î³] (e : Î³ â‰ƒáµ¤ Î²) :
  @uniform_equiv (Î± â†’ Î³) (Î± â†’ Î²)
  (uniform_convergence_on.uniform_space Î± Î³ ğ”–) (uniform_convergence_on.uniform_space Î± Î² ğ”–) :=
{ uniform_continuous_to_fun :=
    uniform_convergence_on.postcomp_uniform_continuous e.uniform_continuous,
  uniform_continuous_inv_fun :=
    uniform_convergence_on.postcomp_uniform_continuous e.symm.uniform_continuous,
  .. equiv.Pi_congr_right (Î» a, e.to_equiv) }

protected lemma precomp_uniform_continuous {ğ”— : set (set Î³)} {f : Î³ â†’ Î±}
  (hf : ğ”— âŠ† (image f) â»Â¹' ğ”–) :
  @uniform_continuous (Î± â†’ Î²) (Î³ â†’ Î²)
  (uniform_convergence_on.uniform_space Î± Î² ğ”–) (uniform_convergence_on.uniform_space Î³ Î² ğ”—)
  (Î» g : Î± â†’ Î², g âˆ˜ f) :=
begin
  simp_rw [uniform_continuous_iff, uniform_convergence_on.uniform_space, uniform_space.comap_infi],
  refine le_infiâ‚‚ (Î» t ht, infi_le_of_le (f '' t) $ infi_le_of_le (hf ht) _),
  rw â† uniform_space.comap_comap,
  let f' : t â†’ f '' t := (maps_to_image f t).restrict f t (f '' t),
  have : restrict t âˆ˜ (Î» g : Î± â†’ Î², g âˆ˜ f) = (Î» g : (f '' t) â†’ Î², g âˆ˜ f') âˆ˜ restrict (f '' t) :=
    rfl,
  rw [this, @uniform_space.comap_comap (Î± â†’ Î²) ((f '' t) â†’ Î²)],
  refine uniform_space.comap_mono _,
  rw â† uniform_continuous_iff,
  exact uniform_convergence.precomp_uniform_continuous
end

lemma t2_space_of_covering [t2_space Î²] (h : â‹ƒâ‚€ ğ”– = univ) :
  @t2_space _ (uniform_convergence_on.topological_space Î± Î² ğ”–) :=
{ t2 :=
  begin
    letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
    letI : topological_space (Î± â†’ Î²) := uniform_convergence_on.topological_space Î± Î² ğ”–,
    intros f g hfg,
    obtain âŸ¨x, hxâŸ© := not_forall.mp (mt funext hfg),
    obtain âŸ¨s, hs, hxsâŸ© : âˆƒ s âˆˆ ğ”–, x âˆˆ s := mem_sUnion.mp (h.symm â–¸ true.intro),
    exact separated_by_continuous (uniform_continuous_eval_of_mem Î² ğ”– hxs hs).continuous hx
  end }

protected lemma le_Pi_of_covering (h : â‹ƒâ‚€ ğ”– = univ) :
  uniform_convergence_on.uniform_space Î± Î² ğ”– â‰¤ Pi.uniform_space (Î» _, Î²) :=
begin
  rw [le_iff_uniform_continuous_id, uniform_continuous_pi],
  intros x,
  obtain âŸ¨s : set Î±, hs : s âˆˆ ğ”–, hxs :  x âˆˆ sâŸ© := sUnion_eq_univ_iff.mp h x,
  exact uniform_continuous_eval_of_mem Î² ğ”– hxs hs
end

protected lemma tendsto_iff_tendsto_uniformly_on :
  tendsto F p (@nhds _ (uniform_convergence_on.topological_space Î± Î² ğ”–) f) â†”
  âˆ€ s âˆˆ ğ”–, tendsto_uniformly_on F f p s :=
begin
  letI : uniform_space (Î± â†’ Î²) := uniform_convergence_on.uniform_space Î± Î² ğ”–,
  rw [uniform_convergence_on.topological_space_eq, nhds_infi, tendsto_infi],
  refine forall_congr (Î» s, _),
  rw [nhds_infi, tendsto_infi],
  refine forall_congr (Î» hs, _),
  rw [nhds_induced, tendsto_comap_iff, tendsto_uniformly_on_iff_tendsto_uniformly_comp_coe,
      uniform_convergence.tendsto_iff_tendsto_uniformly],
  refl
end

/-- If `Î± â†’ Î² Ã— Î³`, `Î± â†’ Î²` and `Î± â†’ Î³` are equipped with the uniform structures of
`ğ”–`-convergence, then the natural bijection between `(Î± â†’ Î² Ã— Î³)` and `((Î± â†’ Î²) Ã— (Î± â†’ Î³))` is a
uniform isomorphism. -/
protected def uniform_equiv_prod_arrow [uniform_space Î³] :
  @uniform_equiv (Î± â†’ Î² Ã— Î³) ((Î± â†’ Î²) Ã— (Î± â†’ Î³))
  (uniform_convergence_on.uniform_space Î± (Î² Ã— Î³) ğ”–)
  (@prod.uniform_space _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–)
    (uniform_convergence_on.uniform_space Î± Î³ ğ”–)) :=
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  (uniform_convergence_on.uniform_space Î± (Î² Ã— Î³) ğ”–)
  (@prod.uniform_space _ _ (uniform_convergence_on.uniform_space Î± Î² ğ”–)
    (uniform_convergence_on.uniform_space Î± Î³ ğ”–))
  (equiv.arrow_prod_equiv_prod_arrow _ _ _)
begin
  split,
  change comap (prod.map (equiv.arrow_prod_equiv_prod_arrow _ _ _)
    (equiv.arrow_prod_equiv_prod_arrow _ _ _)) _ = _,
  rw â† uniformity_comap rfl,
  congr,
  rw [prod.uniform_space, prod.uniform_space, uniform_space.comap_inf,
      uniform_convergence_on.inf_eq],
  congr;
  rw [â† uniform_space.comap_comap, uniform_convergence_on.comap_eq];
  refl
end

variables (ğ”–) (Î´ : Î¹ â†’ Type*) [Î  i, uniform_space (Î´ i)]

/-- If `Î± â†’ Î  i, Î´ i` and each `Î± â†’ Î´ i` are equipped with the uniform structures of
`ğ”–`-convergence, then "swapping the arguments" is a uniform isomorphism between `Î± â†’ Î  i, Î´ i` and
`Î  i, Î± â†’ Î´ i`. -/
protected def uniform_equiv_Pi_comm : @uniform_equiv (Î± â†’ Î  i, Î´ i) (Î  i, Î± â†’ Î´ i)
  (@uniform_convergence_on.uniform_space Î± (Î  i, Î´ i) (Pi.uniform_space Î´) ğ”–)
  (@Pi.uniform_space Î¹ (Î» i, Î± â†’ Î´ i) (Î» i, uniform_convergence_on.uniform_space Î± (Î´ i) ğ”–)) :=
@equiv.to_uniform_equiv_of_uniform_inducing _ _
  (@uniform_convergence_on.uniform_space Î± (Î  i, Î´ i) (Pi.uniform_space Î´) ğ”–)
  (@Pi.uniform_space Î¹ (Î» i, Î± â†’ Î´ i) (Î» i, uniform_convergence_on.uniform_space Î± (Î´ i) ğ”–))
  (equiv.Pi_comm _)
begin
  split,
  change comap (prod.map function.swap function.swap) _ = _,
  rw â† uniformity_comap rfl,
  congr,
  rw [Pi.uniform_space, uniform_space.of_core_eq_to_core, Pi.uniform_space,
      uniform_space.of_core_eq_to_core, uniform_space.comap_infi, uniform_convergence_on.infi_eq],
  refine infi_congr (Î» i, _),
  rw [â† uniform_space.comap_comap, uniform_convergence_on.comap_eq]
end

end uniform_convergence_on
